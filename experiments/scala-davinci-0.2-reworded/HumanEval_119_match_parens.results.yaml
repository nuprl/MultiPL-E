language: scala
name: HumanEval_119_match_parens
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') {\n   \
    \             stack.push(c)\n            } else {\n                if (stack.isEmpty)\
    \ return \"No\"\n                stack.pop\n            }\n        }\n       \
    \ if (stack.isEmpty) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprsik2km4.scala:36)\n\tat Problem.main(tmprsik2km4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rcnvf42.scala:35)\n\tat Problem.main(tmp5rcnvf42.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwq40dvzm.scala:35)\n\tat Problem.main(tmpwq40dvzm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        var count = 0\n        for (c <- s) {\n          \
    \  if (c == '(') count += 1\n            else count -= 1\n            if (count\
    \ < 0) return \"No\"\n        }\n        if (count == 0) \"Yes\" else \"No\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4u2r2uuc.scala:31)\n\tat Problem.main(tmp4u2r2uuc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1_left = s1.count(_ == '(')\n\
    \        val s1_right = s1.count(_ == ')')\n        val s2_left = s2.count(_ ==\
    \ '(')\n        val s2_right = s2.count(_ == ')')\n        if (s1_left == s1_right\
    \ && s2_left == s2_right) return \"Yes\"\n        if (s1_left == s1_right && s2_left\
    \ != s2_right) return \"No\"\n        if (s1_left != s1_right && s2_left == s2_right)\
    \ return \"No\"\n        if (s1_left != s1_right && s2_left != s2_right) {\n \
    \           val s1_diff = abs(s1_left - s1_right)\n            val s2_diff = abs(s2_left\
    \ - s2_right)\n            if (s1_diff == s2_diff) return \"Yes\"\n          \
    \  else return \"No\"\n        }\n        return \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprstlpsaz.scala:37)\n\tat Problem.main(tmprstlpsaz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ isGood(s : String) : Boolean = {\n            var count = 0\n            for\
    \ (c <- s) {\n                if (c == '(') count += 1\n                else if\
    \ (c == ')') count -= 1\n                if (count < 0) return false\n       \
    \     }\n            return count == 0\n        }\n        if (isGood(lst(0) +\
    \ lst(1))) return \"Yes\"\n        if (isGood(lst(1) + lst(0))) return \"Yes\"\
    \n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ua8oj_p.scala:36)\n\tat Problem.main(tmp8ua8oj_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str1 = lst(0)\n        val str2 = lst(1)\n        val str = str1 + str2\n  \
    \      var count = 0\n        for (c <- str) {\n            if (c == '(') count\
    \ += 1\n            else count -= 1\n            if (count < 0) return \"No\"\n\
    \        }\n        if (count == 0) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi5d9i_vv.scala:33)\n\tat Problem.main(tmpi5d9i_vv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        def isGood(s : String) : Boolean\
    \ = {\n            var count = 0\n            for (c <- s) {\n               \
    \ if (c == '(') count += 1\n                else if (c == ')') count -= 1\n  \
    \              if (count < 0) return false\n            }\n            return\
    \ count == 0\n        }\n        if (isGood(s1 + s2)) return \"Yes\"\n       \
    \ else if (isGood(s2 + s1)) return \"Yes\"\n        else return \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str1 = lst(0)\n        val str2 = lst(1)\n        val str1_open = str1.count(_\
    \ == '(')\n        val str1_close = str1.count(_ == ')')\n        val str2_open\
    \ = str2.count(_ == '(')\n        val str2_close = str2.count(_ == ')')\n    \
    \    if (str1_open == str1_close && str2_open == str2_close) \"Yes\"\n       \
    \ else if (str1_open == str1_close && str2_open != str2_close) \"No\"\n      \
    \  else if (str1_open != str1_close && str2_open == str2_close) \"No\"\n     \
    \   else if (str1_open != str1_close && str2_open != str2_close) {\n         \
    \   if (str1_open > str1_close) {\n                if (str1_open - str1_close\
    \ == str2_open - str2_close) \"Yes\"\n                else \"No\"\n          \
    \  }\n            else {\n                if (str1_close - str1_open == str2_close\
    \ - str2_open) \"Yes\"\n                else \"No\"\n            }\n        }\n\
    \        else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbwp2nvqw.scala:40)\n\tat Problem.main(tmpbwp2nvqw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var count\
    \ = 0\n        for (i <- 0 until s.length) {\n            if (s(i) == '(') count\
    \ += 1\n            else count -= 1\n            if (count < 0) return \"No\"\n\
    \        }\n        if (count == 0) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf5uxk_08.scala:33)\n\tat Problem.main(tmpf5uxk_08.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.reduceLeft(_ + _)\n        if (s.length % 2 == 1) return \"No\"\n  \
    \      val stack = new Stack[Char]\n        for (c <- s) {\n            if (c\
    \ == '(') stack.push(c)\n            else if (stack.isEmpty) return \"No\"\n \
    \           else stack.pop\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwx3ehaoj.scala:32)\n\tat Problem.main(tmpwx3ehaoj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ (s1, s2) = (lst(0), lst(1))\n        val (c1, c2) = (s1.count(_ == '('), s1.count(_\
    \ == ')'))\n        val (d1, d2) = (s2.count(_ == '('), s2.count(_ == ')'))\n\
    \        if (c1 == c2 && d1 == d2) \"Yes\"\n        else if (c1 == c2 && d1 !=\
    \ d2) \"No\"\n        else if (c1 != c2 && d1 == d2) \"No\"\n        else if (c1\
    \ > c2 && d1 > d2) \"Yes\"\n        else if (c1 < c2 && d1 < d2) \"Yes\"\n   \
    \     else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpigv07osg.scala:29)\n\tat Problem.main(tmpigv07osg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var count = 0\n        for (i <- 0 until n) {\n        \
    \    if (s(i) == '(') count += 1\n            else count -= 1\n            if\
    \ (count < 0) return \"No\"\n        }\n        if (count == 0) \"Yes\" else \"\
    No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpntypfqmd.scala:34)\n\tat Problem.main(tmpntypfqmd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1c = s1.count(_ == '(')\n\
    \        val s2c = s2.count(_ == '(')\n        val s1o = s1.count(_ == ')')\n\
    \        val s2o = s2.count(_ == ')')\n        if (s1c == s1o && s2c == s2o) {\n\
    \            \"Yes\"\n        } else if (s1c == s1o && s2c > s2o) {\n        \
    \    if (s2c - s2o <= s1c) \"Yes\" else \"No\"\n        } else if (s1c > s1o &&\
    \ s2c == s2o) {\n            if (s1c - s1o <= s2c) \"Yes\" else \"No\"\n     \
    \   } else if (s1c > s1o && s2c > s2o) {\n            if (s1c - s1o <= s2c &&\
    \ s2c - s2o <= s1c) \"Yes\" else \"No\"\n        } else {\n            \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm6nm1rcp.scala:37)\n\tat Problem.main(tmpm6nm1rcp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1c = s1.count(_ == '(')\n\
    \        val s2c = s2.count(_ == '(')\n        val s1o = s1.count(_ == ')')\n\
    \        val s2o = s2.count(_ == ')')\n        if (s1c == s1o && s2c == s2o) return\
    \ \"Yes\"\n        else if (s1c == s1o && s2c > s2o) return \"Yes\"\n        else\
    \ if (s1c > s1o && s2c == s2o) return \"Yes\"\n        else return \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaebm64ls.scala:30)\n\tat Problem.main(tmpaebm64ls.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        if (s.length\
    \ % 2 == 1) return \"No\"\n        val stack = new Stack[Char]\n        for (c\
    \ <- s) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8f0ze5xm.scala:34)\n\tat Problem.main(tmp8f0ze5xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps69ycxbd.scala:35)\n\tat Problem.main(tmps69ycxbd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794502
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ isGood(s : String) : Boolean = {\n            var count = 0\n            for\
    \ (c <- s) {\n                if (c == '(') count += 1\n                else if\
    \ (c == ')') count -= 1\n                if (count < 0) return false\n       \
    \     }\n            return count == 0\n        }\n        if (isGood(lst(0) +\
    \ lst(1))) return \"Yes\"\n        if (isGood(lst(1) + lst(0))) return \"Yes\"\
    \n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str1 = lst(0)\n        val str2 = lst(1)\n        val str1Open = str1.count(_\
    \ == '(')\n        val str1Close = str1.count(_ == ')')\n        val str2Open\
    \ = str2.count(_ == '(')\n        val str2Close = str2.count(_ == ')')\n     \
    \   if (str1Open == str1Close && str2Open == str2Close) {\n            \"Yes\"\
    \n        } else if (str1Open == str1Close && str2Open > str2Close) {\n      \
    \      if (str2Open - str2Close == str1Open) \"Yes\" else \"No\"\n        } else\
    \ if (str1Open == str1Close && str2Open < str2Close) {\n            if (str2Close\
    \ - str2Open == str1Open) \"Yes\" else \"No\"\n        } else if (str1Open > str1Close\
    \ && str2Open == str2Close) {\n            if (str1Open - str1Close == str2Open)\
    \ \"Yes\" else \"No\"\n        } else if (str1Open < str1Close && str2Open ==\
    \ str2Close) {\n            if (str1Close - str1Open == str2Open) \"Yes\" else\
    \ \"No\"\n        } else if (str1Open > str1Close && str2Open > str2Close) {\n\
    \            if (str1Open - str1Close == str2Open - str2Close) \"Yes\" else \"\
    No\"\n        } else if (str1Open > str1Close && str2Open < str2Close) {\n   \
    \         if (str1Open - str1Close == str2Close - str2Open) \"Yes\" else \"No\"\
    \n        } else if (str1Open < str1Close && str2Open > str2Close) {\n       \
    \     if (str1Close - str1Open == str2Open - str2Close) \"Yes\" else \"No\"\n\
    \        } else if (str1Open < str1Close && str2Open < str2Close) {\n        \
    \    if (str1Close - str1Open == str2Close - str2Open) \"Yes\" else \"No\"\n \
    \       } else {\n            \"No\"\n        }\n    }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw13i677v.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m}\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0meof expected,\
    \ but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw13i677v.scala:48:11\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m    assert(matchParens((List[\e\
    [35mString\e[0m](\e[31m\"()(\"\e[0m, \e[31m\")\"\e[0m))).equals((\e[31m\"Yes\"\
    \e[0m)));\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \          Not found: matchParens\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpw13i677v.scala:49:11 ------------------------\e[0m\e[0m\n\e[31m49 |\e\
    [0m    assert(matchParens((List[\e[35mString\e[0m](\e[31m\")\"\e[0m, \e[31m\"\
    )\"\e[0m))).equals((\e[31m\"No\"\e[0m)));\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           Not found: matchParens\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw13i677v.scala:50:11 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    assert(matchParens((List[\e[35mString\e[0m](\e[31m\"\
    (()(())\"\e[0m, \e[31m\"())())\"\e[0m))).equals((\e[31m\"No\"\e[0m)));\n\e[31m\e\
    [31m   |\e[0m           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           Not found:\
    \ matchParens\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw13i677v.scala:51:11\
    \ ------------------------\e[0m\e[0m\n\e[31m51 |\e[0m    assert(matchParens((List[\e\
    [35mString\e[0m](\e[31m\")())\"\e[0m, \e[31m\"(()()(\"\e[0m))).equals((\e[31m\"\
    Yes\"\e[0m)));\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m           Not found: matchParens\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpw13i677v.scala:52:11 ------------------------\e[0m\e\
    [0m\n\e[31m52 |\e[0m    assert(matchParens((List[\e[35mString\e[0m](\e[31m\"(())))\"\
    \e[0m, \e[31m\"(()())((\"\e[0m))).equals((\e[31m\"Yes\"\e[0m)));\n\e[31m\e[31m\
    \   |\e[0m           ^^^^^^^^^^^\e[0"
  stdout: ''
  timestamp: 1659794503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else {\n      \
    \          if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfyxn5f6f.scala:36)\n\tat Problem.main(tmpfyxn5f6f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var cnt = 0\n        for (i <- 0 until n) {\n          \
    \  if (s(i) == '(') cnt += 1\n            else cnt -= 1\n            if (cnt <\
    \ 0) return \"No\"\n        }\n        if (cnt == 0) \"Yes\" else \"No\"\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80303z0x.scala:34)\n\tat Problem.main(tmp80303z0x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        val n = s.length\n        var cnt = 0\n        for\
    \ (i <- 0 until n) {\n            if (s(i) == '(') cnt += 1\n            else\
    \ cnt -= 1\n            if (cnt < 0) return \"No\"\n        }\n        if (cnt\
    \ == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphjj8s85x.scala:32)\n\tat Problem.main(tmphjj8s85x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        if (s.length\
    \ % 2 == 1) return \"No\"\n        val stack = new Stack[Char]\n        for (c\
    \ <- s) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8f0ze5xm.scala:34)\n\tat Problem.main(tmp8f0ze5xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ (s1, s2) = (lst(0), lst(1))\n        if (s1.length == 0) {\n            if (s2.length\
    \ == 0) \"Yes\"\n            else if (s2.length % 2 == 0) \"Yes\"\n          \
    \  else \"No\"\n        } else if (s2.length == 0) {\n            if (s1.length\
    \ == 0) \"Yes\"\n            else if (s1.length % 2 == 0) \"Yes\"\n          \
    \  else \"No\"\n        } else {\n            val (c1, c2) = (s1(0), s2(0))\n\
    \            if (c1 == '(' && c2 == ')') \"Yes\"\n            else if (c1 == ')'\
    \ && c2 == '(') \"Yes\"\n            else matchParens(List(s1.substring(1), s2.substring(1)))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6al6pnnn.scala:36)\n\tat Problem.main(tmp6al6pnnn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\
    \n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcswk1hz8.scala:37)\n\tat Problem.main(tmpcswk1hz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        if (s.length % 2 == 1) return \"No\"\n        val\
    \ stack = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (stack.isEmpty) return \"No\"\n            else stack.pop\n\
    \        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp111un39i.scala:32)\n\tat Problem.main(tmp111un39i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        def isGood(s : String) : Boolean\
    \ = {\n            var stack = new Stack[Char]\n            for (c <- s) {\n \
    \               if (c == '(') stack.push(c)\n                else if (c == ')')\
    \ {\n                    if (stack.isEmpty) return false\n                   \
    \ else stack.pop\n                }\n            }\n            stack.isEmpty\n\
    \        }\n        if (isGood(s1 + s2)) \"Yes\"\n        else if (isGood(s2 +\
    \ s1)) \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        if (s.count(_ == '(') != s.count(_ == ')')) \"No\"\
    \n        else {\n            val stack = new Stack[Char]\n            for (c\
    \ <- s) {\n                if (c == '(') stack.push(c)\n                else if\
    \ (stack.isEmpty) return \"No\"\n                else stack.pop\n            }\n\
    \            if (stack.isEmpty) \"Yes\" else \"No\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2uu0vqbs.scala:34)\n\tat Problem.main(tmp2uu0vqbs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ua8oj_p.scala:36)\n\tat Problem.main(tmp8ua8oj_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var count = 0\n        for (i <- 0 until n) {\n        \
    \    if (s(i) == '(') count += 1\n            else count -= 1\n            if\
    \ (count < 0) return \"No\"\n        }\n        if (count == 0) \"Yes\" else \"\
    No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpntypfqmd.scala:34)\n\tat Problem.main(tmpntypfqmd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.foldLeft(\"\")(_ + _)\n        if (s.count(_ == '(') != s.count(_ ==\
    \ ')')) return \"No\"\n        var cnt = 0\n        for (c <- s) {\n         \
    \   if (c == '(') cnt += 1\n            else cnt -= 1\n            if (cnt < 0)\
    \ return \"No\"\n        }\n        \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpayjtwt95.scala:32)\n\tat Problem.main(tmpayjtwt95.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1c = s1.count(_ == '(')\n\
    \        val s2c = s2.count(_ == '(')\n        val s1o = s1.count(_ == ')')\n\
    \        val s2o = s2.count(_ == ')')\n        if (s1c == s1o && s2c == s2o) \"\
    Yes\"\n        else if (s1c == s1o && s2c < s2o) \"No\"\n        else if (s1c\
    \ < s1o && s2c == s2o) \"No\"\n        else if (s1c < s1o && s2c < s2o) \"No\"\
    \n        else if (s1c > s1o && s2c > s2o) \"Yes\"\n        else if (s1c > s1o\
    \ && s2c < s2o) \"Yes\"\n        else if (s1c < s1o && s2c > s2o) \"Yes\"\n  \
    \      else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphywsxude.scala:36)\n\tat Problem.main(tmphywsxude.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        val n = s.length\n        var cnt = 0\n        for\
    \ (i <- 0 until n) {\n            if (s(i) == '(') cnt += 1\n            else\
    \ cnt -= 1\n            if (cnt < 0) return \"No\"\n        }\n        if (cnt\
    \ == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphjj8s85x.scala:32)\n\tat Problem.main(tmphjj8s85x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\
    \n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcswk1hz8.scala:37)\n\tat Problem.main(tmpcswk1hz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwq40dvzm.scala:35)\n\tat Problem.main(tmpwq40dvzm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ isGood(s : String) : Boolean = {\n            var cnt = 0\n            for (c\
    \ <- s) {\n                if (c == '(') cnt += 1\n                else cnt -=\
    \ 1\n                if (cnt < 0) return false\n            }\n            return\
    \ cnt == 0\n        }\n        if (isGood(lst(0) + lst(1))) \"Yes\"\n        else\
    \ if (isGood(lst(1) + lst(0))) \"Yes\"\n        else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        def isGood(s : String) : Boolean\
    \ = {\n            var count = 0\n            for (c <- s) {\n               \
    \ if (c == '(') count += 1\n                else count -= 1\n                if\
    \ (count < 0) return false\n            }\n            return count == 0\n   \
    \     }\n        if (isGood(s1 + s2)) return \"Yes\"\n        if (isGood(s2 +\
    \ s1)) return \"Yes\"\n        return \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            if (s(i) == '(') stack.push(s(i))\n            else if (s(i)\
    \ == ')') {\n                if (stack.isEmpty) return \"No\"\n              \
    \  stack.pop\n            }\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu1_ze0bd.scala:36)\n\tat Problem.main(tmpu1_ze0bd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        val n = s.length\n        var cnt = 0\n        for\
    \ (i <- 0 until n) {\n            if (s(i) == '(') cnt += 1\n            else\
    \ cnt -= 1\n            if (cnt < 0) return \"No\"\n        }\n        if (cnt\
    \ == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphjj8s85x.scala:32)\n\tat Problem.main(tmphjj8s85x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str1 = lst(0)\n        val str2 = lst(1)\n        val str1_len = str1.length\n\
    \        val str2_len = str2.length\n        val str1_open = str1.count(_ == '(')\n\
    \        val str1_close = str1.count(_ == ')')\n        val str2_open = str2.count(_\
    \ == '(')\n        val str2_close = str2.count(_ == ')')\n        if (str1_open\
    \ == str1_close && str2_open == str2_close) {\n            if (str1_open == str2_close)\
    \ \"Yes\"\n            else \"No\"\n        }\n        else if (str1_open == str1_close)\
    \ {\n            if (str1_open == str2_close) \"Yes\"\n            else \"No\"\
    \n        }\n        else if (str2_open == str2_close) {\n            if (str2_open\
    \ == str1_close) \"Yes\"\n            else \"No\"\n        }\n        else \"\
    No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7xg_e7kf.scala:41)\n\tat Problem.main(tmp7xg_e7kf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else {\n      \
    \          if (stack.isEmpty) return \"No\"\n                stack.pop\n     \
    \       }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxsmkbstm.scala:36)\n\tat Problem.main(tmpxsmkbstm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val n1 = s1.length\n        val\
    \ n2 = s2.length\n        val dp = Array.ofDim[Int](n1 + 1, n2 + 1)\n        for\
    \ (i <- 0 to n1) {\n            for (j <- 0 to n2) {\n                if (i ==\
    \ 0 && j == 0) dp(i)(j) = 0\n                else if (i == 0) {\n            \
    \        if (s2(j - 1) == '(') dp(i)(j) = dp(i)(j - 1) + 1\n                 \
    \   else dp(i)(j) = dp(i)(j - 1) - 1\n                }\n                else\
    \ if (j == 0) {\n                    if (s1(i - 1) == '(') dp(i)(j) = dp(i - 1)(j)\
    \ + 1\n                    else dp(i)(j) = dp(i - 1)(j) - 1\n                }\n\
    \                else {\n                    if (s1(i - 1) == '(') dp(i)(j) =\
    \ max(dp(i - 1)(j) + 1, dp(i)(j - 1))\n                    else dp(i)(j) = max(dp(i\
    \ - 1)(j) - 1, dp(i)(j - 1))\n                }\n            }\n        }\n  \
    \      if (dp(n1)(n2) == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8xxw6piw.scala:43)\n\tat Problem.main(tmp8xxw6piw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa514d142.scala:36)\n\tat Problem.main(tmpa514d142.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val len\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until len)\
    \ {\n            if (s(i) == '(') stack.push('(')\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc1mwusih.scala:34)\n\tat Problem.main(tmpc1mwusih.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rcnvf42.scala:35)\n\tat Problem.main(tmp5rcnvf42.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            if (s(i) == '(') stack.push(s(i))\n            else if (s(i)\
    \ == ')') {\n                if (stack.isEmpty) return \"No\"\n              \
    \  else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"Yes\"\
    \ else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbhb13a2j.scala:36)\n\tat Problem.main(tmpbhb13a2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1c = s1.count(c => c == '(')\n\
    \        val s2c = s2.count(c => c == '(')\n        if (s1c == s2c) {\n      \
    \      val s = s1 + s2\n            if (s.count(c => c == '(') == s.count(c =>\
    \ c == ')')) \"Yes\" else \"No\"\n        } else if (s1c > s2c) {\n          \
    \  val s = s1 + s2\n            if (s.count(c => c == '(') == s.count(c => c ==\
    \ ')')) \"Yes\" else \"No\"\n        } else {\n            val s = s2 + s1\n \
    \           if (s.count(c => c == '(') == s.count(c => c == ')')) \"Yes\" else\
    \ \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvif8lvka.scala:43)\n\tat Problem.main(tmpvif8lvka.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwq40dvzm.scala:35)\n\tat Problem.main(tmpwq40dvzm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else {\n      \
    \          if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqq5deb2x.scala:36)\n\tat Problem.main(tmpqq5deb2x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwq40dvzm.scala:35)\n\tat Problem.main(tmpwq40dvzm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var cnt = 0\n        for (i <- 0 until n) {\n          \
    \  if (s(i) == '(') cnt += 1\n            else cnt -= 1\n            if (cnt <\
    \ 0) return \"No\"\n        }\n        if (cnt == 0) \"Yes\" else \"No\"\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80303z0x.scala:34)\n\tat Problem.main(tmp80303z0x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwq40dvzm.scala:35)\n\tat Problem.main(tmpwq40dvzm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa514d142.scala:36)\n\tat Problem.main(tmpa514d142.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = Stack[Char]()\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpctjzt7_p.scala:35)\n\tat Problem.main(tmpctjzt7_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794524
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        val dp = Array.fill(n + 1)(0)\n        for (i <- 0 until\
    \ n) {\n            if (s(i) == '(') dp(i + 1) = dp(i) + 1\n            else dp(i\
    \ + 1) = dp(i) - 1\n        }\n        if (dp(n) != 0) return \"No\"\n       \
    \ for (i <- 0 until n) {\n            if (dp(i) < 0) return \"No\"\n        }\n\
    \        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxc_948tt.scala:37)\n\tat Problem.main(tmpxc_948tt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1_good = isGood(s1)\n   \
    \     val s2_good = isGood(s2)\n        if (s1_good && s2_good) return \"Yes\"\
    \n        if (s1_good) {\n            val s2_good_after_concat = isGood(s1 + s2)\n\
    \            if (s2_good_after_concat) return \"Yes\"\n        }\n        if (s2_good)\
    \ {\n            val s1_good_after_concat = isGood(s2 + s1)\n            if (s1_good_after_concat)\
    \ return \"Yes\"\n        }\n        \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8r7yewn6.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36ms1_good\e[0m = isGood(s1)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Not found: isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8r7yewn6.scala:21:22 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        \e[33mval\e[0m \e[36ms2_good\e[0m = isGood(s2)\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8r7yewn6.scala:24:39\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36ms2_good_after_concat\e[0m = isGood(s1 + s2)\n\e[31m\e[31m   |\e[0m   \
    \                                    ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                           Not found: isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8r7yewn6.scala:28:39 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36ms1_good_after_concat\e\
    [0m = isGood(s2 + s1)\n\e[31m\e[31m   |\e[0m                                 \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                                       Not\
    \ found: isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659794521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else {\n      \
    \          if (stack.isEmpty) return \"No\"\n                stack.pop\n     \
    \       }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpinu982pi.scala:36)\n\tat Problem.main(tmpinu982pi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1Open = s1.count(_ == '(')\n\
    \        val s1Close = s1.count(_ == ')')\n        val s2Open = s2.count(_ ==\
    \ '(')\n        val s2Close = s2.count(_ == ')')\n        if (s1Open == s1Close\
    \ && s2Open == s2Close) \"Yes\"\n        else if (s1Open == s1Close && s2Open\
    \ > s2Close) \"Yes\"\n        else if (s1Open > s1Close && s2Open == s2Close)\
    \ \"Yes\"\n        else if (s1Open > s1Close && s2Open > s2Close) {\n        \
    \    if (s1Open - s1Close == s2Open - s2Close) \"Yes\"\n            else \"No\"\
    \n        }\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzhe8z38a.scala:34)\n\tat Problem.main(tmpzhe8z38a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa514d142.scala:36)\n\tat Problem.main(tmpa514d142.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1_count = s1.count(_ == '(')\n\
    \        val s2_count = s2.count(_ == '(')\n        val s1_count_close = s1.count(_\
    \ == ')')\n        val s2_count_close = s2.count(_ == ')')\n        if (s1_count\
    \ == s1_count_close && s2_count == s2_count_close) {\n            if (s1_count\
    \ == s2_count_close && s2_count == s1_count_close) {\n                \"Yes\"\n\
    \            } else {\n                \"No\"\n            }\n        } else {\n\
    \            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx_nh7xl9.scala:35)\n\tat Problem.main(tmpx_nh7xl9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ (l, r) = (lst(0), lst(1))\n        val (l_open, l_close) = (l.count(_ == '('),\
    \ l.count(_ == ')'))\n        val (r_open, r_close) = (r.count(_ == '('), r.count(_\
    \ == ')'))\n        if (l_open == l_close && r_open == r_close) \"Yes\"\n    \
    \    else if (l_open == l_close && r_open > r_close) \"Yes\"\n        else if\
    \ (l_open > l_close && r_open == r_close) \"Yes\"\n        else if (l_open > l_close\
    \ && r_open > r_close) \"Yes\"\n        else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprvh7iaup.scala:28)\n\tat Problem.main(tmprvh7iaup.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        if (s.count(_\
    \ == '(') != s.count(_ == ')')) return \"No\"\n        var stack = new Stack[Char]\n\
    \        for (c <- s) {\n            if (c == '(') stack.push(c)\n           \
    \ else {\n                if (stack.isEmpty) return \"No\"\n                else\
    \ stack.pop\n            }\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgsh5tijs.scala:36)\n\tat Problem.main(tmpgsh5tijs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        if (s.length\
    \ % 2 == 1) return \"No\"\n        val stack = new Stack[Char]\n        for (i\
    \ <- 0 until s.length) {\n            if (s(i) == '(') stack.push('(')\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpof0tfwdb.scala:36)\n\tat Problem.main(tmpof0tfwdb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\
    \n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcswk1hz8.scala:37)\n\tat Problem.main(tmpcswk1hz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4es24utp.scala:36)\n\tat Problem.main(tmp4es24utp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str1 = lst(0)\n        val str2 = lst(1)\n        val str1Len = str1.length\n\
    \        val str2Len = str2.length\n        val str1Open = str1.count(_ == '(')\n\
    \        val str1Close = str1.count(_ == ')')\n        val str2Open = str2.count(_\
    \ == '(')\n        val str2Close = str2.count(_ == ')')\n        if (str1Open\
    \ == str1Close && str2Open == str2Close) {\n            \"Yes\"\n        } else\
    \ if (str1Open == str1Close && str2Open != str2Close) {\n            if (str2Open\
    \ > str2Close) {\n                if (str2Open - str2Close == str1Open) {\n  \
    \                  \"Yes\"\n                } else {\n                    \"No\"\
    \n                }\n            } else {\n                if (str2Close - str2Open\
    \ == str1Close) {\n                    \"Yes\"\n                } else {\n   \
    \                 \"No\"\n                }\n            }\n        } else if\
    \ (str1Open != str1Close && str2Open == str2Close) {\n            if (str1Open\
    \ > str1Close) {\n                if (str1Open - str1Close == str2Open) {\n  \
    \                  \"Yes\"\n                } else {\n                    \"No\"\
    \n                }\n            } else {\n                if (str1Close - str1Open\
    \ == str2Close) {\n                    \"Yes\"\n                } else {\n   \
    \                 \"No\"\n                }\n            }\n        } else {\n\
    \            if (str1Open > str1Close) {\n                if (str1Open - str1Close\
    \ == str2Open) {\n                    \"Yes\"\n                } else {\n    \
    \                \"No\"\n                }\n            } else {\n           \
    \     if (str1Close - str1Open == str2Close) {\n                    \"Yes\"\n\
    \                } else {\n                    \"No\"\n                }\n   \
    \         }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq9bsjd3r.scala:73)\n\tat Problem.main(tmpq9bsjd3r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.foldLeft(\"\")((x, y) => x + y)\n        val n = s.length\n        var\
    \ stack = new Stack[Char]\n        for (i <- 0 until n) {\n            val c =\
    \ s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptthrlsmr.scala:35)\n\tat Problem.main(tmptthrlsmr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1l = s1.length\n        val\
    \ s2l = s2.length\n        val s1c = s1.count(_ == '(')\n        val s2c = s2.count(_\
    \ == '(')\n        val s1o = s1.count(_ == ')')\n        val s2o = s2.count(_\
    \ == ')')\n        if (s1c == s1o && s2c == s2o) {\n            if (s1c == s2o)\
    \ \"Yes\"\n            else \"No\"\n        } else {\n            if (s1c == s2o\
    \ && s1o == s2c) \"Yes\"\n            else \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcubkn3rs.scala:35)\n\tat Problem.main(tmpcubkn3rs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            if (s(i)\
    \ == '(') stack.push('(')\n            else if (stack.isEmpty) return \"No\"\n\
    \            else stack.pop\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ged_dhh.scala:33)\n\tat Problem.main(tmp9ged_dhh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps69ycxbd.scala:35)\n\tat Problem.main(tmps69ycxbd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794502
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = Stack[Char]()\n        for (i <- 0 until s.length) {\n            val c =\
    \ s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpga64vnsp.scala:36)\n\tat Problem.main(tmpga64vnsp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa514d142.scala:36)\n\tat Problem.main(tmpa514d142.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        if (s.length\
    \ % 2 == 1) return \"No\"\n        val stack = new Stack[Char]\n        for (c\
    \ <- s) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8f0ze5xm.scala:34)\n\tat Problem.main(tmp8f0ze5xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        if (s.length\
    \ % 2 == 1) return \"No\"\n        val stack = new Stack[Char]\n        for (c\
    \ <- s) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8f0ze5xm.scala:34)\n\tat Problem.main(tmp8f0ze5xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1_count = s1.count(_ == '(')\n\
    \        val s2_count = s2.count(_ == '(')\n        val s1_count_close = s1.count(_\
    \ == ')')\n        val s2_count_close = s2.count(_ == ')')\n        if (s1_count\
    \ == s1_count_close && s2_count == s2_count_close) {\n            val s = s1 +\
    \ s2\n            val s_count = s.count(_ == '(')\n            val s_count_close\
    \ = s.count(_ == ')')\n            if (s_count == s_count_close) \"Yes\" else\
    \ \"No\"\n        } else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnalj_vnf.scala:32)\n\tat Problem.main(tmpnalj_vnf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else {\n      \
    \          if (stack.isEmpty) return \"No\"\n                stack.pop\n     \
    \       }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxsmkbstm.scala:36)\n\tat Problem.main(tmpxsmkbstm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ s = lst(0) + lst(1)\n        var count = 0\n        for (i <- 0 until s.length)\
    \ {\n            if (s(i) == '(') count += 1\n            else count -= 1\n  \
    \          if (count < 0) return \"No\"\n        }\n        if (count == 0) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwe1ez4pm.scala:31)\n\tat Problem.main(tmpwe1ez4pm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\
    \n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcswk1hz8.scala:37)\n\tat Problem.main(tmpcswk1hz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        var stack = new Stack[Char]\n\
    \        for (c <- s1) {\n            if (c == '(') stack.push(c)\n          \
    \  else if (stack.nonEmpty) stack.pop\n            else return \"No\"\n      \
    \  }\n        for (c <- s2) {\n            if (c == '(') stack.push(c)\n     \
    \       else if (stack.nonEmpty) stack.pop\n            else return \"No\"\n \
    \       }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq97g6_r_.scala:37)\n\tat Problem.main(tmpq97g6_r_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\
    \n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcswk1hz8.scala:37)\n\tat Problem.main(tmpcswk1hz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        if (s.length\
    \ % 2 == 1) return \"No\"\n        val stack = new Stack[Char]\n        for (c\
    \ <- s) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8f0ze5xm.scala:34)\n\tat Problem.main(tmp8f0ze5xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4))\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (isGood(s3)) \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ isGood\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjuqnr55.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (isGood(s4)) \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isGood\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1_open = s1.count(_ == '(')\n\
    \        val s1_close = s1.count(_ == ')')\n        val s2_open = s2.count(_ ==\
    \ '(')\n        val s2_close = s2.count(_ == ')')\n        if (s1_open == s1_close\
    \ && s2_open == s2_close) \"Yes\"\n        else if (s1_open == s1_close && s2_open\
    \ > s2_close) {\n            if (s2_open - s2_close <= s1_open) \"Yes\"\n    \
    \        else \"No\"\n        }\n        else if (s1_open == s1_close && s2_open\
    \ < s2_close) {\n            if (s2_close - s2_open <= s1_open) \"Yes\"\n    \
    \        else \"No\"\n        }\n        else if (s1_open > s1_close && s2_open\
    \ == s2_close) {\n            if (s1_open - s1_close <= s2_open) \"Yes\"\n   \
    \         else \"No\"\n        }\n        else if (s1_open < s1_close && s2_open\
    \ == s2_close) {\n            if (s1_close - s1_open <= s2_open) \"Yes\"\n   \
    \         else \"No\"\n        }\n        else if (s1_open > s1_close && s2_open\
    \ > s2_close) {\n            if (s1_open - s1_close + s2_open - s2_close <= s1_open\
    \ + s2_open) \"Yes\"\n            else \"No\"\n        }\n        else if (s1_open\
    \ > s1_close && s2_open < s2_close) {\n            if (s1_open - s1_close + s2_close\
    \ - s2_open <= s1_open + s2_open) \"Yes\"\n            else \"No\"\n        }\n\
    \        else if (s1_open < s1_close && s2_open > s2_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx32f8s14.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx32f8s14.scala:49:49\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (s1_open < s1_close && s2_open > s2_\n\e[31m\e[31m   |\e[0m      \
    \                                           ^^^\e[0m\n\e[31m   |\e[0m        \
    \                                         Not found: s2_\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794525
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa514d142.scala:36)\n\tat Problem.main(tmpa514d142.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1c = s1.count(_ == '(')\n\
    \        val s2c = s2.count(_ == '(')\n        val s1o = s1.count(_ == ')')\n\
    \        val s2o = s2.count(_ == ')')\n        if (s1c == s1o && s2c == s2o) \"\
    Yes\"\n        else if (s1c == s1o && s2c > s2o) \"Yes\"\n        else if (s1c\
    \ > s1o && s2c == s2o) \"Yes\"\n        else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpchplu96c.scala:30)\n\tat Problem.main(tmpchplu96c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1_open = s1.count(_ == '(')\n\
    \        val s1_close = s1.count(_ == ')')\n        val s2_open = s2.count(_ ==\
    \ '(')\n        val s2_close = s2.count(_ == ')')\n        if (s1_open == s1_close\
    \ && s2_open == s2_close) \"Yes\"\n        else if (s1_open == s1_close && s2_open\
    \ > s2_close) \"Yes\"\n        else if (s1_open > s1_close && s2_open == s2_close)\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe2ue6r8z.scala:30)\n\tat Problem.main(tmpe2ue6r8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else {\n      \
    \          if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfyxn5f6f.scala:36)\n\tat Problem.main(tmpfyxn5f6f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1c = s1.count(_ == '(')\n\
    \        val s2c = s2.count(_ == '(')\n        if (s1c == s2c) \"Yes\"\n     \
    \   else if (s1c > s2c) {\n            if (s1.count(_ == ')') > s2.count(_ ==\
    \ ')')) \"Yes\"\n            else \"No\"\n        }\n        else {\n        \
    \    if (s2.count(_ == ')') > s1.count(_ == ')')) \"Yes\"\n            else \"\
    No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi_4fpc_m.scala:33)\n\tat Problem.main(tmpi_4fpc_m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s1Count = s1.count(_ == '(')\n\
    \        val s2Count = s2.count(_ == '(')\n        if (s1Count == s2Count) \"\
    Yes\"\n        else if (s1Count == s2Count + 1) {\n            if (s1.count(_\
    \ == ')') == s2.count(_ == ')')) \"Yes\"\n            else \"No\"\n        }\n\
    \        else if (s1Count + 1 == s2Count) {\n            if (s1.count(_ == ')')\
    \ == s2.count(_ == ')')) \"Yes\"\n            else \"No\"\n        }\n       \
    \ else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3c4njeuy.scala:34)\n\tat Problem.main(tmp3c4njeuy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        if (s3.length\
    \ % 2 == 1) return \"No\"\n        val stack = new Stack[Char]\n        for (c\
    \ <- s3) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8w390nyd.scala:34)\n\tat Problem.main(tmp8w390nyd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794536
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        if (s.count(_ == '(') != s.count(_ == ')')) \"No\"\
    \n        else {\n            val stack = new Stack[Char]\n            for (c\
    \ <- s) {\n                if (c == '(') stack.push(c)\n                else if\
    \ (stack.isEmpty) return \"No\"\n                else stack.pop\n            }\n\
    \            if (stack.isEmpty) \"Yes\" else \"No\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2uu0vqbs.scala:34)\n\tat Problem.main(tmp2uu0vqbs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ (s1, s2) = (lst(0), lst(1))\n        def isGood(s : String) : Boolean = {\n\
    \            var count = 0\n            for (c <- s) {\n                if (c\
    \ == '(') count += 1\n                else if (c == ')') count -= 1\n        \
    \        if (count < 0) return false\n            }\n            return count\
    \ == 0\n        }\n        if (isGood(s1 + s2)) return \"Yes\"\n        if (isGood(s2\
    \ + s1)) return \"Yes\"\n        return \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\
    \n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcswk1hz8.scala:37)\n\tat Problem.main(tmpcswk1hz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val\
    \ s4 = s2 + s1\n        if (s3.length % 2 == 1) return \"No\"\n        val stack\
    \ = new Stack[Char]\n        for (c <- s3) {\n            if (c == '(') stack.push(c)\n\
    \            else if (stack.isEmpty) return \"No\"\n            else stack.pop\n\
    \        }\n        if (stack.isEmpty) return \"Yes\"\n        else {\n      \
    \      stack.clear\n            for (c <- s4) {\n                if (c == '(')\
    \ stack.push(c)\n                else if (stack.isEmpty) return \"No\"\n     \
    \           else stack.pop\n            }\n            if (stack.isEmpty) return\
    \ \"Yes\"\n            else return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxz5xt0dc.scala:45)\n\tat Problem.main(tmpxz5xt0dc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpke9gtlan.scala:35)\n\tat Problem.main(tmpke9gtlan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        if (s1.length + s2.length % 2\
    \ == 1) return \"No\"\n        val s = s1 + s2\n        val stack = new Stack[Char]\n\
    \        for (c <- s) {\n            if (c == '(') stack.push(c)\n           \
    \ else {\n                if (stack.isEmpty) return \"No\"\n                stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdrl29ih.scala:36)\n\tat Problem.main(tmpgdrl29ih.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcblz88o.scala:37)\n\tat Problem.main(tmpdcblz88o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = Stack[Char]()\n        for (i <- 0 until n)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else {\n                if (stack.isEmpty) return \"No\"\n           \
    \     else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf9fpbsdd.scala:37)\n\tat Problem.main(tmpf9fpbsdd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794538
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString(\"\")\n        val stack = new Stack[Char]\n        for (c\
    \ <- s) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3lfisy76.scala:31)\n\tat Problem.main(tmp3lfisy76.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794538
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4akc9kw7.scala:35)\n\tat Problem.main(tmp4akc9kw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var cnt = 0\n        for (i <- 0 until n) {\n          \
    \  if (s(i) == '(') cnt += 1\n            else cnt -= 1\n            if (cnt <\
    \ 0) return \"No\"\n        }\n        if (cnt == 0) \"Yes\" else \"No\"\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80303z0x.scala:34)\n\tat Problem.main(tmp80303z0x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_xjaj83b.scala:35)\n\tat Problem.main(tmp_xjaj83b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794538
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzzhme_6.scala:35)\n\tat Problem.main(tmpqzzhme_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val n\
    \ = s.length\n        var stack = new Stack[Char]\n        for (i <- 0 until n)\
    \ {\n            if (s(i) == '(') stack.push(s(i))\n            else if (s(i)\
    \ == ')') {\n                if (stack.isEmpty) return \"No\"\n              \
    \  else stack.pop\n            }\n        }\n        if (stack.isEmpty) \"Yes\"\
    \ else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbhb13a2j.scala:36)\n\tat Problem.main(tmpbhb13a2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until s.length) {\n            val c\
    \ = s(i)\n            if (c == '(') stack.push(c)\n            else {\n      \
    \          if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfyxn5f6f.scala:36)\n\tat Problem.main(tmpfyxn5f6f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9jndr_.scala:35)\n\tat Problem.main(tmpun9jndr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        if (s3.count(_\
    \ == '(') == s3.count(_ == ')')) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplchunwh9.scala:33)\n\tat Problem.main(tmplchunwh9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794538
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.mkString\n        var count = 0\n        for (c <- s) {\n          \
    \  if (c == '(') count += 1\n            else count -= 1\n            if (count\
    \ < 0) return \"No\"\n        }\n        if (count == 0) \"Yes\" else \"No\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4u2r2uuc.scala:31)\n\tat Problem.main(tmp4u2r2uuc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ s = lst(0) + lst(1)\n        var stack = new Stack[Char]\n        for (c <-\
    \ s) {\n            if (c == '(') stack.push(c)\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5sw_vc3a.scala:31)\n\tat Problem.main(tmp5sw_vc3a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794538
