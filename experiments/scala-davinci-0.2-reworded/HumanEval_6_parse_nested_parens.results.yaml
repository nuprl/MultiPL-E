language: scala
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (group <- paren_groups) {\n            var max_level = 0\n\
    \            var level = 0\n            for (paren <- group) {\n             \
    \   if (paren == '(') {\n                    level += 1\n                    if\
    \ (level > max_level) max_level = level\n                }\n                else\
    \ if (paren == ')') {\n                    level -= 1\n                }\n   \
    \         }\n            result = result :+ max_level\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var stack\
    \ = Stack[Char]()\n            var max_depth = 0\n            var depth = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         stack.push(c)\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          stack.pop\n                    depth -= 1\n                }\n    \
    \        }\n            result = result :+ max_depth\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797850
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_list = List[Long]()\n        var paren_stack = Stack[Char]()\n\
    \        var max_depth = 0\n        for (c <- paren_string) {\n            if\
    \ (c == '(') {\n                paren_stack.push(c)\n                max_depth\
    \ = max(max_depth, paren_stack.size)\n            } else if (c == ')') {\n   \
    \             if (paren_stack.isEmpty) {\n                    println(\"Invalid\
    \ input\")\n                    return List[Long]()\n                }\n     \
    \           paren_stack.pop\n            } else if (c == ' ') {\n            \
    \    paren_list = paren_list :+ max_depth\n                max_depth = 0\n   \
    \         }\n        }\n        if (!paren_stack.isEmpty) {\n            println(\"\
    Invalid input\")\n            return List[Long]()\n        }\n        paren_list\
    \ = paren_list :+ max_depth\n        return paren_list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') depth += 1\n                else if (paren == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result = result :+ max_depth\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_max = paren_levels.map(x => if (x < 0) 0 else x)\n  \
    \      paren_levels_max.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ro8lqxj.scala:13:25\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_levels_max.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            levels += max_level\n        }\n        levels.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_level = 0\n            var\
    \ current_level = 0\n            for (i <- 0 until group.length) {\n         \
    \       if (group(i) == '(') {\n                    current_level += 1\n     \
    \               max_level = max(max_level, current_level)\n                } else\
    \ if (group(i) == ')') {\n                    current_level -= 1\n           \
    \     }\n            }\n            max_level\n        })\n        max_nesting_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaxtmxaza.scala:24:27\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting_levels.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_nesting += 1\n\
    \                    max_nesting = max(max_nesting, current_nesting)\n       \
    \         } else if (paren == ')') {\n                    current_nesting -= 1\n\
    \                }\n            }\n            result = result :+ max_nesting\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var paren_list = paren_string.split(\"\
    \ \")\n        for (i <- 0 until paren_list.length) {\n            var paren_group\
    \ = paren_list(i)\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (j <- 0 until paren_group.length) {\n                if\
    \ (paren_group(j) == '(') {\n                    current_depth += 1\n        \
    \            if (current_depth > max_depth) max_depth = current_depth\n      \
    \          }\n                else if (paren_group(j) == ')') {\n            \
    \        current_depth -= 1\n                }\n            }\n            result\
    \ = result :+ max_depth\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result =\
    \ result :+ max_depth\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren <- parens) {\n            var depth =\
    \ 0\n            var max_depth = 0\n            for (c <- paren) {\n         \
    \       if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result = result :+ max_depth\n        }\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var max_level\
    \ = 0\n        var level = 0\n        var max_levels = List[Long]()\n        for\
    \ (i <- 0 until paren_groups.length) {\n            val paren_group = paren_groups(i)\n\
    \            for (j <- 0 until paren_group.length) {\n                val paren\
    \ = paren_group(j)\n                if (paren == '(') {\n                    level\
    \ += 1\n                    if (level > max_level) max_level = level\n       \
    \         }\n                else if (paren == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_levels = max_levels\
    \ :+ max_level\n            max_level = 0\n            level = 0\n        }\n\
    \        return max_levels\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParens(x, 0))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8qcxnb5m.scala:11:67\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e\
    [0m = paren_groups.map(\e[36mx\e[0m => parseNestedParens(x, \e[31m0\e[0m))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \         ^^^^\e[0m\n\e[31m   |\e[0m                                         \
    \        Found:    \e[1m\e[31m(\e[0mString\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e\
    [1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                          \
    \                       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8qcxnb5m.scala:12:21 --------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        paren_levels.toList\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m]\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0l.toLong, 0l.toLong)((acc, y) =>\
    \ {\n            if (y == '(') (acc._1 + 1, max(acc._1 + 1, acc._2))\n       \
    \     else if (y == ')') (acc._1 - 1, acc._2)\n            else acc\n        })._2)\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797850
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_level = 0l\n            var current_level = 0l\n            for\
    \ (paren <- paren_group) {\n                if (paren == '(') {\n            \
    \        current_level += 1\n                    if (current_level > max_level)\
    \ max_level = current_level\n                }\n                else if (paren\
    \ == ')') {\n                    current_level -= 1\n                }\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(x => x == '(') - x.count(x => x == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        val max_level\
    \ = paren_levels_abs.max\n        val paren_levels_max = paren_levels.map(x =>\
    \ if (x > 0) max_level else -max_level)\n        val paren_levels_max_abs = paren_levels_max.map(x\
    \ => abs(x))\n        paren_levels_max_abs.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcahd3h0g.scala:16:29\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        paren_levels_max_abs.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    current_level += 1\n\
    \                    max_level = max(max_level, current_level)\n             \
    \   } else if (c == ')') {\n                    current_level -= 1\n         \
    \       }\n            }\n            result += max_level\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_groups_nested_levels\
    \ = paren_groups.map(x => x.count(_ == '(') - x.count(_ == ')'))\n        val\
    \ paren_groups_nested_levels_max = paren_groups_nested_levels.map(x => if (x <\
    \ 0) 0 else x)\n        paren_groups_nested_levels_max.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4gsosm8z.scala:13:39\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_groups_nested_levels_max.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m       \
    \ Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n   \
    \         var count = 0\n            var max_count = 0\n            for (j <-\
    \ 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j) ==\
    \ '(') count += 1\n                else if (paren_groups(i)(j) == ')') count -=\
    \ 1\n                if (count > max_count) max_count = count\n            }\n\
    \            result += max_count\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else level -= 1\n            \
    \    max_level = max(max_level, level)\n            }\n            result = result\
    \ :+ max_level\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1)).map(x =>\
    \ x.scanLeft(0)(_ + _).drop(1))\n        paren_levels.map(x => x.max).map(x =>\
    \ if (x < 0) 0 else x).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6eb65ptl.scala:12:67\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        paren_levels.map(\e[36mx\e\
    [0m => x.max).map(\e[36mx\e[0m => \e[33mif\e[0m (x < \e[31m0\e[0m) \e[31m0\e[0m\
    \ \e[33melse\e[0m x).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                max_level = max(max_level, level)\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_max = paren_levels.map(x => if (x > 0) x else 0)\n  \
    \      paren_levels_max.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpitr2ziun.scala:13:25\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_levels_max.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (group <- paren_groups) {\n            var max_depth = 0\n\
    \            var current_depth = 0\n            for (c <- group) {\n         \
    \       if (c == '(') {\n                    current_depth += 1\n            \
    \        if (current_depth > max_depth) max_depth = current_depth\n          \
    \      }\n                else if (c == ')') {\n                    current_depth\
    \ -= 1\n                }\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // TODO: Implement this function\n        var result:List[Long] =\
    \ List()\n        var stack:Stack[Char] = Stack()\n        var max:Long = 0\n\
    \        var count:Long = 0\n        for (c <- paren_string) {\n            if\
    \ (c == '(') {\n                stack.push(c)\n                count += 1\n  \
    \              if (count > max) {\n                    max = count\n         \
    \       }\n            } else if (c == ')') {\n                stack.pop()\n \
    \               count -= 1\n            } else if (c == ' ') {\n             \
    \   result = result :+ max\n                max = 0\n                count = 0\n\
    \            }\n        }\n        result = result :+ max\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n   \
    \         val paren_group = paren_groups(i)\n            var paren_level = 0\n\
    \            var max_paren_level = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                val paren = paren_group(j)\n                if (paren ==\
    \ '(') paren_level += 1\n                else if (paren == ')') paren_level -=\
    \ 1\n                if (paren_level > max_paren_level) max_paren_level = paren_level\n\
    \            }\n            paren_levels += max_paren_level\n        }\n     \
    \   paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.filter(y => y == '(' || y == ')').map(y =>\
    \ if (y == '(') 1 else -1).scanLeft(0)(_ + _).max)\n        paren_levels.toList.map(x\
    \ => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_nesting_level = 0\n     \
    \       var nesting_level = 0\n            for (paren <- group) {\n          \
    \      if (paren == '(') {\n                    nesting_level += 1\n         \
    \           if (nesting_level > max_nesting_level) max_nesting_level = nesting_level\n\
    \                }\n                else if (paren == ')') {\n               \
    \     nesting_level -= 1\n                }\n            }\n            max_nesting_level\n\
    \        })\n        max_nesting_levels.toList.map(x => x.toLong)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') level += 1\n                else if (x(i) == ')') level -= 1\n        \
    \        if (level > max_level) max_level = level\n            }\n           \
    \ max_level\n        })\n        paren_levels.toList.map(x => x.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') level += 1\n                else if (x(i) == ')') level -= 1\n        \
    \        max_level = max(max_level, level)\n            }\n            max_level\n\
    \        })\n        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            val paren_group = paren_groups(i)\n            var level = 0\n  \
    \          var max_level = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group(j) == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (paren_group(j) == ')') {\n                \
    \    level -= 1\n                }\n            }\n            paren_levels +=\
    \ max_level\n        }\n        paren_levels.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n   \
    \         var max_depth = 0\n            var current_depth = 0\n            for\
    \ (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                }\n                else if\
    \ (paren_groups(i)(j) == ')') {\n                    current_depth -= 1\n    \
    \            }\n            }\n            result += max_depth\n        }\n  \
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ count = 0\n            var max_count = 0\n            for (c <- group) {\n \
    \               if (c == '(') count += 1\n                else if (c == ')') count\
    \ -= 1\n                if (count > max_count) max_count = count\n           \
    \ }\n            result += max_count\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (paren <- parens) {\n            var stack = new Stack[Char]()\n\
    \            var max_depth = 0\n            var cur_depth = 0\n            for\
    \ (c <- paren) {\n                if (c == '(') {\n                    stack.push(c)\n\
    \                    cur_depth += 1\n                    max_depth = max(max_depth,\
    \ cur_depth)\n                } else if (c == ')') {\n                    if (stack.isEmpty)\
    \ {\n                        throw new Exception(\"Invalid paren string\")\n \
    \                   }\n                    stack.pop\n                    cur_depth\
    \ -= 1\n                }\n            }\n            if (!stack.isEmpty) {\n\
    \                throw new Exception(\"Invalid paren string\")\n            }\n\
    \            result = result :+ max_depth\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n            var level = 0\n\
    \            var max_level = 0\n            for (c <- x) {\n                if\
    \ (c == '(') level += 1\n                else level -= 1\n                max_level\
    \ = max(max_level, level)\n            }\n            max_level\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo62ysmew.scala:19:11\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e\
    [31m\" \"\e[0m).map(\e[36mx\e[0m => {\n\e[31m11 |\e[0m            \e[33mvar\e\
    [0m \e[36mlevel\e[0m = \e[31m0\e[0m\n\e[31m12 |\e[0m            \e[33mvar\e[0m\
    \ \e[36mmax_level\e[0m = \e[31m0\e[0m\n\e[31m13 |\e[0m            \e[33mfor\e\
    [0m (c <- x) {\n\e[31m14 |\e[0m                \e[33mif\e[0m (c == \e[31m'('\e\
    [0m) level += \e[31m1\e[0m\n\e[31m15 |\e[0m                \e[33melse\e[0m level\
    \ -= \e[31m1\e[0m\n\e[31m16 |\e[0m                max_level = max(max_level, level)\n\
    \e[31m17 |\e[0m            }\n\e[31m18 |\e[0m            max_level\n\e[31m19 |\e\
    [0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_nesting_level = 0\n            var current_nesting_level = 0\n\
    \            for (paren <- paren_group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = current_nesting_level\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           current_nesting_level -= 1\n                }\n            }\n   \
    \         max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_max = paren_levels.map(x => if (x < 0) 0 else x)\n  \
    \      paren_levels_max.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ro8lqxj.scala:13:25\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_levels_max.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0l\n            var current_nesting_level = 0l\n  \
    \          for (paren <- group) {\n                if (paren == '(') {\n     \
    \               current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var max_level = 0\n            var level = 0\n         \
    \   for (c <- group) {\n                if (c == '(') level += 1\n           \
    \     else if (c == ')') level -= 1\n                max_level = max(max_level,\
    \ level)\n            }\n            result = result :+ max_level\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var max_nesting_levels\
    \ = List[Long]()\n        for (paren_group <- paren_groups) {\n            var\
    \ max_nesting_level = 0l\n            var current_nesting_level = 0l\n       \
    \     for (paren <- paren_group) {\n                if (paren == '(') {\n    \
    \                current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels = max_nesting_levels\
    \ :+ max_nesting_level\n        }\n        return max_nesting_levels\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into groups of parentheses separated by spaces.\n\
    \        val paren_groups = paren_string.split(\" \")\n        // For each group,\
    \ find the maximum depth of nesting of parentheses.\n        paren_groups.map(group\
    \ => {\n            // Initialize the maximum depth of nesting to 0.\n       \
    \     var max_depth = 0\n            // Initialize the current depth of nesting\
    \ to 0.\n            var cur_depth = 0\n            // Iterate through each character\
    \ in the group.\n            for (i <- 0 until group.length) {\n             \
    \   // If the character is an opening parenthesis, increment the current depth\
    \ of nesting.\n                if (group(i) == '(') cur_depth += 1\n         \
    \       // If the character is a closing parenthesis, decrement the current depth\
    \ of nesting.\n                else if (group(i) == ')') cur_depth -= 1\n    \
    \            // Update the maximum depth of nesting if the current depth of nesting\
    \ is greater than the maximum depth of nesting.\n                if (cur_depth\
    \ > max_depth) max_depth = cur_depth\n            }\n            // Return the\
    \ maximum depth of nesting.\n            max_depth\n        }).toList.map(depth\
    \ => depth.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.filter(y => y == '(' || y == ')').map(y =>\
    \ if (y == '(') 1 else -1).scanLeft(0)(_ + _).max)\n        paren_levels.toList.map(x\
    \ => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.foldLeft(List[Long](0l.toLong))((acc, c) => {\n  \
    \          if (c == '(') {\n                (acc.head + 1l.toLong) :: acc\n  \
    \          } else {\n                (acc.head - 1l.toLong) :: acc\n         \
    \   }\n        }).tail.reverse.max)\n        paren_levels.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_level = 0\n            var\
    \ current_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (paren == ')') {\n\
    \                    current_level -= 1\n                }\n            }\n  \
    \          max_level\n        })\n        max_nesting_levels.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6i9_nb2j.scala:24:27\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting_levels.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var cur_level = 0\n            for (c <- group) {\n\
    \                if (c == '(') {\n                    cur_level += 1\n       \
    \             max_level = max(max_level, cur_level)\n                } else if\
    \ (c == ')') {\n                    cur_level -= 1\n                }\n      \
    \      }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_depth += 1\n\
    \                    max_depth = max(max_depth, current_depth)\n             \
    \   } else if (paren == ')') {\n                    current_depth -= 1\n     \
    \           }\n            }\n            result = result :+ max_depth\n     \
    \   }\n        return result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (i\
    \ <- 0 until group.length) {\n                if (group(i) == '(') {\n       \
    \             current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (group(i) == ')') {\n          \
    \          current_nesting -= 1\n                }\n            }\n          \
    \  result += max_nesting\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into groups of parentheses.\n        val paren_groups\
    \ = paren_string.split(\" \")\n        // For each group, find the maximum nesting\
    \ level.\n        val max_nesting_levels = paren_groups.map(group => {\n     \
    \       // Find the maximum nesting level for this group.\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (paren <- group)\
    \ {\n                paren match {\n                    case '(' => current_nesting_level\
    \ += 1\n                    case ')' => current_nesting_level -= 1\n         \
    \           case _ =>\n                }\n                max_nesting_level =\
    \ max(max_nesting_level, current_nesting_level)\n            }\n            max_nesting_level\n\
    \        })\n        // Return the maximum nesting levels.\n        max_nesting_levels.toList.map(level\
    \ => level.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var paren_count = 0\n            var max_paren_count = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') paren_count += 1\n          \
    \      else if (paren == ')') paren_count -= 1\n                if (paren_count\
    \ > max_paren_count) max_paren_count = paren_count\n            }\n          \
    \  paren_levels += max_paren_count\n        }\n        paren_levels.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    if (current_level > max_level) {\n               \
    \         max_level = current_level\n                    }\n                }\
    \ else if (c == ')') {\n                    current_level -= 1\n             \
    \   }\n            }\n            max_nesting_levels += max_level\n        }\n\
    \        max_nesting_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (paren == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            paren_levels += max_level\n       \
    \ }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797873
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string by spaces.\n        val paren_groups = paren_string.split(\"\
    \ \")\n        // For each of the group, find the maximum depth of nesting.\n\
    \        val depths = paren_groups.map(group => {\n            // Keep track of\
    \ the current depth.\n            var depth = 0\n            // Keep track of\
    \ the maximum depth.\n            var max_depth = 0\n            // Go through\
    \ each character in the group.\n            group.foreach(c => {\n           \
    \     // If the character is an open parenthesis, increment the depth.\n     \
    \           if (c == '(') depth += 1\n                // If the character is a\
    \ close parenthesis, decrement the depth.\n                else if (c == ')')\
    \ depth -= 1\n                // If the current depth is greater than the maximum\
    \ depth, update the maximum depth.\n                if (depth > max_depth) max_depth\
    \ = depth\n            })\n            // Return the maximum depth.\n        \
    \    max_depth\n        })\n        // Return the list of depths.\n        depths.toList.map(depth\
    \ => depth.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (c\
    \ <- group) {\n                if (c == '(') current_nesting += 1\n          \
    \      else if (c == ')') current_nesting -= 1\n                max_nesting =\
    \ max(max_nesting, current_nesting)\n            }\n            result += max_nesting\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_nesting_level = 0\n            var current_nesting_level = 0\n\
    \            for (paren <- paren_group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren <- parens) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- paren) {\n           \
    \     if (c == '(') depth += 1\n                else depth -= 1\n            \
    \    max_depth = max(max_depth, depth)\n            }\n            result += max_depth\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result = result :+ max_depth\n        }\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (c\
    \ <- group) {\n                if (c == '(') {\n                    current_nesting\
    \ += 1\n                    max_nesting = max(max_nesting, current_nesting)\n\
    \                } else if (c == ')') {\n                    current_nesting -=\
    \ 1\n                }\n            }\n            result += max_nesting\n   \
    \     }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797873
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList.map(level\
    \ => level.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (char\
    \ <- group) {\n                if (char == '(') {\n                    current_level\
    \ += 1\n                    if (current_level > max_level) max_level = current_level\n\
    \                }\n                else if (char == ')') {\n                \
    \    current_level -= 1\n                }\n            }\n            max_nesting_levels\
    \ += max_level\n        }\n        max_nesting_levels.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    current_level += 1\n\
    \                    max_level = max(max_level, current_level)\n             \
    \   } else if (c == ')') {\n                    current_level -= 1\n         \
    \       }\n            }\n            result += max_level\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nestings\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_nesting\
    \ += 1\n                    if (current_nesting > max_nesting) {\n           \
    \             max_nesting = current_nesting\n                    }\n         \
    \       } else if (paren == ')') {\n                    current_nesting -= 1\n\
    \                }\n            }\n            max_nestings += max_nesting\n \
    \       }\n        max_nestings.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8wkm5grd.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8wkm5grd.scala:11:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseParens(x))\n        paren_levels.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9vkpiqz.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseParens(x))\n\e[31m\e[31m   |\e[0m                         \
    \                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                              Not found: parseParens\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpw9vkpiqz.scala:11:64 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseParens(x))\n\e[31m\e[31m   |\e[0m                         \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                            No ClassTag available for B\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m                                          where:    B is a type variable\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- paren) {\n                if (c == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => {\n            var max_depth = 0\n            var current_depth = 0\n   \
    \         for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n\
    \                    current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (x(i) == ')') {\n                \
    \    current_depth -= 1\n                }\n            }\n            max_depth\n\
    \        }).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfx2t1teb.scala:23:11\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_groups.map(\e[36mx\e\
    [0m => {\n\e[31m12 |\e[0m            \e[33mvar\e[0m \e[36mmax_depth\e[0m = \e\
    [31m0\e[0m\n\e[31m13 |\e[0m            \e[33mvar\e[0m \e[36mcurrent_depth\e[0m\
    \ = \e[31m0\e[0m\n\e[31m14 |\e[0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m\
    \ until x.length) {\n\e[31m15 |\e[0m                \e[33mif\e[0m (x(i) == \e\
    [31m'('\e[0m) {\n\e[31m16 |\e[0m                    current_depth += \e[31m1\e\
    [0m\n\e[31m17 |\e[0m                    max_depth = max(max_depth, current_depth)\n\
    \e[31m18 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (x(i) == \e[31m')'\e\
    [0m) {\n\e[31m19 |\e[0m                    current_depth -= \e[31m1\e[0m\n\e[31m20\
    \ |\e[0m                }\n\e[31m21 |\e[0m            }\n\e[31m22 |\e[0m     \
    \       max_depth\n\e[31m23 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m   \
    \     ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m\
    \   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var max_depth = 0\n        var\
    \ depth = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n\
    \                depth += 1\n                max_depth = max(max_depth, depth)\n\
    \            } else if (c == ')') {\n                depth -= 1\n            }\
    \ else if (c == ' ') {\n                result = result :+ max_depth\n       \
    \         max_depth = 0\n                depth = 0\n            }\n        }\n\
    \        result = result :+ max_depth\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var current_level\
    \ = 0\n            var max_level = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    current_level += 1\n          \
    \          max_level = max(max_level, current_level)\n                } else if\
    \ (c == ')') {\n                    current_level -= 1\n                }\n  \
    \          }\n            result = result :+ max_level\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var current_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_level += 1\n\
    \                    max_level = max(max_level, current_level)\n             \
    \   } else if (paren == ')') {\n                    current_level -= 1\n     \
    \           }\n            }\n            result = result :+ max_level\n     \
    \   }\n        return result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var stack = Stack[Char]()\n  \
    \      var max_depth = 0\n        var depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                stack.push(c)\n            \
    \    depth += 1\n                max_depth = max(max_depth, depth)\n         \
    \   } else if (c == ')') {\n                stack.pop\n                depth -=\
    \ 1\n            } else if (c == ' ') {\n                result = result :+ max_depth\n\
    \                max_depth = 0\n                depth = 0\n            }\n   \
    \     }\n        result = result :+ max_depth\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var max_depth = 0\n        var\
    \ current_depth = 0\n        for (c <- paren_string) {\n            if (c == '(')\
    \ {\n                current_depth += 1\n                max_depth = max(max_depth,\
    \ current_depth)\n            } else if (c == ')') {\n                current_depth\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_depth\n                max_depth = 0\n                current_depth = 0\n\
    \            }\n        }\n        result = result :+ max_depth\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_list = paren_string.split(\" \").toList\n        var result\
    \ = List[Long]()\n        for (paren <- paren_list) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- paren) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    if\
    \ (level > max_level) {\n                        max_level = level\n         \
    \           }\n                } else if (c == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var current_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_level += 1\n\
    \                    max_level = max(max_level, current_level)\n             \
    \   } else if (paren == ')') {\n                    current_level -= 1\n     \
    \           }\n            }\n            result = result :+ max_level\n     \
    \   }\n        return result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (char <- group) {\n\
    \                if (char == '(') {\n                    current_depth += 1\n\
    \                    max_depth = max(max_depth, current_depth)\n             \
    \   } else if (char == ')') {\n                    current_depth -= 1\n      \
    \          }\n            }\n            result = result :+ max_depth\n      \
    \  }\n        return result\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0l)((acc, y) => if (y == '(') acc\
    \ + 1 else if (y == ')') acc - 1 else acc)).toList\n        paren_levels\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9yij3gq.scala:15)\n\tat Problem.main(tmpn9yij3gq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => x.toList.foldLeft(List[Long](0))((acc,\
    \ x) => {\n            if (x == '(') {\n                acc.head + 1 :: acc\n\
    \            } else {\n                acc.tail\n            }\n        })).map(x\
    \ => x.head).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp91svymsw.scala:19)\n\tat Problem.main(tmp91svymsw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var current_depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    current_depth += 1\n\
    \                    max_depth = max(max_depth, current_depth)\n             \
    \   } else if (c == ')') {\n                    current_depth -= 1\n         \
    \       }\n            }\n            result += max_depth\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 if (level > max_level) max_level = level\n                }\n\
    \                else if (paren == ')') {\n                    level -= 1\n  \
    \              }\n            }\n            paren_levels += max_level\n     \
    \   }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (i <- 0 until group.length)\
    \ {\n                if (group(i) == '(') depth += 1\n                else if\
    \ (group(i) == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        val paren_levels_max\
    \ = paren_levels_abs.max\n        val paren_levels_max_index = paren_levels_abs.indexOf(paren_levels_max)\n\
    \        val paren_levels_max_sign = paren_levels(paren_levels_max_index)\n  \
    \      val paren_levels_max_sign_abs = abs(paren_levels_max_sign)\n        val\
    \ paren_levels_max_sign_abs_list = List.fill(paren_levels_max_sign_abs)(paren_levels_max_sign_abs)\n\
    \        val paren_levels_max_sign_abs_list_tail = paren_levels_max_sign_abs_list.tail\n\
    \        val paren_levels_max_sign_abs_list_tail_rev = paren_levels_max_sign_abs_list_tail.reverse\n\
    \        val paren_levels_max_sign_abs_list_tail_rev_map = paren_levels_max_sign_abs_list_tail_rev.map(x\
    \ => x * paren_levels_max_sign)\n        val paren_levels_max_sign_abs_list_tail_rev_map_rev\
    \ = paren_levels_max_sign_abs_list_tail_rev_map.reverse\n        val paren_levels_max_sign_abs_list_tail_rev_map_rev_updated\
    \ = paren_levels_max_sign_abs_list_tail_rev_map_rev.updated(0, paren_levels_max_sign_abs_list_tail_rev_map_rev(0)\
    \ + paren_levels_max_sign)\n        val paren_levels_max_sign_abs_list_tail_rev_map_rev_updated_map\
    \ = paren_levels_max_sign_abs_list_tail_rev_map_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxqxi1cna.scala:23:74 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mparen_levels_max_sign_abs_list_tail_rev_map_rev_updated_map\e\
    [0m = paren_levels_max_sign_abs_list_tail_rev_map_\n\e[31m\e[31m   |\e[0m    \
    \                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: paren_levels_max_sign_abs_list_tail_rev_map_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxqxi1cna.scala:24:5\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0l\n            var max_level = 0l\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(x => {\n            var max_nesting_level = 0\n         \
    \   var current_nesting_level = 0\n            for (i <- 0 until x.length) {\n\
    \                if (x(i) == '(') {\n                    current_nesting_level\
    \ += 1\n                    max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \                } else if (x(i) == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_level\n    \
    \    }).toList\n        max_nesting_levels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuc73q6si.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting_levels\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (max_nesting_levels : List[Int])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (paren_group <- paren_groups) {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (c <- paren_group)\
    \ {\n                if (c == '(') {\n                    current_level += 1\n\
    \                    max_level = max(max_level, current_level)\n             \
    \   } else if (c == ')') {\n                    current_level -= 1\n         \
    \       }\n            }\n            result = result :+ max_level\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_list = List[Long]()\n        for (paren <- paren_string.split(\"\
    \ \")) {\n            var level = 0\n            var max_level = 0\n         \
    \   for (c <- paren) {\n                if (c == '(') {\n                    level\
    \ += 1\n                    max_level = max(max_level, level)\n              \
    \  } else if (c == ')') {\n                    level -= 1\n                }\n\
    \            }\n            paren_list = paren_list :+ max_level\n        }\n\
    \        return paren_list\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                if (depth > max_depth) max_depth = depth\n           \
    \ }\n            result += max_depth\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = paren_groups.map(x => {\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (c <- x) {\n                if (c == '(') current_depth\
    \ += 1\n                else if (c == ')') current_depth -= 1\n              \
    \  max_depth = max(max_depth, current_depth)\n            }\n            max_depth\n\
    \        }).toList\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpucgekksh.scala:21:8\
    \ ---------------------\e[0m\e[0m\n\e[31m21 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797893
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    if (current_level > max_level) max_level = current_level\n\
    \                }\n                else if (paren == ')') {\n               \
    \     current_level -= 1\n                }\n            }\n            max_nesting_levels\
    \ += max_level\n        }\n        max_nesting_levels.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') level\
    \ += 1\n                else if (paren == ')') level -= 1\n                if\
    \ (level > max_level) max_level = level\n            }\n            max_level\n\
    \        })\n        paren_levels.toList.map(level => level.toLong)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        val paren_levels_max\
    \ = paren_levels_abs.max\n        val paren_levels_max_index = paren_levels_abs.indexOf(paren_levels_max)\n\
    \        val paren_levels_max_sign = paren_levels(paren_levels_max_index)\n  \
    \      val paren_levels_max_sign_abs = abs(paren_levels_max_sign)\n        val\
    \ paren_levels_max_sign_abs_list = List.fill(paren_levels_max_sign_abs)(paren_levels_max_sign)\n\
    \        val paren_levels_max_sign_abs_list_updated = paren_levels_max_sign_abs_list.updated(0,\
    \ paren_levels_max_sign_abs_list(0) - paren_levels_max_sign)\n        val paren_levels_max_sign_abs_list_updated_abs\
    \ = paren_levels_max_sign_abs_list_updated.map(x => abs(x))\n        val paren_levels_max_sign_abs_list_updated_abs_max\
    \ = paren_levels_max_sign_abs_list_updated_abs.max\n        val paren_levels_max_sign_abs_list_updated_abs_max_list\
    \ = List.fill(paren_levels_max_sign_abs_list_updated_abs_max)(paren_levels_max_sign_abs_list_updated_abs_max)\n\
    \        val paren_levels_max_sign_abs_list_updated_abs_max_list_updated = paren_levels_max_sign_abs_list_updated_abs_max_list.updated(0,\
    \ paren_levels_max_sign_abs_list_updated_abs_max_list(0) - paren_levels_max_sign_abs_list_updated_abs_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphu9tdpnn.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphu9tdpnn.scala:22:194\
    \ -----------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mparen_levels_max_sign_abs_list_updated_abs_max_list_updated\e[0m = paren_levels_max_sign_abs_list_updated_abs_max_list.updated(\e\
    [31m0\e[0m, paren_levels_max_sign_abs_list_updated_abs_max_list(\e[31m0\e[0m)\
    \ - paren_levels_max_sign_abs_list_updated_abs_\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                                                                            \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: paren_levels_max_sign_abs_list_updated_abs_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphu9tdpnn.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into groups of parentheses\n        val paren_groups\
    \ = paren_string.split(\" \")\n        // For each group, count the maximum level\
    \ of nesting\n        paren_groups.map(group => {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_nesting += 1\n\
    \                    max_nesting = max(max_nesting, current_nesting)\n       \
    \         } else if (paren == ')') {\n                    current_nesting -= 1\n\
    \                }\n            }\n            max_nesting\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjrh6syqj.scala:25:11\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_groups.map(\e[36mgroup\e\
    [0m => {\n\e[31m14 |\e[0m            \e[33mvar\e[0m \e[36mmax_nesting\e[0m = \e\
    [31m0\e[0m\n\e[31m15 |\e[0m            \e[33mvar\e[0m \e[36mcurrent_nesting\e\
    [0m = \e[31m0\e[0m\n\e[31m16 |\e[0m            \e[33mfor\e[0m (paren <- group)\
    \ {\n\e[31m17 |\e[0m                \e[33mif\e[0m (paren == \e[31m'('\e[0m) {\n\
    \e[31m18 |\e[0m                    current_nesting += \e[31m1\e[0m\n\e[31m19 |\e\
    [0m                    max_nesting = max(max_nesting, current_nesting)\n\e[31m20\
    \ |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (paren == \e[31m')'\e\
    [0m) {\n\e[31m21 |\e[0m                    current_nesting -= \e[31m1\e[0m\n\e\
    [31m22 |\e[0m                }\n\e[31m23 |\e[0m            }\n\e[31m24 |\e[0m\
    \            max_nesting\n\e[31m25 |\e[0m        }).toList\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\
    \e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659797894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var current_level = 0\n      \
    \  var max_level = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            } else if (c == ')') {\n                current_level\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_level\n                max_level = 0\n                current_level = 0\n\
    \            }\n        }\n        result = result :+ max_level\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') depth += 1\n                else if (paren == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var current_level = 0\n            for (i <- 0 until group.length)\
    \ {\n                if (group(i) == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (group(i) == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = paren_groups.map(x => {\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (c <- x) {\n                if (c == '(') {\n         \
    \           current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (c == ')') {\n                   \
    \ current_depth -= 1\n                }\n            }\n            max_depth\n\
    \        }).toList\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa0lq_djk.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result =\
    \ result :+ max_level\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_nesting_level = 0\n     \
    \       var current_nesting_level = 0\n            for (paren <- group) {\n  \
    \              if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_level\n        })\n        max_nesting_levels.toList.map(x\
    \ => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList.map(level\
    \ => level.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result =\
    \ result :+ max_level\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = paren_groups.map(x => parseNestedParensHelper(x)).toList\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwio43o4g.scala:11:43 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x)).toList\n\e[31m\e[31m   |\e[0m      \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpwio43o4g.scala:11:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x)).toList\n\e[31m\e[31m   |\e[0m      \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.foldLeft(0l)((acc, c) => if (c == '(') acc + 1 else\
    \ acc - 1)).toList\n        val max_levels = paren_levels.map(x => if (x < 0)\
    \ 0 else x)\n        max_levels\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptet37ojj.scala:16)\n\tat Problem.main(tmptet37ojj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                max_level = max(max_level, level)\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // For each group, we will keep track of the current level of nesting.\n\
    \        // We will increase the level of nesting when we see an open parenthesis\
    \ and decrease it when we see a close parenthesis.\n        // We will keep track\
    \ of the maximum level of nesting we have seen so far.\n        // We will return\
    \ the maximum level of nesting we have seen so far.\n        def parseNestedParensHelper(paren_string\
    \ : String, current_level : Long, max_level : Long) : Long = {\n            if\
    \ (paren_string.length == 0) max_level\n            else if (paren_string.head\
    \ == '(') parseNestedParensHelper(paren_string.tail, current_level + 1, max(current_level\
    \ + 1, max_level))\n            else if (paren_string.head == ')') parseNestedParensHelper(paren_string.tail,\
    \ current_level - 1, max(current_level - 1, max_level))\n            else parseNestedParensHelper(paren_string.tail,\
    \ current_level, max_level)\n        }\n        paren_string.split(\" \").map(x\
    \ => parseNestedParensHelper(x, 0, 0)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797896
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (i <- 0 until paren_groups.length) {\n         \
    \   var paren_group = paren_groups(i)\n            var max_level = 0\n       \
    \     var level = 0\n            for (j <- 0 until paren_group.length) {\n   \
    \             if (paren_group(j) == '(') {\n                    level += 1\n \
    \                   if (level > max_level) max_level = level\n               \
    \ }\n                else if (paren_group(j) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val results = new\
    \ ListBuffer[Long]()\n        for (group <- groups) {\n            var max_level\
    \ = 0\n            var cur_level = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    cur_level += 1\n              \
    \      max_level = max(max_level, cur_level)\n                } else if (c ==\
    \ ')') {\n                    cur_level -= 1\n                }\n            }\n\
    \            results += max_level\n        }\n        results.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => {\n            var max_depth = 0\n            var depth = 0\n           \
    \ for (c <- x) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            max_depth\n        }).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpesn1e4gd.scala:20:11\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_groups.map(\e[36mx\e\
    [0m => {\n\e[31m12 |\e[0m            \e[33mvar\e[0m \e[36mmax_depth\e[0m = \e\
    [31m0\e[0m\n\e[31m13 |\e[0m            \e[33mvar\e[0m \e[36mdepth\e[0m = \e[31m0\e\
    [0m\n\e[31m14 |\e[0m            \e[33mfor\e[0m (c <- x) {\n\e[31m15 |\e[0m   \
    \             \e[33mif\e[0m (c == \e[31m'('\e[0m) depth += \e[31m1\e[0m\n\e[31m16\
    \ |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m')'\e[0m) depth\
    \ -= \e[31m1\e[0m\n\e[31m17 |\e[0m                \e[33mif\e[0m (depth > max_depth)\
    \ max_depth = depth\n\e[31m18 |\e[0m            }\n\e[31m19 |\e[0m           \
    \ max_depth\n\e[31m20 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (c\
    \ <- group) {\n                if (c == '(') current_nesting += 1\n          \
    \      else if (c == ')') current_nesting -= 1\n                max_nesting =\
    \ max(max_nesting, current_nesting)\n            }\n            result += max_nesting\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        if (level > max_level) max_level = level\n                }\n       \
    \         else if (c == ')') {\n                    level -= 1\n             \
    \   }\n            }\n            max_levels += max_level\n        }\n       \
    \ max_levels.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797896
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        for (paren_group <- paren_string.split(\"\
    \ \")) {\n            var max_depth = 0\n            var depth = 0\n         \
    \   for (paren <- paren_group) {\n                if (paren == '(') depth += 1\n\
    \                else if (paren == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result = result :+\
    \ max_depth\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var depth = 0\n            var max_depth\
    \ = 0\n            for (c <- paren) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result += max_depth\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797905
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var nesting_level = 0\n            var max_nesting_level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  nesting_level += 1\n                    if (nesting_level > max_nesting_level)\
    \ max_nesting_level = nesting_level\n                }\n                else if\
    \ (paren == ')') {\n                    nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797905
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var current_level = 0\n      \
    \  var max_level = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            } else if (c == ')') {\n                current_level\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_level\n                max_level = 0\n                current_level = 0\n\
    \            }\n        }\n        result = result :+ max_level\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.filter(y => y == '(' || y == ')').map(y => if (y ==\
    \ '(') 1 else -1).scanLeft(0)(_ + _).max)\n        paren_levels.toList.map(x =>\
    \ x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdrqp7mmz.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        max_levels.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        val paren_levels_max\
    \ = paren_levels_abs.max\n        val paren_levels_max_list = paren_levels_abs.map(x\
    \ => if (x == paren_levels_max) 1l else 0l)\n        paren_levels_max_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp65wl7qfj.scala:18)\n\tat Problem.main(tmp65wl7qfj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ArrayBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_depth += 1\n\
    \                    max_depth = max(max_depth, current_depth)\n             \
    \   } else if (paren == ')') {\n                    current_depth -= 1\n     \
    \           }\n            }\n            result += max_depth\n        }\n   \
    \     result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_nesting\
    \ += 1\n                    max_nesting = max(max_nesting, current_nesting)\n\
    \                } else if (paren == ')') {\n                    current_nesting\
    \ -= 1\n                }\n            }\n            result += max_nesting\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_nesting_level = 0\n            var current_nesting_level = 0\n         \
    \   for (paren <- group) {\n                if (paren == '(') {\n            \
    \        current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (paren == ')') {\n                    current_level -= 1\n\
    \                }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result =\
    \ result :+ max_depth\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') depth += 1\n                else depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(x => {\n            var max_nesting_level = 0\n         \
    \   var current_nesting_level = 0\n            for (i <- 0 until x.length) {\n\
    \                if (x(i) == '(') {\n                    current_nesting_level\
    \ += 1\n                    max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \                } else if (x(i) == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_level\n    \
    \    }).toList\n        max_nesting_levels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuc73q6si.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting_levels\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (max_nesting_levels : List[Int])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            val paren_group = paren_groups(i)\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (j <- 0 until\
    \ paren_group.length) {\n                val paren = paren_group(j)\n        \
    \        if (paren == '(') {\n                    current_nesting_level += 1\n\
    \                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                max_level = max(max_level, level)\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                if (depth > max_depth) max_depth = depth\n           \
    \ }\n            result += max_depth\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_groups_count\
    \ = paren_groups.length\n        val paren_groups_count_long = paren_groups_count.toLong\n\
    \        val paren_groups_count_long_range = (0l.toLong until paren_groups_count_long)\n\
    \        val paren_groups_count_long_range_list = paren_groups_count_long_range.toList\n\
    \        val paren_groups_count_long_range_list_map = paren_groups_count_long_range_list.map(i\
    \ => (i, paren_groups(i.toInt)))\n        val paren_groups_count_long_range_list_map_map\
    \ = paren_groups_count_long_range_list_map.map(i => (i._1, i._2.toList))\n   \
    \     val paren_groups_count_long_range_list_map_map_map = paren_groups_count_long_range_list_map_map.map(i\
    \ => (i._1, i._2.map(j => j.toString)))\n        val paren_groups_count_long_range_list_map_map_map_map\
    \ = paren_groups_count_long_range_list_map_map_map.map(i => (i._1, i._2.map(j\
    \ => j.toList)))\n        val paren_groups_count_long_range_list_map_map_map_map_map\
    \ = paren_groups_count_long_range_list_map_map_map_map.map(i => (i._1, i._2.map(j\
    \ => j.map(k => k.toString))))\n        val paren_groups_count_long_range_list_map_map_map_map_map_map\
    \ = paren_groups_count_long_range_list_map_map_map_map_map.map(i => (i._1, i._2.map(j\
    \ => j.map(k => k.toList))))\n        val paren_groups_count_long_range_list_map_map_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdht6lw8d.scala:22:4 ----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpdht6lw8d.scala:22:5 ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        val paren_levels_max\
    \ = paren_levels_abs.max\n        val paren_levels_max_index = paren_levels_abs.indexOf(paren_levels_max)\n\
    \        val paren_levels_max_sign = paren_levels(paren_levels_max_index)\n  \
    \      val paren_levels_max_sign_abs = abs(paren_levels_max_sign)\n        val\
    \ paren_levels_max_sign_abs_list = List.fill(paren_levels_max_sign_abs)(paren_levels_max_sign)\n\
    \        val paren_levels_max_sign_abs_list_updated = paren_levels_max_sign_abs_list.updated(0,\
    \ paren_levels_max_sign_abs_list(0) - paren_levels_max_sign_abs)\n        val\
    \ paren_levels_updated = paren_levels.updated(paren_levels_max_index, 0)\n   \
    \     val paren_levels_updated_final = paren_levels_updated ++ paren_levels_max_sign_abs_list_updated\n\
    \        val paren_levels_updated_final_abs = paren_levels_updated_final.map(x\
    \ => abs(x))\n        paren_levels_updated_final_abs\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ssqh60s.scala:22:8\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m        paren_levels_updated_final_abs\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    (paren_levels_updated_final_abs : Array[Int])\n\e[31m   |\e\
    [0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var current_level = 0\n      \
    \  var max_level = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            } else if (c == ')') {\n                current_level\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_level\n                max_level = 0\n                current_level = 0\n\
    \            }\n        }\n        result = result :+ max_level\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var stack\
    \ = Stack[Char]()\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               stack.push(c)\n                    current_level += 1\n      \
    \              max_level = max(max_level, current_level)\n                } else\
    \ if (c == ')') {\n                    stack.pop\n                    current_level\
    \ -= 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (i <- 0 until paren_groups.length) {\n         \
    \   var max_depth = 0\n            var depth = 0\n            for (j <- 0 until\
    \ paren_groups(i).length) {\n                if (paren_groups(i)(j) == '(') depth\
    \ += 1\n                else if (paren_groups(i)(j) == ')') depth -= 1\n     \
    \           if (depth > max_depth) max_depth = depth\n            }\n        \
    \    result = max_depth :: result\n        }\n        result.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var current_level = 0\n      \
    \  var max_level = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            } else if (c == ')') {\n                current_level\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_level\n                max_level = 0\n                current_level = 0\n\
    \            }\n        }\n        result = result :+ max_level\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_depth = 0\n        var depth = 0\n        var result = List[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    depth += 1\n                max_depth = max(max_depth, depth)\n         \
    \   } else if (c == ')') {\n                depth -= 1\n            } else if\
    \ (c == ' ') {\n                result = result :+ max_depth\n               \
    \ max_depth = 0\n                depth = 0\n            }\n        }\n       \
    \ result = result :+ max_depth\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdrqp7mmz.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        max_levels.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') depth += 1\n                else if (paren\
    \ == ')') depth -= 1\n                if (depth > max_depth) max_depth = depth\n\
    \            }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (paren <-\
    \ group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (paren == ')') {\n                    current_level -= 1\n\
    \                }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (char <- group)\
    \ {\n                if (char == '(') {\n                    level += 1\n    \
    \                if (level > max_level) max_level = level\n                }\n\
    \                else if (char == ')') {\n                    level -= 1\n   \
    \             }\n            }\n            paren_levels += max_level\n      \
    \  }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (c <- group) {\n                if (c == '(') {\n               \
    \     current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = current_nesting_level\n\
    \                    }\n                } else if (c == ')') {\n             \
    \       current_nesting_level -= 1\n                }\n            }\n       \
    \     max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    current_nesting += 1\n  \
    \                  max_nesting = max(max_nesting, current_nesting)\n         \
    \       } else if (c == ')') {\n                    current_nesting -= 1\n   \
    \             }\n            }\n            result = result :+ max_nesting\n \
    \       }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result =\
    \ result :+ max_level\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x.toList))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyozn2lix.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x.toList))\n\e[31m\e[31m   |\e[0m      \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                      Not found: parseNestedParensHelper\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpyozn2lix.scala:11:83 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x.toList))\n\e[31m\e[31m   |\e[0m      \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toCharArray.foldLeft(0)((acc, c) => if (c == '(')\
    \ acc + 1 else if (c == ')') acc - 1 else acc))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb_bk4_67.scala:12:21\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        paren_levels.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \ Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var stack = Stack[Char]()\n  \
    \      var max_depth = 0\n        var depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                depth += 1\n               \
    \ max_depth = max(max_depth, depth)\n            } else if (c == ')') {\n    \
    \            depth -= 1\n            } else if (c == ' ') {\n                result\
    \ = result :+ max_depth\n                max_depth = 0\n                depth\
    \ = 0\n            }\n        }\n        result = result :+ max_depth\n      \
    \  return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_depth = 0\n            var current_depth = 0\n            for\
    \ (paren <- paren_group) {\n                if (paren == '(') current_depth +=\
    \ 1\n                else if (paren == ')') current_depth -= 1\n             \
    \   max_depth = max(max_depth, current_depth)\n            }\n            result\
    \ += max_depth\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(c => c == '(') - x.count(c => c == ')'))\n \
    \       val max_level = paren_levels.max\n        val min_level = paren_levels.min\n\
    \        val paren_groups_max = paren_groups.filter(x => x.count(c => c == '(')\
    \ - x.count(c => c == ')') == max_level)\n        val paren_groups_min = paren_groups.filter(x\
    \ => x.count(c => c == '(') - x.count(c => c == ')') == min_level)\n        val\
    \ max_level_nested = paren_groups_max.map(x => x.count(c => c == '(') + x.count(c\
    \ => c == ')')).max\n        val min_level_nested = paren_groups_min.map(x =>\
    \ x.count(c => c == '(') + x.count(c => c == ')')).min\n        val max_level_nested_groups\
    \ = paren_groups_max.filter(x => x.count(c => c == '(') + x.count(c => c == ')')\
    \ == max_level_nested)\n        val min_level_nested_groups = paren_groups_min.filter(x\
    \ => x.count(c => c == '(') + x.count(c => c == ')') == min_level_nested)\n  \
    \      val max_level_nested_groups_max = max_level_nested_groups.map(x => x.count(c\
    \ => c == '(')).max\n        val min_level_nested_groups_min = min_level_nested_groups.map(x\
    \ => x.count(c => c == '(')).min\n        List(max_level_nested_groups_max, min_level_nested_groups_min)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ltygaob.scala:25)\n\tat Problem.main(tmp2ltygaob.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') level += 1\n                else if (c == ')') level\
    \ -= 1\n                if (level > max_level) max_level = level\n           \
    \ }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797911
