name: HumanEval_94_skjkasdkd
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of integers.\n    // You need to find the largest prime\
  \ value and return the sum of its digits.\n    // Examples:\n    // >>> skjkasdkd((List[Long](0l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong,\
  \ 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong,\
  \ 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))\n    //\
  \ (10l)\n    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong,\
  \ 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))\n\
  \    // (25l)\n    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong,\
  \ 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong,\
  \ 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))\n\
  \    // (13l)\n    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong,\
  \ 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong,\
  \ 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    // (11l)\n    // >>> skjkasdkd((List[Long](0l.toLong,\
  \ 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))\n    // (3l)\n   \
  \ // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 7l.toLong)))\n    // (7l)\n    def skjkasdkd(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong,\
  \ 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong,\
  \ 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));\n\
  \    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong,\
  \ 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));\n\
  \    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong,\
  \ 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong,\
  \ 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong,\
  \ 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));\n\
  \    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong,\
  \ 1l.toLong, 21l.toLong))) == (3l));\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));\n    assert(skjkasdkd((List[Long](8191l.toLong)))\
  \ == (19l));\n    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong,\
  \ 7l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong,\
  \ 8192l.toLong))) == (10l));\n    }\n\n}\n"
completions: ["        var max = 0l\n        for (i <- lst) {\n            if (isPrime(i)\
    \ && i > max) max = i\n        }\n        return sumDigits(max)", "        val\
    \ primes = lst.filter(x => isPrime(x))\n        val maxPrime = primes.max\n  \
    \      val digits = maxPrime.toString.map(x => x.asDigit)\n        digits.sum",
  "        val primes = lst.filter(x => isPrime(x)).sortWith(_ > _)\n        if (primes.length\
    \ == 0) 0\n        else primes(0).toString.map(_.asDigit).sum", "        val primes\
    \ = new ArrayBuffer[Long]()\n        val primeSet = new HashSet[Long]()\n    \
    \    val primeMap = new HashMap[Long, Long]()\n        def isPrime(n : Long) :\
    \ Boolean = {\n            if (n < 2) return false\n            if (n == 2) return\
    \ true\n            if (n % 2 == 0) return false\n            for (i <- 3l to\
    \ sqrt(n).toLong by 2) {\n                if (n % i == 0) return false\n     \
    \       }\n            return true\n        }\n        def getPrimes(n : Long)\
    \ : List[Long] = {\n            if (n < 2) return List[Long]()\n            if\
    \ (n == 2) return List[Long](2l)\n            if (n % 2 == 0) return getPrimes(n\
    \ - 1)\n            for (i <- 3l to sqrt(n).toLong by 2) {\n                if\
    \ (n % i == 0) return getPrimes(n - 1)\n            }\n            return getPrimes(n\
    \ - 1) :+ n\n        }\n        def getPrimeSum(n : Long) : Long = {\n       \
    \     if (n < 10) return n\n            return getPrimeSum(n / 10) + n % 10\n\
    \        }\n        for (i <- lst) {\n            if (isPrime(i)) {\n        \
    \        primes += i\n                primeSet += i\n                primeMap(i)\
    \ = getPrimeSum(i)\n            }\n        }\n        val maxPrime = primes.max\n\
    \        return primeMap(maxPrime)", "        var max = 0l\n        for (i <-\
    \ lst) {\n            if (isPrime(i) && i > max) max = i\n        }\n        var\
    \ sum = 0l\n        var x = max\n        while (x > 0) {\n            sum += x\
    \ % 10\n            x /= 10\n        }\n        return sum", "        var max\
    \ = 0l\n        for (i <- lst) {\n            if (i > max && isPrime(i)) max =\
    \ i\n        }\n        var sum = 0l\n        while (max > 0) {\n            sum\
    \ += max % 10\n            max /= 10\n        }\n        return sum", "      \
    \  var primes = new ArrayBuffer[Long]()\n        for (i <- lst) {\n          \
    \  if (isPrime(i)) primes += i\n        }\n        var max = primes.max\n    \
    \    var sum = 0l\n        while (max > 0) {\n            sum += max % 10\n  \
    \          max /= 10\n        }\n        return sum", "        var primes = new\
    \ ArrayBuffer[Long]()\n        for (i <- lst) {\n            if (isPrime(i)) primes\
    \ += i\n        }\n        var max = primes.max\n        var sum = 0l\n      \
    \  while (max > 0) {\n            sum += max % 10\n            max /= 10\n   \
    \     }\n        return sum", "        val primes = lst.filter(x => isPrime(x))\n\
    \        val maxPrime = primes.max\n        val digits = maxPrime.toString.map(_.asDigit)\n\
    \        digits.sum", "        val primes = lst.filter(x => isPrime(x))\n    \
    \    val max = primes.max\n        max.toString.map(x => x.asDigit).sum", "  \
    \      // Your code here\n        val primes = lst.filter(x => isPrime(x))\n \
    \       val maxPrime = primes.max\n        sumDigits(maxPrime)", "        var\
    \ max = 0l\n        for (i <- lst) {\n            if (isPrime(i) && i > max) {\n\
    \                max = i\n            }\n        }\n        var sum = 0l\n   \
    \     while (max > 0) {\n            sum += max % 10\n            max /= 10\n\
    \        }\n        return sum", "        var primes = List[Long]()\n        for\
    \ (i <- lst) {\n            if (isPrime(i)) primes = i :: primes\n        }\n\
    \        var max = 0l\n        for (i <- primes) {\n            if (i > max) max\
    \ = i\n        }\n        var sum = 0l\n        var str = max.toString\n     \
    \   for (i <- str) {\n            sum += i.toString.toLong\n        }\n      \
    \  return sum", "        val primes = lst.filter(x => isPrime(x))\n        val\
    \ maxPrime = primes.max\n        val digits = maxPrime.toString.map(_.asDigit).toList\n\
    \        digits.sum", "        val primes = lst.filter(x => isPrime(x))\n    \
    \    val largestPrime = primes.max\n        val digits = largestPrime.toString.map(_.asDigit)\n\
    \        digits.sum", "        val primes = lst.filter(x => isPrime(x))\n    \
    \    val maxPrime = primes.max\n        val digits = maxPrime.toString.map(_.asDigit)\n\
    \        digits.sum", "        var primes = new ListBuffer[Long]\n        for\
    \ (i <- lst) {\n            if (isPrime(i)) primes += i\n        }\n        var\
    \ max = 0l\n        for (i <- primes) {\n            if (i > max) max = i\n  \
    \      }\n        var sum = 0l\n        var str = max.toString\n        for (i\
    \ <- str) {\n            sum += i.toString.toLong\n        }\n        return sum",
  "        val primes = lst.filter(x => isPrime(x))\n        val largest = primes.max\n\
    \        largest.toString.map(x => x.asDigit).sum", "        var primes = List[Long]()\n\
    \        var max = 0l\n        for (i <- lst) {\n            if (isPrime(i)) {\n\
    \                primes = i :: primes\n                if (i > max) max = i\n\
    \            }\n        }\n        var sum = 0l\n        var temp = max\n    \
    \    while (temp > 0) {\n            sum += temp % 10\n            temp /= 10\n\
    \        }\n        return sum", "        val primes = lst.filter(x => isPrime(x))\n\
    \        val max = primes.max\n        max.toString.map(x => x.asDigit).sum"]
stop_tokens:
- "\n    }\n"
