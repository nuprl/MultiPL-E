language: scala
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) < abs(num - ceil)) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = num.floor\n        val ceil = num.ceil\n        if (num -\
    \ floor > ceil - num) ceil else floor\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0_e4oli0.scala:21:38\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (num -\
    \ floor > ceil - num) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m      \
    \                                ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                    Found:    (ceil : Double)\n\e[31m   |\e[0m              \
    \                        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp0_e4oli0.scala:21:48 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (num - floor > ceil - num) ceil \e[33melse\e\
    [0m floor\n\e[31m\e[31m   |\e[0m                                             \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                                              Found:\
    \    (floor : Double)\n\e[31m   |\e[0m                                       \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = floor(number)\n        val ceil = ceil(number)\n\
    \        if (abs(number - floor) < abs(number - ceil)) floor.toLong else ceil.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprx6hco9m.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmprx6hco9m.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n < 0) -closestInteger(-n)\n        else {\n            val d = n\
    \ - floor(n)\n            if (d < 0.5) floor(n).toLong\n            else ceil(n).toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6mjjkdfe.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (n < \e\
    [31m0\e[0m) -closestInteger(-n)\n\e[31m\e[31m   |\e[0m                       \
    \            ^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Double\n\e[31m   |\e[0m                                   Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val f = floor(d)\n        val c = ceil(d)\n        if (abs(d - f) ==\
    \ abs(d - c)) {\n            if (d > 0) c else f\n        } else if (abs(d - f)\
    \ < abs(d - c)) f else c\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ei0yqtp.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (d\
    \ > \e[31m0\e[0m) c \e[33melse\e[0m f\n\e[31m\e[31m   |\e[0m                 \
    \      ^\e[0m\n\e[31m   |\e[0m                       Found:    (c : Double)\n\e\
    [31m   |\e[0m                       Required: Long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_ei0yqtp.scala:22:30 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (d > \e[31m0\e[0m) c \e[33melse\e\
    [0m f\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e\
    [0m                              Found:    (f : Double)\n\e[31m   |\e[0m     \
    \                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_ei0yqtp.scala:23:44 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(d - f) < abs(d\
    \ - c)) f \e[33melse\e[0m c\n\e[31m\e[31m   |\e[0m                           \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \        Found:    (f : Double)\n\e[31m   |\e[0m                             \
    \               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_ei0yqtp.scala:23:51 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(d - f) < abs(d - c)) f \e\
    [33melse\e[0m c\n\e[31m\e[31m   |\e[0m                                       \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \         Found:    (c : Double)\n\e[31m   |\e[0m                            \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = num.floor\n        val ceil = num.ceil\n        if (abs(num\
    \ - floor) == abs(num - ceil)) {\n            if (num > 0) ceil else floor\n \
    \       } else if (abs(num - floor) < abs(num - ceil)) floor else ceil\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpafagv48u.scala:22:25\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num\
    \ > \e[31m0\e[0m) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m          \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                         Found:    (ceil\
    \ : Double)\n\e[31m   |\e[0m                         Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpafagv48u.scala:22:35 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num > \e[31m0\e[0m) ceil \e\
    [33melse\e[0m floor\n\e[31m\e[31m   |\e[0m                                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    (floor : Double)\n\
    \e[31m   |\e[0m                                   Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpafagv48u.scala:23:55 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(num - floor)\
    \ < abs(num - ceil)) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m       \
    \                                                ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                             Found:    (floor : Double)\n\e[31m\
    \   |\e[0m                                              Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpafagv48u.scala:23:66 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(num - floor)\
    \ < abs(num - ceil)) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m       \
    \                                                           ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                               Found:    (ceil : Double)\n\
    \e[31m   |\e[0m                                               Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val m = round(n)\n        if (abs(n - m) == 0.5) {\n            if (n\
    \ > 0) m + 1 else m - 1\n        } else m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmploiu5r1h.scala:26)\n\tat Problem.main(tmploiu5r1h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = math.floor(num)\n        val ceil = math.ceil(num)\n    \
    \    if (num - floor > ceil - num) ceil.toLong else floor.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphrxeuoyl.scala:25)\n\tat Problem.main(tmphrxeuoyl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num < 0) -round(-num) else round(num)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            val n = ceil(d)\n            if (n - d == 0.5)\
    \ {\n                n.toLong + 1\n            } else {\n                n.toLong\n\
    \            }\n        } else {\n            val n = floor(d)\n            if\
    \ (d - n == 0.5) {\n                n.toLong - 1\n            } else {\n     \
    \           n.toLong\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg354pjk6.scala:37)\n\tat Problem.main(tmpg354pjk6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val floor = floor(d)\n        val ceil = ceil(d)\n        if (abs(floor\
    \ - d) == abs(ceil - d)) {\n            if (floor < 0) floor.toLong else ceil.toLong\n\
    \        } else if (abs(floor - d) < abs(ceil - d)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_b1jkoth.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(d)\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_b1jkoth.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(d)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            ceil(num).toLong\n        } else {\n    \
    \        floor(num).toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbl143yn6.scala:29)\n\tat Problem.main(tmpbl143yn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            val floor = num.floor\n            val ceil\
    \ = num.ceil\n            if (num - floor < ceil - num) floor else ceil\n    \
    \    } else {\n            val floor = num.floor\n            val ceil = num.ceil\n\
    \            if (num - floor > ceil - num) floor else ceil\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq_af0a5i.scala:22:42\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num\
    \ - floor < ceil - num) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m    \
    \                                      ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               Found:    (floor : Double)\n\e[31m   |\e[0m  \
    \                                        Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpq_af0a5i.scala:22:53 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num - floor < ceil - num)\
    \ floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m                          \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                        Found:    (ceil : Double)\n\e[31m   |\e[0m          \
    \                                     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpq_af0a5i.scala:26:42 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m (num - floor > ceil - num)\
    \ floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m                          \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \         Found:    (floor : Double)\n\e[31m   |\e[0m                        \
    \                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpq_af0a5i.scala:26:53 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mif\e[0m (num - floor > ceil - num) floor \e[33melse\e\
    [0m ceil\n\e[31m\e[31m   |\e[0m                                              \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                                           \
    \    Found:    (ceil : Double)\n\e[31m   |\e[0m                              \
    \                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = num.floor\n        val ceil = num.ceil\n        if (abs(num\
    \ - floor) == abs(num - ceil)) {\n            if (num >= 0) ceil else floor\n\
    \        } else if (abs(num - floor) < abs(num - ceil)) floor else ceil\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4y6vfgf.scala:22:26\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num\
    \ >= \e[31m0\e[0m) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m         \
    \                 ^^^^\e[0m\n\e[31m   |\e[0m                          Found: \
    \   (ceil : Double)\n\e[31m   |\e[0m                          Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4y6vfgf.scala:22:36\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num\
    \ >= \e[31m0\e[0m) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m         \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \              Found:    (floor : Double)\n\e[31m   |\e[0m                   \
    \                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp4y6vfgf.scala:23:55 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(num - floor) < abs(num -\
    \ ceil)) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m                   \
    \                                    ^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                 Found:    (floor : Double)\n\e[31m   |\e[0m\
    \                                              Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4y6vfgf.scala:23:66 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(num - floor)\
    \ < abs(num - ceil)) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m       \
    \                                                           ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                               Found:    (ceil : Double)\n\
    \e[31m   |\e[0m                                               Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i < 0.5) i else i + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe19xu68j.scala:25)\n\tat Problem.main(tmpe19xu68j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) < abs(num - ceil)) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) -closestInteger(-d)\n        else {\n            val i = d.toLong\n\
    \            if (d - i < 0.5) i\n            else i + 1\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe060opss.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (d < \e\
    [31m0\e[0m) -closestInteger(-d)\n\e[31m\e[31m   |\e[0m                       \
    \            ^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Double\n\e[31m   |\e[0m                                   Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val x = round(d)\n        val y = floor(d)\n        val z = ceil(d)\n\
    \        if (abs(x - d) < abs(y - d)) x.toLong\n        else if (abs(x - d) >\
    \ abs(z - d)) z.toLong\n        else if (d > 0) z.toLong\n        else y.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoa0tjdbl.scala:31)\n\tat Problem.main(tmpoa0tjdbl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = math.floor(num)\n        val ceil = math.ceil(num)\n    \
    \    if (num - floor < ceil - num) floor.toLong else ceil.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp01e_5hmi.scala:26)\n\tat Problem.main(tmp01e_5hmi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) == abs(num - ceil)) {\n            if (num > 0) ceil.toLong else floor.toLong\n\
    \        } else if (abs(num - floor) < abs(num - ceil)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) -closestInteger(value.tail)\n        else {\n            val\
    \ i = d.toLong\n            if (d - i < 0.5) i\n            else i + 1\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805300
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val y = round(x)\n        if (abs(x - y) == 0.5) {\n            if (x\
    \ > 0) y + 1 else y - 1\n        } else {\n            y\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl7g6746m.scala:28)\n\tat Problem.main(tmpl7g6746m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805302
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = math.floor(num)\n        val ceil = math.ceil(num)\n    \
    \    if (abs(num - floor) == abs(num - ceil)) {\n            if (num > 0) ceil.toLong\
    \ else floor.toLong\n        } else if (abs(num - floor) < abs(num - ceil)) {\n\
    \            floor.toLong\n        } else {\n            ceil.toLong\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805302
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val l = d.toLong\n        if (d - l > 0.5) l + 1\n        else l\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzeyl2i8e.scala:25)\n\tat Problem.main(tmpzeyl2i8e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805301
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val m = round(n)\n        if (n - m >= 0.5) m + 1 else m\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsvktpy5i.scala:25)\n\tat Problem.main(tmpsvktpy5i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val l = d.toLong\n        if (d - l < 0.5) l else l + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprp8hi_cz.scala:25)\n\tat Problem.main(tmprp8hi_cz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805303
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n < 0) {\n            val n1 = ceil(n)\n            val n2 = floor(n)\n\
    \            if (abs(n1) - abs(n) < abs(n) - abs(n2)) n1.toLong else n2.toLong\n\
    \        } else {\n            val n1 = floor(n)\n            val n2 = ceil(n)\n\
    \            if (n1 - n < n - n2) n1.toLong else n2.toLong\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnuu3t6fx.scala:33)\n\tat Problem.main(tmpnuu3t6fx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val floor = d.floor\n        val ceil = d.ceil\n        if (abs(d - floor)\
    \ < abs(d - ceil)) floor else ceil\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppj1_2318.scala:21:44\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - floor) < abs(d - ceil)) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m\
    \                                            ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                       Found:    (floor : Double)\n\e[31m   |\e\
    [0m                                            Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppj1_2318.scala:21:55 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (abs(d - floor) < abs(d - ceil))\
    \ floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m                          \
    \                             ^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                          Found:    (ceil : Double)\n\e[31m   |\e[0m        \
    \                                       Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) == abs(num - ceil)) {\n            if (num > 0) ceil.toLong else floor.toLong\n\
    \        } else if (abs(num - floor) < abs(num - ceil)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val f = floor(d)\n        val c = ceil(d)\n        if (abs(d - f) < abs(d\
    \ - c)) f.toLong else c.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2992zid2.scala:26)\n\tat Problem.main(tmp2992zid2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) < abs(num - ceil)) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) >= 0.5) i + signum(d) else i\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkyx4d0io.scala:20:31\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) >= \e[31m0.5\e[0m) i + signum(d) \e[33melse\e[0m i\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                       Found:    Double\n\e[31m   |\e[0m                    \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = floor(number)\n        val ceil = ceil(number)\n\
    \        if (abs(floor - number) == abs(ceil - number)) {\n            if (floor\
    \ < 0) {\n                ceil.toLong\n            } else {\n                floor.toLong\n\
    \            }\n        } else if (abs(floor - number) < abs(ceil - number)) {\n\
    \            floor.toLong\n        } else {\n            ceil.toLong\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpey46l1y4.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpey46l1y4.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805302
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val l = d.toLong\n        if (d - l < 0.5) l else l + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprp8hi_cz.scala:25)\n\tat Problem.main(tmprp8hi_cz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n < 0) -closestInteger(-n)\n        else {\n            val d = n\
    \ - floor(n)\n            if (d < 0.5) floor(n).toLong\n            else ceil(n).toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6mjjkdfe.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (n < \e\
    [31m0\e[0m) -closestInteger(-n)\n\e[31m\e[31m   |\e[0m                       \
    \            ^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Double\n\e[31m   |\e[0m                                   Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val y = round(x)\n        val z = floor(x)\n        val w = ceil(x)\n\
    \        if (abs(x - y) < abs(x - z)) y.toLong\n        else if (abs(x - y) <\
    \ abs(x - w)) y.toLong\n        else if (abs(x - z) < abs(x - w)) z.toLong\n \
    \       else w.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwqbv4eft.scala:30)\n\tat Problem.main(tmpwqbv4eft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val y = round(x)\n        val z = floor(x)\n        val w = ceil(x)\n\
    \        if (abs(x - y) == abs(x - z)) {\n            if (abs(x - y) == abs(x\
    \ - w)) {\n                if (x > 0) y else z\n            } else {\n       \
    \         if (abs(x - y) < abs(x - w)) y else w\n            }\n        } else\
    \ {\n            if (abs(x - y) < abs(x - z)) y else z\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mzwp58v.scala:24:34\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m\
    \ (x > \e[31m0\e[0m) y \e[33melse\e[0m z\n\e[31m\e[31m   |\e[0m              \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \ Found:    (z : Double)\n\e[31m   |\e[0m                                  Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mzwp58v.scala:26:52\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m\
    \ (abs(x - y) < abs(x - w)) y \e[33melse\e[0m w\n\e[31m\e[31m   |\e[0m       \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \                                          Found:    (w : Double)\n\e[31m   |\e\
    [0m                                                  Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mzwp58v.scala:29:48 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (abs(x - y) < abs(x - z)) y\
    \ \e[33melse\e[0m z\n\e[31m\e[31m   |\e[0m                                   \
    \             ^\e[0m\n\e[31m   |\e[0m                                        \
    \        Found:    (z : Double)\n\e[31m   |\e[0m                             \
    \                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            val d2 = ceil(d)\n            if (d2 - d ==\
    \ 0.5) {\n                d2.toLong - 1\n            } else {\n              \
    \  d2.toLong\n            }\n        } else {\n            val d2 = floor(d)\n\
    \            if (d - d2 == 0.5) {\n                d2.toLong + 1\n           \
    \ } else {\n                d2.toLong\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) < abs(num - ceil)) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = value.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d\
    \ - i)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp74cj9rmf.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d - i)\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    Double\n\e[31m   |\e[0m      \
    \                               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            if (num - num.toLong > 0.5) num.toLong +\
    \ 1\n            else num.toLong\n        } else {\n            if (num - num.toLong\
    \ < -0.5) num.toLong - 1\n            else num.toLong\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3kb6m5h8.scala:29)\n\tat Problem.main(tmp3kb6m5h8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        val f = d - i\n        if (f < 0.5) i else\
    \ i + 1\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptl9jm8xk.scala:26)\n\tat Problem.main(tmptl9jm8xk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i >= 0.5) i + 1 else i\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0acygb6_.scala:25)\n\tat Problem.main(tmp0acygb6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val floor = floor(n)\n        val ceil = ceil(n)\n        if (abs(floor\
    \ - n) == abs(ceil - n)) {\n            if (floor < 0) {\n                ceil.toLong\n\
    \            } else {\n                floor.toLong\n            }\n        }\
    \ else if (abs(floor - n) < abs(ceil - n)) {\n            floor.toLong\n     \
    \   } else {\n            ceil.toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcyzex2ut.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(n)\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcyzex2ut.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(n)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805301
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) > 0.5) i + signum(d) else i\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmg331dho.scala:20:30\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) > \e[31m0.5\e[0m) i + signum(d) \e[33melse\e[0m i\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    Double\n\e[31m   |\e[0m                        \
    \      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = floor(number)\n        val ceil = ceil(number)\n\
    \        if (abs(number - floor) < abs(number - ceil)) floor.toLong else ceil.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprx6hco9m.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmprx6hco9m.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = num.floor\n        val ceil = num.ceil\n        if (abs(floor\
    \ - num) == abs(ceil - num)) {\n            if (floor < 0) floor else ceil\n \
    \       } else if (abs(floor - num) < abs(ceil - num)) floor else ceil\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyzxwwawb.scala:22:27\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (floor\
    \ < \e[31m0\e[0m) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m          \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (floor : Double)\n\e[31m   |\e[0m                           Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyzxwwawb.scala:22:38\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (floor\
    \ < \e[31m0\e[0m) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m          \
    \                            ^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                Found:    (ceil : Double)\n\e[31m   |\e[0m                  \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpyzxwwawb.scala:23:55 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(floor - num) < abs(ceil -\
    \ num)) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m                    \
    \                                   ^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                                Found:    (floor : Double)\n\e[31m   |\e[0m \
    \                                             Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyzxwwawb.scala:23:66 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(floor -\
    \ num) < abs(ceil - num)) floor \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m  \
    \                                                                ^^^^\e[0m\n\e\
    [31m   |\e[0m                                               Found:    (ceil :\
    \ Double)\n\e[31m   |\e[0m                                               Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            ceil(num).toLong\n        } else {\n    \
    \        floor(num).toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbl143yn6.scala:29)\n\tat Problem.main(tmpbl143yn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + (if (d > 0)\
    \ 1 else -1)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = floor(number)\n        val ceil = ceil(number)\n\
    \        if (abs(floor - number) < abs(ceil - number)) floor.toLong\n        else\
    \ ceil.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp655hj5un.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp655hj5un.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) -closestInteger(-d)\n        else {\n            val i = d.toLong\n\
    \            if (d - i < 0.5) i\n            else i + 1\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe060opss.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (d < \e\
    [31m0\e[0m) -closestInteger(-d)\n\e[31m\e[31m   |\e[0m                       \
    \            ^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Double\n\e[31m   |\e[0m                                   Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if (x > 0) {\n            if (x - x.toLong < 0.5) x.toLong else x.toLong\
    \ + 1\n        } else {\n            if (x - x.toLong > -0.5) x.toLong else x.toLong\
    \ - 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805312
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        if (v < 0) -closestInteger(-v)\n        else {\n            val c = ceil(v)\n\
    \            val f = floor(v)\n            if (c - v < v - f) c.toLong\n     \
    \       else f.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7fck36xw.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (v < \e\
    [31m0\e[0m) -closestInteger(-v)\n\e[31m\e[31m   |\e[0m                       \
    \            ^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Double\n\e[31m   |\e[0m                                   Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805312
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val x = floor(n)\n        val y = ceil(n)\n        if (n - x < y - n)\
    \ x.toLong else y.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ifv55u2.scala:26)\n\tat Problem.main(tmp3ifv55u2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805311
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + (if (d > 0)\
    \ 1 else -1)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) == abs(num - ceil)) {\n            if (num >= 0) ceil.toLong else floor.toLong\n\
    \        } else if (abs(num - floor) < abs(num - ceil)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwexqm1sc.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwexqm1sc.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val y = round(x)\n        val z = floor(x)\n        val w = ceil(x)\n\
    \        if (abs(x - y) < abs(x - z)) y.toLong\n        else if (abs(x - y) <\
    \ abs(x - w)) y.toLong\n        else if (abs(x - z) < abs(x - w)) z.toLong\n \
    \       else w.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwqbv4eft.scala:30)\n\tat Problem.main(tmpwqbv4eft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            ceil(num).toLong\n        } else {\n    \
    \        floor(num).toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbl143yn6.scala:29)\n\tat Problem.main(tmpbl143yn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i > 0.5) i + 1 else i\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpul8ccv6k.scala:24)\n\tat Problem.main(tmpul8ccv6k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805312
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val d1 = floor(d)\n        val d2 = ceil(d)\n        if (abs(d - d1)\
    \ < abs(d - d2)) d1.toLong else d2.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp92zo9h3_.scala:26)\n\tat Problem.main(tmp92zo9h3_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i < 0.5) i else i + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe19xu68j.scala:25)\n\tat Problem.main(tmpe19xu68j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i < 0.5) i else i + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe19xu68j.scala:25)\n\tat Problem.main(tmpe19xu68j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val m = round(n)\n        if (abs(n - m) == 0.5) {\n            if (n\
    \ > 0) m + 1 else m - 1\n        } else {\n            m.toLong\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsuqxlnz4.scala:28)\n\tat Problem.main(tmpsuqxlnz4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        val v1 = floor(v)\n        val v2 = ceil(v)\n        if (abs(v - v1)\
    \ < abs(v - v2)) v1.toLong else v2.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb8dxw3ii.scala:26)\n\tat Problem.main(tmpb8dxw3ii.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val r = round(n)\n        val f = floor(n)\n        val c = ceil(n)\n\
    \        if (abs(r - n) < abs(f - n)) r.toLong\n        else if (abs(r - n) >\
    \ abs(c - n)) c.toLong\n        else if (r > 0) r.toLong\n        else c.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp01x2p8f.scala:30)\n\tat Problem.main(tmpp01x2p8f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        val c = round(v)\n        if (abs(v - c) == 0.5) {\n            if (v\
    \ > 0) c + 1 else c - 1\n        } else {\n            c\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppp5a72g0.scala:28)\n\tat Problem.main(tmppp5a72g0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = value.toLong\n        if (d - i >= 0.5) i + 1 else i\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpmobvfo1f.scala:19)\n\
    \tat Problem$.main(tmpmobvfo1f.scala:24)\n\tat Problem.main(tmpmobvfo1f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var d = value.toDouble\n\
    \        if (d < 0) {\n            return ceil(d).toLong\n        }\n        return\
    \ floor(d).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp79ud209x.scala:26)\n\tat Problem.main(tmp79ud209x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = value.toLong\n        if (d - i >= 0.5) i + 1 else i\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpmobvfo1f.scala:19)\n\
    \tat Problem$.main(tmpmobvfo1f.scala:24)\n\tat Problem.main(tmpmobvfo1f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805313
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            ceil(num).toLong\n        } else {\n    \
    \        floor(num).toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbl143yn6.scala:29)\n\tat Problem.main(tmpbl143yn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val floor = d.floor\n        val ceil = d.ceil\n        if (abs(floor\
    \ - d) < abs(ceil - d)) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc3wch62u.scala:26)\n\tat Problem.main(tmpc3wch62u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val f = floor(d)\n        val c = ceil(d)\n        if (abs(d - f) < abs(d\
    \ - c)) f.toLong else c.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2992zid2.scala:26)\n\tat Problem.main(tmp2992zid2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i >= 0.5) i + 1 else i\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0acygb6_.scala:25)\n\tat Problem.main(tmp0acygb6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val y = round(x)\n        if (abs(x - y) == 0.5) {\n            if (x\
    \ > 0) y + 1 else y - 1\n        } else y\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpspdtcl9e.scala:26)\n\tat Problem.main(tmpspdtcl9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val r = round(n)\n        if (abs(n - r) == 0.5) {\n            if (n\
    \ > 0) r + 1 else r - 1\n        } else {\n            r\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmzccxw80.scala:28)\n\tat Problem.main(tmpmzccxw80.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i >= 0.5) i + 1 else i\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0acygb6_.scala:25)\n\tat Problem.main(tmp0acygb6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i < 0.5) i else i + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe19xu68j.scala:25)\n\tat Problem.main(tmpe19xu68j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            ceil(num).toLong\n        } else {\n    \
    \        floor(num).toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbl143yn6.scala:29)\n\tat Problem.main(tmpbl143yn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i >= 0.5) i + 1 else i\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0acygb6_.scala:25)\n\tat Problem.main(tmp0acygb6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val floor = d.floor\n        val ceil = d.ceil\n        if (abs(floor\
    \ - d) == abs(ceil - d)) {\n            if (floor < 0) ceil else floor\n     \
    \   } else if (abs(floor - d) < abs(ceil - d)) {\n            floor\n        }\
    \ else {\n            ceil\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz5zvwg0i.scala:22:27\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (floor\
    \ < \e[31m0\e[0m) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m          \
    \                 ^^^^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (ceil : Double)\n\e[31m   |\e[0m                           Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz5zvwg0i.scala:22:37\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (floor\
    \ < \e[31m0\e[0m) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m          \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \               Found:    (floor : Double)\n\e[31m   |\e[0m                  \
    \                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpz5zvwg0i.scala:24:12 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            floor\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Found:    (floor : Double)\n\e[31m   |\e[0m            Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz5zvwg0i.scala:26:12\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            ceil\n\e[31m\e[31m\
    \   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            Found:    (ceil :\
    \ Double)\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + (if (d > 0)\
    \ 1 else -1)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val l = d.toLong\n        if (d - l >= 0.5) l + 1\n        else l\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7355gwrz.scala:26)\n\tat Problem.main(tmp7355gwrz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n > 0) {\n            if (n - n.toLong < 0.5) n.toLong else n.toLong\
    \ + 1\n        } else {\n            if (n - n.toLong > -0.5) n.toLong else n.toLong\
    \ - 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if (x < 0) {\n            val y = ceil(x)\n            if (y - x == 0.5)\
    \ y.toLong - 1 else y.toLong\n        } else {\n            val y = floor(x)\n\
    \            if (x - y == 0.5) y.toLong + 1 else y.toLong\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val ceil = ceil(num)\n        val floor = floor(num)\n        if (ceil\
    \ - num == num - floor) {\n            if (ceil > 0) ceil.toLong else floor.toLong\n\
    \        } else if (ceil - num < num - floor) ceil.toLong else floor.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9z1xxs2g.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9z1xxs2g.scala:20:20 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805312
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i < 0.5) i else i + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe19xu68j.scala:25)\n\tat Problem.main(tmpe19xu68j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val f = floor(d)\n        val c = ceil(d)\n        if (abs(d - f) ==\
    \ abs(d - c)) {\n            if (d > 0) c else f\n        } else if (abs(d - f)\
    \ < abs(d - c)) f else c\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ei0yqtp.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (d\
    \ > \e[31m0\e[0m) c \e[33melse\e[0m f\n\e[31m\e[31m   |\e[0m                 \
    \      ^\e[0m\n\e[31m   |\e[0m                       Found:    (c : Double)\n\e\
    [31m   |\e[0m                       Required: Long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_ei0yqtp.scala:22:30 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (d > \e[31m0\e[0m) c \e[33melse\e\
    [0m f\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e\
    [0m                              Found:    (f : Double)\n\e[31m   |\e[0m     \
    \                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_ei0yqtp.scala:23:44 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(d - f) < abs(d\
    \ - c)) f \e[33melse\e[0m c\n\e[31m\e[31m   |\e[0m                           \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \        Found:    (f : Double)\n\e[31m   |\e[0m                             \
    \               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_ei0yqtp.scala:23:51 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(d - f) < abs(d - c)) f \e\
    [33melse\e[0m c\n\e[31m\e[31m   |\e[0m                                       \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \         Found:    (c : Double)\n\e[31m   |\e[0m                            \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = value.toLong\n        if (abs(d - i) < 0.5) i else i + (if (d\
    \ > 0) 1 else -1)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpqxs7m_ff.scala:19)\n\
    \tat Problem$.main(tmpqxs7m_ff.scala:24)\n\tat Problem.main(tmpqxs7m_ff.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val d = n - n.floor\n        if (d < 0.5) n.floor.toLong else n.ceil.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphtf5bfbz.scala:25)\n\tat Problem.main(tmphtf5bfbz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = floor(number)\n        val ceil = ceil(number)\n\
    \        if (abs(number - floor) < abs(number - ceil)) floor.toLong else ceil.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprx6hco9m.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmprx6hco9m.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val l = d.toLong\n        if (d - l >= 0.5) l + 1 else l\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb3l8kisy.scala:25)\n\tat Problem.main(tmpb3l8kisy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805317
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            val d1 = ceil(d)\n            val d2 = floor(d)\n\
    \            if (d1 - d < d - d2) d1.toLong else d2.toLong\n        } else {\n\
    \            val d1 = floor(d)\n            val d2 = ceil(d)\n            if (d2\
    \ - d < d - d1) d2.toLong else d1.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9nc4d0y_.scala:31)\n\tat Problem.main(tmp9nc4d0y_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805318
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) > 0.5) i + signum(d) else i\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmg331dho.scala:20:30\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) > \e[31m0.5\e[0m) i + signum(d) \e[33melse\e[0m i\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    Double\n\e[31m   |\e[0m                        \
    \      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) > 0.5) {\n            if (d\
    \ > 0) i + 1 else i - 1\n        } else i\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphmdg9rgu.scala:26)\n\tat Problem.main(tmphmdg9rgu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805320
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgv76190h.scala:27)\n\tat Problem.main(tmpgv76190h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val floor = floor(d)\n        val ceil = ceil(d)\n        if (d - floor\
    \ < ceil - d) floor.toLong else ceil.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyxdin393.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(d)\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyxdin393.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(d)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805317
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) >= 0.5) i + (if (d > 0) 1 else\
    \ -1) else i\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805321
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val c = round(n)\n        val f = floor(n)\n        val c_d = abs(c -\
    \ n)\n        val f_d = abs(f - n)\n        if (c_d < f_d) c.toLong else f.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcsv58_aj.scala:27)\n\tat Problem.main(tmpcsv58_aj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805321
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val l = floor(n).toLong\n        val r = ceil(n).toLong\n        if (abs(n\
    \ - l) < abs(n - r)) l else r\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpae2f6e7a.scala:26)\n\tat Problem.main(tmpae2f6e7a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i >= 0.5) i + 1 else i\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0acygb6_.scala:25)\n\tat Problem.main(tmp0acygb6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val d1 = floor(d)\n        val d2 = ceil(d)\n        if (abs(d - d1)\
    \ < abs(d - d2)) d1.toLong else d2.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp92zo9h3_.scala:26)\n\tat Problem.main(tmp92zo9h3_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val y = round(x)\n        if (abs(x - y) == 0.5) {\n            if (x\
    \ > 0) y + 1 else y - 1\n        } else y\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpspdtcl9e.scala:26)\n\tat Problem.main(tmpspdtcl9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) < abs(num - ceil)) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpum3ddxfx.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        if (v < 0) {\n            val v1 = ceil(v)\n            val v2 = floor(v)\n\
    \            if (abs(v1) - abs(v2) < 0.5) v1.toLong else v2.toLong\n        }\
    \ else {\n            val v1 = floor(v)\n            val v2 = ceil(v)\n      \
    \      if (v2 - v1 < 0.5) v1.toLong else v2.toLong\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpag1_0mw0.scala:32)\n\tat Problem.main(tmpag1_0mw0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (num\
    \ - floor < ceil - num) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnu9fm4qn.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnu9fm4qn.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805320
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(floor\
    \ - num) == abs(ceil - num)) {\n            if (floor < 0) floor.toLong else ceil.toLong\n\
    \        } else if (abs(floor - num) < abs(ceil - num)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8ij4n54a.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8ij4n54a.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805319
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            val n = ceil(d)\n            if (n - d == 0.5)\
    \ {\n                n.toLong - 1\n            } else {\n                n.toLong\n\
    \            }\n        } else {\n            val n = floor(d)\n            if\
    \ (d - n == 0.5) {\n                n.toLong + 1\n            } else {\n     \
    \           n.toLong\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val floor = floor(d)\n        val ceil = ceil(d)\n        if (abs(d -\
    \ floor) < abs(d - ceil)) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp48_59wn7.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(d)\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp48_59wn7.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(d)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805320
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val f = floor(d)\n        val c = ceil(d)\n        if (d - f < c - d)\
    \ f.toLong else c.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvyblsi57.scala:26)\n\tat Problem.main(tmpvyblsi57.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) == abs(num - ceil)) {\n            if (num > 0) ceil.toLong else floor.toLong\n\
    \        } else if (abs(num - floor) < abs(num - ceil)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(floor\
    \ - num) == abs(ceil - num)) {\n            if (floor < 0) {\n               \
    \ floor.toLong\n            } else {\n                ceil.toLong\n          \
    \  }\n        } else if (abs(floor - num) < abs(ceil - num)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcck8j_o2.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcck8j_o2.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805320
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val l = d.toLong\n        if (abs(d - l) < 0.5) l else l + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4s2th0sa.scala:25)\n\tat Problem.main(tmp4s2th0sa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) -closestInteger(-d)\n        else {\n            val l = d.toLong\n\
    \            if (d - l < 0.5) l\n            else l + 1\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpznfnsim1.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (d < \e\
    [31m0\e[0m) -closestInteger(-d)\n\e[31m\e[31m   |\e[0m                       \
    \            ^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Double\n\e[31m   |\e[0m                                   Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = floor(number)\n        val ceil = ceil(number)\n\
    \        if (abs(floor - number) < abs(ceil - number)) floor.toLong\n        else\
    \ ceil.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp655hj5un.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp655hj5un.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805307
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val l = d.toLong\n        if (abs(d - l) < 0.5) l else l + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4s2th0sa.scala:25)\n\tat Problem.main(tmp4s2th0sa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) >= 0.5) {\n            if (d\
    \ > 0) i + 1 else i - 1\n        } else i\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (num\
    \ - floor < ceil - num) floor.toLong else ceil.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnu9fm4qn.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnu9fm4qn.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805320
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            val d1 = ceil(d)\n            val d2 = floor(d)\n\
    \            if (d1 - d < d - d2) d1.toLong else d2.toLong\n        } else {\n\
    \            val d1 = floor(d)\n            val d2 = ceil(d)\n            if (d2\
    \ - d < d - d1) d2.toLong else d1.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9nc4d0y_.scala:31)\n\tat Problem.main(tmp9nc4d0y_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805318
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val i = round(n)\n        if (abs(n - i) == 0.5) {\n            if (n\
    \ > 0) i + 1 else i - 1\n        } else i\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3z6xmlgo.scala:26)\n\tat Problem.main(tmp3z6xmlgo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805323
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val d = n - n.toLong\n        if (d < 0.5) n.toLong else n.toLong + 1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpahqgqw5_.scala:25)\n\tat Problem.main(tmpahqgqw5_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805323
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val floor = d.floor\n        val ceil = d.ceil\n        if (abs(floor\
    \ - d) == abs(ceil - d)) {\n            if (floor < 0) ceil else floor\n     \
    \   } else if (abs(floor - d) < abs(ceil - d)) {\n            floor\n        }\
    \ else {\n            ceil\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz5zvwg0i.scala:22:27\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (floor\
    \ < \e[31m0\e[0m) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m          \
    \                 ^^^^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (ceil : Double)\n\e[31m   |\e[0m                           Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz5zvwg0i.scala:22:37\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (floor\
    \ < \e[31m0\e[0m) ceil \e[33melse\e[0m floor\n\e[31m\e[31m   |\e[0m          \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \               Found:    (floor : Double)\n\e[31m   |\e[0m                  \
    \                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpz5zvwg0i.scala:24:12 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            floor\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Found:    (floor : Double)\n\e[31m   |\e[0m            Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz5zvwg0i.scala:26:12\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            ceil\n\e[31m\e[31m\
    \   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            Found:    (ceil :\
    \ Double)\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + (if (d > 0)\
    \ 1 else -1)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n > 0) {\n            if (n - n.toLong < 0.5) n.toLong else n.toLong\
    \ + 1\n        } else {\n            if (n - n.toLong > -0.5) n.toLong else n.toLong\
    \ - 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        val ceil = ceil(num)\n        if (abs(num\
    \ - floor) == abs(num - ceil)) {\n            if (num > 0) ceil.toLong else floor.toLong\n\
    \        } else if (abs(num - floor) < abs(num - ceil)) {\n            floor.toLong\n\
    \        } else {\n            ceil.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdq0f3j8x.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(num)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = floor(number)\n        val ceil = ceil(number)\n\
    \        if (abs(floor - number) < abs(ceil - number)) floor.toLong\n        else\
    \ ceil.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp655hj5un.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp655hj5un.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805307
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            if (d - d.toLong < 0.5) d.toLong else d.toLong\
    \ + 1\n        } else {\n            if (d - d.toLong > -0.5) d.toLong else d.toLong\
    \ - 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            -closestInteger(-d)\n        } else {\n   \
    \         val i = d.toLong\n            if (d - i < 0.5) i else i + 1\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbwtr1x2w.scala:20:28\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            -closestInteger(-d)\n\
    \e[31m\e[31m   |\e[0m                            ^^\e[0m\n\e[31m   |\e[0m    \
    \                        Found:    Double\n\e[31m   |\e[0m                   \
    \         Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805323
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val x = floor(d)\n        val y = ceil(d)\n        if (abs(d - x) < abs(d\
    \ - y)) x.toLong else y.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkjgyvbmz.scala:26)\n\tat Problem.main(tmpkjgyvbmz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805323
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num > 0) {\n            if (num - num.toLong < 0.5) num.toLong else\
    \ num.toLong + 1\n        } else {\n            if (num - num.toLong > -0.5) num.toLong\
    \ else num.toLong - 1\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805324
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (d - i < 0.5) i else i + 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe19xu68j.scala:25)\n\tat Problem.main(tmpe19xu68j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d < 0) {\n            val d2 = ceil(d)\n            if (d2 - d ==\
    \ 0.5) {\n                return d2.toLong\n            } else {\n           \
    \     return floor(d).toLong\n            }\n        } else {\n            val\
    \ d2 = floor(d)\n            if (d - d2 == 0.5) {\n                return d2.toLong\n\
    \            } else {\n                return ceil(d).toLong\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppugpqslq.scala:37)\n\tat Problem.main(tmppugpqslq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805324
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52o6v7el.scala:25)\n\tat Problem.main(tmp52o6v7el.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = value.toLong\n        if (d - i < 0.5) i else i + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmphmbrntjy.scala:19)\n\
    \tat Problem$.main(tmphmbrntjy.scala:24)\n\tat Problem.main(tmphmbrntjy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805324
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy53_eekz.scala:25)\n\tat Problem.main(tmpy53_eekz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) {\n            ceil(d).toLong\n        } else {\n        \
    \    floor(d).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxckhk4p.scala:29)\n\tat Problem.main(tmpxxckhk4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = d.toLong\n        if (abs(d - i) < 0.5) i else i + signum(d)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmzin17e.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (abs(d\
    \ - i) < \e[31m0.5\e[0m) i \e[33melse\e[0m i + signum(d)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Double\n\e[31m   |\e[0m          \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805294
