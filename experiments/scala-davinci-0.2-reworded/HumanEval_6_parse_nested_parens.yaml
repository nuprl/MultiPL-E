name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((()))\
  \ () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n\
  \    def parseNestedParens(paren_string : String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList", "       \
    \ var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (group <- paren_groups) {\n            var max_level = 0\n\
    \            var level = 0\n            for (paren <- group) {\n             \
    \   if (paren == '(') {\n                    level += 1\n                    if\
    \ (level > max_level) max_level = level\n                }\n                else\
    \ if (paren == ')') {\n                    level -= 1\n                }\n   \
    \         }\n            result = result :+ max_level\n        }\n        return\
    \ result", "        val paren_groups = paren_string.split(\" \")\n        val\
    \ result = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n   \
    \         var max_depth = 0\n            var current_depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var stack = Stack[Char]()\n            var max_depth = 0\n  \
    \          var depth = 0\n            for (c <- group) {\n                if (c\
    \ == '(') {\n                    stack.push(c)\n                    depth += 1\n\
    \                    max_depth = max(max_depth, depth)\n                } else\
    \ if (c == ')') {\n                    stack.pop\n                    depth -=\
    \ 1\n                }\n            }\n            result = result :+ max_depth\n\
    \        }\n        result", "        var paren_list = List[Long]()\n        var\
    \ paren_stack = Stack[Char]()\n        var max_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                paren_stack.push(c)\n      \
    \          max_depth = max(max_depth, paren_stack.size)\n            } else if\
    \ (c == ')') {\n                if (paren_stack.isEmpty) {\n                 \
    \   println(\"Invalid input\")\n                    return List[Long]()\n    \
    \            }\n                paren_stack.pop\n            } else if (c == '\
    \ ') {\n                paren_list = paren_list :+ max_depth\n               \
    \ max_depth = 0\n            }\n        }\n        if (!paren_stack.isEmpty) {\n\
    \            println(\"Invalid input\")\n            return List[Long]()\n   \
    \     }\n        paren_list = paren_list :+ max_depth\n        return paren_list",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ = result :+ max_depth\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (c == ')') {\n\
    \                    level -= 1\n                }\n            }\n          \
    \  paren_levels += max_level\n        }\n        paren_levels.toList", "     \
    \   val paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => x.count(y => y == '(') - x.count(y => y == ')'))\n        val paren_levels_max\
    \ = paren_levels.map(x => if (x < 0) 0 else x)\n        paren_levels_max.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val levels = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    level += 1\n                  \
    \  max_level = max(max_level, level)\n                } else if (c == ')') {\n\
    \                    level -= 1\n                }\n            }\n          \
    \  levels += max_level\n        }\n        levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = paren_groups.map(group\
    \ => {\n            var max_level = 0\n            var current_level = 0\n   \
    \         for (i <- 0 until group.length) {\n                if (group(i) == '(')\
    \ {\n                    current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (group(i) == ')') {\n            \
    \        current_level -= 1\n                }\n            }\n            max_level\n\
    \        })\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (paren <- group) {\n                if (paren == '(') {\n     \
    \               current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (paren == ')') {\n             \
    \       current_nesting -= 1\n                }\n            }\n            result\
    \ = result :+ max_nesting\n        }\n        return result", "        var result\
    \ = List[Long]()\n        var paren_list = paren_string.split(\" \")\n       \
    \ for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list(i)\n\
    \            var max_depth = 0\n            var current_depth = 0\n          \
    \  for (j <- 0 until paren_group.length) {\n                if (paren_group(j)\
    \ == '(') {\n                    current_depth += 1\n                    if (current_depth\
    \ > max_depth) max_depth = current_depth\n                }\n                else\
    \ if (paren_group(j) == ')') {\n                    current_depth -= 1\n     \
    \           }\n            }\n            result = result :+ max_depth\n     \
    \   }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    depth +=\
    \ 1\n                    max_depth = max(max_depth, depth)\n                }\
    \ else if (c == ')') {\n                    depth -= 1\n                }\n  \
    \          }\n            result = result :+ max_depth\n        }\n        result",
  "        val parens = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var depth = 0\n            var max_depth\
    \ = 0\n            for (c <- paren) {\n                if (c == '(') {\n     \
    \               depth += 1\n                    max_depth = max(max_depth, depth)\n\
    \                } else if (c == ')') {\n                    depth -= 1\n    \
    \            }\n            }\n            result += max_depth\n        }\n  \
    \      result.toList", "        val paren_groups = paren_string.split(\" \")\n\
    \        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  level += 1\n                    max_level = max(max_level, level)\n       \
    \         } else if (paren == ')') {\n                    level -= 1\n       \
    \         }\n            }\n            result += max_level\n        }\n     \
    \   result.toList", "        val paren_groups = paren_string.split(\" \")\n  \
    \      val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result", "        val paren_groups = paren_string.split(\" \")\n        var\
    \ max_level = 0\n        var level = 0\n        var max_levels = List[Long]()\n\
    \        for (i <- 0 until paren_groups.length) {\n            val paren_group\
    \ = paren_groups(i)\n            for (j <- 0 until paren_group.length) {\n   \
    \             val paren = paren_group(j)\n                if (paren == '(') {\n\
    \                    level += 1\n                    if (level > max_level) max_level\
    \ = level\n                }\n                else if (paren == ')') {\n     \
    \               level -= 1\n                }\n            }\n            max_levels\
    \ = max_levels :+ max_level\n            max_level = 0\n            level = 0\n\
    \        }\n        return max_levels", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList"]
stop_tokens:
- "\n    }\n"
