name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((()))\
  \ () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n\
  \    def parseNestedParens(paren_string : String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList", "       \
    \ var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (group <- paren_groups) {\n            var max_level = 0\n\
    \            var level = 0\n            for (paren <- group) {\n             \
    \   if (paren == '(') {\n                    level += 1\n                    if\
    \ (level > max_level) max_level = level\n                }\n                else\
    \ if (paren == ')') {\n                    level -= 1\n                }\n   \
    \         }\n            result = result :+ max_level\n        }\n        return\
    \ result", "        val paren_groups = paren_string.split(\" \")\n        val\
    \ result = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n   \
    \         var max_depth = 0\n            var current_depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var stack = Stack[Char]()\n            var max_depth = 0\n  \
    \          var depth = 0\n            for (c <- group) {\n                if (c\
    \ == '(') {\n                    stack.push(c)\n                    depth += 1\n\
    \                    max_depth = max(max_depth, depth)\n                } else\
    \ if (c == ')') {\n                    stack.pop\n                    depth -=\
    \ 1\n                }\n            }\n            result = result :+ max_depth\n\
    \        }\n        result", "        var paren_list = List[Long]()\n        var\
    \ paren_stack = Stack[Char]()\n        var max_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                paren_stack.push(c)\n      \
    \          max_depth = max(max_depth, paren_stack.size)\n            } else if\
    \ (c == ')') {\n                if (paren_stack.isEmpty) {\n                 \
    \   println(\"Invalid input\")\n                    return List[Long]()\n    \
    \            }\n                paren_stack.pop\n            } else if (c == '\
    \ ') {\n                paren_list = paren_list :+ max_depth\n               \
    \ max_depth = 0\n            }\n        }\n        if (!paren_stack.isEmpty) {\n\
    \            println(\"Invalid input\")\n            return List[Long]()\n   \
    \     }\n        paren_list = paren_list :+ max_depth\n        return paren_list",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ = result :+ max_depth\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (c == ')') {\n\
    \                    level -= 1\n                }\n            }\n          \
    \  paren_levels += max_level\n        }\n        paren_levels.toList", "     \
    \   val paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => x.count(y => y == '(') - x.count(y => y == ')'))\n        val paren_levels_max\
    \ = paren_levels.map(x => if (x < 0) 0 else x)\n        paren_levels_max.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val levels = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    level += 1\n                  \
    \  max_level = max(max_level, level)\n                } else if (c == ')') {\n\
    \                    level -= 1\n                }\n            }\n          \
    \  levels += max_level\n        }\n        levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = paren_groups.map(group\
    \ => {\n            var max_level = 0\n            var current_level = 0\n   \
    \         for (i <- 0 until group.length) {\n                if (group(i) == '(')\
    \ {\n                    current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (group(i) == ')') {\n            \
    \        current_level -= 1\n                }\n            }\n            max_level\n\
    \        })\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (paren <- group) {\n                if (paren == '(') {\n     \
    \               current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (paren == ')') {\n             \
    \       current_nesting -= 1\n                }\n            }\n            result\
    \ = result :+ max_nesting\n        }\n        return result", "        var result\
    \ = List[Long]()\n        var paren_list = paren_string.split(\" \")\n       \
    \ for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list(i)\n\
    \            var max_depth = 0\n            var current_depth = 0\n          \
    \  for (j <- 0 until paren_group.length) {\n                if (paren_group(j)\
    \ == '(') {\n                    current_depth += 1\n                    if (current_depth\
    \ > max_depth) max_depth = current_depth\n                }\n                else\
    \ if (paren_group(j) == ')') {\n                    current_depth -= 1\n     \
    \           }\n            }\n            result = result :+ max_depth\n     \
    \   }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    depth +=\
    \ 1\n                    max_depth = max(max_depth, depth)\n                }\
    \ else if (c == ')') {\n                    depth -= 1\n                }\n  \
    \          }\n            result = result :+ max_depth\n        }\n        result",
  "        val parens = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var depth = 0\n            var max_depth\
    \ = 0\n            for (c <- paren) {\n                if (c == '(') {\n     \
    \               depth += 1\n                    max_depth = max(max_depth, depth)\n\
    \                } else if (c == ')') {\n                    depth -= 1\n    \
    \            }\n            }\n            result += max_depth\n        }\n  \
    \      result.toList", "        val paren_groups = paren_string.split(\" \")\n\
    \        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  level += 1\n                    max_level = max(max_level, level)\n       \
    \         } else if (paren == ')') {\n                    level -= 1\n       \
    \         }\n            }\n            result += max_level\n        }\n     \
    \   result.toList", "        val paren_groups = paren_string.split(\" \")\n  \
    \      val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result", "        val paren_groups = paren_string.split(\" \")\n        var\
    \ max_level = 0\n        var level = 0\n        var max_levels = List[Long]()\n\
    \        for (i <- 0 until paren_groups.length) {\n            val paren_group\
    \ = paren_groups(i)\n            for (j <- 0 until paren_group.length) {\n   \
    \             val paren = paren_group(j)\n                if (paren == '(') {\n\
    \                    level += 1\n                    if (level > max_level) max_level\
    \ = level\n                }\n                else if (paren == ')') {\n     \
    \               level -= 1\n                }\n            }\n            max_levels\
    \ = max_levels :+ max_level\n            max_level = 0\n            level = 0\n\
    \        }\n        return max_levels", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParens(x, 0))\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0l.toLong, 0l.toLong)((acc, y) =>\
    \ {\n            if (y == '(') (acc._1 + 1, max(acc._1 + 1, acc._2))\n       \
    \     else if (y == ')') (acc._1 - 1, acc._2)\n            else acc\n        })._2)\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (paren_group\
    \ <- paren_groups) {\n            var max_level = 0l\n            var current_level\
    \ = 0l\n            for (paren <- paren_group) {\n                if (paren ==\
    \ '(') {\n                    current_level += 1\n                    if (current_level\
    \ > max_level) max_level = current_level\n                }\n                else\
    \ if (paren == ')') {\n                    current_level -= 1\n              \
    \  }\n            }\n            paren_levels += max_level\n        }\n      \
    \  paren_levels.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = paren_groups.map(x => x.count(x => x == '(') - x.count(x\
    \ => x == ')'))\n        val paren_levels_abs = paren_levels.map(x => abs(x))\n\
    \        val max_level = paren_levels_abs.max\n        val paren_levels_max =\
    \ paren_levels.map(x => if (x > 0) max_level else -max_level)\n        val paren_levels_max_abs\
    \ = paren_levels_max.map(x => abs(x))\n        paren_levels_max_abs.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_groups_nested_levels\
    \ = paren_groups.map(x => x.count(_ == '(') - x.count(_ == ')'))\n        val\
    \ paren_groups_nested_levels_max = paren_groups_nested_levels.map(x => if (x <\
    \ 0) 0 else x)\n        paren_groups_nested_levels_max.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (i <- 0 until paren_groups.length) {\n            var count = 0\n    \
    \        var max_count = 0\n            for (j <- 0 until paren_groups(i).length)\
    \ {\n                if (paren_groups(i)(j) == '(') count += 1\n             \
    \   else if (paren_groups(i)(j) == ')') count -= 1\n                if (count\
    \ > max_count) max_count = count\n            }\n            result += max_count\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ level -= 1\n                max_level = max(max_level, level)\n            }\n\
    \            result = result :+ max_level\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1)).map(x =>\
    \ x.scanLeft(0)(_ + _).drop(1))\n        paren_levels.map(x => x.max).map(x =>\
    \ if (x < 0) 0 else x).toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                max_level = max(max_level, level)\n\
    \            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_max = paren_levels.map(x => if (x > 0) x else 0)\n  \
    \      paren_levels_max.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') level += 1\n  \
    \              else if (c == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (group <- paren_groups) {\n            var max_depth = 0\n\
    \            var current_depth = 0\n            for (c <- group) {\n         \
    \       if (c == '(') {\n                    current_depth += 1\n            \
    \        if (current_depth > max_depth) max_depth = current_depth\n          \
    \      }\n                else if (c == ')') {\n                    current_depth\
    \ -= 1\n                }\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result", "        // TODO: Implement this function\n\
    \        var result:List[Long] = List()\n        var stack:Stack[Char] = Stack()\n\
    \        var max:Long = 0\n        var count:Long = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                stack.push(c)\n            \
    \    count += 1\n                if (count > max) {\n                    max =\
    \ count\n                }\n            } else if (c == ')') {\n             \
    \   stack.pop()\n                count -= 1\n            } else if (c == ' ')\
    \ {\n                result = result :+ max\n                max = 0\n       \
    \         count = 0\n            }\n        }\n        result = result :+ max\n\
    \        return result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n   \
    \         val paren_group = paren_groups(i)\n            var paren_level = 0\n\
    \            var max_paren_level = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                val paren = paren_group(j)\n                if (paren ==\
    \ '(') paren_level += 1\n                else if (paren == ')') paren_level -=\
    \ 1\n                if (paren_level > max_paren_level) max_paren_level = paren_level\n\
    \            }\n            paren_levels += max_paren_level\n        }\n     \
    \   paren_levels.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = paren_groups.map(x => x.toList.filter(y => y ==\
    \ '(' || y == ')').map(y => if (y == '(') 1 else -1).scanLeft(0)(_ + _).max)\n\
    \        paren_levels.toList.map(x => x.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val max_nesting_levels = paren_groups.map(group\
    \ => {\n            var max_nesting_level = 0\n            var nesting_level =\
    \ 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    nesting_level += 1\n                    if (nesting_level\
    \ > max_nesting_level) max_nesting_level = nesting_level\n                }\n\
    \                else if (paren == ')') {\n                    nesting_level -=\
    \ 1\n                }\n            }\n            max_nesting_level\n       \
    \ })\n        max_nesting_levels.toList.map(x => x.toLong)", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (i <- 0 until x.length) {\n                if (x(i) == '(') level += 1\n   \
    \             else if (x(i) == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            max_level\n        })\n      \
    \  paren_levels.toList.map(x => x.toLong)", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var max_level = 0\n            var level = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         level += 1\n                    if (level > max_level) max_level = level\n\
    \                }\n                else if (c == ')') {\n                   \
    \ level -= 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => {\n            var level\
    \ = 0\n            var max_level = 0\n            for (i <- 0 until x.length)\
    \ {\n                if (x(i) == '(') level += 1\n                else if (x(i)\
    \ == ')') level -= 1\n                max_level = max(max_level, level)\n    \
    \        }\n            max_level\n        })\n        paren_levels.toList.map(x\
    \ => x.toLong)", "        val paren_groups = paren_string.split(\" \")\n     \
    \   val paren_levels = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length)\
    \ {\n            val paren_group = paren_groups(i)\n            var level = 0\n\
    \            var max_level = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group(j) == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (paren_group(j) == ')') {\n                \
    \    level -= 1\n                }\n            }\n            paren_levels +=\
    \ max_level\n        }\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (i <- 0 until paren_groups.length) {\n            var max_depth = 0\n\
    \            var current_depth = 0\n            for (j <- 0 until paren_groups(i).length)\
    \ {\n                if (paren_groups(i)(j) == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          }\n                else if (paren_groups(i)(j) == ')') {\n        \
    \            current_depth -= 1\n                }\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (group <- paren_groups) {\n            var count = 0\n            var\
    \ max_count = 0\n            for (c <- group) {\n                if (c == '(')\
    \ count += 1\n                else if (c == ')') count -= 1\n                if\
    \ (count > max_count) max_count = count\n            }\n            result +=\
    \ max_count\n        }\n        result.toList", "        val parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (paren <- parens) {\n  \
    \          var stack = new Stack[Char]()\n            var max_depth = 0\n    \
    \        var cur_depth = 0\n            for (c <- paren) {\n                if\
    \ (c == '(') {\n                    stack.push(c)\n                    cur_depth\
    \ += 1\n                    max_depth = max(max_depth, cur_depth)\n          \
    \      } else if (c == ')') {\n                    if (stack.isEmpty) {\n    \
    \                    throw new Exception(\"Invalid paren string\")\n         \
    \           }\n                    stack.pop\n                    cur_depth -=\
    \ 1\n                }\n            }\n            if (!stack.isEmpty) {\n   \
    \             throw new Exception(\"Invalid paren string\")\n            }\n \
    \           result = result :+ max_depth\n        }\n        result", "      \
    \  paren_string.split(\" \").map(x => {\n            var level = 0\n         \
    \   var max_level = 0\n            for (c <- x) {\n                if (c == '(')\
    \ level += 1\n                else level -= 1\n                max_level = max(max_level,\
    \ level)\n            }\n            max_level\n        }).toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val max_nesting_levels = new\
    \ ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- paren_group) {\n                if (paren == '(') {\n \
    \                   current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = current_nesting_level\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           current_nesting_level -= 1\n                }\n            }\n   \
    \         max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_max = paren_levels.map(x => if (x < 0) 0 else x)\n  \
    \      paren_levels_max.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0l\n            var\
    \ current_nesting_level = 0l\n            for (paren <- group) {\n           \
    \     if (paren == '(') {\n                    current_nesting_level += 1\n  \
    \                  if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        var result = List[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var max_level = 0\n            var level = 0\n         \
    \   for (c <- group) {\n                if (c == '(') level += 1\n           \
    \     else if (c == ')') level -= 1\n                max_level = max(max_level,\
    \ level)\n            }\n            result = result :+ max_level\n        }\n\
    \        return result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var max_nesting_levels = List[Long]()\n        for (paren_group\
    \ <- paren_groups) {\n            var max_nesting_level = 0l\n            var\
    \ current_nesting_level = 0l\n            for (paren <- paren_group) {\n     \
    \           if (paren == '(') {\n                    current_nesting_level +=\
    \ 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels = max_nesting_levels :+ max_nesting_level\n\
    \        }\n        return max_nesting_levels", "        // Split the string into\
    \ groups of parentheses separated by spaces.\n        val paren_groups = paren_string.split(\"\
    \ \")\n        // For each group, find the maximum depth of nesting of parentheses.\n\
    \        paren_groups.map(group => {\n            // Initialize the maximum depth\
    \ of nesting to 0.\n            var max_depth = 0\n            // Initialize the\
    \ current depth of nesting to 0.\n            var cur_depth = 0\n            //\
    \ Iterate through each character in the group.\n            for (i <- 0 until\
    \ group.length) {\n                // If the character is an opening parenthesis,\
    \ increment the current depth of nesting.\n                if (group(i) == '(')\
    \ cur_depth += 1\n                // If the character is a closing parenthesis,\
    \ decrement the current depth of nesting.\n                else if (group(i) ==\
    \ ')') cur_depth -= 1\n                // Update the maximum depth of nesting\
    \ if the current depth of nesting is greater than the maximum depth of nesting.\n\
    \                if (cur_depth > max_depth) max_depth = cur_depth\n          \
    \  }\n            // Return the maximum depth of nesting.\n            max_depth\n\
    \        }).toList.map(depth => depth.toLong)", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.toList.filter(y => y\
    \ == '(' || y == ')').map(y => if (y == '(') 1 else -1).scanLeft(0)(_ + _).max)\n\
    \        paren_levels.toList.map(x => x.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.foldLeft(List[Long](0l.toLong))((acc, c) => {\n            if (c == '(') {\n\
    \                (acc.head + 1l.toLong) :: acc\n            } else {\n       \
    \         (acc.head - 1l.toLong) :: acc\n            }\n        }).tail.reverse.max)\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = paren_groups.map(group => {\n        \
    \    var max_level = 0\n            var current_level = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (paren == ')') {\n                    current_level -= 1\n\
    \                }\n            }\n            max_level\n        })\n       \
    \ max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var cur_level = 0\n          \
    \  for (c <- group) {\n                if (c == '(') {\n                    cur_level\
    \ += 1\n                    max_level = max(max_level, cur_level)\n          \
    \      } else if (c == ')') {\n                    cur_level -= 1\n          \
    \      }\n            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (paren <- group) {\n           \
    \     if (paren == '(') {\n                    current_depth += 1\n          \
    \          max_depth = max(max_depth, current_depth)\n                } else if\
    \ (paren == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result", "        val paren_groups = paren_string.split(\" \")\n        val\
    \ result = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n   \
    \         var max_level = 0\n            var current_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (i <- 0 until group.length) {\n                if (group(i) ==\
    \ '(') {\n                    current_nesting += 1\n                    max_nesting\
    \ = max(max_nesting, current_nesting)\n                } else if (group(i) ==\
    \ ')') {\n                    current_nesting -= 1\n                }\n      \
    \      }\n            result += max_nesting\n        }\n        result.toList",
  "        // Split the string into groups of parentheses.\n        val paren_groups\
    \ = paren_string.split(\" \")\n        // For each group, find the maximum nesting\
    \ level.\n        val max_nesting_levels = paren_groups.map(group => {\n     \
    \       // Find the maximum nesting level for this group.\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (paren <- group)\
    \ {\n                paren match {\n                    case '(' => current_nesting_level\
    \ += 1\n                    case ')' => current_nesting_level -= 1\n         \
    \           case _ =>\n                }\n                max_nesting_level =\
    \ max(max_nesting_level, current_nesting_level)\n            }\n            max_nesting_level\n\
    \        })\n        // Return the maximum nesting levels.\n        max_nesting_levels.toList.map(level\
    \ => level.toLong)", "        val paren_groups = paren_string.split(\" \")\n \
    \       val paren_levels = paren_groups.map(x => {\n            var level = 0\n\
    \            var max_level = 0\n            for (i <- 0 until x.length) {\n  \
    \              if (x(i) == '(') {\n                    level += 1\n          \
    \          max_level = max(max_level, level)\n                } else if (x(i)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            max_level\n        })\n        paren_levels.toList.map(x => x.toLong)",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var paren_count = 0\n            var max_paren_count = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') paren_count += 1\n          \
    \      else if (paren == ')') paren_count -= 1\n                if (paren_count\
    \ > max_paren_count) max_paren_count = paren_count\n            }\n          \
    \  paren_levels += max_paren_count\n        }\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    if (current_level > max_level) {\n               \
    \         max_level = current_level\n                    }\n                }\
    \ else if (c == ')') {\n                    current_level -= 1\n             \
    \   }\n            }\n            max_nesting_levels += max_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (paren == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            paren_levels += max_level\n       \
    \ }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        // Split the string by spaces.\n\
    \        val paren_groups = paren_string.split(\" \")\n        // For each of\
    \ the group, find the maximum depth of nesting.\n        val depths = paren_groups.map(group\
    \ => {\n            // Keep track of the current depth.\n            var depth\
    \ = 0\n            // Keep track of the maximum depth.\n            var max_depth\
    \ = 0\n            // Go through each character in the group.\n            group.foreach(c\
    \ => {\n                // If the character is an open parenthesis, increment\
    \ the depth.\n                if (c == '(') depth += 1\n                // If\
    \ the character is a close parenthesis, decrement the depth.\n               \
    \ else if (c == ')') depth -= 1\n                // If the current depth is greater\
    \ than the maximum depth, update the maximum depth.\n                if (depth\
    \ > max_depth) max_depth = depth\n            })\n            // Return the maximum\
    \ depth.\n            max_depth\n        })\n        // Return the list of depths.\n\
    \        depths.toList.map(depth => depth.toLong)", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_ + _).max)\n       \
    \ paren_levels.toList.map(x => x.toLong)", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (c <- group) {\n                if (c == '(') current_nesting +=\
    \ 1\n                else if (c == ')') current_nesting -= 1\n               \
    \ max_nesting = max(max_nesting, current_nesting)\n            }\n           \
    \ result += max_nesting\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = new ListBuffer[Long]()\n\
    \        for (paren_group <- paren_groups) {\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (paren <- paren_group)\
    \ {\n                if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val parens = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- paren) {\n                if (c == '(') depth\
    \ += 1\n                else depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     max_depth = max(max_depth, depth)\n            }\n            result = result\
    \ :+ max_depth\n        }\n        return result", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_nesting = 0\n       \
    \     var current_nesting = 0\n            for (c <- group) {\n              \
    \  if (c == '(') {\n                    current_nesting += 1\n               \
    \     max_nesting = max(max_nesting, current_nesting)\n                } else\
    \ if (c == ')') {\n                    current_nesting -= 1\n                }\n\
    \            }\n            result += max_nesting\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList.map(level\
    \ => level.toLong)", "        val paren_groups = paren_string.split(\" \")\n \
    \       val max_nesting_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (char <- group) {\n                if (char == '(') {\n\
    \                    current_level += 1\n                    if (current_level\
    \ > max_level) max_level = current_level\n                }\n                else\
    \ if (char == ')') {\n                    current_level -= 1\n               \
    \ }\n            }\n            max_nesting_levels += max_level\n        }\n \
    \       max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else if (c == ')') level -= 1\n\
    \                if (level > max_level) max_level = level\n            }\n   \
    \         result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val max_nestings = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_nesting = 0\n    \
    \        var current_nesting = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') {\n                    current_nesting += 1\n    \
    \                if (current_nesting > max_nesting) {\n                      \
    \  max_nesting = current_nesting\n                    }\n                } else\
    \ if (paren == ')') {\n                    current_nesting -= 1\n            \
    \    }\n            }\n            max_nestings += max_nesting\n        }\n  \
    \      max_nestings.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseParens(x))\n        paren_levels.toList", "   \
    \     val parens = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- paren) {\n                if (c == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.map(x => {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (i <- 0 until x.length) {\n    \
    \            if (x(i) == '(') {\n                    current_depth += 1\n    \
    \                max_depth = max(max_depth, current_depth)\n                }\
    \ else if (x(i) == ')') {\n                    current_depth -= 1\n          \
    \      }\n            }\n            max_depth\n        }).toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (paren == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            result += max_level\n  \
    \      }\n        result.toList", "        var result = List[Long]()\n       \
    \ var max_depth = 0\n        var depth = 0\n        for (c <- paren_string) {\n\
    \            if (c == '(') {\n                depth += 1\n                max_depth\
    \ = max(max_depth, depth)\n            } else if (c == ')') {\n              \
    \  depth -= 1\n            } else if (c == ' ') {\n                result = result\
    \ :+ max_depth\n                max_depth = 0\n                depth = 0\n   \
    \         }\n        }\n        result = result :+ max_depth\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var current_level = 0\n  \
    \          var max_level = 0\n            for (c <- group) {\n               \
    \ if (c == '(') {\n                    current_level += 1\n                  \
    \  max_level = max(max_level, current_level)\n                } else if (c ==\
    \ ')') {\n                    current_level -= 1\n                }\n        \
    \    }\n            result = result :+ max_level\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var current_level = 0\n            for (paren <- group) {\n           \
    \     if (paren == '(') {\n                    current_level += 1\n          \
    \          max_level = max(max_level, current_level)\n                } else if\
    \ (paren == ')') {\n                    current_level -= 1\n                }\n\
    \            }\n            result = result :+ max_level\n        }\n        return\
    \ result", "        val paren_groups = paren_string.split(\" \")\n        val\
    \ result = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n   \
    \         var max_depth = 0\n            var depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') depth += 1\n                else if\
    \ (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n \
    \           }\n            result += max_depth\n        }\n        result.toList",
  "        var result = List[Long]()\n        var stack = Stack[Char]()\n        var\
    \ max_depth = 0\n        var depth = 0\n        for (c <- paren_string) {\n  \
    \          if (c == '(') {\n                stack.push(c)\n                depth\
    \ += 1\n                max_depth = max(max_depth, depth)\n            } else\
    \ if (c == ')') {\n                stack.pop\n                depth -= 1\n   \
    \         } else if (c == ' ') {\n                result = result :+ max_depth\n\
    \                max_depth = 0\n                depth = 0\n            }\n   \
    \     }\n        result = result :+ max_depth\n        return result", "     \
    \   var result = List[Long]()\n        var max_depth = 0\n        var current_depth\
    \ = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n      \
    \          current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            } else if (c == ')') {\n                current_depth -= 1\n    \
    \        } else if (c == ' ') {\n                result = result :+ max_depth\n\
    \                max_depth = 0\n                current_depth = 0\n          \
    \  }\n        }\n        result = result :+ max_depth\n        return result",
  "        var paren_list = paren_string.split(\" \").toList\n        var result =\
    \ List[Long]()\n        for (paren <- paren_list) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- paren) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    if\
    \ (level > max_level) {\n                        max_level = level\n         \
    \           }\n                } else if (c == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (paren <- group) {\n                if (paren == '(') {\n         \
    \           current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (paren == ')') {\n               \
    \     current_level -= 1\n                }\n            }\n            result\
    \ = result :+ max_level\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (char <- group) {\n                if (char == '(') {\n\
    \                    current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (char == ')') {\n                \
    \    current_depth -= 1\n                }\n            }\n            result\
    \ = result :+ max_depth\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.toList.foldLeft(0l)((acc, y) => if (y == '(') acc + 1 else if (y == ')') acc\
    \ - 1 else acc)).toList\n        paren_levels", "        paren_string.split(\"\
    \ \").map(x => x.toList.foldLeft(List[Long](0))((acc, x) => {\n            if\
    \ (x == '(') {\n                acc.head + 1 :: acc\n            } else {\n  \
    \              acc.tail\n            }\n        })).map(x => x.head).toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') {\n   \
    \                 level += 1\n                    if (level > max_level) max_level\
    \ = level\n                }\n                else if (paren == ')') {\n     \
    \               level -= 1\n                }\n            }\n            paren_levels\
    \ += max_level\n        }\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (i <- 0 until group.length) {\n                if (group(i)\
    \ == '(') depth += 1\n                else if (group(i) == ')') depth -= 1\n \
    \               max_depth = max(max_depth, depth)\n            }\n           \
    \ result = result :+ max_depth\n        }\n        return result", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => x.count(y => y == '(') - x.count(y => y == ')'))\n        val paren_levels_abs\
    \ = paren_levels.map(x => abs(x))\n        val paren_levels_max = paren_levels_abs.max\n\
    \        val paren_levels_max_index = paren_levels_abs.indexOf(paren_levels_max)\n\
    \        val paren_levels_max_sign = paren_levels(paren_levels_max_index)\n  \
    \      val paren_levels_max_sign_abs = abs(paren_levels_max_sign)\n        val\
    \ paren_levels_max_sign_abs_list = List.fill(paren_levels_max_sign_abs)(paren_levels_max_sign_abs)\n\
    \        val paren_levels_max_sign_abs_list_tail = paren_levels_max_sign_abs_list.tail\n\
    \        val paren_levels_max_sign_abs_list_tail_rev = paren_levels_max_sign_abs_list_tail.reverse\n\
    \        val paren_levels_max_sign_abs_list_tail_rev_map = paren_levels_max_sign_abs_list_tail_rev.map(x\
    \ => x * paren_levels_max_sign)\n        val paren_levels_max_sign_abs_list_tail_rev_map_rev\
    \ = paren_levels_max_sign_abs_list_tail_rev_map.reverse\n        val paren_levels_max_sign_abs_list_tail_rev_map_rev_updated\
    \ = paren_levels_max_sign_abs_list_tail_rev_map_rev.updated(0, paren_levels_max_sign_abs_list_tail_rev_map_rev(0)\
    \ + paren_levels_max_sign)\n        val paren_levels_max_sign_abs_list_tail_rev_map_rev_updated_map\
    \ = paren_levels_max_sign_abs_list_tail_rev_map_", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0l\n         \
    \   var max_level = 0l\n            for (c <- group) {\n                if (c\
    \ == '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (c == ')') {\n\
    \                    level -= 1\n                }\n            }\n          \
    \  paren_levels += max_level\n        }\n        paren_levels.toList", "     \
    \   val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(x => {\n            var max_nesting_level = 0\n         \
    \   var current_nesting_level = 0\n            for (i <- 0 until x.length) {\n\
    \                if (x(i) == '(') {\n                    current_nesting_level\
    \ += 1\n                    max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \                } else if (x(i) == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_level\n    \
    \    }).toList\n        max_nesting_levels", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (paren_group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- paren_group) {\n                if (c == '(') {\n           \
    \         current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result", "        var paren_list = List[Long]()\n \
    \       for (paren <- paren_string.split(\" \")) {\n            var level = 0\n\
    \            var max_level = 0\n            for (c <- paren) {\n             \
    \   if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            paren_list\
    \ = paren_list :+ max_level\n        }\n        return paren_list", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = paren_groups.map(x => {\n  \
    \          var max_depth = 0\n            var current_depth = 0\n            for\
    \ (c <- x) {\n                if (c == '(') current_depth += 1\n             \
    \   else if (c == ')') current_depth -= 1\n                max_depth = max(max_depth,\
    \ current_depth)\n            }\n            max_depth\n        }).toList\n  \
    \      result", "        val paren_groups = paren_string.split(\" \")\n      \
    \  val max_nesting_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (paren <- group) {\n                if (paren == '(') {\n         \
    \           current_level += 1\n                    if (current_level > max_level)\
    \ max_level = current_level\n                }\n                else if (paren\
    \ == ')') {\n                    current_level -= 1\n                }\n     \
    \       }\n            max_nesting_levels += max_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') level\
    \ += 1\n                else if (paren == ')') level -= 1\n                if\
    \ (level > max_level) max_level = level\n            }\n            max_level\n\
    \        })\n        paren_levels.toList.map(level => level.toLong)", "      \
    \  val paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => x.count(y => y == '(') - x.count(y => y == ')'))\n        val paren_levels_abs\
    \ = paren_levels.map(x => abs(x))\n        val paren_levels_max = paren_levels_abs.max\n\
    \        val paren_levels_max_index = paren_levels_abs.indexOf(paren_levels_max)\n\
    \        val paren_levels_max_sign = paren_levels(paren_levels_max_index)\n  \
    \      val paren_levels_max_sign_abs = abs(paren_levels_max_sign)\n        val\
    \ paren_levels_max_sign_abs_list = List.fill(paren_levels_max_sign_abs)(paren_levels_max_sign)\n\
    \        val paren_levels_max_sign_abs_list_updated = paren_levels_max_sign_abs_list.updated(0,\
    \ paren_levels_max_sign_abs_list(0) - paren_levels_max_sign)\n        val paren_levels_max_sign_abs_list_updated_abs\
    \ = paren_levels_max_sign_abs_list_updated.map(x => abs(x))\n        val paren_levels_max_sign_abs_list_updated_abs_max\
    \ = paren_levels_max_sign_abs_list_updated_abs.max\n        val paren_levels_max_sign_abs_list_updated_abs_max_list\
    \ = List.fill(paren_levels_max_sign_abs_list_updated_abs_max)(paren_levels_max_sign_abs_list_updated_abs_max)\n\
    \        val paren_levels_max_sign_abs_list_updated_abs_max_list_updated = paren_levels_max_sign_abs_list_updated_abs_max_list.updated(0,\
    \ paren_levels_max_sign_abs_list_updated_abs_max_list(0) - paren_levels_max_sign_abs_list_updated_abs_",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)", "        // Split\
    \ the string into groups of parentheses\n        val paren_groups = paren_string.split(\"\
    \ \")\n        // For each group, count the maximum level of nesting\n       \
    \ paren_groups.map(group => {\n            var max_nesting = 0\n            var\
    \ current_nesting = 0\n            for (paren <- group) {\n                if\
    \ (paren == '(') {\n                    current_nesting += 1\n               \
    \     max_nesting = max(max_nesting, current_nesting)\n                } else\
    \ if (paren == ')') {\n                    current_nesting -= 1\n            \
    \    }\n            }\n            max_nesting\n        }).toList", "        var\
    \ result = List[Long]()\n        var current_level = 0\n        var max_level\
    \ = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n      \
    \          current_level += 1\n                max_level = max(max_level, current_level)\n\
    \            } else if (c == ')') {\n                current_level -= 1\n    \
    \        } else if (c == ' ') {\n                result = result :+ max_level\n\
    \                max_level = 0\n                current_level = 0\n          \
    \  }\n        }\n        result = result :+ max_level\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            if (depth > max_depth) max_depth = depth\n            }\n       \
    \     result = result :+ max_depth\n        }\n        return result", "     \
    \   val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (i <- 0 until group.length) {\n                if (group(i) == '(')\
    \ {\n                    current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (group(i) == ')') {\n            \
    \        current_level -= 1\n                }\n            }\n            result\
    \ = result :+ max_level\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = paren_groups.map(x => {\n\
    \            var max_depth = 0\n            var current_depth = 0\n          \
    \  for (c <- x) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            max_depth\n        }).toList\n  \
    \      result", "        val paren_groups = paren_string.split(\" \")\n      \
    \  val max_nesting_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result = result :+ max_level\n        }\n        result",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_nesting_level = 0\n     \
    \       var current_nesting_level = 0\n            for (paren <- group) {\n  \
    \              if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_level\n        })\n        max_nesting_levels.toList.map(x\
    \ => x.toLong)", "        val paren_groups = paren_string.split(\" \")\n     \
    \   val result = ListBuffer[Long]()\n        for (group <- paren_groups) {\n \
    \           var max_depth = 0\n            var depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') depth += 1\n                else if\
    \ (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n \
    \           }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList.map(level\
    \ => level.toLong)", "        val paren_groups = paren_string.split(\" \")\n \
    \       val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result = result :+ max_level\n        }\n        result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = paren_groups.map(x\
    \ => parseNestedParensHelper(x)).toList\n        return result", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => x.foldLeft(0l)((acc, c) => if (c == '(') acc + 1 else acc - 1)).toList\n\
    \        val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n       \
    \ max_levels", "        val paren_groups = paren_string.split(\" \")\n       \
    \ val result = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n\
    \            var max_level = 0\n            var level = 0\n            for (c\
    \ <- group) {\n                if (c == '(') {\n                    level += 1\n\
    \                    max_level = max(max_level, level)\n                } else\
    \ if (c == ')') {\n                    level -= 1\n                }\n       \
    \     }\n            result += max_level\n        }\n        result.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else if (c == ')') level -= 1\n\
    \                max_level = max(max_level, level)\n            }\n          \
    \  result += max_level\n        }\n        result.toList", "        // For each\
    \ group, we will keep track of the current level of nesting.\n        // We will\
    \ increase the level of nesting when we see an open parenthesis and decrease it\
    \ when we see a close parenthesis.\n        // We will keep track of the maximum\
    \ level of nesting we have seen so far.\n        // We will return the maximum\
    \ level of nesting we have seen so far.\n        def parseNestedParensHelper(paren_string\
    \ : String, current_level : Long, max_level : Long) : Long = {\n            if\
    \ (paren_string.length == 0) max_level\n            else if (paren_string.head\
    \ == '(') parseNestedParensHelper(paren_string.tail, current_level + 1, max(current_level\
    \ + 1, max_level))\n            else if (paren_string.head == ')') parseNestedParensHelper(paren_string.tail,\
    \ current_level - 1, max(current_level - 1, max_level))\n            else parseNestedParensHelper(paren_string.tail,\
    \ current_level, max_level)\n        }\n        paren_string.split(\" \").map(x\
    \ => parseNestedParensHelper(x, 0, 0)).toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (i <- 0 until paren_groups.length) {\n            var paren_group\
    \ = paren_groups(i)\n            var max_level = 0\n            var level = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group(j)\
    \ == '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (paren_group(j)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result = result :+ max_level\n        }\n        return result",
  "        val groups = paren_string.split(\" \")\n        val results = new ListBuffer[Long]()\n\
    \        for (group <- groups) {\n            var max_level = 0\n            var\
    \ cur_level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    cur_level += 1\n                    max_level = max(max_level,\
    \ cur_level)\n                } else if (c == ')') {\n                    cur_level\
    \ -= 1\n                }\n            }\n            results += max_level\n \
    \       }\n        results.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.map(x => {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- x) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            max_depth\n\
    \        }).toList", "        val paren_groups = paren_string.split(\" \")\n \
    \       val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') level += 1\n         \
    \       else if (paren == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (c <- group) {\n                if (c == '(') current_nesting +=\
    \ 1\n                else if (c == ')') current_nesting -= 1\n               \
    \ max_nesting = max(max_nesting, current_nesting)\n            }\n           \
    \ result += max_nesting\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_levels = ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var level = 0\n           \
    \ var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (c == ')') {\n\
    \                    level -= 1\n                }\n            }\n          \
    \  max_levels += max_level\n        }\n        max_levels.toList", "        var\
    \ result = List[Long]()\n        for (paren_group <- paren_string.split(\" \"\
    )) {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- paren_group) {\n                if (paren == '(') depth += 1\n   \
    \             else if (paren == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (paren <- parens)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (c <- paren) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var nesting_level = 0\n            var max_nesting_level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  nesting_level += 1\n                    if (nesting_level > max_nesting_level)\
    \ max_nesting_level = nesting_level\n                }\n                else if\
    \ (paren == ')') {\n                    nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        var result = List[Long]()\n    \
    \    var current_level = 0\n        var max_level = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_level += 1\n       \
    \         max_level = max(max_level, current_level)\n            } else if (c\
    \ == ')') {\n                current_level -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_level\n                max_level\
    \ = 0\n                current_level = 0\n            }\n        }\n        result\
    \ = result :+ max_level\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.filter(y => y == '('\
    \ || y == ')').map(y => if (y == '(') 1 else -1).scanLeft(0)(_ + _).max)\n   \
    \     paren_levels.toList.map(x => x.toLong)", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val max_levels = paren_levels.map(x => if\
    \ (x < 0) 0 else x)\n        max_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val paren_levels_abs = paren_levels.map(x\
    \ => abs(x))\n        val paren_levels_max = paren_levels_abs.max\n        val\
    \ paren_levels_max_list = paren_levels_abs.map(x => if (x == paren_levels_max)\
    \ 1l else 0l)\n        paren_levels_max_list.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ArrayBuffer[Long]()\n    \
    \    for (group <- paren_groups) {\n            var max_depth = 0\n          \
    \  var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                if (level > max_level) max_level =\
    \ level\n            }\n            result += max_level\n        }\n        result.toList",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- groups) {\n            var max_depth = 0\n            var\
    \ current_depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                } else if (paren == ')') {\n\
    \                    current_depth -= 1\n                }\n            }\n  \
    \          result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_nesting = 0\n    \
    \        var current_nesting = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') {\n                    current_nesting += 1\n    \
    \                max_nesting = max(max_nesting, current_nesting)\n           \
    \     } else if (paren == ')') {\n                    current_nesting -= 1\n \
    \               }\n            }\n            result += max_nesting\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val max_nesting_levels = ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (paren <- group) {\n                if (paren == '(') {\n         \
    \           current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (paren == ')') {\n               \
    \     current_level -= 1\n                }\n            }\n            result\
    \ += max_level\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        var result = List[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_depth = 0\n            var depth = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         depth += 1\n                    max_depth = max(max_depth, depth)\n\
    \                } else if (c == ')') {\n                    depth -= 1\n    \
    \            }\n            }\n            result = result :+ max_depth\n    \
    \    }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') depth += 1\n         \
    \       else depth -= 1\n                max_depth = max(max_depth, depth)\n \
    \           }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     max_depth = max(max_depth, depth)\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = paren_groups.map(x => {\n            var\
    \ max_nesting_level = 0\n            var current_nesting_level = 0\n         \
    \   for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n      \
    \              current_nesting_level += 1\n                    max_nesting_level\
    \ = max(max_nesting_level, current_nesting_level)\n                } else if (x(i)\
    \ == ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_level\n        }).toList\n        max_nesting_levels",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            val paren_group = paren_groups(i)\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (j <- 0 until\
    \ paren_group.length) {\n                val paren = paren_group(j)\n        \
    \        if (paren == '(') {\n                    current_nesting_level += 1\n\
    \                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var max_level = 0\n            var level = 0\n\
    \            for (c <- group) {\n                if (c == '(') level += 1\n  \
    \              else if (c == ')') level -= 1\n                max_level = max(max_level,\
    \ level)\n            }\n            paren_levels += max_level\n        }\n  \
    \      paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_groups_count\
    \ = paren_groups.length\n        val paren_groups_count_long = paren_groups_count.toLong\n\
    \        val paren_groups_count_long_range = (0l.toLong until paren_groups_count_long)\n\
    \        val paren_groups_count_long_range_list = paren_groups_count_long_range.toList\n\
    \        val paren_groups_count_long_range_list_map = paren_groups_count_long_range_list.map(i\
    \ => (i, paren_groups(i.toInt)))\n        val paren_groups_count_long_range_list_map_map\
    \ = paren_groups_count_long_range_list_map.map(i => (i._1, i._2.toList))\n   \
    \     val paren_groups_count_long_range_list_map_map_map = paren_groups_count_long_range_list_map_map.map(i\
    \ => (i._1, i._2.map(j => j.toString)))\n        val paren_groups_count_long_range_list_map_map_map_map\
    \ = paren_groups_count_long_range_list_map_map_map.map(i => (i._1, i._2.map(j\
    \ => j.toList)))\n        val paren_groups_count_long_range_list_map_map_map_map_map\
    \ = paren_groups_count_long_range_list_map_map_map_map.map(i => (i._1, i._2.map(j\
    \ => j.map(k => k.toString))))\n        val paren_groups_count_long_range_list_map_map_map_map_map_map\
    \ = paren_groups_count_long_range_list_map_map_map_map_map.map(i => (i._1, i._2.map(j\
    \ => j.map(k => k.toList))))\n        val paren_groups_count_long_range_list_map_map_",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_abs = paren_levels.map(x => abs(x))\n        val paren_levels_max\
    \ = paren_levels_abs.max\n        val paren_levels_max_index = paren_levels_abs.indexOf(paren_levels_max)\n\
    \        val paren_levels_max_sign = paren_levels(paren_levels_max_index)\n  \
    \      val paren_levels_max_sign_abs = abs(paren_levels_max_sign)\n        val\
    \ paren_levels_max_sign_abs_list = List.fill(paren_levels_max_sign_abs)(paren_levels_max_sign)\n\
    \        val paren_levels_max_sign_abs_list_updated = paren_levels_max_sign_abs_list.updated(0,\
    \ paren_levels_max_sign_abs_list(0) - paren_levels_max_sign_abs)\n        val\
    \ paren_levels_updated = paren_levels.updated(paren_levels_max_index, 0)\n   \
    \     val paren_levels_updated_final = paren_levels_updated ++ paren_levels_max_sign_abs_list_updated\n\
    \        val paren_levels_updated_final_abs = paren_levels_updated_final.map(x\
    \ => abs(x))\n        paren_levels_updated_final_abs", "        var result = List[Long]()\n\
    \        var current_level = 0\n        var max_level = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_level += 1\n       \
    \         max_level = max(max_level, current_level)\n            } else if (c\
    \ == ')') {\n                current_level -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_level\n                max_level\
    \ = 0\n                current_level = 0\n            }\n        }\n        result\
    \ = result :+ max_level\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var stack = Stack[Char]()\n            var max_level = 0\n  \
    \          var current_level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    stack.push(c)\n                   \
    \ current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    stack.pop\n     \
    \               current_level -= 1\n                }\n            }\n       \
    \     result = result :+ max_level\n        }\n        result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_nesting_level = 0\n\
    \            var current_nesting_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until paren_groups.length)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') depth += 1\n                else if (paren_groups(i)(j) == ')') depth\
    \ -= 1\n                if (depth > max_depth) max_depth = depth\n           \
    \ }\n            result = max_depth :: result\n        }\n        result.reverse",
  "        var result = List[Long]()\n        var current_level = 0\n        var max_level\
    \ = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n      \
    \          current_level += 1\n                max_level = max(max_level, current_level)\n\
    \            } else if (c == ')') {\n                current_level -= 1\n    \
    \        } else if (c == ' ') {\n                result = result :+ max_level\n\
    \                max_level = 0\n                current_level = 0\n          \
    \  }\n        }\n        result = result :+ max_level\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)", "        var max_depth = 0\n\
    \        var depth = 0\n        var result = List[Long]()\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                depth += 1\n               \
    \ max_depth = max(max_depth, depth)\n            } else if (c == ')') {\n    \
    \            depth -= 1\n            } else if (c == ' ') {\n                result\
    \ = result :+ max_depth\n                max_depth = 0\n                depth\
    \ = 0\n            }\n        }\n        result = result :+ max_depth\n      \
    \  return result", "        val paren_groups = paren_string.split(\" \")\n   \
    \     val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            if (depth > max_depth) max_depth = depth\n            }\n       \
    \     result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (group <- paren_groups) {\n            var max_level = 0\n           \
    \ var current_level = 0\n            for (paren <- group) {\n                if\
    \ (paren == '(') {\n                    current_level += 1\n                 \
    \   max_level = max(max_level, current_level)\n                } else if (paren\
    \ == ')') {\n                    current_level -= 1\n                }\n     \
    \       }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (char <- group) {\n                if (char\
    \ == '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (char == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      paren_levels += max_level\n        }\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (c <- group) {\n                if (c == '(') {\n               \
    \     current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = current_nesting_level\n\
    \                    }\n                } else if (c == ')') {\n             \
    \       current_nesting_level -= 1\n                }\n            }\n       \
    \     max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     max_depth = max(max_depth, depth)\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (c <- group) {\n                if (c == '(') {\n             \
    \       current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (c == ')') {\n                 \
    \   current_nesting -= 1\n                }\n            }\n            result\
    \ = result :+ max_nesting\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_level = 0\n            var level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            result = result :+ max_level\n    \
    \    }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x.toList))\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toCharArray.foldLeft(0)((acc, c) => if (c == '(')\
    \ acc + 1 else if (c == ')') acc - 1 else acc))\n        paren_levels.toList",
  "        var result = List[Long]()\n        var stack = Stack[Char]()\n        var\
    \ max_depth = 0\n        var depth = 0\n        for (c <- paren_string) {\n  \
    \          if (c == '(') {\n                depth += 1\n                max_depth\
    \ = max(max_depth, depth)\n            } else if (c == ')') {\n              \
    \  depth -= 1\n            } else if (c == ' ') {\n                result = result\
    \ :+ max_depth\n                max_depth = 0\n                depth = 0\n   \
    \         }\n        }\n        result = result :+ max_depth\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') current_depth += 1\n  \
    \              else if (paren == ')') current_depth -= 1\n                max_depth\
    \ = max(max_depth, current_depth)\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(c => c == '(')\
    \ - x.count(c => c == ')'))\n        val max_level = paren_levels.max\n      \
    \  val min_level = paren_levels.min\n        val paren_groups_max = paren_groups.filter(x\
    \ => x.count(c => c == '(') - x.count(c => c == ')') == max_level)\n        val\
    \ paren_groups_min = paren_groups.filter(x => x.count(c => c == '(') - x.count(c\
    \ => c == ')') == min_level)\n        val max_level_nested = paren_groups_max.map(x\
    \ => x.count(c => c == '(') + x.count(c => c == ')')).max\n        val min_level_nested\
    \ = paren_groups_min.map(x => x.count(c => c == '(') + x.count(c => c == ')')).min\n\
    \        val max_level_nested_groups = paren_groups_max.filter(x => x.count(c\
    \ => c == '(') + x.count(c => c == ')') == max_level_nested)\n        val min_level_nested_groups\
    \ = paren_groups_min.filter(x => x.count(c => c == '(') + x.count(c => c == ')')\
    \ == min_level_nested)\n        val max_level_nested_groups_max = max_level_nested_groups.map(x\
    \ => x.count(c => c == '(')).max\n        val min_level_nested_groups_min = min_level_nested_groups.map(x\
    \ => x.count(c => c == '(')).min\n        List(max_level_nested_groups_max, min_level_nested_groups_min)",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') level += 1\n                else if (c == ')') level\
    \ -= 1\n                if (level > max_level) max_level = level\n           \
    \ }\n            paren_levels += max_level\n        }\n        paren_levels.toList"]
stop_tokens:
- "\n    }\n"
