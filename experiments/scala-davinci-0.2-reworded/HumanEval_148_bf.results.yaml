language: scala
name: HumanEval_148_bf
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            List()\n\
    \        } else {\n            val startIndex = min(planet1Index, planet2Index)\n\
    \            val endIndex = max(planet1Index, planet2Index)\n            planets.slice(startIndex\
    \ + 1, endIndex)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 > p2) {\n            return planets.slice(p2, p1)\n        }\n    \
    \    planets.slice(p1, p2)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7a983398.scala:33)\n\tat Problem.main(tmp7a983398.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            List()\n\
    \        } else {\n            val start = min(planet1Index, planet2Index)\n \
    \           val end = max(planet1Index, planet2Index)\n            planets.slice(start\
    \ + 1, end)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (a, b) = if (p1 < p2)\
    \ (p1, p2) else (p2, p1)\n        planets.slice(a + 1, b)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        List[String]()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq8ro04m5.scala:25)\n\tat Problem.main(tmpq8ro04m5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n \
    \       if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n       \
    \ } else {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 > p2) {\n            return planets.slice(p2, p1)\n        }\n    \
    \    planets.slice(p1, p2)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7a983398.scala:33)\n\tat Problem.main(tmp7a983398.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) return List()\n       \
    \ if (planet1Index < planet2Index) return planets.slice(planet1Index + 1, planet2Index)\n\
    \        else return planets.slice(planet2Index + 1, planet1Index)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List[String]()\n\
    \        }\n        if (planet1Index < planet2Index) {\n            return planets.slice(planet1Index\
    \ + 1, planet2Index)\n        } else {\n            return planets.slice(planet2Index\
    \ + 1, planet1Index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min\
    \ + 1, max)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code goes here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwzgjahjk.scala:25)\n\tat Problem.main(tmpwzgjahjk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 >\
    \ index2) return planets.slice(index2, index1 + 1)\n        planets.slice(index1,\
    \ index2 + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr4vmz0uo.scala:29)\n\tat Problem.main(tmpr4vmz0uo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the code here\n        val planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val index1 = planets.indexOf(planet1)\n        val index2\
    \ = planets.indexOf(planet2)\n        if (index1 == -1 || index2 == -1) return\
    \ List()\n        if (index1 < index2) planets.slice(index1 + 1, index2)\n   \
    \     else planets.slice(index2 + 1, index1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 > p2) planets.slice(p2,\
    \ p1 + 1)\n        else planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg8p5ff76.scala:29)\n\tat Problem.main(tmpg8p5ff76.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) return planets.slice(p1\
    \ + 1, p2)\n        else return planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3yapp9zw.scala:25)\n\tat Problem.main(tmp3yapp9zw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List[String]()\n        if (p1 > p2) return\
    \ planets.slice(p2 + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        null\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.bf(String, String)\" is null\n\tat Problem$.main(tmp17vxoo2p.scala:25)\n\
    \tat Problem.main(tmp17vxoo2p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val start\
    \ = planets.indexOf(planet1)\n        val end = planets.indexOf(planet2)\n   \
    \     if (start == -1 || end == -1) return List()\n        if (start > end) return\
    \ planets.slice(end, start + 1)\n        else return planets.slice(start, end\
    \ + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptko3jwn3.scala:29)\n\tat Problem.main(tmptko3jwn3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeckhkl9i.scala:29)\n\tat Problem.main(tmpeckhkl9i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val i1\
    \ = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n    \
    \    if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return planets.slice(i2,\
    \ i1 + 1)\n        planets.slice(i1, i2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswcqs4m6.scala:29)\n\tat Problem.main(tmpswcqs4m6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            return List()\n    \
    \    }\n        if (index1 < index2) {\n            return planets.slice(index1\
    \ + 1, index2)\n        }\n        else {\n            return planets.slice(index2\
    \ + 1, index1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            List()\n        } else\
    \ {\n            val start = min(index1, index2)\n            val end = max(index1,\
    \ index2)\n            planets.slice(start + 1, end)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1)\n            return List()\n        if (p1 > p2)\n\
    \            return planets.slice(p2, p1)\n        else\n            return planets.slice(p1,\
    \ p2)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpygywrmhr.scala:32)\n\tat Problem.main(tmpygywrmhr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpquz1i7ww.scala:29)\n\tat Problem.main(tmpquz1i7ww.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 > p2) planets.slice(p2,\
    \ p1 + 1)\n        else planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg8p5ff76.scala:29)\n\tat Problem.main(tmpg8p5ff76.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        if (planet1Index < planet2Index) {\n            return planets.slice(planet1Index\
    \ + 1, planet2Index)\n        } else {\n            return planets.slice(planet2Index\
    \ + 1, planet1Index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the code here\n        val planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        if (planets.contains(planet1) && planets.contains(planet2))\
    \ {\n            val p1 = planets.indexOf(planet1)\n            val p2 = planets.indexOf(planet2)\n\
    \            if (p1 < p2) planets.slice(p1 + 1, p2)\n            else planets.slice(p2\
    \ + 1, p1)\n        }\n        else List()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) return List()\n       \
    \ val minIndex = min(planet1Index, planet2Index)\n        val maxIndex = max(planet1Index,\
    \ planet2Index)\n        planets.slice(minIndex + 1, maxIndex)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 <\
    \ index2) planets.slice(index1 + 1, index2)\n        else planets.slice(index2\
    \ + 1, index1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n \
    \           if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n      \
    \      } else {\n                planets.slice(p2 + 1, p1)\n            }\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9k67ctbw.scala:29)\n\tat Problem.main(tmp9k67ctbw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the code here\n        val planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n \
    \           val min = min(p1, p2)\n            val max = max(p1, p2)\n       \
    \     (min + 1 until max).map(planets(_)).toList\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgm37endh.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgm37endh.scala:29:22 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        if (planet1Index < planet2Index) {\n            return planets.slice(planet1Index\
    \ + 1, planet2Index)\n        } else {\n            return planets.slice(planet2Index\
    \ + 1, planet1Index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2\
    \ + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            return List()\n    \
    \    }\n        val min = min(index1, index2)\n        val max = max(index1, index2)\n\
    \        planets.slice(min + 1, max)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpftzvmpoq.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(index1, index2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpftzvmpoq.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(index1, index2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 > p2) planets.slice(p2,\
    \ p1 + 1)\n        else planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg8p5ff76.scala:29)\n\tat Problem.main(tmpg8p5ff76.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else {\n            val (a, b)\
    \ = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(a + 1, b)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (start, end) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(start + 1, end)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val planet1Index = planets.indexOf(planet1)\n        val planet2Index\
    \ = planets.indexOf(planet2)\n        if (planet1Index == -1 || planet2Index ==\
    \ -1) {\n            return List()\n        }\n        val minIndex = min(planet1Index,\
    \ planet2Index)\n        val maxIndex = max(planet1Index, planet2Index)\n    \
    \    return planets.slice(minIndex + 1, maxIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val i1\
    \ = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n    \
    \    if (i1 == -1 || i2 == -1) return List()\n        if (i1 < i2) planets.slice(i1\
    \ + 1, i2)\n        else planets.slice(i2 + 1, i1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Write your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpglc59o_v.scala:25)\n\tat Problem.main(tmpglc59o_v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        if (planets.contains(planet1) && planets.contains(planet2)) {\n   \
    \         val start = planets.indexOf(planet1)\n            val end = planets.indexOf(planet2)\n\
    \            if (start < end) {\n                planets.slice(start + 1, end)\n\
    \            } else {\n                planets.slice(end + 1, start)\n       \
    \     }\n        } else {\n            List()\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val (i1,\
    \ i2) = (planets.indexOf(planet1), planets.indexOf(planet2))\n        if (i1 ==\
    \ -1 || i2 == -1) return List()\n        val (min, max) = (min(i1, i2), max(i1,\
    \ i2))\n        planets.slice(min + 1, max)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_3w0nhub.scala:24:13 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m (min, max) = (min(i1, i2), max(i1,\
    \ i2))\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m            \
    \ Recursive \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp_3w0nhub.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m (min, max) = (min(i1, i2), max(i1,\
    \ i2))\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsajko7tk.scala:29)\n\tat Problem.main(tmpsajko7tk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        val minIndex = min(planet1Index, planet2Index)\n        val\
    \ maxIndex = max(planet1Index, planet2Index)\n        planets.slice(minIndex +\
    \ 1, maxIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2\
    \ + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 > p2) {\n            return planets.slice(p2, p1 + 1)\n        }\n\
    \        return planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07enw0xr.scala:33)\n\tat Problem.main(tmp07enw0xr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) planets.slice(p2,\
    \ p1 + 1)\n        else planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppahqo_lk.scala:29)\n\tat Problem.main(tmppahqo_lk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        (min + 1 until max).map(planets(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            List()\n\
    \        } else {\n            val minIndex = min(planet1Index, planet2Index)\n\
    \            val maxIndex = max(planet1Index, planet2Index)\n            planets.slice(minIndex\
    \ + 1, maxIndex)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val (p1,\
    \ p2) = (planets.indexOf(planet1), planets.indexOf(planet2))\n        if (p1 ==\
    \ -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1 + 1, p2)\n\
    \        else planets.slice(p2 + 1, p1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            List()\n        } else\
    \ {\n            if (index1 < index2) {\n                planets.slice(index1\
    \ + 1, index2)\n            } else {\n                planets.slice(index2 + 1,\
    \ index1)\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        if (planets.contains(planet1)\
    \ && planets.contains(planet2)) {\n            val p1 = planets.indexOf(planet1)\n\
    \            val p2 = planets.indexOf(planet2)\n            if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n            else planets.slice(p2 + 1, p1)\n        }\n        else\
    \ List()\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        val min = min(p1, p2)\n    \
    \    val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2h4n1v3a.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2h4n1v3a.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            List()\n        } else\
    \ {\n            if (index1 < index2) {\n                planets.slice(index1\
    \ + 1, index2)\n            } else {\n                planets.slice(index2 + 1,\
    \ index1)\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val idx1\
    \ = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n  \
    \      if (idx1 == -1 || idx2 == -1) List()\n        else if (idx1 < idx2) planets.slice(idx1\
    \ + 1, idx2)\n        else planets.slice(idx2 + 1, idx1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        (min + 1 until max).map(planets(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfhw6mu5c.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfhw6mu5c.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val start\
    \ = planets.indexOf(planet1)\n        val end = planets.indexOf(planet2)\n   \
    \     if (start == -1 || end == -1) return List()\n        if (start > end) return\
    \ planets.slice(end, start + 1)\n        else return planets.slice(start, end\
    \ + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptko3jwn3.scala:29)\n\tat Problem.main(tmptko3jwn3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val index1 = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) List()\n        else if (index1 < index2)\
    \ planets.slice(index1 + 1, index2)\n        else planets.slice(index2 + 1, index1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            return List()\n    \
    \    }\n        if (index1 < index2) {\n            return planets.slice(index1\
    \ + 1, index2)\n        }\n        else {\n            return planets.slice(index2\
    \ + 1, index1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val idx1\
    \ = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n  \
    \      if (idx1 == -1 || idx2 == -1) return List()\n        if (idx1 < idx2) planets.slice(idx1\
    \ + 1, idx2)\n        else planets.slice(idx2 + 1, idx1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) return planets.slice(p1\
    \ + 1, p2)\n        else return planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2\
    \ + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        val result = planets.slice(min + 1, max)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6iqowc_o.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6iqowc_o.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val idx1\
    \ = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n  \
    \      if (idx1 == -1 || idx2 == -1) {\n            return List()\n        }\n\
    \        if (idx1 < idx2) {\n            return planets.slice(idx1 + 1, idx2)\n\
    \        } else {\n            return planets.slice(idx2 + 1, idx1)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeckhkl9i.scala:29)\n\tat Problem.main(tmpeckhkl9i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val (p1,\
    \ p2) = (planets.indexOf(planet1), planets.indexOf(planet2))\n        if (p1 ==\
    \ -1 || p2 == -1) return List()\n        val (min, max) = (min(p1, p2), max(p1,\
    \ p2))\n        planets.slice(min + 1, max)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpszho5_ky.scala:24:13 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m (min, max) = (min(p1, p2), max(p1,\
    \ p2))\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m            \
    \ Recursive \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpszho5_ky.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m (min, max) = (min(p1, p2), max(p1,\
    \ p2))\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798006
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        if (planet1Index > planet2Index) {\n            return planets.slice(planet2Index,\
    \ planet1Index)\n        }\n        planets.slice(planet1Index, planet2Index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpev_vhlcj.scala:33)\n\tat Problem.main(tmpev_vhlcj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n \
    \           val min = min(p1, p2)\n            val max = max(p1, p2)\n       \
    \     planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnkf49lem.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnkf49lem.scala:29:22 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798006
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyu7i7zhz.scala:25)\n\tat Problem.main(tmpyu7i7zhz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val start = min(p1, p2)\n\
    \        val end = max(p1, p2)\n        planets.slice(start + 1, end)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            return List()\n    \
    \    }\n        if (index1 < index2) {\n            return planets.slice(index1\
    \ + 1, index2)\n        }\n        return planets.slice(index2 + 1, index1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 > p2) planets.slice(p2,\
    \ p1 + 1)\n        else planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg8p5ff76.scala:29)\n\tat Problem.main(tmpg8p5ff76.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val i1\
    \ = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n    \
    \    if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if (i1\
    \ < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        List[String]()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq8ro04m5.scala:25)\n\tat Problem.main(tmpq8ro04m5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val idx1\
    \ = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n  \
    \      if (idx1 == -1 || idx2 == -1) return List()\n        if (idx1 < idx2) planets.slice(idx1\
    \ + 1, idx2)\n        else planets.slice(idx2 + 1, idx1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return List()\n\
    \        planets.slice(p1 + 1, p2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsotzjltm.scala:30)\n\tat Problem.main(tmpsotzjltm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val i1\
    \ = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n    \
    \    if (i1 == -1 || i2 == -1) return List()\n        if (i1 < i2) planets.slice(i1+1,\
    \ i2)\n        else planets.slice(i2+1, i1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 <\
    \ index2) planets.slice(index1 + 1, index2)\n        else planets.slice(index2\
    \ + 1, index1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        List[String]()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq8ro04m5.scala:25)\n\tat Problem.main(tmpq8ro04m5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        val (min, max) = if (p1 < p2)\
    \ (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        var index1\
    \ = planets.indexOf(planet1)\n        var index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        var result =\
    \ List[String]()\n        if (index1 < index2) {\n            for (i <- index1\
    \ + 1 to index2) result = result :+ planets(i)\n        } else {\n           \
    \ for (i <- index2 + 1 to index1) result = result :+ planets(i)\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppgktatys.scala:34)\n\tat Problem.main(tmppgktatys.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   val min = min(p1, p2)\n        val max = max(p1, p2)\n        return planets.slice(min\
    \ + 1, max)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2iisstn5.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2iisstn5.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return null\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.bf(String, String)\" is null\n\tat Problem$.main(tmpmhbueld8.scala:25)\n\
    \tat Problem.main(tmpmhbueld8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
