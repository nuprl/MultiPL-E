name: HumanEval_11_string_xor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform\
  \ binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"\
  010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String)\
  \ : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
  ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
  0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n   \
  \ }\n\n}\n"
completions: ["        val a_bytes = a.getBytes\n        val b_bytes = b.getBytes\n\
    \        val c_bytes = new Array[Byte](a_bytes.length)\n        for (i <- 0 until\
    \ a_bytes.length) {\n            c_bytes(i) = (a_bytes(i) ^ b_bytes(i)).toByte\n\
    \        }\n        new String(c_bytes)", "        var result = \"\"\n       \
    \ for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result += \"0\"\
    \n            else result += \"1\"\n        }\n        return result", "     \
    \   val aBits = a.map(c => c.toString.toInt)\n        val bBits = b.map(c => c.toString.toInt)\n\
    \        val xorBits = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xorBits.map(b\
    \ => b.toString).reduceLeft(_ + _)", "        val aBits = a.map(x => x.toString.toInt)\n\
    \        val bBits = b.map(x => x.toString.toInt)\n        val result = aBits.zip(bBits).map(x\
    \ => x._1 ^ x._2)\n        result.map(x => x.toString).reduceLeft(_ + _)", " \
    \       val result = new StringBuilder\n        for (i <- 0 until a.length) {\n\
    \            if (a(i) == b(i)) result.append(\"0\")\n            else result.append(\"\
    1\")\n        }\n        result.toString", "        var result = \"\"\n      \
    \  for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result += \"0\"\
    \n            else result += \"1\"\n        }\n        return result", "     \
    \   val aBits = a.toList.map(c => c.toString.toInt)\n        val bBits = b.toList.map(c\
    \ => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p => p._1 ^\
    \ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", "        val\
    \ aBits = a.map(c => c.toString.toInt)\n        val bBits = b.map(c => c.toString.toInt)\n\
    \        val xorBits = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xorBits.mkString",
  "        val aBits = a.toList.map(x => x.toString.toInt)\n        val bBits = b.toList.map(x\
    \ => x.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(x => x._1 ^\
    \ x._2)\n        xorBits.map(x => x.toString).reduceLeft(_ + _)", "        var\
    \ result = \"\"\n        for (i <- 0 until a.length) {\n            if (a(i) ==\
    \ b(i)) result += \"0\"\n            else result += \"1\"\n        }\n       \
    \ return result", "        val aBits = a.map(c => c.toString.toInt)\n        val\
    \ bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", " \
    \       val n = a.length\n        val c = new Array[Char](n)\n        for (i <-\
    \ 0 until n) {\n            if (a(i) == b(i)) c(i) = '0'\n            else c(i)\
    \ = '1'\n        }\n        c.mkString", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", " \
    \       val result = new StringBuilder\n        for (i <- 0 until a.length) {\n\
    \            if (a(i) == b(i)) result.append(\"0\")\n            else result.append(\"\
    1\")\n        }\n        result.toString", "        require(a.length == b.length)\n\
    \        val result = new StringBuilder\n        for (i <- 0 until a.length) {\n\
    \            if (a(i) == b(i)) result.append(\"0\")\n            else result.append(\"\
    1\")\n        }\n        result.toString", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(t\
    \ => t._1 ^ t._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", " \
    \       val aBits = a.toList.map(x => x.toString.toInt)\n        val bBits = b.toList.map(x\
    \ => x.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(x => x._1 ^\
    \ x._2)\n        xorBits.map(x => x.toString).reduceLeft(_ + _)", "        val\
    \ aa = a.toCharArray\n        val bb = b.toCharArray\n        val cc = new Array[Char](aa.length)\n\
    \        for (i <- 0 until aa.length) {\n            if (aa(i) == bb(i)) cc(i)\
    \ = '0'\n            else cc(i) = '1'\n        }\n        return cc.mkString",
  "        val sb = new StringBuilder\n        for (i <- 0 until a.length) {\n   \
    \         if (a(i) == b(i)) sb.append(\"0\")\n            else sb.append(\"1\"\
    )\n        }\n        sb.toString", "        val c = new StringBuilder\n     \
    \   for (i <- 0 until a.length) {\n            if (a(i) == b(i)) c.append(\"0\"\
    )\n            else c.append(\"1\")\n        }\n        c.toString"]
stop_tokens:
- "\n    }\n"
