name: HumanEval_72_will_it_fly
language: r
prompt: "# Write a function that returns TRUE if the object q will fly, and FALSE\
  \ otherwise.\n# The object q will fly if it's balanced (it is a palindromic list)\
  \ and the sum of its elements is less than or equal the maximum possible weight\
  \ w.\n# Example:\n# >>> will_it_fly(c(1, 2), 5)\n# FALSE\n# # 1+2 is less than the\
  \ maximum possible weight, but it's unbalanced.\n# >>> will_it_fly(c(3, 2, 3), 1)\n\
  # FALSE\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
  # >>> will_it_fly(c(3, 2, 3), 9)\n# TRUE\n# # 3+2+3 is less than the maximum possible\
  \ weight, and it's balanced.\n# >>> will_it_fly(c(3), 5)\n# TRUE\n# # 3 is less\
  \ than the maximum possible weight, and it's balanced.\nwill_it_fly <- function(q,\
  \ w) {"
tests: "test_humaneval <- function() {\ncandidate <- will_it_fly\n    if(!identical(candidate(c(3,\
  \ 2, 3), 9), TRUE)){quit('no', 1)}\n    if(!identical(candidate(c(1, 2), 5), FALSE)){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(3), 5), TRUE)){quit('no', 1)}\n    if(!identical(candidate(c(3,\
  \ 2, 3), 1), FALSE)){quit('no', 1)}\n    if(!identical(candidate(c(1, 2, 3), 6),\
  \ FALSE)){quit('no', 1)}\n    if(!identical(candidate(c(5), 5), TRUE)){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  q <- as.list(q)\n  w <- as.integer(w)\n  sum(q) <= w && all(q ==\
    \ rev(q))\n}\n", "\n  w <- as.integer(w)\n  q <- as.list(q)\n  sum(q) <= w &&\
    \ all(q == rev(rev(q)))\n}\n", "\n  if(length(q) == 0) {\n    return(FALSE)\n\
    \  }\n  if(all(q == rev(q))) {\n    return(TRUE)\n  }\n  if(sum(q) <= w) {\n \
    \   return(TRUE)\n  }\n  return(FALSE)\n}\n", "\n  q <- unlist(q)\n  w <- as.integer(w)\n\
    \  sum(q) <= w & is.palindromic(q)\n}\n", "\n  is_balanced <- function(q) {\n\
    \    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    sum(q) == sum(rev(q))\n\
    \  }\n  is_valid <- function(q) {\n    is_balanced(q) && is_palindrome(q)\n  }\n\
    \  is_valid(q)\n}\n</cell>\n<text>\nProblem 4\nWrite a function that returns the\
    \ number of palindromic lists whose elements are less than or equal to a given\
    \ value x.\n\n\n</text>\n<cell>", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  sum(q) <= w && all(diff(q) == 0)\n}\n", "\n  is_balanced <- function(x) {\n\
    \    sum(x) <= w\n  }\n  is_palindrome <- function(x) {\n    x <- x[order(x)]\n\
    \    x <- x[x != x[1]]\n    x <- x[x != x[2]]\n    x <- x[x != x[3]]\n    x <-\
    \ x[x != x[4]]\n    x <- x[x != x[5]]\n    x <- x[x != x[6]]\n    x <- x[x !=\
    \ x[7]]\n    x <- x[x != x[8]]\n    x <- x[x != x[9]]\n    x <- x[x != x[10]]\n\
    \    x <- x[x != x[11]]\n    x <- x[x != x[12]]\n    x <- x[x != x[13]]\n    x\
    \ <- x[x != x[14]]\n    x <- x[x != x[15]]\n    x <- x[x != x[16]]\n    x <- x[x\
    \ != x[17]]\n    x <- x[x != x[18]]\n    x <- x[x != x[19]]\n    x <- x[x != x[20]]\n\
    \    x <- x[x != x[21]]\n    x <- x[x != x[22]]\n    x <- x[x != x[23]]\n    x\
    \ <- x[x != x[24]]\n    x <- x[x != x[25]]\n    x <- x[x != x[26]]\n    x <- x[x\
    \ != x[27]]\n    x <- x[x != x[28]]\n    x <- x[x != x[29]]\n    x <- x[x != x[30]]\n\
    \    x <- x[x != x[31]]\n    x <- x[x != x[32]]\n    x <- x[x != x[33]]\n    x\
    \ <- x[x != x[34]]\n    x <- x[x != x[35]]\n    x <- x[x != x[36]]\n    x <- x[x\
    \ != x[37]]\n    x <- x[x != x[38]]\n    x <- x[x != x[39]]\n    x <- x[x != x[40]]\n\
    \    x <- x[x != x[41]]\n    x <- x[x != x[42]]\n    x <- x[x != x[43]]\n    x\
    \ <- x[x != x[44]]\n    x <- x[x != x[45]]\n    x <- x[x != x[46]]\n    x <- x[x\
    \ != x[47]]\n    x ", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n\
    \  is_palindrome <- function(q) {\n    sum(q) == sum(rev(q))\n  }\n  is_balanced(q)\
    \ && is_palindrome(q)\n}\n</cell>\n<text>\nProblem 3\nWrite a function that takes\
    \ a vector of integers and returns a vector of the same length where each element\
    \ is the sum of the squares of the integers in the original vector. For example,\
    \ if the input vector is [1,2,3,4,5], the output vector should be [1,4,9,16,25].\n\
    \nThe function should work for vectors of any length.\n\n\n</text>\n<cell>", "\n\
    \  is_balanced <- function(q) {\n    sum <- 0\n    for(i in 1:length(q)) {\n \
    \     sum <- sum + q[i]\n    }\n    sum <- sum < w\n    return(sum)\n  }\n  is_palindrome\
    \ <- function(q) {\n    for(i in 1:length(q)) {\n      if(q[i] != q[length(q)-i])\
    \ {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  is_balanced(q)\
    \ & is_palindrome(q)\n}\n</cell>\n<cell>", "\n  w <- as.integer(w)\n  sum(q) <=\
    \ w && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n</cell>\n<text>\nQuestion\
    \ 4\nWrite a function that returns TRUE if the object q will fly, and FALSE otherwise.\n\
    The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\nExample:\n\
    >>> will_it_fly(c(1, 2), 5)\nFALSE", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  sum(q) <= w && is.palindromic(q) && sum(q) == w\n}\n", "\n  q <- as.list(q)\n\
    \  w <- as.integer(w)\n  sum(q) <= w && all(q == rev(q))\n}\n</cell>\n<text>\n\
    Q7. Write a function that returns TRUE if the object q will fly, and FALSE otherwise.\n\
    The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\nExample:\n\
    >>> will_it_fly(c(1, 2), 5)\nFALSE", "\n  if(length(q) == 0 || w < 0)\n    return(FALSE)\n\
    \  if(sum(q) <= w)\n    return(TRUE)\n  return(FALSE)\n}\n", "\n  sum(q) <= w\
    \ && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n", "\n  is_balanced <-\
    \ function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    all(q\
    \ == rev(q))\n  }\n  is_valid <- function(q) {\n    is_balanced(q) && is_palindrome(q)\n\
    \  }\n  is_valid(q)\n}\n", "\n  is_balanced <- function(x) {\n    sum(x) <= w\n\
    \  }\n  is_palindrome <- function(x) {\n    x <- x[order(x)]\n    x <- x[seq(1,\
    \ length(x), 2)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[!is.na", "\n  q <- unlist(q)\n  w <- as.integer(w)\n\
    \  sum(q) <= w & is.palindromic(q) & sum(q) == sum(rev(q))\n}\n", "\n  sum(q)\
    \ <= w & is.palindromic(q) & sum(q) <= w\n}\n", "\n  sum(q) <= w && all(q == rev(q))\n\
    }\n", "\n  if(all(is.numeric(q))) return(TRUE)\n  if(all(is.numeric(w))) return(TRUE)\n\
    \  if(all(is.numeric(q[[1]]))) return(TRUE)\n  if(all(is.numeric(q[[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]]))) return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]]))) return(TRUE)\n\
    \  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]]))) return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric(q[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]])))\
    \ return(TRUE)\n  if(all(is.numeric", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  sum(q) <= w & all(q == rev(q))\n}\n</cell>\n<cell>", "\n  is_balanced <- function(q)\
    \ {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    all(tail(q, -1)\
    \ == head(q,-1))\n  }\n  is_balanced(q) && is_palindrome(q) && sum(q) <= w\n}\n",
  "\n  is_balanced <- function(q) {\n    sum <- 0\n    for(i in 1:length(q)) {\n \
    \     if(q[i] != q[length(q)-i]) {\n        sum <- sum + 1\n      }\n    }\n \
    \   if(sum == length(q)) {\n      return(TRUE)\n    } else {\n      return(FALSE)\n\
    \    }\n  }\n  is_palindrome <- function(q) {\n    for(i in 1:length(q)) {\n \
    \     if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n  \
    \  return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q)) {\n\
    \      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n \
    \   return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] != q[length(q)-i]) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  }\n  is_valid <- function(q) {\n    for(i in 1:length(q))\
    \ {\n      if(q[i] ", "\n  q <- as.list(q)\n  w <- as.integer(w)\n  \n  if(length(q)\
    \ == 0) {\n    return(FALSE)\n  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n\
    \  }\n  \n  if(sum(q) > w) {\n    return(FALSE)\n  }\n  \n  return(TRUE)\n}\n",
  "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    all(q == c(tail(q, 1), head(q, -1)))\n  }\n  is_balanced(q) && is_palindrome(q)\n\
    }\n", "\n  sum(q) <= w & is.palindromic(q) & sum(q) == sum(rev(q))\n}\n", "\n\
    \  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    all(q == c(q[length(q)/2], q[length(q)/2-1L]))\n  }\n  is_balanced(q)\
    \ && is_palindrome(q)\n}\n", "\n  w <- w\n  q <- q\n  \n  if(sum(q) <= w) {\n\
    \    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n", "\n  return(\n  \
    \  sum(q) <= w &&\n    all(q == rev(rev(q))) &&\n    sum(q) == w\n  )\n}\n", "\n\
    \  q <- as.list(q)\n  w <- as.integer(w)\n  sum(q) <= w && all(q == rev(q))\n\
    }\n", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    q == rev(q)\n  }\n  is_valid <- function(q) {\n    is_balanced(q)\
    \ && is_palindrome(q)\n  }\n  is_valid(q)\n}\n</cell>\n<cell>", "\n  sum(q) <=\
    \ w && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n", "\n  sum(q) <= w\
    \ && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n</cell>\n<text>\nQ: What\
    \ is the maximum possible weight of a palindromic list with n elements?\n\n\n\
    </text>\n<cell>", "\n  sum(q) <= w && all(q == rev(rev(q)))\n}\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the first element of a list that satisfies\
    \ a condition. For example,\n\nfirst_satisfying_condition(list(1, 2, 3), condition\
    \ = is_even)\nshould return 2.\n\n\n</text>\n<cell>", "\n  if(sum(q) <= w) {\n\
    \    TRUE\n  } else {\n    FALSE\n  }\n}\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  sum(q) <= w && is.palindromic(q) && sum(q) == w\n}\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that returns TRUE if q will fly, and FALSE otherwise.\n\
    The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\nThe function\
    \ should return TRUE if and only if q is a palindromic list whose elements are\
    \ all less than or equal to w (that is, if w is greater than or equal to the sum\
    \ of the elements).\nExample:\n>>> will_it_fly(c(1, 2), 5)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 1)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 9)\nTRUE\n>>> will_it_fly(c(3),\
    \ 5)\nTRUE\n>>> will_it_fly(c(3, 2), 5)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3),\
    \ 5)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 6)\nTRUE\n>>> will_it_fly(c(3, 2,\
    \ 4, 3), 7)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 8)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 9)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 10)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 11)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 12)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 13)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 14)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 15)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 16)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 17)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 18)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 19)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 20)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 21)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 22)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 23)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 24)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3), 25)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3), 26)\nFALSE\n>>> ", "\n\
    \  q <- as.list(q)\n  w <- as.integer(w)\n  sum(q) <= w && all(q == rev(q))\n\
    }\n", "\n  if(is.list(q) && is.numeric(w)) {\n    sum(q) <= w && is.palindromic(q)\
    \ && sum(q) <= w\n  }\n}\n</cell>\n<cell>", "\n  w <- as.integer(w)\n  sum(q)\
    \ <= w && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n", "\n  return(\n\
    \    sum(q) <= w &&\n    all(q == rev(rev(q))) &&\n    sum(q) == w\n  )\n}\n</cell>\n\
    <cell>", "\n  q <- as.list(q)\n  w <- as.integer(w)\n  \n  if(length(q) == 0 |\
    \ w == 0) return(FALSE)\n  \n  if(sum(q) == w) return(TRUE)\n  \n  if(sum(q) <\
    \ w) return(FALSE)\n  \n  return(TRUE)\n}\n", "\n  return(\n    sum(q) <= w &&\n\
    \    all(q == rev(rev(q))) &&\n    sum(q) <= w\n  )\n}\n", "\n  q <- as.list(q)\n\
    \  w <- as.integer(w)\n  sum(q) <= w && all(q == rev(q))\n}\n</cell>\n<cell>",
  "\n  if(length(q) < 2) return(FALSE)\n  if(sum(q) <= w) return(TRUE)\n  return(FALSE)\n\
    }\n", "\n  if(all(is.numeric(q)) && sum(q) <= w) {\n    sum(q) == w\n  } else\
    \ {\n    FALSE\n  }\n}\n</cell>\n<cell>", "\n  sum(q) <= w && is.list(q) && is.palindromic(q)\
    \ && sum(q) <= w\n}\n</cell>\n<cell>", "\n  if(length(q) == 0) {\n    return(FALSE)\n\
    \  }\n  if(sum(q) <= w) {\n    return(TRUE)\n  }\n  return(FALSE)\n}\n</cell>\n\
    <cell>", "\n  if(is.list(q) && is.numeric(w)) {\n    sum(q) <= w && is.palindromic(q)\
    \ && sum(q) <= w\n  } else {\n    stop(\"'q' must be a list and 'w' must be a\
    \ number.\")\n  }\n}\n", "\n  is_balanced <- function(q) {\n    sum <- 0\n   \
    \ for(i in 1:length(q)) {\n      if(q[i] > 0) sum <- sum + q[i]\n    }\n    sum\
    \ <- sum < w\n    return(sum)\n  }\n  is_palindrome <- function(q) {\n    for(i\
    \ in 1:length(q)) {\n      if(q[i] != q[length(q)-i]) return(FALSE)\n    }\n \
    \   return(TRUE)\n  }\n  is_valid <- function(q) {\n    if(!is_balanced(q)) return(FALSE)\n\
    \    if(!is_palindrome(q)) return(FALSE)\n    return(TRUE)\n  }\n  if(is_valid(q))\
    \ return(TRUE)\n  return(FALSE)\n}\n", "\n  w <- as.integer(w)\n  q <- as.list(q)\n\
    \  sum(q) <= w && is.palindromic(q) && sum(q) == sum(rev(q))\n}\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns a list with the first n prime numbers.\
    \ You can use the Sieve of Eratosthenes or the Sieve of Atkin.\n\n\n</text>\n\
    <cell>", "\n  return(\n    sum(q) <= w &&\n    all(abs(diff(q)) <= w)\n  )\n}\n",
  "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    paste0(q, collapse=\"\") == paste0(rev(q), collapse=\"\")\n  }\n  is_balanced(q)\
    \ && is_palindrome(q) && sum(q) <= w\n}\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that takes a list of numbers and returns the sum of the numbers in the list.\
    \ \nIf the list is empty return 0.\nIf the list has one number in it return that\
    \ number.\nIf the list has two or more numbers in it return the first number in\
    \ the list followed by the sum of the other numbers in the list.\nExample:\n>>>\
    \ sum_of_list(list(1,2,3))\n6\n>>> sum_of_list(list(1,2))\n3\n>>> sum_of_list(list())\n\
    0\n>>> sum_of_list(list(1,2,3,4,5))\n6\n>>> sum_of_list(list(1,2,3,4,5,6,7,8,9,10))\n\
    15\n>>> sum_of_list(list(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))\n15\n>>> sum_of_list(list(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100))\n\
    15\n>>> sum_of_list(list(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,9",
  "\n  return(sum(q) <= w && is.palindromic(q) && sum(q) == w)\n}\n", "\n  if(length(q)\
    \ == 0 | w == 0) return(FALSE)\n  if(sum(q) <= w) return(TRUE)\n  return(FALSE)\n\
    }\n", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    all(tail(q, -1) == head(q,-1))\n  }\n  is_valid <- function(q)\
    \ {\n    is_balanced(q) && is_palindrome(q)\n  }\n  is_valid(q)\n}\n", "\n  q\
    \ <- as.list(q)\n  w <- as.integer(w)\n  \n  if(length(q) == 0) {\n    return(FALSE)\n\
    \  }\n  \n  if(length(q) == 1) {\n    return(TRUE)\n  }\n  \n  if(all(tail(q,\
    \ 1) == head(q, -1))) {\n    return(TRUE)\n  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n\
    \  }\n  \n  return(FALSE)\n}\n", "\n  is_balanced <- function(x) {\n    sum(tail(x,\
    \ -1)) == sum(x[-length(x)])\n  }\n  is_palindrome <- function(x) {\n    x <-\
    \ x[!is.na(x)]\n    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <- x[order(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <- x[order(x)]\n    x <-\
    \ x[-length(x)]\n    x <- x[!is.na(x)]\n    x <- x[order(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <- x[order(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <- x[order(x)]\n    x <-\
    \ x[-length(x)]\n    x <- x[!is.na(x)]\n    x <- x[order(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[!is.na(x)]\n    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <-\
    \ x[!is.na(x)]\n    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n\
    \    x <- x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <-\
    \ x[order(x)]\n    x <- x[-length(x)]\n    x <- x[!is.na(x)]\n    x <- x[order(x)]\n\
    \    ", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    all(tail(q, -1) == head(q, -1))\n  }\n  is_balanced(q)\
    \ && is_palindrome(q)\n}\n", "\n  if(is.list(q) && is.numeric(w) && sum(q) <=\
    \ w) {\n    for(i in seq_along(q)) {\n      if(q[[i]] <= w) return(FALSE)\n  \
    \  }\n    return(TRUE)\n  }\n  return(FALSE)\n}\n", "\n  return(sum(q) <= w &&\
    \ is_balanced(q))\n}\n", "\n  sum(q) <= w & is_balanced(q)\n}\n", "\n  is_balanced\
    \ <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n \
    \   all(q == rev(q))\n  }\n  is_valid <- function(q) {\n    is_balanced(q) &&\
    \ is_palindrome(q)\n  }\n  is_valid(q)\n}\n", "\n  is_balanced <- function(q)\
    \ {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    sum(q) == sum(rev(q))\n\
    \  }\n  is_balanced(q) && is_palindrome(q)\n}\n", "\n  q <- as.list(q)\n  w <-\
    \ as.integer(w)\n  sum(q) <= w && all(q == rev(q))\n}\n", "\n  if(length(q) ==\
    \ 0 | length(q) == 1) {\n    return(FALSE)\n  }\n  if(sum(q) <= w) {\n    return(TRUE)\n\
    \  }\n  return(FALSE)\n}\n", "\n  if(is.list(q) && is.numeric(w) && w <= sum(q)\
    \ && sum(q) <= w)\n    sum(q) <= w\n  else\n    TRUE\n}\n", "\n  is_balanced <-\
    \ function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    all(q\
    \ == c(q[[1]], q[[2]]))\n  }\n  is_balanced(q) && is_palindrome(q)\n}\n", "\n\
    \  is_balanced <- function(x) {\n    sum(x) <= w\n  }\n  is_palindrome <- function(x)\
    \ {\n    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    x <- rev(x)\n    x <- x[order(x)]\n    x <- rev(x)\n\
    \    x <- x[order(x)]\n    ", "\n  q <- as.list(q)\n  w <- as.integer(w)\n  \n\
    \  if(length(q) == 0 | w == 0) {\n    return(FALSE)\n  }\n  \n  if(length(q) ==\
    \ 1) {\n    return(TRUE)\n  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n  }\n\
    \  \n  return(FALSE)\n}\n", "\n  return(\n    sum(q) <= w &&\n    all(q == rev(rev(q)))\
    \ &&\n    sum(q) == w\n  )\n}\n", "\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w)))\
    \ return(FALSE)\n  if(all(is.na(sum(q)))) return(FALSE)\n  if(all(is.na(sum(w))))\
    \ return(FALSE)\n  if(all(is.na(sum(q) + sum(w)))) return(FALSE)\n  if(all(is.na(sum(q)\
    \ - sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) * sum(w)))) return(FALSE)\n\
    \  if(all(is.na(sum(q) / sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) %% sum(w))))\
    \ return(FALSE)\n  if(all(is.na(sum(q) ^ sum(w)))) return(FALSE)\n  if(all(is.na(sum(q)\
    \ %% sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) ^ sum(w)))) return(FALSE)\n\
    \  if(all(is.na(sum(q) %% sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) ^ sum(w))))\
    \ return(FALSE)\n  if(all(is.na(sum(q) %% sum(w)))) return(FALSE)\n  if(all(is.na(sum(q)\
    \ ^ sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) %% sum(w)))) return(FALSE)\n\
    \  if(all(is.na(sum(q) ^ sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) %% sum(w))))\
    \ return(FALSE)\n  if(all(is.na(sum(q) ^ sum(w)))) return(FALSE)\n  if(all(is.na(sum(q)\
    \ %% sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) ^ sum(w)))) return(FALSE)\n\
    \  if(all(is.na(sum(q) %% sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) ^ sum(w))))\
    \ return(FALSE)\n  if(all(is.na(sum(q) %% sum(w)))) return(FALSE)\n  if(all(is.na(sum(q)\
    \ ^ sum(w)))) return(FALSE)\n  if(all(is.na(sum(q) %% sum(w)))) return(FALSE)\n\
    \  if(all(is.na(sum(q) ^ sum(w)))) return(FALSE)\n  if(all(", "\n  sum(q) <= w\
    \ && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n", "\n  sum(q) <= w &&\
    \ is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a list of numbers and returns the sum of the\
    \ numbers in the list that add up to a number divisible by three.\n\n\n</text>\n\
    <cell>", "\n  return(\n    sum(q) <= w &&\n    is.palindromic(q) &&\n    sum(q)\
    \ == sum(rev(q))\n  )\n}\n</cell>\n<text>\nProblem 3\nWrite a function that returns\
    \ TRUE if q will fly, and FALSE otherwise.\nThe object q will fly if and only\
    \ if it's balanced (it is a palindromic list) and the sum of its elements is less\
    \ than or equal the maximum possible weight w.\nThe function should return TRUE\
    \ if and only if q will fly, and FALSE otherwise.\nExample:\n>>> will_it_fly(c(1,\
    \ 2), 5)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 1)\nTRUE\n>>> will_it_fly(c(3, 2,\
    \ 3), 9)\nTRUE\n>>> will_it_fly(c(3), 5)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 10)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 11)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 12)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 13)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 14)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 15)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 16)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 17)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 18)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 19)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 20)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 21)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 22)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 23)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 24)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 25)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 26)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 27)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 28)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 29)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 30)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 31)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 32)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 33)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 34)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 35)\n", "\n  q <- as.list(q)\n  w <- as.numeric(w)\n\
    \  sum(q) <= w & all(q == rev(q))\n}\n</code>\n<|/ a tags=r,list,palindrome,function\
    \ |>\n<| c |>\nThanks so much! This was really helpful!\n<|/ c |>\n<| a tags=r,list,palindrome,function\
    \ |>\n<code>\npalindrome <- function(x) {\n  x <- as.character(x)\n  x <- x[x\
    \ != \"\"]\n  x <- x[x != \" \"]\n  x <- x[x != \".\"]\n  x <- x[x != \",\"]\n\
    \  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x\
    \ != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n\
    \  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x\
    \ != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n\
    \  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x\
    \ != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n\
    \  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x\
    \ != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n\
    \  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x\
    \ != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n\
    \  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x\
    \ != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[x != \"]\"]\n  x <- x[", "\n  q <-\
    \ as.list(q)\n  w <- as.integer(w)\n  sum(q) <= w && all(palindromic(q) && sum(q)\
    \ <= w)\n}\n", "\n  if(sum(q) <= w) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n\
    \  }\n}\n", "\n  is_balanced <- function(x) {\n    sum(tail(x, -1)) == 0 & sum(head(x,\
    \ -1)) == 0\n  }\n  is_palindrome <- function(x) {\n    x <- sort(x)\n    tail(x,\
    \ -1) == head(x, -1)\n  }\n  is_balanced(q) & is_palindrome(q) & w <= sum(q)\n\
    }\n", "\n  is_balanced <- function(q) {\n    sum <- 0\n    for (i in 1:length(q))\
    \ {\n      sum <- sum + q[i]\n    }\n    if (sum == 0) return FALSE\n    else\
    \ return TRUE\n  }\n  is_palindrome <- function(q) {\n    i <- 1\n    while(i\
    \ <= length(q)) {\n      if (q[i] != q[length(q) - i - 1]) {\n        return FALSE\n\
    \      }\n      i <- i + 1\n    }\n    return TRUE\n  }\n  is_balanced(q) && is_palindrome(q)\
    \ && sum(q) <= w\n}\n", "\n  if(is.list(q) && sum(q) <= w) {\n    for(i in 1:length(q))\
    \ {\n      if(q[[i]] != rev(q[[i]])) {\n        return(FALSE)\n      }\n    }\n\
    \    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n", "\n  if(length(q)\
    \ == 0 || w == 0) return(FALSE)\n  if(sum(q) <= w) return(TRUE)\n  return(FALSE)\n\
    }\n", "\n  return(\n    sum(q) <= w &&\n    all(q == rev(rev(q))) &\n    all(q\
    \ == rev(rev(q))[[1]])\n  )\n}\n", "\n  if(sum(q) <= w) {\n    return(TRUE)\n\
    \  } else {\n    return(FALSE)\n  }\n}\n", "\n  is_balanced <- function(q) {\n\
    \    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    all(q == c(q[[1]],\
    \ q[length(q)])) # reverse the list\n  }\n  is_valid <- function(q) {\n    is_balanced(q)\
    \ & is_palindrome(q)\n  }\n  is_valid(q)\n}\n</cell>\n<cell>", "\n  is_balanced\
    \ <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n \
    \   all(q == rev(q))\n  }\n  is_valid <- function(q) {\n    is_balanced(q) &&\
    \ is_palindrome(q)\n  }\n  is_valid(q)\n}\n</cell>\n<cell>", "\n  q <- unlist(q)\n\
    \  w <- as.integer(w)\n  sum(q) <= w && is.palindromic(q) && sum(q) == w\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThank you for taking the time to write this\
    \ up. I'm going to try it out and see if it works. I appreciate it!\n<|/ c |>\n\
    <| c |>\nI ran your code, and it works great! I really appreciate your help. Thank\
    \ you!\n<|/ c |>\n<| c |>\nGlad it helped! If this answer solved your problem,\
    \ please consider marking it as accepted by clicking the check mark next to it.\n\
    <|/ c |>\n<| a tags=r,palindrome,list |>\nI wrote a function that checks if a\
    \ list is palindrome or not and also checks if it has a maximum weight or not.\n\
    <code>\nis_palindrome <- function(list) {\n  \n  if(length(list) == 1) {\n   \
    \ return(TRUE)\n  }\n  \n  if(length(list) == 2) {\n    return(list[1] == list[length(list)])\
    \ \n  }\n  \n  if(length(list) == 3) {\n    return(list[1] == list[2] && list[2]\
    \ == list[3])\n  }\n  \n  if(length(list) == 4) {\n    return(list[1] == list[2]\
    \ && list[2] == list[3] && list[3] == list[4])\n  }\n  \n  if(length(list) ==\
    \ 5) {\n    return(list[1] == list[2] && list[2] == list[3] && list[3] == list[4]\
    \ && list[4] == list[5])\n  }\n  \n  if(length(list) == 6) {\n    return(list[1]\
    \ == list[2] && list[2] == list[3] && list[3] == list[4] && list[4] == list[5]\
    \ && list[5] == list[6])\n  }\n  \n  if(length(list) == 7) {\n    return(list[1]\
    \ == list[2] && list[2] == list[3] && list[3] == list[4] && list[4] == list[5]\
    \ && list[5] == list[6] && list[6] == list[7])\n  }\n  \n  if(length(list) ==\
    \ 8) {\n    return(list[1] == list[2] && list[2] == list[3] && list[3] == list[4]\
    \ && list[4] == list[5] && list[5] == list[6] && list[6] == list[7] && list[7]\
    \ == list[8])\n  }\n  \n  if(length(list) == 9) {\n    return(list[1] == list[2]\
    \ && list[2] == list[3] && list[3] == list[4] && list[4] == list[5", "\n  q <-\
    \ as.list(q)\n  w <- as.integer(w)\n  \n  if(length(q) == 1) {\n    return(TRUE)\n\
    \  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n  }\n  \n  if(sum(q) == w) {\n\
    \    return(TRUE)\n  }\n  \n  return(FALSE)\n}\n", "\n  is_balanced <- function(q)\
    \ {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    paste0(q, collapse\
    \ = \"\")[length(paste0(q, collapse = \"\")) - 1] == paste0(q, collapse = \"\"\
    )[1]\n  }\n  is_balanced(q) && is_palindrome(q) && sum(q) <= w\n}\n", "\n  is_balanced\
    \ <- function(q) {\n    sum <- 0\n    for(i in 1:length(q)) {\n      sum <- sum\
    \ + q[i]\n    }\n    sum <- sum < w\n    return(sum)\n  }\n  is_palindrome <-\
    \ function(q) {\n    for(i in 1:length(q)) {\n      if(q[i] != q[length(q)-i])\
    \ {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  is_valid\
    \ <- function(q) {\n    is_balanced(q)\n    is_palindrome(q)\n  }\n  if(is_valid(q))\
    \ {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n", "\n  if(is.list(q)\
    \ && is.numeric(w) && sum(q) <= w) {\n    for(i in seq_along(q)) {\n      if(q[[i]]\
    \ <= w) return(FALSE)\n    }\n    return(TRUE)\n  }\n  return(FALSE)\n}\n", "\n\
    \  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    q == c(rev(q), rev(q))\n  }\n  is_balanced(q) && is_palindrome(q)\n}\n\
    </cell>\n<text>\nThe function is_balanced checks if the sum of its elements is\
    \ less than or equal the maximum possible weight w. is_palindrome checks if the\
    \ object q is a palindromic list. Both functions return TRUE or FALSE.\n\n\n</text>\n\
    <cell>", "\n  if(length(q) == 0 | w == 0) return(FALSE)\n  if(w < sum(q)) return(FALSE)\n\
    \  if(w == sum(q)) return(TRUE)\n  if(w == sum(q) - 1) return(TRUE)\n  return(FALSE)\n\
    }\n", "\n  w <- as.integer(w)\n  q <- as.list(q)\n  q <- lapply(q, as.integer)\n\
    \  sum(q) <= w && all(palindromic(q))\n}\n", "\n  is_balanced <- function(q) {\n\
    \    sum <- 0\n    for(i in 1:length(q)) {\n      sum <- sum + q[i]\n    }\n \
    \   sum <- sum > w\n    return(sum)\n  }\n  is_palindrome <- function(q) {\n \
    \   for(i in 1:length(q)) {\n      if(q[i] != q[length(q) - i - 1]) {\n      \
    \  return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  is_balanced(q) & is_palindrome(q)\
    \ & sum(q) <= w\n}\n</cell>\n<text>\nProblem 3\nWrite a function that takes a\
    \ vector of integers and returns a vector where each element is the product of\
    \ all the numbers in the original vector, except the number itself.\n\nExample:\n\
    >>> my_vector(c(1, 2, 3))", "\n  q <- as.list(q)\n  w <- as.integer(w)\n  sum(q)\
    \ <= w && all(rev(q) == rev(q))\n}\n</cell>\n<cell>", "\n  return(sum(q) <= w\
    \ && is.palindromic(q) && sum(q) == w)\n}\n</cell>\n<text>\nProblem 3\nWrite a\
    \ function that returns TRUE if q has exactly one palindromic sublist, and FALSE\
    \ otherwise.\nThe sublist must be the longest palindromic sublist in the list\
    \ q.\nExample:\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nTRUE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n\
    >>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n\
    >>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n\
    >>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n\
    >>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n\
    >>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n\
    >>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n\
    >>> palindromic_sublist(c(1, 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1,\
    \ 2), c(3, 2, 3))\nFALSE\n>>> palindromic_sublist(c(1, 2), ", "\n  w <- as.integer(w)\n\
    \  q <- as.list(q)\n  sum(q) <= w && all(q == rev(q))\n}\n", "\n  if(is.list(q)\
    \ && sum(q) <= w) {\n    sum(q) == w\n  } else {\n    FALSE\n  }\n}\n", "\n  if(is.list(q)\
    \ && sum(q) <= w) {\n    for(i in seq_along(q)) {\n      if(q[[i]] > w) q[[i]]\
    \ <- w\n    }\n    sum(q) <= w\n  } else {\n    FALSE\n  }\n}\n", "\n  w <- as.integer(w)\n\
    \  sum(q) <= w && all(q == rev(rev(q)))\n}\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that returns TRUE if the object q will fly, and FALSE otherwise.\n\
    The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\nExample:\n\
    >>> will_it_fly(c(1, 2), 5)\nFALSE", "\n  is_balanced <- function(q) {\n    sum(q)\
    \ <= w\n  }\n  is_palindrome <- function(q) {\n    all(q == c(tail(q, 1), head(q,\
    \ -1)))\n  }\n  is_balanced(q) && is_palindrome(q)\n}\n", "\n  sum(q) <= w &&\
    \ all(q == rev(rev(q)))\n}\n", "\n  is_balanced <- function(q) {\n    sum(q) <=\
    \ w\n  }\n  is_palindrome <- function(q) {\n    all(tail(q, -1) == head(q, -1))\n\
    \  }\n  is_valid <- function(q) {\n    is_balanced(q) && is_palindrome(q)\n  }\n\
    \  is_valid(q)\n}\n</cell>\n<cell>", "\n  q <- as.list(q)\n  sum(q) <= w & is_balanced(q)\n\
    }\n</cell>\n<text>\nProblem 3\nWrite a function that returns TRUE if the object\
    \ q will fly, and FALSE otherwise.\nThe object q will fly if it's balanced (it\
    \ is a palindromic list) and the sum of its elements is less than or equal the\
    \ maximum possible weight w.\nExample:\n>>> will_it_fly(c(1, 2), 5)\nFALSE", "\n\
    \  if(length(q) == 0 || (length(unique(q)) == 1 && !is.numeric(q))) {\n    return(FALSE)\n\
    \  }\n  if(is.numeric(q)) {\n    sum(q) <= w\n  } else {\n    sum(q[[1]]) <= w\
    \ && sum(q[[2]]) <= w\n  }\n}\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  sum(q) <= w && all(palindrome(q))\n}\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns TRUE if q will fly, and FALSE otherwise.\nThe object q will fly\
    \ if it's balanced (it is a palindromic list) and the sum of its elements is less\
    \ than or equal the maximum possible weight w.\nThe function should work for any\
    \ type of list, not just numeric lists.\nExample:\n>>> will_it_fly(c(1, 2), 5)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 1)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 9)\n\
    TRUE\n>>> will_it_fly(c(3), 5)\nTRUE\n>>> will_it_fly(c(1, 2), 0)\nFALSE\n>>>\
    \ will_it_fly(c(1, 2), -5)\nFALSE\n>>> will_it_fly(c(1, 2), -10)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), -100)\nFALSE\n>>> will_it_fly(c(1, 2), -1000)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), -10000)\nFALSE\n>>> will_it_fly(c(1, 2), -100000)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), -1000000)\nFALSE\n>>> will_it_fly(c(1, 2), -10000000)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), -100000000)\nFALSE\n>>> will_it_fly(c(1, 2), -1000000000)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), -10000000000)\nFALSE\n>>> will_it_fly(c(1, 2), -100000000000)\nFALSE\n>>>\
    \ will_it_fly(c(1, 2), -1000000000000)\nFALSE\n>>> will_it_fly(c(1, 2), -1000000000001)\n\
    FALSE\n>>> will_it_fly(c(1, 2), -1000000000002)\nFALSE\n>>> will_it_fly(c(1, 2),\
    \ -1000000000003)\nFALSE\n>>> will_it_fly(c(1, 2), -1000000000004)\nFALSE\n>>>\
    \ will_it_fly(c(1, 2), -1000000000005)\nFALSE\n>>> will_it_fly(c(1, 2), -1000000000006)\n\
    FALSE\n>>> will_it_fly(c(1, 2), -1000000000007)\nFALSE\n>>> will_it_fly(c(1, 2),\
    \ -1000000000008)\nFALSE\n>>> will_it_fly(c(1, 2), -1000000000009)\nFALSE\n>>>\
    \ will_it_fly(c", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    all(tail(q, -1) == head(q,-1))\n  }\n  is_valid <- function(q)\
    \ {\n    is_balanced(q) && is_palindrome(q)\n  }\n  is_valid(q)\n}\n</cell>\n\
    <text>\nProblem 4\nWrite a function that returns the number of palindromic lists\
    \ whose elements sum to at most a given value.\n\n\n</text>\n<cell>", "\n  q <-\
    \ unlist(q)\n  w <- as.integer(w)\n  sum(q) <= w && all(q == rev(q))\n}\n", "\n\
    \  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    all(q == c(tail(q, 1), head(q, -1)))\n  }\n  is_valid <- function(q)\
    \ {\n    is_balanced(q) && is_palindrome(q)\n  }\n  is_valid(q)\n}\n</cell>\n\
    <text>\nQuestion 3\nWrite a function that returns TRUE if q will fly, and FALSE\
    \ if q will not.\nThe object q will fly if and only if it's balanced (it is a\
    \ palindromic list) and the sum of its elements is less than or equal the maximum\
    \ possible weight w.\nThe function should work for any type of object q (not only\
    \ lists).\nExample:\n>>> will_it_fly(c(1, 2), 5)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 1)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 9)\nTRUE\n>>> will_it_fly(c(3),\
    \ 5)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 10)\nFALSE\n>>> will_it_fly(c(3, 2, 3),\
    \ 11)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 12)\nFALSE\n>>> will_it_fly(c(3, 2,\
    \ 3), 13)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 14)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 15)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 16)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 17)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 18)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 19)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 20)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 21)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 22)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 23)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 24)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 25)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 26)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 27)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 28)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 29)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 30)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 31)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 32)\nFALSE\n>>> ", "\n  return(\n\
    \    sum(q) <= w &&\n    all(q == rev(rev(q))) &\n    all(q == rev(rev(q))) &\n\
    \    all(q == rev(rev(q)))\n  )\n}\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  \n  if(length(q) == 0) {\n    return(FALSE)\n  }\n  \n  if(length(q) == 1)\
    \ {\n    return(TRUE)\n  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n  }\n \
    \ \n  if(sum(q) >= w) {\n    return(FALSE)\n  }\n  \n  if(sum(q) == w) {\n   \
    \ return(TRUE)\n  }\n  \n  if(sum(q) == 0) {\n    return(FALSE)\n  }\n  \n  return(FALSE)\n\
    }\n", "\n  return(sum(q) <= w && is_balanced(q))\n}\n", "\n  w <- as.integer(w)\n\
    \  q <- as.list(q)\n  q <- lapply(q, as.integer)\n  sum(q) <= w & is.palindromic(q)\
    \ & sum(q) <= w\n}\n</cell>\n<text>\nProblem 3\nWrite a function that takes as\
    \ input a vector of integers and an integer k, and returns a vector of the same\
    \ length with all elements equal to k. \nThe function should return the same vector\
    \ if k is less than or equal to the length of the input vector. \nThe function\
    \ should return NULL if the input vector is NULL.\nThe function should return\
    \ NULL if the input vector is NULL.\nThe function should return NULL if the input\
    \ vector is NULL.\nThe function should return NULL if the input vector is NULL.\n\
    The function should return NULL if the input vector is NULL.\nThe function should\
    \ return NULL if the input vector is NULL.\nThe function should return NULL if\
    \ the input vector is NULL.\nThe function should return NULL if the input vector\
    \ is NULL.\nThe function should return NULL if the input vector is NULL.\nThe\
    \ function should return NULL if the input vector is NULL.\nThe function should\
    \ return NULL if the input vector is NULL.\nThe function should return NULL if\
    \ the input vector is NULL.\nThe function should return NULL if the input vector\
    \ is NULL.\nThe function should return NULL if the input vector is NULL.\nThe\
    \ function should return NULL if the input vector is NULL.\nThe function should\
    \ return NULL if the input vector is NULL.\nThe function should return NULL if\
    \ the input vector is NULL.\nThe function should return NULL if the input vector\
    \ is NULL.\nThe function should return NULL if the input vector is NULL.\nThe\
    \ function should return NULL if the input vector is NULL.\nThe function should\
    \ return NULL if the input vector is NULL.\nThe function should return NULL if\
    \ the input vector is NULL.\nThe function should return NULL if the input vector\
    \ is NULL.\nThe function should return NULL if the input vector is NULL.\nThe\
    \ function should return NULL if the input vector is NULL.\nThe function should\
    \ return NULL if the input vector is NULL.\nThe function should return NULL if\
    \ the input vector is NULL.\nThe function should return NULL if the input vector\
    \ is NULL.\nThe function should return NULL if the input vector is NULL.\nThe\
    \ function should return NULL if the input vector is NULL.\nThe function should\
    \ return NULL if the input vector is NULL.\nThe function should return NULL if\
    \ the input vector is NULL.\nThe function should return NULL if the input vector\
    \ is NULL.\nThe function should return NULL if the input vector is NULL.\nThe\
    \ function should return NULL ", "\n  w <- as.integer(w)\n  q <- as.list(q)\n\
    \  q <- lapply(q, as.integer)\n  sum(q) <= w && all(rev(q) == q)\n}\n", "\n  w\
    \ <- as.integer(w)\n  q <- as.list(q)\n  sum(q) <= w & all(q == rev(q))\n}\n</cell>\n\
    <cell>", "\n  q <- as.list(q)\n  w <- as.integer(w)\n  q <- lapply(q, as.integer)\n\
    \  q <- unlist(q)\n  q <- sort(q)\n  q <- q[length(q):1]\n  sum(q) <= w\n}\n",
  "\n  return(\n    sum(q) <= w &&\n    all(q == rev(q)) &&\n    all(q == c(q[1],\
    \ q[length(q)]))\n  )\n}\n", "\n  sum(q) <= w && is.list(q) && is.palindromic(q)\
    \ && sum(q) <= w\n}\n", "\n  w <- as.integer(w)\n  q <- as.list(q)\n  sum(q) <=\
    \ w && is.palindromic(q) && sum(q) == sum(rev(q))\n}\n", "\n  is_balanced <- function(x)\
    \ {\n    sum(x) <= w\n  }\n  is_palindrome <- function(x) {\n    x <- x[order(x)]\n\
    \    paste0(x[1:(length(x)-1)], x[(length(x)+1):length(x)])\n  }\n  is_balanced(q)\
    \ && is_palindrome(q) && sum(q) <= w\n}\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  \n  if(length(q) == 0 | is.null(q) | is.na(q) | is.logical(q) | is.character(q)\
    \ | is.factor(q) | is.numeric(q) | is.integer(q) | is.complex(q) | is.logical(w)\
    \ | is.character(w) | is.factor(w) | is.numeric(w) | is.integer(w) | is.complex(w)\
    \ | is.logical(1)) {\n    return(FALSE)\n  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n\
    \  }\n  \n  return(FALSE)\n}\n", "\n  is_balanced <- function(q) {\n    sum <-\
    \ 0\n    for (i in 1:length(q)) {\n      sum <- sum + q[i]\n    }\n    return\
    \ (sum == 0)\n  }\n  is_palindrome <- function(q) {\n    sum <- 0\n    for (i\
    \ in 1:length(q)) {\n      sum <- sum + q[i]\n    }\n    return (sum == 0)\n \
    \ }\n  is_valid <- function(q) {\n    sum <- 0\n    for (i in 1:length(q)) {\n\
    \      sum <- sum + q[i]\n    }\n    return (sum < w)\n  }\n  is_valid <- function(q)\
    \ {\n    sum <- 0\n    for (i in 1:length(q)) {\n      sum <- sum + q[i]\n   \
    \ }\n    return (sum < w)\n  }\n  is_valid <- function(q) {\n    sum <- 0\n  \
    \  for (i in 1:length(q)) {\n      sum <- sum + q[i]\n    }\n    return (sum <\
    \ w)\n  }\n  is_valid <- function(q) {\n    sum <- 0\n    for (i in 1:length(q))\
    \ {\n      sum <- sum + q[i]\n    }\n    return (sum < w)\n  }\n  is_valid <-\
    \ function(q) {\n    sum <- 0\n    for (i in 1:length(q)) {\n      sum <- sum\
    \ + q[i]\n    }\n    return (sum < w)\n  }\n  is_valid <- function(q) {\n    sum\
    \ <- 0\n    for (i in 1:length(q)) {\n      sum <- sum + q[i]\n    }\n    return\
    \ (sum < w)\n  }\n  is_valid <- function(q) {\n    sum <- 0\n    for (i in 1:length(q))\
    \ {\n      sum <- sum + q[i]\n    }\n    return (sum < w)\n  }\n  is_valid <-\
    \ function(q) {\n    sum <- 0\n    for (i in 1:length(q)) {\n      sum <- sum\
    \ + q[i]\n    }\n    return (sum < w)\n  }\n  is_valid <- function(q) {\n    sum\
    \ <- 0\n    for (i in 1:length(q)) {\n      sum <- sum + q[i]\n    }\n    return\
    \ (sum < w)\n  }\n  is_valid <- function(q) {\n    sum <- 0\n    for (i in 1:length(q))\
    \ {\n      sum <- sum + q[i]\n    }\n    return (sum < w)\n  }\n  is_valid <-\
    \ function(q) {\n    sum <- 0\n    for (i in 1:length(q)) {\n      sum <- sum",
  "\n  q <- as.list(q)\n  w <- as.numeric(w)\n  \n  if(length(q) == 0) {\n    return(FALSE)\n\
    \  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n  }\n  \n  return(FALSE)\n}\n",
  "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    all(q == c(q[[1]], q[[2]]))\n  }\n  is_valid <- function(q) {\n    is_balanced(q)\
    \ && is_palindrome(q)\n  }\n  is_valid(q)\n}\n", "\n  if(is.list(q) && is.numeric(w)\
    \ && sum(q) <= w) {\n    for(i in seq_along(q)) {\n      if(q[i] != rev(q[i]))\
    \ {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  return(FALSE)\n\
    }\n</cell>\n<text>\nProblem 3\nWrite a function that returns a list of all the\
    \ palindromic lists whose elements are less than or equal to a given number k.\n\
    \n\n</text>\n<cell>", "\n  w <- w\n  q <- q\n  \n  if(all(is.na(q))) return(FALSE)\n\
    \  if(all(is.na(w))) return(FALSE)\n  \n  if(all(is.na(sort(q))) || all(is.na(sort(w)))\
    \ || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) ||\
    \ all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w)))\
    \ || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) ||\
    \ all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w)))\
    \ || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) ||\
    \ all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w)))\
    \ || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) ||\
    \ all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w)))\
    \ || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) ||\
    \ all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w)))\
    \ || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) ||\
    \ all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w)))\
    \ || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) || all(is.na(sort(q+w))) ||\
    \ all(is.", "\n  if(is.list(q) && sum(q) <= w) {\n    sum(q) == w\n  } else {\n\
    \    FALSE\n  }\n}\n", "\n  w <- as.integer(w)\n  q <- as.list(q)\n  q <- lapply(q,\
    \ function(x) as.integer(x))\n  q <- lapply(q, function(x) ifelse(x <= w, TRUE,\
    \ FALSE))\n  sum(q) == w\n}\n", "\n  is_balanced <- function(q) {\n    n <- length(q)\n\
    \    i <- 1\n    while (i <= n) {\n      if (q[i] != q[n - i - 1]) return(FALSE)\n\
    \      i <- i + 1\n    }\n    return(TRUE)\n  }\n  is_palindrome <- function(q)\
    \ {\n    n <- length(q)\n    i <- 1\n    while (i <= n) {\n      if (q[i] != q[n\
    \ - i - 1]) return(FALSE)\n      i <- i + 1\n    }\n    return(TRUE)\n  }\n  is_balanced(q)\n\
    \  is_palindrome(q)\n  sum(q) <= w\n}\n</cell>\n<cell>", "\n  if(all(is.numeric(q))\
    \ && sum(q) <= w) {\n    all(q == rev(q))\n  } else {\n    FALSE\n  }\n}\n", "\n\
    \  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    all(tail(q, -1) == head(q, -1))\n  }\n  is_valid <- function(q) {\n \
    \   is_balanced(q) && is_palindrome(q)\n  }\n  is_valid(q)\n}\n", "\n  q <- as.list(q)\n\
    \  w <- as.numeric(w)\n  sum(q) <= w & is.palindromic(q) & sum(q) == sum(rev(q))\n\
    }\n", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    all(tail(q, -1) == head(q, -1))\n  }\n  is_balanced(q)\
    \ && is_palindrome(q)\n}\n</cell>\n<cell>", "\n  is_balanced <- function(q) {\n\
    \    sum(q) <= w\n  }\n  is_palindromic <- function(q) {\n    all(q == c(tail(q,\
    \ 1), head(q, -1)))\n  }\n  is_valid <- function(q) {\n    is_balanced(q) && is_palindromic(q)\n\
    \  }\n  is_valid(q)\n}\n", "\n  w <- as.integer(w)\n  q <- as.list(q)\n  sum(q)\
    \ <= w && all(q == rev(rev(q)))\n}\n", "\n  is_balanced <- function(x) {\n   \
    \ sum(x) <= w\n  }\n  is_palindrome <- function(x) {\n    x <- x[order(x)]\n \
    \   paste0(x[1:(length(x)-1)], x[(length(x)+1):length(x)])\n  }\n  is_balanced(q)\
    \ && is_palindrome(q) && sum(q) <= w\n}\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  \n  if(length(q) == 0) {\n    return(FALSE)\n  }\n  \n  if(length(q) == 1)\
    \ {\n    return(TRUE)\n  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n  }\n \
    \ \n  return(FALSE)\n}\n", "\n  if(length(q) == 0) {\n    return(FALSE)\n  }\n\
    \  if(all(q == rev(q))) {\n    return(TRUE)\n  }\n  if(sum(q) <= w) {\n    return(FALSE)\n\
    \  }\n  return(TRUE)\n}\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n  sum(q)\
    \ <= w && all(palindrome(q) && sum(q) <= w)\n}\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that returns TRUE if q will fly, and FALSE otherwise.\nThe object\
    \ q will fly if and only if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\nThe function\
    \ should work for any data type.\nExample:\n>>> will_it_fly(c(1, 2), 5)\nFALSE\n\
    >>> will_it_fly(c(3, 2, 3), 1)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 9)\nTRUE\n\
    >>> will_it_fly(c(3), 5)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 10)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 11)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 12)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 13)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 14)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 15)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 16)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 17)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 18)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 19)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 20)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 21)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 22)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 23)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 24)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 25)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 26)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 27)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 28)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 29)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 30)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 31)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 32)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 33)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 34)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 3), 35)\nTRUE\n>>> will_it_fly(", "\n  sum(q) <= w && all(q == rev(q))\n\
    }\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n  \n  if(length(q) == 0 | w\
    \ == 0) {\n    return(FALSE)\n  }\n  \n  if(length(q) == 1) {\n    return(TRUE)\n\
    \  }\n  \n  if(sum(q) <= w) {\n    return(TRUE)\n  }\n  \n  return(FALSE)\n}\n",
  "\n  return(\n    sum(q) <= w &&\n    all(q == rev(rev(q))) &\n    sum(q) == sum(rev(rev(q)))\n\
    \  )\n}\n", "\n  sum(q) <= w && all(q == rev(rev(q)))\n}\n", "\n  sum(q) <= w\
    \ && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n", "\n  if(all(is.numeric(q)))\
    \ return(TRUE)\n  if(all(is.factor(q))) return(FALSE)\n  if(all(is.character(q)))\
    \ return(FALSE)\n  if(all(is.logical(q))) return(FALSE)\n  if(all(is.integer(q)))\
    \ return(FALSE)\n  if(all(is.double(q))) return(FALSE)\n  if(all(is.numeric(q)))\
    \ return(FALSE)\n  if(all(is.list(q))) return(FALSE)\n  if(all(is.atomic(q)))\
    \ return(FALSE)\n  if(all(is.factor(q))) return(FALSE)\n  if(all(is.numeric(q)))\
    \ return(FALSE)\n  if(all(is.list(q))) return(FALSE)\n  if(all(is.atomic(q)))\
    \ return(FALSE)\n  if(all(is.double(q))) return(FALSE)\n  if(all(is.integer(q)))\
    \ return(FALSE)\n  if(all(is.logical(q))) return(FALSE)\n  if(all(is.character(q)))\
    \ return(FALSE)\n  if(all(is.factor(q))) return(FALSE)\n  if(all(is.numeric(q)))\
    \ return(FALSE)\n  if(all(is.list(q))) return(FALSE)\n  if(all(is.atomic(q)))\
    \ return(FALSE)\n  if(all(is.double(q))) return(FALSE)\n  if(all(is.integer(q)))\
    \ return(FALSE)\n  if(all(is.logical(q))) return(FALSE)\n  if(all(is.character(q)))\
    \ return(FALSE)\n  if(all(is.factor(q))) return(FALSE)\n  if(all(is.numeric(q)))\
    \ return(FALSE)\n  if(all(is.list(q))) return(FALSE)\n  if(all(is.atomic(q)))\
    \ return(FALSE)\n  if(all(is.double(q))) return(FALSE)\n  if(all(is.integer(q)))\
    \ return(FALSE)\n  if(all(is.logical(q))) return(FALSE)\n  if(all(is.character(q)))\
    \ return(FALSE)\n  if(all(is.factor(q))) return(FALSE)\n  if(all(is.numeric(q)))\
    \ return(FALSE)\n  if(all(is.list(q))) return(FALSE)\n  if(all(is.atomic(q)))\
    \ return(FALSE)\n  if(all(is.double(q))) return(FALSE)\n  if(all(is.integ", "\n\
    \  is_balanced <- function(q) {\n    n <- length(q)\n    sum <- 0\n    for (i\
    \ in 1:n) {\n      sum <- sum + q[i]\n    }\n    sum <- sum % 10\n    return (sum\
    \ == 0)\n  }\n  is_palindrome <- function(q) {\n    n <- length(q)\n    i <- 1\n\
    \    while (i < n) {\n      if (q[i] != q[n-i]) {\n        break\n      }\n  \
    \    i <- i + 1\n    }\n    return (TRUE)\n  }\n  is_valid <- function(q) {\n\
    \    n <- length(q)\n    i <- 1\n    while (i < n) {\n      if (q[i] > w) {\n\
    \        break\n      }\n      i <- i + 1\n    }\n    return (TRUE)\n  }\n  is_valid\
    \ <- is_balanced(q)\n  is_valid <- is_palindrome(q)\n  is_valid <- is_valid(q)\n\
    \  return (is_valid)\n}\n</cell>\n<cell>", "\n  is_balanced <- function(q) {\n\
    \    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    paste0(q, collapse=\"\
    \") == paste0(rev(q), collapse=\"\")\n  }\n  is_balanced(q) & is_palindrome(q)\n\
    }\n</cell>\n<cell>", "\n  return(\n    sum(q) <= w &&\n    is.palindromic(q) &&\n\
    \    sum(q) == sum(rev(q))\n  )\n}\n", "\n  is_balanced <- function(q) {\n   \
    \ n <- length(q)\n    sum <- 0\n    for (i in 1:n) {\n      sum <- sum + q[i]\n\
    \    }\n    if (sum == 0 || sum > w) {\n      return(FALSE)\n    }\n    return(TRUE)\n\
    \  }\n  is_palindrome <- function(q) {\n    n <- length(q)\n    i <- 1\n    while\
    \ (i <= n / 2) {\n      if (q[i] != q[n-i]) return(FALSE)\n      i <- i + 1\n\
    \    }\n    return(TRUE)\n  }\n  is_balanced(q)\n  is_palindrome(q)\n  return(TRUE)\n\
    }\n</cell>\n<cell>", "\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w)))\
    \ return(FALSE)\n  if(all(is.na(q[[1]]))) return(FALSE)\n  if(all(is.na(q[[2]])))\
    \ return(FALSE)\n  if(all(is.na(q[[3]]))) return(FALSE)\n  if(all(is.na(q[[4]])))\
    \ return(FALSE)\n  if(all(is.na(q[[5]]))) return(FALSE)\n  if(all(is.na(q[[6]])))\
    \ return(FALSE)\n  if(all(is.na(q[[7]]))) return(FALSE)\n  if(all(is.na(q[[8]])))\
    \ return(FALSE)\n  if(all(is.na(q[[9]]))) return(FALSE)\n  if(all(is.na(q[[10]])))\
    \ return(FALSE)\n  if(all(is.na(q[[11]]))) return(FALSE)\n  if(all(is.na(q[[12]])))\
    \ return(FALSE)\n  if(all(is.na(q[[13]]))) return(FALSE)\n  if(all(is.na(q[[14]])))\
    \ return(FALSE)\n  if(all(is.na(q[[15]]))) return(FALSE)\n  if(all(is.na(q[[16]])))\
    \ return(FALSE)\n  if(all(is.na(q[[17]]))) return(FALSE)\n  if(all(is.na(q[[18]])))\
    \ return(FALSE)\n  if(all(is.na(q[[19]]))) return(FALSE)\n  if(all(is.na(q[[20]])))\
    \ return(FALSE)\n  if(all(is.na(q[[21]]))) return(FALSE)\n  if(all(is.na(q[[22]])))\
    \ return(FALSE)\n  if(all(is.na(q[[23]]))) return(FALSE)\n  if(all(is.na(q[[24]])))\
    \ return(FALSE)\n  if(all(is.na(q[[25]]))) return(FALSE)\n  if(all(is.na(q[[26]])))\
    \ return(FALSE)\n  if(all(is.na(q[[27]]))) return(FALSE)\n  if(all(is.na(q[[28]])))\
    \ return(FALSE)\n  if(all(is.na(q[[29]]))) return(FALSE)\n  if(all(is.na(q[[30]])))\
    \ return(FALSE)\n  if(all(is.na(q[[31]]))) return(FALSE)", "\n  if(sum(q) <= w)\
    \ {\n    TRUE\n  } else {\n    FALSE\n  }\n}\n", "\n  sum(q) <= w && is_palindromic(q)\
    \ && sum(q) <= w\n}\n", "\n  return(\n    sum(q) <= w &&\n    all(abs(diff(q))\
    \ <= w)\n  )\n}\n", "\n  sum(q) <= w & is.palindromic(q) & sum(q) == w\n}\n",
  "\n  if(sum(q) <= w) return(TRUE)\n  if(sum(q) == w) return(TRUE)\n  return(FALSE)\n\
    }\n", "\n  w <- as.integer(w)\n  q <- as.list(q)\n  sum(q) <= w && all(q == rev(rev(q)))\n\
    }\n</cell>\n<text>\nQuestion 3\nWrite a function that returns TRUE if the object\
    \ q will fly, and FALSE otherwise.\nThe object q will fly if it's balanced (it\
    \ is a palindromic list) and the sum of its elements is less than or equal the\
    \ maximum possible weight w.\nExample:\n>>> will_it_fly(c(1, 2), 5)\nFALSE", "\n\
    \  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    sum(q) == sum(rev(q))\n  }\n  is_balanced(q) && is_palindrome(q)\n}\n\
    </cell>\n<cell>", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    all(tail(q, -1) == head(q, -1))\n  }\n  is_balanced(q)\
    \ && is_palindrome(q)\n}\n</cell>\n<text>\nProblem 3\nWrite a function that takes\
    \ a vector of integers and returns the sum of the squares of the numbers in the\
    \ vector.\nExample:\n>>> square_sum(1:10)\n25\n>>> square_sum(1:10)\n4950\n>>>\
    \ square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n\
    >>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n\
    4950\n>>> square_sum(1:10)\n4950\n>>> square_sum(1:10)\n49", "\n  is_balanced\
    \ <- function(q) {\n    sum(q) <= w\n  }\n  is_palindromic <- function(q) {\n\
    \    all(tail(q, -1) == head(q, -1))\n  }\n  is_balanced(q) && is_palindromic(q)\n\
    }\n", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    all(q == c(tail(q, 1), head(q, -1)))\n  }\n  is_valid\
    \ <- function(q) {\n    is_balanced(q) && is_palindrome(q)\n  }\n  is_valid(q)\n\
    }\n", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    all(tail(q, -1) == head(q,-1))\n  }\n  is_balanced(q)\
    \ && is_palindrome(q)\n}\n", "\n  is_balanced <- function(x) {\n    sum(sort(x))\
    \ == length(x)\n  }\n  is_palindrome <- function(x) {\n    paste0(sort(x), collapse=\"\
    \") == paste0(rev(x), collapse=\"\")\n  }\n  is_valid <- function(x) {\n    is_balanced(x)\
    \ && is_palindrome(x)\n  }\n  is_valid(q) && sum(q) <= w\n}\n", "\n  if(is_balanced(q)\
    \ && sum(q) <= w) {\n    TRUE\n  } else {\n    FALSE\n  }\n}\n", "\n  sum(q) <=\
    \ w && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n", "\n  w <- as.integer(w)\n\
    \  q <- as.list(q)\n  q <- lapply(q, as.integer)\n  q <- lapply(q, function(x)\
    \ ifelse(x <= w, TRUE, FALSE))\n  sum(q) == w\n}\n", "\n  q <- as.list(q)\n  w\
    \ <- as.integer(w)\n  q <- lapply(q, as.integer)\n  q <- lapply(q, function(x)\
    \ ifelse(x <= w, TRUE, FALSE))\n  sum(q) == w\n}\n", "\n  sum(q) <= w && all(q\
    \ == rev(q))\n}\n</cell>\n<text>\nPart III: Balancing an Object\nNow that we have\
    \ defined a function to check if an object will fly, let's define a function that\
    \ will fly.\n\nThe function will fly, if and only if:\n\nThe object q will fly,\
    \ and\nThe sum of its elements is less than or equal the maximum possible weight\
    \ w.\n\nThe function will fly, if and only if:\n\nThe object q will fly, and\n\
    The sum of its elements is less than or equal the maximum possible weight w.\n\
    \nThe function will fly, if and only if:\n\nThe object q will fly, and\nThe sum\
    \ of its elements is less than or equal the maximum possible weight w.\n\nThe\
    \ function will fly, if and only if:\n\nThe object q will fly, and\nThe sum of\
    \ its elements is less than or equal the maximum possible weight w.\n\nThe function\
    \ will fly, if and only if:\n\nThe object q will fly, and\nThe sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\nThe function will fly,\
    \ if and only if:\n\nThe object q will fly, and\nThe sum of its elements is less\
    \ than or equal the maximum possible weight w.\n\nThe function will fly, if and\
    \ only if:\n\nThe object q will fly, and\nThe sum of its elements is less than\
    \ or equal the maximum possible weight w.\n\nThe function will fly, if and only\
    \ if:\n\nThe object q will fly, and\nThe sum of its elements is less than or equal\
    \ the maximum possible weight w.\n\nThe function will fly, if and only if:\n\n\
    The object q will fly, and\nThe sum of its elements is less than or equal the\
    \ maximum possible weight w.\n\nThe function will fly, if and only if:\n\nThe\
    \ object q will fly, and\nThe sum of its elements is less than or equal the maximum\
    \ possible weight w.\n\nThe function will fly, if and only if:\n\nThe object q\
    \ will fly, and\nThe sum of its elements is less than or equal the maximum possible\
    \ weight w.\n\nThe function will fly, if and only if:\n\nThe object q will fly,\
    \ and\nThe sum of its elements is less than or equal the maximum possible weight\
    \ w.\n\nThe function will fly, if and only if:\n\nThe object q will fly, and\n\
    The sum of its elements is less than or equal the maximum possible weight w.\n\
    \nThe function will fly, if and only if:\n\nThe object q will fly, and\nThe sum\
    \ of its elements is less than or equal the maximum possible ", "\n  return(sum(q)\
    \ <= w && is_balanced(q))\n}\n", "\n  q <- unlist(q)\n  w <- as.integer(w)\n \
    \ sum(q) <= w & all(q == rev(rev(q)))\n}\n", "\n  q <- as.list(q)\n  w <- as.integer(w)\n\
    \  \n  if(length(q) == 1) {\n    return(TRUE)\n  }\n  \n  if(length(q) == 2) {\n\
    \    if(q[1] > q[2]) {\n      return(FALSE)\n    }\n  }\n  \n  if(length(q) ==\
    \ 3) {\n    if(q[1] > q[2] && q[1] > q[3]) {\n      return(FALSE)\n    }\n  }\n\
    \  \n  if(length(q) == 4) {\n    if(q[1] > q[2] && q[1] > q[3] && q[1] > q[4])\
    \ {\n      return(FALSE)\n    }\n  }\n  \n  if(length(q) == 5) {\n    if(q[1]\
    \ > q[2] && q[1] > q[3] && q[1] > q[4] && q[1] > q[5]) {\n      return(FALSE)\n\
    \    }\n  }\n  \n  if(length(q) == 6) {\n    if(q[1] > q[2] && q[1] > q[3] &&\
    \ q[1] > q[4] && q[1] > q[5] && q[1] > q[6]) {\n      return(FALSE)\n    }\n \
    \ }\n  \n  if(length(q) == 7) {\n    if(q[1] > q[2] && q[1] > q[3] && q[1] > q[4]\
    \ && q[1] > q[5] && q[1] > q[6] && q[1] > q[7]) {\n      return(FALSE)\n    }\n\
    \  }\n  \n  if(length(q) == 8) {\n    if(q[1] > q[2] && q[1] > q[3] && q[1] >\
    \ q[4] && q[1] > q[5] && q[1] > q[6] && q[1] > q[7] && q[1] > q[8]) {\n      return(FALSE)\n\
    \    }\n  }\n  \n  if(length(q) == 9) {\n    if(q[1] > q[2] && q[1] > q[3] &&\
    \ q[1] > q[4] && q[1] > q[5] && q[1] > q[6] && q[1] > q[7] && q[1] > q[8] && q[1]\
    \ > q[9]) {\n      return(FALSE)\n    }\n  }\n  \n  if(length(q) == 10) {\n  \
    \  if(q[1] > q[2] && q[1] > q[3] && q[1] > q[4] && q[1] > q[5] && q[1] > q[6]\
    \ && q[1] > q[7] && q[1] > q[8] && q[1] > q[9] && q[1] > q[10]) {\n      return(FALSE)\n\
    \    }\n  }\n  \n  if(length(q) == 11) {\n    if(q[1]", "\n  sum(q) <= w && is.list(q)\
    \ && is.palindromic(q) && sum(q) <= w\n}\n", "\n  if(is.list(q) && is.numeric(w))\
    \ {\n    sum(q) <= w && is.palindromic(q) && sum(q) <= w\n  } else {\n    stop(\"\
    'q' must be a list and 'w' must be a numeric value.\")\n  }\n}\n", "\n  is_balanced\
    \ <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n \
    \   all(tail(q, -1) == head(q, -1))\n  }\n  is_valid <- function(q) {\n    is_balanced(q)\
    \ && is_palindrome(q)\n  }\n  is_valid(q)\n}\n", "\n  sum(q) <= w & is.palindromic(q)\
    \ & sum(q) <= w\n}\n</cell>\n<text>\nProblem 3\nWrite a function that takes a\
    \ vector of integers and returns the number of palindromic pairs in the vector.\n\
    \nExample:\n>>> palindromic_pairs(c(1, 2, 3, 4))\n2\n>>> palindromic_pairs(c(3,\
    \ 2, 1))\n1\n>>> palindromic_pairs(c(3, 2, 4, 1))\n2\n>>> palindromic_pairs(c(3,\
    \ 2, 4, 1, 5))\n3\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6))\n4\n>>> palindromic_pairs(c(3,\
    \ 2, 4, 1, 5, 6, 7))\n5\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8))\n6\n\
    >>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9))\n7\n>>> palindromic_pairs(c(3,\
    \ 2, 4, 1, 5, 6, 7, 8, 9, 10))\n8\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7,\
    \ 8, 9, 10, 11))\n9\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11,\
    \ 12))\n10\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13))\n\
    11\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))\n\
    12\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))\n\
    13\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\
    \ 16))\n14\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17))\n15\n>>> palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18))\n16\n>>> palindromic_pairs(c(3, 2, 4, 1, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))\n17\n>>> palindromic_pairs(c(3,\
    \ 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))\n18\n>>>\
    \ palindromic_pairs(c(3, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\
    \ 18, 19, 20, 21))\n19\n>>> palindromic_pairs(c(3, 2, 4, 1, ", "\n  is_balanced\
    \ <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n \
    \   all(q == rev(rev(q)))\n  }\n  is_balanced(q) && is_palindrome(q)\n}\n</cell>\n\
    <cell>", "\n  sum(q) <= w && is.list(q) && is.palindromic(q) && sum(q) <= w\n\
    }\n</cell>\n<cell>", "\n  sum(q) <= w && is.list(q) && is.palindromic(q) && sum(q)\
    \ <= w\n}\n", "\n  sum(q) <= w && is.list(q) && is.palindromic(q) && sum(q) <=\
    \ w\n}\n", "\n  sum(q) <= w && is.list(q) && is.palindromic(q) && sum(q) <= w\n\
    }\n", "\n  sum(q) <= w && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n",
  "\n  w <- as.integer(w)\n  sum(q) <= w & is.palindromic(q) & sum(q) <= w\n}\n",
  "\n  sum(q) <= w && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n</cell>\n\
    <cell>", "\n  w <- as.integer(w)\n  sum(q) <= w && is.list(q) && is.palindromic(q)\
    \ && sum(q) <= w\n}\n", "\n  w <- as.integer(w)\n  sum(q) <= w && is.palindromic(q)\
    \ && sum(q) <= w\n}\n", "\n  is_balanced <- function(x) {\n    sum(sort(x)) ==\
    \ length(x)\n  }\n  is_palindrome <- function(x) {\n    x <- sort(x)\n    y <-\
    \ x\n    y[length(x)] <- NA\n    x <- x[-length(x)]\n    x <- c(x, y)\n    x <-\
    \ x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x\
    \ <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x\
    \ <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x\
    \ <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x\
    \ <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x\
    \ <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x\
    \ <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n\
    \    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x <- x[-length(x)]\n    x\
    \ <- x[-length(x)]", "\n  is_balanced <- function(q) {\n    n <- length(q)\n \
    \   sum(q[1:(n-1)]) == n\n  }\n  is_palindrome <- function(q) {\n    n <- length(q)\n\
    \    all(q == rev(q))\n  }\n  is_valid <- function(q) {\n    is_balanced(q) &&\
    \ is_palindrome(q)\n  }\n  is_valid_q <- function(q) {\n    is_valid(q) && sum(q)\
    \ <= w\n  }\n  is_valid_q(q)\n}\n</cell>\n<text>\nLet's try it out!\n\n\n</text>\n\
    <cell>\nwill_it_fly(c(1, 2), 5)\n</cell>\n<cell>\nwill_it_fly(c(3, 2, 3), 1)\n\
    </cell>\n<cell>\nwill_it_fly(c(3, 2, 3), 9)\n</cell>\n<cell>\nwill_it_fly(c(3),\
    \ 5)\n</cell>\n<cell>\nwill_it_fly(c(3, 2, 3), 10)\n</cell>\n<text>\nWe see that\
    \ our function works as intended. Let's now see how we can use it to solve the\
    \ problem of determining whether a palindromic list will fly.\n\n\n</text>\n<cell>",
  "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    all(q == c(q[[1]], q[length(q)]))\n  }\n  is_balanced(q) && is_palindrome(q)\n\
    }\n", "\n  sum(q) <= w && is.list(q) && is.palindromic(q) && sum(q) <= w\n}\n",
  "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome <- function(q)\
    \ {\n    all(q == c(tail(q, 1), head(q, -1)))\n  }\n  is_valid <- function(q)\
    \ {\n    is_balanced(q) && is_palindrome(q)\n  }\n  is_valid(q)\n}\n</cell>\n\
    <cell>", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n  }\n  is_palindrome\
    \ <- function(q) {\n    sum(q) == sum(rev(q))\n  }\n  is_valid <- function(q)\
    \ {\n    is_balanced(q) && is_palindrome(q)\n  }\n  is_balanced(q) && is_palindrome(q)\
    \ && is_valid(q)\n}\n", "\n  is_balanced <- function(q) {\n    sum(q) <= w\n \
    \ }\n  is_palindrome <- function(q) {\n    all(q == rev(rev(q)))\n  }\n  is_valid\
    \ <- function(q) {\n    is_balanced(q) && is_palindrome(q)\n  }\n  is_valid(q)\n\
    }\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number of palindromic\
    \ lists that satisfy the conditions described above.\n\nThe function should take\
    \ as input a vector q of positive integers, and a positive integer w, and should\
    \ return an integer that represents the number of palindromic lists that satisfy\
    \ the conditions described above.\n\nThe function should return -1 if w is less\
    \ than or equal to 0.\n\nThe function should return 0 if the vector q is empty.\n\
    \nThe function should return 1 if the vector q is a palindromic list.\n\nThe function\
    \ should return -1 if the vector q contains any negative elements.\n\nThe function\
    \ should return 0 if the vector q contains any zero elements.\n\nThe function\
    \ should return 1 if the vector q contains any positive elements.\n\nThe function\
    \ should return -1 if the vector q contains any negative or zero elements.\n\n\
    The function should return 0 if the vector q contains any positive and zero elements.\n\
    \nThe function should return 1 if the vector q contains any positive and negative\
    \ elements.\n\nThe function should return -1 if the vector q contains any negative\
    \ and positive elements.\n\nThe function should return 0 if the vector q contains\
    \ any positive and negative and zero elements.\n\nThe function should return 1\
    \ if the vector q contains any negative and positive and zero elements.\n\nThe\
    \ function should return -1 if the vector q contains any negative and positive\
    \ and negative elements.\n\nThe function should return 0 if the vector q contains\
    \ any negative and positive and negative and zero elements.\n\nThe function should\
    \ return 1 if the vector q contains any negative and positive and negative and\
    \ zero elements.\n\nThe function should return -1 if the vector q contains any\
    \ negative and positive and negative and zero elements.\n\nThe function should\
    \ return 0 if the vector q contains any negative and positive and negative and\
    \ zero elements.\n\nThe function should return 1 if the vector q contains any\
    \ negative and positive and negative and zero elements.\n\nThe function should\
    \ return -1 if the vector q contains any negative and positive and negative and\
    \ zero elements.\n\nThe function should return 0 if the vector q contains any\
    \ negative and positive and negative and zero elements.\n\nThe function should\
    \ return 1 if the vector q contains any negative and positive and negative and\
    \ zero elements.\n\nThe function should return -1 if the vector q contains any\
    \ negative and positive and negative and zero elements.\n\nThe function should\
    \ return 0 if the vector q contains ", "\n  if(all(is.na(q))) return(FALSE)\n\
    \  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w)))\
    \ return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n\
    \  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q)))\
    \ return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n\
    \  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w)))\
    \ return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n\
    \  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q)))\
    \ return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n\
    \  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w)))\
    \ return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n\
    \  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q)))\
    \ return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n\
    \  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w)))\
    \ return(FALSE)\n  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n\
    \  if(all(is.na(q))) return(FALSE)\n  if(all(is.na(w))) return(FALSE)\n  if(all(is.na(q)))\
    \ return(FALSE)\n  if(all(is.", "\n  if(length(q) == 1) {\n    return(TRUE)\n\
    \  }\n  if(sum(q) <= w) {\n    return(FALSE)\n  }\n  return(TRUE)\n}\n", "\n \
    \ is_balanced <- function(q) {\n    n <- length(q)\n    sum <- sum(q)\n    sum\
    \ <- sum + ifelse(sum < w, 0, sum)\n    sum <- sum + ifelse(sum > w, 0, sum)\n\
    \    sum <- sum + ifelse(sum == w, 1, 0)\n    return(sum == n)\n  }\n  is_palindromic\
    \ <- function(q) {\n    n <- length(q)\n    sum <- sum(q)\n    sum <- sum + ifelse(sum\
    \ < w, 0, sum)\n    sum <- sum + ifelse(sum > w, 0, sum)\n    sum <- sum + ifelse(sum\
    \ == w, 1, 0)\n    return(sum == n)\n  }\n  is_balanced(q) & is_palindromic(q)\n\
    }\n", "\n  is_balanced <- function(x) {\n    sum(tail(x, -1)) == sum(x[-length(x)])\n\
    \  }\n  is_palindrome <- function(x) {\n    x <- sort(x)\n    tail(x, -1) == head(x,\
    \ -1)\n  }\n  is_balanced(q) && is_palindrome(q) && sum(q) <= w\n}\n", "\n  return(sum(q)\
    \ <= w && is_balanced(q))\n}\n", "\n  if(is_balanced(q) && sum(q) <= w) {\n  \
    \  TRUE\n  } else {\n    FALSE\n  }\n}\n", "\n  is_balanced <- function(q) {\n\
    \    sum(q) <= w\n  }\n  is_palindrome <- function(q) {\n    sum(q) == sum(rev(q))\n\
    \  }\n  is_valid <- function(q) {\n    is_balanced(q) && is_palindrome(q)\n  }\n\
    \  is_valid(q)\n}\n</cell>\n<text>\nProblem 3\nWrite a function that returns TRUE\
    \ if q will fly, and FALSE otherwise.\nThe object q will fly if and only if it's\
    \ balanced (it is a palindromic list) and the sum of its elements is less than\
    \ or equal the maximum possible weight w.\nThe function should work for any type\
    \ of lists, not just palindromic lists.\nExample:\n>>> will_it_fly(c(1, 2), 5)\n\
    FALSE\n>>> will_it_fly(c(3, 2, 3), 1)\nTRUE\n>>> will_it_fly(c(3, 2, 3), 9)\n\
    FALSE\n>>> will_it_fly(c(3), 5)\nTRUE\n>>> will_it_fly(c(3, 2), 5)\nTRUE\n>>>\
    \ will_it_fly(c(3, 2, 4, 3), 9)\nTRUE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 9)\n\
    TRUE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 10)\nFALSE\n>>> will_it_fly(c(3, 2, 4,\
    \ 3, 2), 11)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 12)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, 2), 13)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 14)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, 2), 15)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 16)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, 2), 17)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 18)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, 2), 19)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 20)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, 2), 21)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 22)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, 2), 23)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 24)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, 2), 25)\nFALSE\n>>> will_it_fly(c(3, 2, 4, 3, 2), 26)\nFALSE\n>>> will_it_fly(c(3,\
    \ 2, 4, 3, ", "\n  q <- as.list(q)\n  sum(q) <= w & is.palindromic(q) & all(diff(q)\
    \ == 0)\n}\n</cell>\n<text>\nProblem 3\nWrite a function that returns TRUE if\
    \ q will fly, and FALSE otherwise.\nThe object q will fly if it's balanced (it\
    \ is a palindromic list) and the sum of its elements is less than or equal the\
    \ maximum possible weight w.\nThe function should work for any type of lists,\
    \ not just palindromic lists.\nExample:\n>>> will_it_fly(c(1, 2), 5)\nFALSE\n\
    >>> will_it_fly(c(3, 2, 3), 1)\nFALSE\n>>> will_it_fly(c(3, 2, 3), 9)\nTRUE\n\
    >>> will_it_fly(c(3), 5)\nTRUE\n>>> will_it_fly(c(1, 2), 0)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), 1)\nFALSE\n>>> will_it_fly(c(1, 2), 2)\nFALSE\n>>> will_it_fly(c(1, 2),\
    \ 3)\nFALSE\n>>> will_it_fly(c(1, 2), 4)\nFALSE\n>>> will_it_fly(c(1, 2), 5)\n\
    FALSE\n>>> will_it_fly(c(1, 2), 6)\nFALSE\n>>> will_it_fly(c(1, 2), 7)\nFALSE\n\
    >>> will_it_fly(c(1, 2), 8)\nFALSE\n>>> will_it_fly(c(1, 2), 9)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), 10)\nFALSE\n>>> will_it_fly(c(1, 2), 11)\nFALSE\n>>> will_it_fly(c(1, 2),\
    \ 12)\nFALSE\n>>> will_it_fly(c(1, 2), 13)\nFALSE\n>>> will_it_fly(c(1, 2), 14)\n\
    FALSE\n>>> will_it_fly(c(1, 2), 15)\nFALSE\n>>> will_it_fly(c(1, 2), 16)\nFALSE\n\
    >>> will_it_fly(c(1, 2), 17)\nFALSE\n>>> will_it_fly(c(1, 2), 18)\nFALSE\n>>>\
    \ will_it_fly(c(1, 2), 19)\nFALSE\n>>> will_it_fly(c(1, 2), 20)\nFALSE\n>>> will_it_fly(c(1,\
    \ 2), 21)\nFALSE\n>>> will_it_fly(c(1, 2), 22)\nFALSE\n>>> will_it_fly(c(1, 2),\
    \ 23)\nFALSE\n>>> will_it_fly(c(1, 2), 24)\nFALSE\n>>> will_it_fly(c(1, 2), 25)\n\
    FALSE\n>>> will_it_fly(c(1, 2), 26)\nFALSE\n", "\n  sum(q) <= w && is.list(q)\
    \ && is.palindromic(q) && sum(q) <= w\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
