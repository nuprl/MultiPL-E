name: HumanEval_58_common
language: r
prompt: "# Return sorted unique common elements for two lists.\n# >>> common(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n# c(1, 5, 653)\n# >>> common(c(5,\
  \ 3, 2, 8), c(3, 2))\n# c(2, 3)\ncommon <- function(l1, l2) {"
tests: "test_humaneval <- function() {\ncandidate <- common\n    if(!identical(candidate(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c()), c())){quit('no', 1)}\n}\n\
  test_humaneval()"
completions: ["\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 !=\
    \ u1]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like this solution, but\
    \ I wonder if there is a way to avoid the creation of `u1` and `u2`.  It would\
    \ be nice if there was a way to do this without creating those objects.\n<|/ c\
    \ |>\n<| c |>\nI added a version that doesn't create those objects.\n<|/ c |>\n\
    <| a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,4,3,34,653,2), b = c(5,7,1,5,9,653,121))\ndt[, c := unique(c(a,\
    \ b)), by = names(dt)]\ndt[, d := unique(c(b, a)), by = names(dt)]\ndt[, e :=\
    \ unique(c(c, d)), by = names(dt)]\ndt[, f := unique(c(d, c)), by = names(dt)]\n\
    dt[, g := unique(c(e, f)), by = names(dt)]\ndt[, h := unique(c(f, e)), by = names(dt)]\n\
    dt[, i := unique(c(e, g, h)), by = names(dt)]\ndt[, j := unique(c(g, h, i)), by\
    \ = names(dt)]\ndt[, k := unique(c(h, i, j)), by = names(dt)]\ndt[, l := unique(c(i,\
    \ j, k)), by = names(dt)]\ndt[, m := unique(c(j, k, l)), by = names(dt)]\ndt[,\
    \ n := unique(c(k, l, m)), by = names(dt)]\ndt[, o := unique(c(l, m, n)), by =\
    \ names(dt)]\ndt[, p := unique(c(m, n, o)), by = names(dt)]\ndt[, q := unique(c(n,\
    \ o, p)), by = names(dt)]\ndt[, r := unique(c(o, p, q)), by = names(dt)]\ndt[,\
    \ s := unique(c(p, q, r)), by = names(dt)]\ndt[, t := unique(c(q, r, s)), by =\
    \ names(dt)]\ndt[, u := unique(c(r, s, t)), by = names(dt)]\ndt[, v := unique(c(s,\
    \ t, u)), by", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in either list.\n<|/ c |>\n<| c |>\nYes, it does. I added a note to the answer.\n\
    <|/ c |>\n<| c |>\nI added a note to the answer.\n<|/ c |>\n<| c |>\nI added a\
    \ note to the answer.\n<|/ c |>\n<| c |>\nI added a note to the answer.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nA simple and efficient solution:\n<code>\ncommonElements\
    \ <- function(list1, list2) {\n  list1 <- sort(list1)\n  list2 <- sort(list2)\n\
    \  commonElements <- list1[list2 %in% list1]\n  return(commonElements)\n}\n</code>\n\
    <|/ a tags=r,list |>\n<| a |>\n<code>\ncommonElements <- function(list1, list2)\
    \ {\n  list1 <- sort(list1)\n  list2 <- sort(list2)\n  commonElements <- list1[list2\
    \ %in% list1]\n  return(commonElements)\n}\n</code>\n<|/ a tags=r,list dscore=3\
    \ |>\n<| a tags=r,list |>\n<code>\ncommonElements <- function(list1, list2) {\n\
    \  list1 <- sort(list1)\n  list2 <- sort(list2)\n  commonElements <- list1[list2\
    \ %in% list1]\n  return(commonElements)\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3\
    \ |>\n<code>\ncommonElements <- function(list1, list2) {\n  list1 <- sort(list1)\n\
    \  list2 <- sort(list2)\n  commonElements <- list1[list2 %in% list1]\n  return(commonElements)\n\
    }\n</code>\n<|/ a tags=r,list |>\n<| a dscore=3 |>\n<code>\ncommonElements <-\
    \ function(list1, list2) {\n  list1 <- sort(list1)\n  list2 <- sort(list2)\n \
    \ commonElements <- list1[list2 %in% list1]\n  return(commonElements)\n}\n</code>\n\
    <|/ a tags=r,list |>\n<| a tags=r,list |>\n<code>\ncommonElements <- function(list1,\
    \ list2) {\n  list", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| a dscore=0 |>\nI\
    \ came up with a solution using dplyr and purrr packages.\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this answer because\
    \ it's very concise and easy to understand. Thanks!\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)", "\n \
    \ u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I added a comment to my question\
    \ to explain why I didn't use your solution. Your solution works perfectly for\
    \ my problem, but it's too slow for my purposes.\n<|/ c |>\n<| c |>\nI added a\
    \ comment to my question to explain why I didn't use your solution. Your solution\
    \ works perfectly for my problem, but it's too slow for my purposes.\n<|/ c |>\n\
    <| c |>\nI added a comment to my question to explain why I didn't use your solution.\
    \ Your solution works perfectly for my problem, but it's too slow for my purposes.\n\
    <|/ c |>\n<| c |>\nI added a comment to my question to explain why I didn't use\
    \ your solution. Your solution works perfectly for my problem, but it's too slow\
    \ for my purposes.\n<|/ c |>\n<| c |>\nI added a comment to my question to explain\
    \ why I didn't use your solution. Your solution works perfectly for my problem,\
    \ but it's too slow for my purposes.\n<|/ c |>\n<| a |>\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ndf <- data.frame(x = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThanks for your answer! I didn't know about `intersect`\
    \ before. Unfortunately, it seems that `intersect` doesn't work with `data.frame`s.\
    \ I get the following error: `Error in sort.list(y) : 'x' must be atomic for 'sort.list'\n\
    Have you called 'sort' on a list?`\n<|/ c |>\n<| c |>\nYes, I forgot to mention\
    \ that I used `data.table` instead of `data.frame`. I edited my answer to include\
    \ a solution for `data.frame`s.\n<|/ c |>\n<| c |>\nThanks again! I edited my\
    \ question to include a solution for `data.frame`s. I hope you don't mind that\
    \ I added a comment to your answer that explains why I used `data.table` instead\
    \ of `data.frame`.\n<|/ c |>\n<| c |>\nNo problem. Glad I could help.\n<|/ c |>\n\
    <| a |>\nI believe that you can do what you want with dplyr::intersect:\n<code>\n\
    library(dplyr)\ndf <- data.frame(a = c(1,2,3,4,5,6,7,8,9), b = c(1,2,3,4,5,6,7,8,9))\n\
    intersect(df, df)\n</code>\n<|/ a dscore=3 tags=r,dataframe |>\n<| c |>\nThanks\
    \ for your answer! I didn't know about `intersect` before. Unfortunately, it seems\
    \ that `intersect` doesn't work with `data.frame`s. I get the following error:\
    \ `Error in sort.list(y) : 'x' must be atomic for 'sort.list'\nHave you called\
    \ 'sort' on a list?`\n<|/ c |>\n<| c |>\nYes, I forgot to mention that I used\
    \ `data.table` instead of `data.frame`. I edited my answer to include a solution\
    \ for `data.frame`s.\n<|/ c |>\n<| a dscore=2 |>\nI believe that you can do what\
    \ you want with dplyr::intersect:\n<code>\nlibrary(dplyr)\ndf <- data.frame(a\
    \ = c(1,2,3,4,5,6,7,8,9), b = c(1,2,3,4,5,6,7,8,9))\nintersect(df, df)\n</code>\n\
    <|/ a tags=r,dataframe |>\n<| a dscore=2 |>\nI believe that you can do what you ",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks so much! This was really helpful.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf1 <- data.frame(\n  x = c(1:10,\
    \ 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf2 <- data.frame(\n  x = c(1:10, 1:10),\n\
    \  y = c(1:10, 1:10)\n)\n\ndf3 <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10,\
    \ 1:10)\n)\n\ndf4 <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n\
    )\n\ndf5 <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf6 <-\
    \ data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf7 <- data.frame(\n\
    \  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf8 <- data.frame(\n  x = c(1:10,\
    \ 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf9 <- data.frame(\n  x = c(1:10, 1:10),\n\
    \  y = c(1:10, 1:10)\n)\n\ndf10 <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10,\
    \ 1:10)\n)\n\ndf11 <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n\
    )\n\ndf12 <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf13\
    \ <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf14 <- data.frame(\n\
    \  x = c(1:10, 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf15 <- data.frame(\n  x = c(1:10,\
    \ 1:10),\n  y = c(1:10, 1:10)\n)\n\ndf16 <- data.frame(\n  x = c(1:10, 1:10),\n\
    \  y = c(1:10, 1:10)\n)\n\ndf17 <- data.frame(\n  x = c(1:10, 1:10),\n  y = c(1:10,\
    \ 1:10)\n)\n\ndf18 <- data.frame(\n  x = c(1:10, 1:10),\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work if the two lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting it. I will add an\
    \ example to my answer.\n<|/ c |>\n<| c |>\nI tested it again and it does work.\
    \ Maybe you didn't test it properly. Try `common(c(1,2,3), c(1,2,3,4,5))` and\
    \ see what happens.\n<|/ c |>\n<| c |>\nYes, it does work. Try it again. `common(c(1,2,3),\
    \ c(1,2,3,4,5))` returns `c(1,2,3)`.\n<|/ c |>\n<| c |>\nI tested it again and\
    \ it does work. Maybe you didn't test it properly. Try `common(c(1,2,3), c(1,2,3,4,5))`\
    \ and see what happens.\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt1 <- data.table(a = c(1,2,3,4,5,6,7,8,9,10),\
    \ b = c(1,2,3,4,5,6,7,8,9,10))\ndt2 <- data.table(a = c(1,2,3,4,5,6,7,8,9,10),\
    \ b = c(1,2,3,4,5,6,7,8,9,10))\n\ndt1[dt2, on = \"a\"]\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if the two lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nI tested it again and it does work. Maybe you didn't test it\
    \ properly. Try `common(c(1,2,3), c(1,2,3,4,5))` and see what happens.\n<|/ c\
    \ |>\n<| c |>\nI tested it again and it does work. Maybe you didn't test it properly.\
    \ Try `common(c(1,2,3), c(1,2,3,4,5))` and see what happens.\n<|/ c |>\n<| c |>\n\
    I tested it again and it does work. Maybe you didn't test it properly. Try `common(c(1,2,3),\
    \ c(1,2,3,4,5))` and see what happens.\n<|/ c |>\n<| c |>\nI tested it again and\
    \ it does work. Maybe you didn't test it properly. Try `common(c(1,2,3), c(1,2,3,4,5))`\
    \ and see what happens.\n<|/ c |>\n<| a dscore=2 |>\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI like your `common` function, but I believe it can be simplified\
    \ a bit. `u1 <- unique(c(l1, l2)); u2 <- unique(c(l2, l1)); u1[u1 == u2]` will\
    \ do the same thing.\n<|/ c |>\n<| c |>\nThanks, I didn't know that. I've edited\
    \ my answer to include your suggestion.\n<|/ c |>\n<| c |>\nI like this answer\
    \ because it is simple and easy to understand.  However, I believe it can be simplified\
    \ even further.  See my answer below.\n<|/ c |>\n<| c |>\nI like this answer because\
    \ it is simple and easy to understand. However, I believe it can be simplified\
    \ even further. See my answer below.\n<|/ c |>\n<| c |>\nI like this answer because\
    \ it is simple and easy to understand. However, I believe it can be simplified\
    \ even further. See my answer below.\n<|/ c |>\n<| a dscore=5 |>\nI like to use\
    \ intersect for this:\n<code>\nintersect(list1, list2)\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThis should be the accepted answer. `intersect` returns a vector\
    \ and `intersect` returns a logical vector.\n<|/ c |>\n<| c |>\nThis should be\
    \ the accepted answer. `intersect` returns a vector and `intersect` returns a\
    \ logical vector.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. `intersect`\
    \ returns a vector and `intersect` returns a logical vector.\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer. `intersect` returns a vector and `intersect`\
    \ returns a logical vector.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `intersect` returns a vector and `intersect` returns a logical vector.\n<|/\
    \ c |>\n<| a dscore=5 |>\nThe function intersect is what you're looking for:\n\
    <code>\n> intersect(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"d\"))\n[1] \"a\"\
    \ \"b\"\n</code>\n<|/ a tags=r |>\n<| c |>\nThis should be the accepted answer.\
    \ `intersect` returns a vector and `intersect` returns a logical vector.\n<|/\
    \ c |>\n<| c |>\nThis should be the accep", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting\
    \ |>\n<code>\n> x <- c(1,4,3,34,653,2,5)\n> y <- c(5,7,1,5,9,653,121)\n> \n> \n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1,\
    \ l2))\n  u[!duplicated(u)]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like\
    \ this solution, but I wonder if there is a way to make it more efficient by avoiding\
    \ `unique` altogether. `intersect` doesn't seem to work in this case.\n<|/ c |>\n\
    <| c |>\nI added a solution using `intersect` which avoids `unique` altogether.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using intersect which\
    \ avoids unique:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- intersect(l1,\
    \ l2)\n  u2 <- intersect(l2, l1)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nHere's a solution using setdiff and intersect which avoids unique:\n\
    <code>\ncommon <- function(l1, l2) {\n  u1 <- setdiff(l1, l2)\n  u2 <- setdiff(l2,\
    \ l1)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| a dscore=2\
    \ |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <-\
    \ unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| a dscore=2 |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>\ncommon <- function(l1,\
    \ l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\ncommon <- function(l1,\
    \ l2) {\n  u1 <- unique(c(l1, l2))", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(c(l1, l2)), decreasing =\
    \ TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2] <-\
    \ NA\n  u1\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a solution\
    \ using data.table:\n<code>\nlibrary(data.table)", "\n  l1 <- sort(l1)\n  l2 <-\
    \ sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it with `common(c(1,2,3), c(1,2,3,4,5))`.\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it with `common(c(1,2,3), c(1,2,3,4,5))`.\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it with `common(c(1,2,3), c(1,2,3,4,5))`.\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it with `common(c(1,2,3), c(1,2,3,4,5))`.\n\
    <|/ c |>\n<| a dscore=5 |>\nHere's a function that will do it:\n<code>\nunique\
    \ <- function(x) {\n  u <- unique(x)\n  u[!duplicated(u)]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\nunique(c(list1, list2))\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\n<code>\nunique(c(list1, list2))\n</code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nIt does work if there are repeated elements in the lists. Try\
    \ it out. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns\
    \ `c(1, 5, 653)`.\n<|/ c |>\n<| c |>\nYes, it does work, but I didn't see that\
    \ in your example. Sorry.\n<|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ that uses setdiff to find the unique elements that are in both lists:\n<code>\n\
    common <- function(l1, l2) {\n  setdiff(unique(c(l1, l2)), unique(c(l2, l1)))\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nIt does work if there are repeated\
    \ elements in the lists. Try it out. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7,\
    \ 1, 5, 9, 653, 121))` returns `c(1, 5, 653)`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are repeated elements in the lists.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nA simple solution using setdiff:\n<code>\ncommon <- function(l1, l2) {\n\
    \  setdiff(unique(c(l1, l2)), unique(c(l2, l1)))\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nIt does work if there are repeated elements in the lists. Try it\
    \ out. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns\
    \ `c(1, 5, 653)`.\n<|/ c |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ using setdiff and intersect:\n<code>\ncommon <- function(l1, l2) {\n  setdiff(unique(c(l1,\
    \ l2)), intersect(c(l1, l2), c(l2, l1)))\n}\n</code>\n<|/ a ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,unique,list\
    \ |>\n<| a dscore=2 |>\n<code>\n> x <- list(c(1,4,3,34,653,2,5), c(5,7,1,5,9,653,121))\n\
    > y <- list(c(5,3,2,8), c(3,2))\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> ", "\n  u1 <- unique(c(l1, l2))\n  u2 <-\
    \ unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting\
    \ |>\nA simple solution using base R would be:\n<code>\nx <- c(1,4,3,34,653,2,5)\n\
    y <- c(5,7,1,5,9,653,121)\nx[order(match(y,x))]\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nA solution using dplyr and tidyr:\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\n\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\ndf <-\
    \ data.frame(x, y)\n\ndf %>%\n  mutate(id = row_number()) %>%\n  gather(key, value,\
    \ -id) %>%\n  arrange(id, value) %>%\n  select(-key) %>%\n  filter(value == y)\
    \ %>%\n  select(id)\n"]
stop_tokens:
- "\n#"
- "\n```"
