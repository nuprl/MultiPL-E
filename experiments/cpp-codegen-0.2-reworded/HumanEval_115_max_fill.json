{
  "name": "HumanEval_115_max_fill",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
  "tests": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
  "completions": [
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > capacity) {\n            ans += buckets[i] - capacity;\n            buckets[i] = capacity;\n        }\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans + 1);\n            }\n        }\n    }\n    return dp[0][0];",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n                used[i] += 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        result += max_fill[i] - used[i];\n    }\n    return result;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> left(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n            }\n            if (grid[i][j] == 0) {\n                ++left[i];\n            }\n        }\n    }\n    long result = 0;\n    while (true) {\n        long max_left = 0;\n        for (int i = 0; i < grid.size(); ++i) {\n            if (used[i] == 0 && left[i] > max_left) {\n                max_left = left[i];\n            }\n        }\n        if (max_left == 0) {\n            break;\n        }\n        for (int i = 0; i < grid.size(); ++i) {\n            if (used[i] == 0 && left[i] == max_left) {\n                --left[i];\n                ++result;\n                break;\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> water_level(grid.size(), 0);\n    std::vector<long> water_level_next(grid.size(), 0);\n    std::vector<long> water_level_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev(grid.size(), 0);\n    std::vector<long> water_level_prev_next(grid.size(), 0);\n    std::vector<long> water_level_next_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev(grid.size(), 0);\n    std::vector<long> water_level_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_prev_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev_next_next_prev_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev_next_next_prev_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev_next_next_prev_next_prev_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev_next_next_prev_next_prev_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev_next_next_prev_next_prev_next_prev_prev(grid.size",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (k != i) {\n                        if (grid[k][j] == 1) {\n                            dp[i][j] = std::min(dp[i][j], dp[k][j] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (k != i) {\n                        if (grid[k][j] == 1) {\n                            buckets[k] = std::min(buckets[k], dp[i][j] - 1);\n                        }\n                    }\n                }\n                ans = std::max(ans, buckets[i]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    long ans = 0;\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i]++;\n                } else {\n                    ans++;\n                    used[i] = 0;\n                }\n            }\n        }\n    }\n    return ans;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> well;\n                well.push_back(std::make_pair(i, j));\n                while (!well.empty()) {\n                    auto p = well.back();\n                    well.pop_back();\n                    if (p.first > 0) {\n                        if (grid[p.first - 1][p.second] == 1) {\n                            grid[p.first - 1][p.second] = 0;\n                            well.push_back(std::make_pair(p.first - 1, p.second));\n                        }\n                    }\n                    if (p.first < grid.size() - 1) {\n                        if (grid[p.first + 1][p.second] == 1) {\n                            grid[p.first + 1][p.second] = 0;\n                            well.push_back(std::make_pair(p.first + 1, p.second));\n                        }\n                    }\n                    if (p.second > 0) {\n                        if (grid[p.first][p.second - 1] == 1) {\n                            grid[p.first][p.second - 1] = 0;\n                            well.push_back(std::make_pair(p.first, p.second - 1));\n                        }\n                    }\n                    if (p.second < grid[p.first].size() - 1) {\n                        if (grid[p.first][p.second + 1] == 1) {\n                            grid[p.first][p.second + 1] = 0;\n                            well.push_back(std::make_pair(p.first, p.second + 1));\n                        }\n                    }\n                }\n                max_fill += well.size();\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                --buckets[i];\n                ++ans;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n                used[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 0 && used[i] > max_fill[i]) {\n                max_fill[i] = used[i];\n            }\n        }\n    }\n    long max = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_fill[i] > max) {\n            max = max_fill[i];\n        }\n    }\n    return max;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> buckets;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            buckets.push_back(std::make_pair(k, l));\n                        }\n                    }\n                }\n                std::sort(buckets.begin(), buckets.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                    return a.second < b.second;\n                });\n                for (int k = 0; k < buckets.size(); ++k) {\n                    int i = buckets[k].first;\n                    int j = buckets[k].second;\n                    if (i == j) {\n                        continue;\n                    }\n                    long left = grid[i][j] - 1;\n                    long right = grid[i][j] + 1;\n                    long left_fill = 0;\n                    long right_fill = 0;\n                    for (int m = i - 1; m >= 0; --m) {\n                        if (grid[m][j] == 1) {\n                            left_fill += grid[m][j];\n                        }\n                        if (grid[m][j] == 0) {\n                            break;\n                        }\n                    }\n                    for (int m = i + 1; m < grid.size(); ++m) {\n                        if (grid[m][j] == 1) {\n                            right_fill += grid[m][j];\n                        }\n                        if (grid[m][j] == 0) {\n                            break;\n                        }\n                    }\n                    max_fill = std::max(max_fill, std::max(left_fill, right_fill));\n                    grid[i][j] = 0;\n                }\n                max_fill = std",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                int cur_bucket = i * grid.size() + j;\n                int max_bucket = max_buckets[i];\n                if (max_bucket < cur_bucket) {\n                    max_buckets[i] = cur_bucket;\n                }\n                buckets[i] -= 1;\n                if (buckets[i] < 0) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    long count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                int cur_bucket = i * grid.size() + j;\n                if (max_buckets[i] == cur_bucket) {\n                    count += 1;\n                }\n            }\n        }\n    }\n    return count;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> used_row(grid[0].size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> buckets;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            buckets.push_back(std::make_pair(k, l));\n                        }\n                    }\n                }\n                long fill = 0;\n                while (fill < capacity) {\n                    fill += std::min(buckets.back().first, buckets.back().second);\n                    buckets.pop_back();\n                }\n                max_fill = std::max(max_fill, fill);\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> buckets(grid.size(), 0);\n    long max_buckets = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && used[i] == 0) {\n                --buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0) {\n                --buckets[i];\n                --used[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0) {\n                --buckets[i];\n                --used[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0) {\n                --buckets[i];\n                --used[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0)",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] -= 1;\n                ans += 1;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            result += buckets[i];\n            buckets[i] = 0;\n        }\n    }\n    return result;",
    "    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += max_fill(grid, i, j, capacity);\n            }\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    if (buckets[i] > 0) {\n                        --buckets[i];\n                        ++used[i];\n                        if (--buckets[i] == 0) {\n                            --used[i];\n                        }\n                    }\n                }\n            }\n        }\n        if (std::all_of(used.begin(), used.end(), [](long x) { return x == 0; })) {\n            break;\n        }\n        ++ans;\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> used(grid.size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                long cur_fill = 0;\n                while (cur_fill < grid[i].size() && grid[i][j] == 1) {\n                    ++cur_fill;\n                    ++used[i];\n                    --grid[i][j];\n                }\n                max_fill = std::max(max_fill, cur_fill);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                --used[i];\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < max_buckets[i]) {\n                    --buckets[i];\n                    ++max_fill;\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill += capacity;\n                while (max_fill > grid[i][j]) {\n                    max_fill -= grid[i][j];\n                    grid[i][j] = 0;\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        well_count[i] = grid[i][0];\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 1; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n            }\n            if (well_count[i] > 0) {\n                buckets[i] += capacity;\n                --well_count[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_count[i] > 0) {\n            result += buckets[i];\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                buckets[i] += 1;\n            }\n        }\n    }\n    while (buckets[0] > 0) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    if (buckets[i] > 0) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][j - 1] + 1);\n                    }\n                    if (buckets[i] > capacity) {\n                        dp[i][j] = std::max(dp[i][j], dp[i - 1][j] + 1);\n                    }\n                }\n            }\n        }\n        buckets[0] -= 1;\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[i].size(), 0));\n                dp[i][j] = 1;\n                for (int k = i - 1; k >= 0; --k) {\n                    if (grid[k][j] == 1) {\n                        dp[k][j] = 1;\n                    }\n                }\n                for (int k = i + 1; k < grid.size(); ++k) {\n                    if (grid[k][j] == 1) {\n                        dp[k][j] = 1;\n                    }\n                }\n                for (int k = j - 1; k >= 0; --k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][k] = 1;\n                    }\n                }\n                for (int k = j + 1; k < grid[i].size(); ++k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][k] = 1;\n                    }\n                }\n                for (int k = 0; k < dp.size(); ++k) {\n                    for (int l = 0; l < dp[k].size(); ++l) {\n                        if (dp[k][l] == 1) {\n                            dp[k][l] = dp[k][l] + dp[i][j];\n                        }\n                    }\n                }\n                max_fill = std::max(max_fill, dp[0][0]);\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> buckets(grid.size(), 0);\n    long count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            count += buckets[i] * capacity;\n            buckets[i] = 0;\n        }\n    }\n    return count;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 0 && buckets[i] > 0 && used[i] < capacity) {\n                --buckets[i];\n                --used[i];\n                ++result;\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); k++) {\n                    for (int l = 0; l < grid[k].size(); l++) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;",
    "    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += max_fill(grid, i, j, capacity);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n            max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, max_buckets[i] - buckets[i]);\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i]++;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        ans += std::min(max_fill[i], used[i]) - std::max(max_fill[i], used[i]);\n    }\n    return ans;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_well(grid.size(), 0);\n    std::vector<long> max_well_index(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_well[i] = std::max(max_well[i], j);\n                max_well_index[i] = i;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = max_well[i]; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                    ans += 1;\n                } else {\n                    used[max_well_index[i]] -= 1;\n                    used[i] -= 1;\n                    ans += 1;\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (i != k && grid[k][j] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][j] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n                buckets[i] -= 1;\n            }\n        }\n    }\n    long max_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (well_count[i] > 0 && buckets[i] > 0) {\n                buckets[i] -= 1;\n                --well_count[i];\n                max_count += 1;\n            }\n        }\n    }\n    return max_count;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] -= 1;\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(capacity, 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                buckets[0]++;\n            } else {\n                for (int k = 0; k < capacity; k++) {\n                    if (buckets[k] > 0) {\n                        buckets[k]--;\n                        max_fill++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n            else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i < n; ++i) {\n        for (int j = 1; j < m; ++j) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j] > capacity ? dp[i][j] - capacity : 0;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            for (int k = 0; k < grid.size(); ++k) {\n                for (int l = 0; l < grid[0].size(); ++l) {\n                    if (grid[k][l] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][0];",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long max_buckets = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > max_buckets) {\n            max_buckets = buckets[i];\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] == max_buckets) {\n            ans += max_buckets;\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                visited[i] = 1;\n                buckets[i] += 1;\n                if (buckets[i] > capacity) {\n                    max_fill += 1;\n                    buckets[i] -= capacity;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        if (visited[i] == 0) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    buckets[i] += 1;\n                    if (buckets[i] > capacity) {\n                        max_fill += 1;\n                        buckets[i] -= capacity;\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += 1;\n                max_buckets[i] += capacity;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > max_buckets[i]) {\n            result += buckets[i] - max_buckets[i];\n            buckets[i] = max_buckets[i];\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] > 0) {\n                    --buckets[i];\n                    ++used[i];\n                    if (used[i] == capacity) {\n                        max_fill += capacity;\n                        used[i] = 0;\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> well_capacity(grid.size(), capacity);\n    std::vector<long> well_count(grid.size(), 0);\n    std::vector<long> well_water(grid.size(), 0);\n    std::vector<long> well_water_count(grid.size(), 0);\n    std::vector<long> well_water_capacity(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                well_count[i]++;\n                well_water[i] += well_capacity[i];\n                well_water_count[i] += well_capacity[i];\n                well_water_capacity[i] += well_capacity[i];\n            }\n        }\n    }\n    std::vector<long> well_water_count_new(grid.size(), 0);\n    std::vector<long> well_water_capacity_new(grid.size(), 0);\n    std::vector<long> well_water_count_new_new(grid.size(), 0);\n    std::vector<long> well_water_capacity_new_new(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (well_count[i] > 0) {\n                well_water_count_new[i] += well_water_count[i];\n                well_water_capacity_new[i] += well_water_capacity[i];\n                well_water_count_new_new[i] += well_water_count[i];\n                well_water_capacity_new_new[i] += well_water_capacity[i];\n            }\n        }\n    }\n    long max_well_water_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_water_count_new[i] > max_well_water_count)",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < grid.size(); ++k) {\n                for (int l = 0; l < grid[0].size(); ++l) {\n                    if (grid[k][l] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            ans = std::max(ans, dp[i][j]);\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += dp[i][j];\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i] = 0;\n            } else {\n                used[i] += 1;\n            }\n        }\n    }\n    long max_fill_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_fill[i] < capacity) {\n            max_fill_count += 1;\n        }\n    }\n    return max_fill_count;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                used[i] += max_fill[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += max_fill[i] - used[i];\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> well;\n                well.push_back(std::make_pair(i, j));\n                while (!well.empty()) {\n                    auto p = well.back();\n                    well.pop_back();\n                    if (grid[p.first][p.second] == 0) {\n                        continue;\n                    }\n                    grid[p.first][p.second] = 0;\n                    max_fill += 1;\n                    if (grid[p.first][p.second] == 0) {\n                        well.push_back(std::make_pair(p.first, p.second));\n                    }\n                    if (grid[p.first][p.second] == 1) {\n                        well.push_back(std::make_pair(p.first, p.second));\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> well_capacity(grid.size(), capacity);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                well_count[i]++;\n                well_capacity[i]--;\n            }\n        }\n    }\n    std::vector<long> well_count_new(grid.size(), 0);\n    std::vector<long> well_capacity_new(grid.size(), capacity);\n    while (well_count_new != well_count) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (well_count_new[i] < well_count[i]) {\n                well_count_new[i]++;\n                well_capacity_new[i]--;\n                break;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_capacity_new[i] < 0) {\n            result++;\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(capacity, 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < capacity; ++k) {\n                    if (k < buckets[j]) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][j - 1] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < capacity; ++k) {\n                    if (k < buckets[j]) {\n                        buckets[j]--;\n                        ans = std::max(ans, dp[i][j]);\n                        buckets[j]++;\n                    }\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1 && visited[i] < buckets[i]) {\n                    --buckets[i];\n                    ++visited[i];\n                    if (buckets[i] == 0) {\n                        --ans;\n                    }\n                }\n            }\n        }\n        if (ans == 0) {\n            break;\n        }\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1)",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(m, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[j] = std::max(dp[j], dp[j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < m; ++i) {\n        ans = std::max(ans, dp[i]);\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < 4; ++k) {\n                int r = i + dp[i][j];\n                int c = j + dp[i][j];\n                if (r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\n                    dp[r][c] = std::max(dp[r][c], dp[i][j] + 1);\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (long i = 0; i < grid.size(); ++i) {\n        for (long j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < grid.size(); ++i) {\n        for (long j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += buckets[i];\n                buckets[i] = 0;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            buckets[i]--;\n            result += buckets[i];\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += 1;\n                max_buckets[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (buckets[i] > max_buckets[i]) {\n            ans += buckets[i] - max_buckets[i];\n            buckets[i] = max_buckets[i];\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(capacity, 0);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                buckets[grid[i][j]] += 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > used[i]) {\n            result += buckets[i] - used[i];\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    long count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < capacity) {\n                    ++count;\n                    --buckets[i];\n                }\n            }\n        }\n    }\n    return count;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, max_buckets[i] - buckets[i]);\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (--buckets[i] == 0) {\n                    ++ans;\n                    buckets[i] = capacity;\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (well_count[i] > 0) {\n                    --well_count[i];\n                    --buckets[i];\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] > 0) {\n                    --buckets[i];\n                    ++ans;\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> new_grid = grid;\n                new_grid[i][j] = 0;\n                long fill = max_fill_well(new_grid, capacity);\n                max_fill = std::max(max_fill, fill);\n            }\n        }\n    }\n    return max_fill;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 0;\n            }\n            ans += dp[i][j];\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); k++) {\n                    for (int l = 0; l < grid[0].size(); l++) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (i != k && grid[k][j] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][j] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += well_count[i];\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, buckets[i] - well_count[i]);\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += std::min(dp[i][j], dp[i][j] - 1);\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = std::max(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (dp[i][j] > capacity) {\n                ans += dp[i][j] - capacity;\n                dp[i][j] = capacity;\n            }\n        }\n    }\n    return ans;",
    "    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += max_fill_helper(grid, i, j, capacity);\n            }\n        }\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < m; k++) {\n                if (grid[i][k] == 1) {\n                    dp[i][j] = std::max(dp[i][j], dp[i][k] + 1);\n                }\n            }\n            for (int k = 0; k < m; k++) {\n                if (grid[k][j] == 1) {\n                    dp[i][j] = std::max(dp[i][j], dp[k][j] + 1);\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j] > capacity) {\n                ans += dp[i][j] - capacity;\n            }\n        }\n    }\n    return ans;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            if (buckets[k] < capacity) {\n                                buckets[k] += dp[i][j];\n                                dp[i][j] = 0;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += buckets[i];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); k++) {\n                    for (int l = 0; l < grid[k].size(); l++) {\n                        if (grid[k][l] == 0 && dp[i][j] < dp[i][l] + dp[k][l]) {\n                            dp[i][j] = dp[i][l] + dp[k][l];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j] * capacity;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        ans += max_fill[i] - used[i];\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long max = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max = std::max(max, buckets[i] - capacity);\n            }\n        }\n    }\n    return max;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    long n = grid.size();\n    long m = grid[0].size();\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long result = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                long cur = buckets[i];\n                long next = buckets[i] + capacity;\n                if (next > cur) {\n                    buckets[i] = next;\n                    result += 1;\n                }\n            }\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> well_size(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        well_size[i] = grid[i].size();\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < well_size[i]) {\n                    ++ans;\n                    --buckets[i];\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(n, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i] = std::max(dp[i], dp[i - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        if (dp[i] < capacity) {\n            ans += capacity - dp[i];\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[i].size(), 0));\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (k == i && l == j) continue;\n                        if (grid[k][l] == 1) {\n                            dp[k][l] = std::max(dp[k][l], dp[i][j] + 1);\n                        }\n                    }\n                }\n                max_fill = std::max(max_fill, dp[i][j]);\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> max_visited(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> neighbors = {\n                    std::make_pair(i-1, j),\n                    std::make_pair(i, j-1),\n                    std::make_pair(i+1, j),\n                    std::make_pair(i, j+1)\n                };\n                for (auto neighbor : neighbors) {\n                    if (neighbor.first >= 0 && neighbor.first < grid.size() &&\n                        neighbor.second >= 0 && neighbor.second < grid[i].size() &&\n                        grid[neighbor.first][neighbor.second] == 1) {\n                        buckets[i] -= 1;\n                        buckets[neighbor.first] -= 1;\n                        visited[i] += 1;\n                        visited[neighbor.first] += 1;\n                        if (buckets[i] < 0) {\n                            buckets[i] = 0;\n                        }\n                        if (buckets[neighbor.first] < 0) {\n                            buckets[neighbor.first] = 0;\n                        }\n                        if (visited[i] > max_visited[i]) {\n                            max_visited[i] = visited[i];\n                        }\n                        if (visited[neighbor.first] > max_visited[neighbor.first]) {\n                            max_visited[neighbor.first] = visited[neighbor.first];\n                        }\n                        if (buckets[i] > max_buckets[i]) {\n                            max_buckets[i] = buckets[i];\n                        }\n                        if (buckets[neighbor.first",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > capacity) {\n            result += buckets[i] - capacity;\n            buckets[i] = capacity;\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] -= 1;\n                ans += 1;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(capacity + 1, 0);\n    for (auto& row : grid) {\n        for (long i = 0; i < row.size(); ++i) {\n            if (row[i] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (long i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            result += buckets[i] * i;\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++result;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return result;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        ans = std::max(ans, max_fill[i] - used[i]);\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 0) {\n                            dp[k][l] = std::max(dp[k][l], dp[i][j] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> used_row(grid[0].size(), 0);\n    std::vector<long> used_col(grid[0].size(), 0);\n    std::vector<long> used_well(grid[0].size(), 0);\n    std::vector<long> used_well_row(grid[0].size(), 0);\n    std::vector<long> used_well_col(grid[0].size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                used[i] += 1;\n                used_row[j] += 1;\n                used_col[j] += 1;\n                used_well[j] += 1;\n                used_well_row[i] += 1;\n                used_well_col[i] += 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                if (used[i] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_row[j] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_col[j] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_well[j] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_well_row[i] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_well_col[i] == capacity) {\n                    max_fill += 1;\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long max_buckets = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > max_buckets) {\n            max_buckets = buckets[i];\n        }\n    }\n    long count = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] == max_buckets) {\n            count += max_buckets;\n            for (int j = 0; j < grid.size(); ++j) {\n                if (grid[j][i] == 1) {\n                    --buckets[j];\n                }\n            }\n        }\n    }\n    return count;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> used(m, 0);\n    std::vector<long> used_row(n, 0);\n    std::vector<long> used_col(m, 0);\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ++used_row[i];\n                ++used_col[j];\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                if (used_row[i] > 0) {\n                    --used_row[i];\n                    ++used[j];\n                }\n                if (used_col[j] > 0) {\n                    --used_col[j];\n                    ++used[j];\n                }\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                if (used[j] > 0) {\n                    --used[j];\n                    ++ans;\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(m, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[j] = std::max(dp[j], 1 + max_fill(grid, capacity - 1));\n            }\n        }\n    }\n    return std::max(dp[m - 1], 0);",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                long max_fill_i = max_fill[i];\n                for (int k = j + 1; k < grid[i].size(); ++k) {\n                    if (grid[i][k] == 1) {\n                        max_fill_i += max_fill[k];\n                    }\n                }\n                if (max_fill_i > max_fill[j]) {\n                    max_fill[j] = max_fill_i;\n                }\n            }\n        }\n    }\n    long max_fill_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_fill[i] > 0) {\n            max_fill_count += max_fill[i];\n        }\n    }\n    return max_fill_count;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                well_count[i]++;\n                buckets[i]++;\n                if (buckets[i] > capacity) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_count[i] > 0) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1 && visited[i] == 0) {\n                    visited[i] = 1;\n                    ans += well_count[i];\n                    buckets[i]--;\n                    if (buckets[i] < 0) {\n                        buckets[i] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return ans;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> well_pos;\n                well_pos.push_back(std::make_pair(i, j));\n                while (!well_pos.empty()) {\n                    auto pos = well_pos.back();\n                    well_pos.pop_back();\n                    if (grid[pos.first][pos.second] == 0) {\n                        grid[pos.first][pos.second] = -1;\n                    } else {\n                        grid[pos.first][pos.second]--;\n                        if (grid[pos.first][pos.second] == 0) {\n                            well_pos.push_back(std::make_pair(pos.first, pos.second));\n                        }\n                    }\n                }\n                max_fill = std::max(max_fill, well_pos.size());\n            }\n        }\n    }\n    return max_fill;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(m, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[j] = std::max(dp[j], dp[j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < m; ++i) {\n        ans = std::max(ans, dp[i]);\n    }\n    return ans;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n            }\n        }\n        if (buckets.back() == 0) {\n            break;\n        }\n    }\n    return ans;",
    "    std::vector<long> well_count(grid.size(), 0);\n    std::vector<long> well_capacity(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_count[i] += grid[i][j];\n            well_capacity[i] += capacity;\n        }\n    }\n    std::vector<long> well_remaining(grid.size(), 0);\n    std::vector<long> well_water(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        well_remaining[i] = well_count[i];\n        well_water[i] = 0;\n    }\n    std::vector<std::vector<long>> well_buckets(grid.size(), std::vector<long>(capacity, 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_buckets[i][well_water[i]++] = j;\n        }\n    }\n    long result = 0;\n    while (well_remaining.size() > 0) {\n        std::vector<long> next_well_remaining(well_remaining);\n        for (int i = 0; i < well_remaining.size(); ++i) {\n            if (well_remaining[i] > 0) {\n                long bucket = well_buckets[i][well_remaining[i] - 1];\n                well_remaining[i]--;\n                well_water[i]--;\n                well_buckets[i][well_water[i]] = bucket;\n                well_remaining[well_buckets[i][well_water[i]]]++;\n                well_water[well_buckets[i][well_water[i]]]++;\n            }\n        }\n        result += well_remaining.size();\n        well_remaining = next_well_remaining;\n    }\n    return result;",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> used(grid.size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                long cur_fill = 0;\n                while (cur_fill < grid[i].size() && grid[i][j] == 1) {\n                    ++cur_fill;\n                    ++used[i];\n                    ++used[j];\n                    if (cur_fill == grid[i].size()) {\n                        break;\n                    }\n                    if (grid[i][j] == 1) {\n                        ++used[i];\n                        ++used[j];\n                    }\n                }\n                max_fill = std::max(max_fill, cur_fill);\n            }\n        }\n    }\n    for (int i = 0; i < used.size(); ++i) {\n        if (used[i] == 0) {\n            return max_fill;\n        }\n    }\n    return max_fill + (capacity - used.size());",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            for (int k = 0; k < grid.size(); ++k) {\n                for (int l = 0; l < grid[k].size(); ++l) {\n                    if (grid[k][l] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][l] + dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][0] - 1;",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                buckets[i] -= 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (buckets[i] > 0) {\n            result += 1;\n            buckets[i] -= 1;\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                max_fill += 1;\n                if (max_fill > capacity) {\n                    max_fill -= 1;\n                    break;\n                }\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> visited_row(grid[0].size(), 0);\n    std::vector<long> visited_col(grid[0].size(), 0);\n    long count = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                count++;\n                visited[i] = 1;\n                visited_row[j] = 1;\n                visited_col[j] = 1;\n                buckets[i]++;\n                if (buckets[i] > capacity) {\n                    buckets[i] = capacity;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (visited[i] == 1 && visited_row[j] == 1 && visited_col[j] == 1) {\n                buckets[i]--;\n                if (buckets[i] < 0) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    return count;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                --ans;\n            }\n        }\n        if (ans == 0) {\n            break;\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                buckets[i] += 1;\n                if (buckets[i] > capacity) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (dp[i][j] == 1) {\n                ans += 1;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++result;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return result;",
    "    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> buckets;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            buckets.push_back(std::make_pair(k, l));\n                        }\n                    }\n                }\n                std::sort(buckets.begin(), buckets.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                    return a.first < b.first || (a.first == b.first && a.second < b.second);\n                });\n                for (int k = 0; k < buckets.size(); ++k) {\n                    if (buckets[k].first == i && buckets[k].second == j) {\n                        continue;\n                    }\n                    std::vector<std::pair<int, int>> new_buckets;\n                    for (int l = 0; l < buckets.size(); ++l) {\n                        if (buckets[l].first == i || buckets[l].second == j) {\n                            continue;\n                        }\n                        new_buckets.push_back(buckets[l]);\n                    }\n                    std::sort(new_buckets.begin(), new_buckets.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                        return a.first < b.first || (a.first == b.first && a.second < b.second);\n                    });\n                    long num_buckets = new_buckets.size();\n                    long num_water = num_buckets * capacity;\n                    if (num_water > buckets[k].first * buckets[k].second) {\n                        result += num_buckets - 1;\n                        break;\n                    }\n",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 0) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == 1) {\n                for (long k = 0; k < m; ++k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][k] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == capacity) {\n                ans += 1;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < max_buckets[i]) {\n                    ++ans;\n                    --buckets[i];\n                    --max_buckets[i];\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> well_size(grid.size(), 0);\n    std::vector<long> well_cap(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_size[i] += grid[i][j];\n            well_cap[i] += grid[i][j] * capacity;\n        }\n    }\n    std::vector<long> well_level(grid.size(), 0);\n    std::vector<long> well_flow(grid.size(), 0);\n    std::vector<long> well_flow_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_level[i] += grid[i][j];\n            well_flow[i] += grid[i][j] * capacity;\n            well_flow_count[i] += grid[i][j];\n        }\n    }\n    std::vector<long> well_level_count(grid.size(), 0);\n    std::vector<long> well_flow_count_count(grid.size(), 0);\n    std::vector<long> well_level_flow(grid.size(), 0);\n    std::vector<long> well_level_flow_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_level_count[i] += grid[i][j];\n            well_level_flow[i] += grid[i][j] * capacity;\n            well_level_flow_count[i] += grid[i][j];\n        }\n    }\n    std::vector<long> well_level_flow_count_count(grid.size(), 0);\n    std::vector<long> well_level_flow_count_flow(grid.size(), 0);\n    std::vector<long> well_level_",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;",
    "    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += max_fill_well(grid, i, j, capacity);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans + 1);\n            }\n        }\n    }\n    return ans + 1;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill += capacity;\n                grid[i][j] = 0;\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++count[i];\n                buckets[i] -= 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (count[i] > 0) {\n            result += count[i] * buckets[i];\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < max_fill[i]) {\n                    used[i] += max_fill[i];\n                }\n                max_fill[i] = 0;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (used[i] < max_fill[i]) {\n            result += max_fill[i] - used[i];\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += dp[i][j];\n            }\n        }\n    }\n    return result;",
    "    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i]--;\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_buckets[i] < buckets[i]) {\n            ans++;\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > capacity) {\n            result += buckets[i] - capacity;\n            buckets[i] = capacity;\n        }\n    }\n    return result;",
    "    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> new_grid = grid;\n                new_grid[i][j] = 0;\n                max_fill += max_fill_well(new_grid, capacity);\n            }\n        }\n    }\n    return max_fill;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;",
    "    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                --buckets[i];\n                if (buckets[i] < 0) {\n                    ++ans;\n                    buckets[i] = capacity;\n                }\n            }\n        }\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n        ans = std::max(ans, dp[i][0]);\n    }\n    return ans;",
    "    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];",
    "    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == 1) {\n                for (long k = 0; k < m; ++k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][k] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == 1) {\n                ans += capacity;\n            }\n        }\n    }\n    return ans;"
  ],
  "stop_tokens": [
    "\n}"
  ]
}