{
  "name": "HumanEval_132_is_nested",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n",
  "tests": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp20zwtxzl: /tmp/tmp20zwtxzl.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            } else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpx92kesso: /tmp/tmpx92kesso.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        if (string[i] == ']') {\n            close++;\n        }\n        if (open > close) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp_x04h85m: /tmp/tmp_x04h85m.cpp:36: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp20zwtxzl: /tmp/tmp20zwtxzl.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpp1ge1wtn: /tmp/tmpp1ge1wtn.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push('[');\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmprtzrerf1: /tmp/tmprtzrerf1.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while(i < string.length()) {\n        if(string[i] == '[') {\n            j++;\n        }\n        if(string[i] == ']') {\n            j--;\n        }\n        if(j < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmphcr2veu9: /tmp/tmphcr2veu9.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            } else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpx92kesso: /tmp/tmpx92kesso.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while(i < string.size()) {\n        if(string[i] == '[') {\n            j = i;\n            while(j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if(j == string.size()) {\n                return false;\n            }\n            if(string[j + 1] == ']') {\n                i = j + 2;\n            } else {\n                i = j + 1;\n            }\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmprskk1qim: /tmp/tmprskk1qim.cpp:44: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpe_6uzv9q: /tmp/tmpe_6uzv9q.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpuurr037c: /tmp/tmpuurr037c.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            } else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpx92kesso: /tmp/tmpx92kesso.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    if (string.size() == 1) return false;\n    if (string[0] == '[') return true;\n    if (string[0] == ']') return false;\n    if (string[0] == ']') return false;\n    if (string[string.size() - 1] == ']') return false;\n    if (string[string.size() - 1] == '[') return true;\n    if (string[string.size() - 1] == ']') return false;\n    if (string[string.size() - 2] == ']') return false;\n    if (string[string.size() - 2] == '[') return true;\n    if (string[string.size() - 2] == ']') return false;\n    if (string[string.size() - 3] == ']') return false;\n    if (string[string.size() - 3] == '[') return true;\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmplzmqd0bn: /tmp/tmplzmqd0bn.cpp:37: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            if (i + 1 < len && string[i + 1] == '[') {\n                i++;\n            } else {\n                return false;\n            }\n        } else if (string[i] == ']') {\n            if (i + 1 < len && string[i + 1] == ']') {\n                i++;\n            } else {\n                return false;\n            }\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpq6_f55ll: /tmp/tmpq6_f55ll.cpp:48: int main(): Assertion `candidate((\"[][][[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpe_6uzv9q: /tmp/tmpe_6uzv9q.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j == string.size()) {\n                return false;\n            }\n            if (string[j + 1] == ']') {\n                i = j + 2;\n                continue;\n            }\n            if (string[j + 1] == '[') {\n                i = j + 2;\n                continue;\n            }\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp9zrzbcnf: /tmp/tmp9zrzbcnf.cpp:48: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.length() && string[j] != ']') {\n                j++;\n            }\n            if (j == string.length()) {\n                return false;\n            }\n            if (string[j + 1] == ']') {\n                i = j + 2;\n            } else {\n                i = j + 1;\n            }\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmps3oa62hd: /tmp/tmps3oa62hd.cpp:44: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0, j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.size() && string[j] == ']') {\n                i = j + 1;\n            }\n        } else {\n            i++;\n        }\n    }\n    return i == string.size();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpm5fp_p88: /tmp/tmpm5fp_p88.cpp:38: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        if (string[i] == ']') {\n            close++;\n        }\n        if (open > close) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp_x04h85m: /tmp/tmp_x04h85m.cpp:36: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open_brackets = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open_brackets++;\n        }\n        else if (string[i] == ']') {\n            if (open_brackets == 0) {\n                return false;\n            }\n            open_brackets--;\n        }\n    }\n    return open_brackets == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpwzplqfdo: /tmp/tmpwzplqfdo.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpe_6uzv9q: /tmp/tmpe_6uzv9q.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpdfazfzgi: /tmp/tmpdfazfzgi.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpz49bik6j: /tmp/tmpz49bik6j.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpskx7twp7: /tmp/tmpskx7twp7.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open_brackets = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open_brackets++;\n        }\n        if (string[i] == ']') {\n            open_brackets--;\n        }\n        if (open_brackets < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpiuqddtbe: /tmp/tmpiuqddtbe.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpneojszex: /tmp/tmpneojszex.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp64uhy2ev: /tmp/tmp64uhy2ev.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpskx7twp7: /tmp/tmpskx7twp7.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpnrel24fs: /tmp/tmpnrel24fs.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpg3_7tnd0: /tmp/tmpg3_7tnd0.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            stack.push('[');\n        }\n        else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpv7qxbfn9: /tmp/tmpv7qxbfn9.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpzt2qh3pf: /tmp/tmpzt2qh3pf.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0, j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            if (j == i) {\n                j++;\n            }\n            else {\n                j = i;\n            }\n        }\n        else if (string[i] == ']') {\n            if (j == i) {\n                j++;\n            }\n            else {\n                j = i;\n            }\n        }\n        i++;\n    }\n    return j == i;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmp9c4w58os: /tmp/tmp9c4w58os.cpp:44: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open_brackets = 0;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            open_brackets++;\n        } else if (string[i] == ']') {\n            open_brackets--;\n        }\n        if (open_brackets < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpw2athg3w: /tmp/tmpw2athg3w.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp20zwtxzl: /tmp/tmp20zwtxzl.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpnrel24fs: /tmp/tmpnrel24fs.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    if (string[0] == '[') {\n        if (string.back() == ']') {\n            return true;\n        }\n        else {\n            return is_nested(string.substr(1, string.size() - 2));\n        }\n    }\n    else {\n        return false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpmsidtjtk: /tmp/tmpmsidtjtk.cpp:35: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpneojszex: /tmp/tmpneojszex.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpuurr037c: /tmp/tmpuurr037c.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(auto c : string) {\n        if(c == '[') {\n            stack.push('[');\n        } else if(c == ']') {\n            if(stack.empty() || stack.top() != '[') {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpe2hp__0p: /tmp/tmpe2hp__0p.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.length() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.length() && string[j] == ']') {\n                i = j + 1;\n                j = i;\n                while (j < string.length() && string[j] != ']') {\n                    j++;\n                }\n                if (j < string.length() && string[j] == ']') {\n                    i = j + 1;\n                    j = i;\n                    while (j < string.length() && string[j] != ']') {\n                        j++;\n                    }\n                    if (j < string.length() && string[j] == ']') {\n                        i = j + 1;\n                        j = i;\n                        while (j < string.length() && string[j] != ']') {\n                            j++;\n                        }\n                        if (j < string.length() && string[j] == ']') {\n                            i = j + 1;\n                            j = i;\n                            while (j < string.length() && string[j] != ']') {\n                                j++;\n                            }\n                            if (j < string.length() && string[j] == ']') {\n                                i = j + 1;\n                                j = i;\n                                while (j < string.length() && string[j] != ']') {\n                                    j++;\n                                }\n                                if (j < string.length() && string[j] == ']') {\n                                    i = j + 1;\n                                    j = i;\n                                    while (j < string.length() && string[j] != ']') {\n                                        j++;\n                                    }\n                                    if (j < string.length() && string[j] == ']') {\n                                        i = j + 1;\n                                        j = i;\n                                        while (j < string.length() && string[j] != ']') {\n                                \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "/tmp/tmpaf7offh1.cpp: In function \u2018bool is_nested(std::string)\u2019:\n/tmp/tmpaf7offh1.cpp:69:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n/tmp/tmpaf7offh1.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpaf7offh1.cpp:63:82: note: to match this \u2018{\u2019\n   63 |                                     if (j < string.length() && string[j] == ']') {\n      |                                                                                  ^\n/tmp/tmpaf7offh1.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpaf7offh1.cpp:57:78: note: to match this \u2018{\u2019\n   57 |                                 if (j < string.length() && string[j] == ']') {\n      |                                                                              ^\n/tmp/tmpaf7offh1.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpaf7offh1.cpp:51:74: note: to match this \u2018{\u2019\n   51 |                             if (j < string.length() && string[j] == ']') {\n      |                                                                          ^\n/tmp/tmpaf7offh1.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpaf7offh1.cpp:45:70: note: to match this \u2018{\u2019\n   45 |                         if (j < string.length() && string[j] == ']') {\n      |                                                                      ^\n/tmp/tmpaf7offh1.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpaf7offh1.cpp:39:66: note: to match this \u2018{\u2019\n   39 |                     if (j < string.length() && string[j] == ']') {\n      |                                                                  ^\n/tmp/tmpaf7offh1.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpaf7offh1.cpp:33:62: note: to match this \u2018{\u2019\n   33 |                 if (j < string.length() && string[j] == ']') {\n      |                                                              ^\n/tmp/tmpa",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpzt2qh3pf: /tmp/tmpzt2qh3pf.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpdq8a81ef: /tmp/tmpdq8a81ef.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    int j = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < len && string[j] != ']') {\n                j++;\n            }\n            if (j < len && string[j] == ']') {\n                i = j + 1;\n                j = i;\n                while (j < len && string[j] != ']') {\n                    j++;\n                }\n                if (j < len && string[j] == ']') {\n                    i = j + 1;\n                    j = i;\n                    while (j < len && string[j] != ']') {\n                        j++;\n                    }\n                    if (j < len && string[j] == ']') {\n                        i = j + 1;\n                        j = i;\n                        while (j < len && string[j] != ']') {\n                            j++;\n                        }\n                        if (j < len && string[j] == ']') {\n                            i = j + 1;\n                            j = i;\n                            while (j < len && string[j] != ']') {\n                                j++;\n                            }\n                            if (j < len && string[j] == ']') {\n                                i = j + 1;\n                                j = i;\n                                while (j < len && string[j] != ']') {\n                                    j++;\n                                }\n                                if (j < len && string[j] == ']') {\n                                    i = j + 1;\n                                    j = i;\n                                    while (j < len && string[j] != ']') {\n                                        j++;\n                                    }\n                                    if (j < len && string[j] == ']') {\n                                        i = j + 1;\n                                        j = i;\n                                        while (j < len && string[j] != ']') {\n                                            j++;\n                                        }\n                                        if (j < len && string[j] == ']')\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "/tmp/tmpw94lia55.cpp: In function \u2018bool is_nested(std::string)\u2019:\n/tmp/tmpw94lia55.cpp:72:1: error: expected primary-expression before \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmpw94lia55.cpp:73:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n/tmp/tmpw94lia55.cpp:89:1: error: expected \u2018}\u2019 at end of input\n   89 | }\n      | ^\n/tmp/tmpw94lia55.cpp:59:66: note: to match this \u2018{\u2019\n   59 |                                 if (j < len && string[j] == ']') {\n      |                                                                  ^\n/tmp/tmpw94lia55.cpp:89:1: error: expected \u2018}\u2019 at end of input\n   89 | }\n      | ^\n/tmp/tmpw94lia55.cpp:53:62: note: to match this \u2018{\u2019\n   53 |                             if (j < len && string[j] == ']') {\n      |                                                              ^\n/tmp/tmpw94lia55.cpp:89:1: error: expected \u2018}\u2019 at end of input\n   89 | }\n      | ^\n/tmp/tmpw94lia55.cpp:47:58: note: to match this \u2018{\u2019\n   47 |                         if (j < len && string[j] == ']') {\n      |                                                          ^\n/tmp/tmpw94lia55.cpp:89:1: error: expected \u2018}\u2019 at end of input\n   89 | }\n      | ^\n/tmp/tmpw94lia55.cpp:41:54: note: to match this \u2018{\u2019\n   41 |                     if (j < len && string[j] == ']') {\n      |                                                      ^\n/tmp/tmpw94lia55.cpp:89:1: error: expected \u2018}\u2019 at end of input\n   89 | }\n      | ^\n/tmp/tmpw94lia55.cpp:35:50: note: to match this \u2018{\u2019\n   35 |                 if (j < len && string[j] == ']') {\n      |                                                  ^\n/tmp/tmpw94lia55.cpp:89:1: error: expected \u2018}\u2019 at end of input\n   89 | }\n      | ^\n/tmp/tmpw94lia55.cpp:29:46: note: to match this \u2018{\u2019\n   29 |             if (j < len && string[j] == ']') {\n      |                                              ^\n/tmp/tmpw94lia55.cpp:89:1: error: expected \u2018}\u2019 at end of input\n   89 | }\n      | ^\n/tmp/tmpw94",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    int j = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            j = i;\n            while (i < len && string[i] != ']') {\n                i++;\n            }\n            if (i == len) return false;\n            if (string[i] == ']') {\n                i++;\n                if (i < len && string[i] == '[') {\n                    i++;\n                    j = i;\n                    while (i < len && string[i] != ']') {\n                        i++;\n                    }\n                    if (i == len) return false;\n                    if (string[i] == ']') {\n                        i++;\n                    }\n                }\n            }\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpn4kubon3: /tmp/tmpn4kubon3.cpp:52: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        if (string[i] == ']') {\n            close++;\n        }\n        if (open > close) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp_x04h85m: /tmp/tmp_x04h85m.cpp:36: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpe_6uzv9q: /tmp/tmpe_6uzv9q.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            } else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpx92kesso: /tmp/tmpx92kesso.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    if (string.size() == 1) return false;\n    if (string.size() == 2) return string[0] == '[' && string[1] == ']';\n    if (string[0] == '[' && string[1] == ']') return true;\n    if (string[0] == '[' && string[1] == '[') return true;\n    if (string[0] == ']' && string[1] == ']') return true;\n    if (string[0] == ']' && string[1] == '[') return true;\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpgqmi6w1n: /tmp/tmpgqmi6w1n.cpp:31: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpqxl28w72: /tmp/tmpqxl28w72.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    int j = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            if (j == 0) {\n                j = i;\n            }\n            else {\n                if (string[j] == '[' && i - j > 1) return true;\n                j = 0;\n            }\n        }\n        else {\n            if (string[i] == ']') {\n                if (j == 0) {\n                    j = i;\n                }\n                else {\n                    if (string[j] == ']' && i - j > 1) return true;\n                    j = 0;\n                }\n            }\n        }\n        i++;\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpcjusoj3v: /tmp/tmpcjusoj3v.cpp:50: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpdq8a81ef: /tmp/tmpdq8a81ef.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[' && i < string.length() - 1 && string[i + 1] == ']') {\n                stack.pop();\n                stack.push(']');\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmp790ehpid: /tmp/tmp790ehpid.cpp:38: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpdq8a81ef: /tmp/tmpdq8a81ef.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpzt2qh3pf: /tmp/tmpzt2qh3pf.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(auto c : string) {\n        if(c == '[') {\n            stack.push(c);\n        } else if(c == ']') {\n            if(stack.empty()) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmp1kkf31zw: /tmp/tmp1kkf31zw.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) {\n        return false;\n    }\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            }\n            open--;\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpiabsg5c1: /tmp/tmpiabsg5c1.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(int i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n            stack.push('[');\n        }\n        else if(string[i] == ']') {\n            if(stack.empty()) {\n                return false;\n            }\n            if(stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n                stack.pop();\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpngh5rqbz: /tmp/tmpngh5rqbz.cpp:41: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        }\n        else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            }\n            else {\n                stack.push(']');\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmp9eyl63s5: /tmp/tmp9eyl63s5.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            stack.push(string[i]);\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmp9uotu_ys: /tmp/tmp9uotu_ys.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            } else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpx92kesso: /tmp/tmpx92kesso.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n            stack.push('[');\n        }\n        else if(string[i] == ']') {\n            if(stack.empty()) {\n                return false;\n            }\n            if(stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpjuubszga: /tmp/tmpjuubszga.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if(string.size() == 0) return false;\n    int count = 0;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n            count++;\n        }\n        if(string[i] == ']') {\n            count--;\n        }\n        if(count < 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpy5nfbzek: /tmp/tmpy5nfbzek.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            s.push(string[i]);\n        } else if (string[i] == ']') {\n            if (s.empty()) {\n                return false;\n            } else if (s.top() == '[') {\n                s.pop();\n            } else {\n                s.push(string[i]);\n            }\n        }\n    }\n    return s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpqbc79b8f: /tmp/tmpqbc79b8f.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        }\n        else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            else if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpk7b7i4a6: /tmp/tmpk7b7i4a6.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.size() && string[j] == ']') {\n                i = j + 1;\n                j = i;\n                while (j < string.size() && string[j] != ']') {\n                    j++;\n                }\n                if (j < string.size() && string[j] == ']') {\n                    i = j + 1;\n                    j = i;\n                    while (j < string.size() && string[j] != ']') {\n                        j++;\n                    }\n                    if (j < string.size() && string[j] == ']') {\n                        i = j + 1;\n                        j = i;\n                        while (j < string.size() && string[j] != ']') {\n                            j++;\n                        }\n                        if (j < string.size() && string[j] == ']') {\n                            i = j + 1;\n                            j = i;\n                            while (j < string.size() && string[j] != ']') {\n                                j++;\n                            }\n                            if (j < string.size() && string[j] == ']') {\n                                i = j + 1;\n                                j = i;\n                                while (j < string.size() && string[j] != ']') {\n                                    j++;\n                                }\n                                if (j < string.size() && string[j] == ']') {\n                                    i = j + 1;\n                                    j = i;\n                                    while (j < string.size() && string[j] != ']') {\n                                        j++;\n                                    }\n                                    if (j < string.size() && string[j] == ']') {\n                                        i = j + 1;\n                                        j = i;\n                                        while (j < string.size() && string[j] != ']') {\n                                \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "/tmp/tmpauom3guq.cpp: In function \u2018bool is_nested(std::string)\u2019:\n/tmp/tmpauom3guq.cpp:69:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:63:80: note: to match this \u2018{\u2019\n   63 |                                     if (j < string.size() && string[j] == ']') {\n      |                                                                                ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:57:76: note: to match this \u2018{\u2019\n   57 |                                 if (j < string.size() && string[j] == ']') {\n      |                                                                            ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:51:72: note: to match this \u2018{\u2019\n   51 |                             if (j < string.size() && string[j] == ']') {\n      |                                                                        ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:45:68: note: to match this \u2018{\u2019\n   45 |                         if (j < string.size() && string[j] == ']') {\n      |                                                                    ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:39:64: note: to match this \u2018{\u2019\n   39 |                     if (j < string.size() && string[j] == ']') {\n      |                                                                ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:33:60: note: to match this \u2018{\u2019\n   33 |                 if (j < string.size() && string[j] == ']') {\n      |                                                            ^\n/tmp/tmpauom3guq.cpp:85:1: error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpitjlssla: /tmp/tmpitjlssla.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            if (i + 1 < len && string[i + 1] == '[') {\n                i += 2;\n            } else {\n                i += 1;\n            }\n        } else {\n            i += 1;\n        }\n    }\n    return i == len;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpwalg7ljp: /tmp/tmpwalg7ljp.cpp:38: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp20zwtxzl: /tmp/tmp20zwtxzl.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(']');\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmp9ynfabzn: /tmp/tmp9ynfabzn.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            open--;\n            if (open < 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpj90np_zl: /tmp/tmpj90np_zl.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpuurr037c: /tmp/tmpuurr037c.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphgwnqrl6: /tmp/tmphgwnqrl6.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpneojszex: /tmp/tmpneojszex.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0, j = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.length() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.length()) {\n                if (string[j + 1] == '[') {\n                    i = j + 2;\n                } else {\n                    return true;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            i++;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpf5bwcvg7: /tmp/tmpf5bwcvg7.cpp:44: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            stack.push('[');\n        }\n        else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[' && i < string.size() - 1 && string[i + 1] == '[') {\n                stack.pop();\n                stack.push('[');\n                i++;\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpvnuzt12a: /tmp/tmpvnuzt12a.cpp:44: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpc02qkmkb: /tmp/tmpc02qkmkb.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0, j = 0, count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpykmpaw9h: /tmp/tmpykmpaw9h.cpp:38: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            }\n            open--;\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmph4lnkjuw: /tmp/tmph4lnkjuw.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.size() == 0) return false;\n    if (string[0] == '[') {\n        for (int i = 1; i < string.size(); i++) {\n            if (string[i] == '[') {\n                if (i + 1 < string.size() && string[i + 1] == '[') {\n                    i++;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpd5k9j92f: /tmp/tmpd5k9j92f.cpp:36: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphxnnzz9d: /tmp/tmphxnnzz9d.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    int open = 0;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            if (open == 0) {\n                open = 1;\n            } else {\n                open++;\n            }\n        } else if (string[i] == ']') {\n            if (open == 1) {\n                open--;\n            } else {\n                open--;\n            }\n        }\n        if (open == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmp5jib1jp0: /tmp/tmp5jib1jp0.cpp:43: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if(string.empty()) return false;\n    if(string[0]=='[') return false;\n    int count=0;\n    for(int i=0;i<string.size();i++) {\n        if(string[i]=='[') count++;\n        if(string[i]==']') count--;\n        if(count<0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmph1hr6pah: /tmp/tmph1hr6pah.cpp:31: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    if (string[0] == '[') {\n        int count = 1;\n        for (int i = 1; i < string.size(); i++) {\n            if (string[i] == '[') count++;\n            else if (string[i] == ']') {\n                count--;\n                if (count == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpif_3uihu: /tmp/tmpif_3uihu.cpp:37: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            stack.push(string[i]);\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(string[i]);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpbdir1rn5: /tmp/tmpbdir1rn5.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpz49bik6j: /tmp/tmpz49bik6j.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.size() && string[j] == ']') {\n                i = j + 1;\n                j = i;\n                while (j < string.size() && string[j] != ']') {\n                    j++;\n                }\n                if (j < string.size() && string[j] == ']') {\n                    i = j + 1;\n                    j = i;\n                    while (j < string.size() && string[j] != ']') {\n                        j++;\n                    }\n                    if (j < string.size() && string[j] == ']') {\n                        i = j + 1;\n                        j = i;\n                        while (j < string.size() && string[j] != ']') {\n                            j++;\n                        }\n                        if (j < string.size() && string[j] == ']') {\n                            i = j + 1;\n                            j = i;\n                            while (j < string.size() && string[j] != ']') {\n                                j++;\n                            }\n                            if (j < string.size() && string[j] == ']') {\n                                i = j + 1;\n                                j = i;\n                                while (j < string.size() && string[j] != ']') {\n                                    j++;\n                                }\n                                if (j < string.size() && string[j] == ']') {\n                                    i = j + 1;\n                                    j = i;\n                                    while (j < string.size() && string[j] != ']') {\n                                        j++;\n                                    }\n                                    if (j < string.size() && string[j] == ']') {\n                                        i = j + 1;\n                                        j = i;\n                                        while (j < string.size() && string[j] != ']') {\n                                \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "/tmp/tmpauom3guq.cpp: In function \u2018bool is_nested(std::string)\u2019:\n/tmp/tmpauom3guq.cpp:69:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:63:80: note: to match this \u2018{\u2019\n   63 |                                     if (j < string.size() && string[j] == ']') {\n      |                                                                                ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:57:76: note: to match this \u2018{\u2019\n   57 |                                 if (j < string.size() && string[j] == ']') {\n      |                                                                            ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:51:72: note: to match this \u2018{\u2019\n   51 |                             if (j < string.size() && string[j] == ']') {\n      |                                                                        ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:45:68: note: to match this \u2018{\u2019\n   45 |                         if (j < string.size() && string[j] == ']') {\n      |                                                                    ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:39:64: note: to match this \u2018{\u2019\n   39 |                     if (j < string.size() && string[j] == ']') {\n      |                                                                ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:33:60: note: to match this \u2018{\u2019\n   33 |                 if (j < string.size() && string[j] == ']') {\n      |                                                            ^\n/tmp/tmpauom3guq.cpp:85:1: error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n            stack.push('[');\n        }\n        else if(string[i] == ']') {\n            if(stack.empty()) {\n                return false;\n            }\n            if(stack.top() == '[' && i != 0) {\n                stack.pop();\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmp4afqsd3e: /tmp/tmp4afqsd3e.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphxnnzz9d: /tmp/tmphxnnzz9d.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j == string.size()) {\n                return false;\n            }\n            if (string[j - 1] == ']') {\n                i = j + 1;\n            }\n            else {\n                i = j;\n            }\n        }\n        else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpvg37hjo8: /tmp/tmpvg37hjo8.cpp:46: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push('[');\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpxx47yj2g: /tmp/tmpxx47yj2g.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpc02qkmkb: /tmp/tmpc02qkmkb.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpuurr037c: /tmp/tmpuurr037c.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphgwnqrl6: /tmp/tmphgwnqrl6.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpnrel24fs: /tmp/tmpnrel24fs.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n            count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n        }\n        if(count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpufpnbatn: /tmp/tmpufpnbatn.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            stack.push('[');\n        }\n        else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[' && i == string.size() - 1) {\n                stack.pop();\n                return true;\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmp_53ibmp_: /tmp/tmp_53ibmp_.cpp:43: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            }\n            open--;\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmp2ymdh6rh: /tmp/tmp2ymdh6rh.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpc02qkmkb: /tmp/tmpc02qkmkb.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            stack.push('[');\n        }\n        else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            else if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpemvbnqwf: /tmp/tmpemvbnqwf.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0, j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.size() && string[j] == ']') {\n                i = j + 1;\n            }\n        } else {\n            i++;\n        }\n    }\n    return i == string.size();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpm5fp_p88: /tmp/tmpm5fp_p88.cpp:38: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    int j = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            if (j == i) {\n                j++;\n                i++;\n                continue;\n            }\n            if (string[j] == '[' && string[i] == '[') {\n                i++;\n                j++;\n                continue;\n            }\n            else return false;\n        }\n        else if (string[i] == ']') {\n            if (j == i) {\n                j++;\n                i++;\n                continue;\n            }\n            if (string[j] == ']' && string[i] == ']') {\n                i++;\n                j++;\n                continue;\n            }\n            else return false;\n        }\n        else {\n            i++;\n            j++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpm480keeq: /tmp/tmpm480keeq.cpp:60: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j == string.size()) {\n                return false;\n            }\n            if (string[j - 1] == ']') {\n                return true;\n            }\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmp_za087ny: /tmp/tmp_za087ny.cpp:42: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            } else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpx92kesso: /tmp/tmpx92kesso.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            s.push(string[i]);\n        } else if (string[i] == ']') {\n            if (s.empty()) {\n                return false;\n            } else {\n                s.pop();\n            }\n        }\n    }\n    return s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmp05gyudu1: /tmp/tmp05gyudu1.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpqxl28w72: /tmp/tmpqxl28w72.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpqxl28w72: /tmp/tmpqxl28w72.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    int j = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < len && string[j] != ']') {\n                j++;\n            }\n            if (j == len) return false;\n            if (string[j + 1] == ']') {\n                i = j + 2;\n            } else {\n                i = j + 1;\n            }\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpqi1q10l4: /tmp/tmpqi1q10l4.cpp:44: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty() || stack.top() != '[') {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpn50q7pv9: /tmp/tmpn50q7pv9.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open_bracket = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open_bracket++;\n        } else if (string[i] == ']') {\n            if (open_bracket == 0) {\n                return false;\n            } else {\n                open_bracket--;\n            }\n        }\n    }\n    return open_bracket == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpwsqsj2nu: /tmp/tmpwsqsj2nu.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if(string.size() == 0)\n        return false;\n    if(string[0] == '[')\n        return true;\n    if(string[0] == ']')\n        return false;\n    for(int i = 1; i < string.size(); i++) {\n        if(string[i] == '[' && string[i-1] != '[')\n            return true;\n        if(string[i] == ']' && string[i-1] != ']')\n            return false;\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpl9q2dlu8: /tmp/tmpl9q2dlu8.cpp:36: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for (auto c : string) {\n        if (c == '[') {\n            s.push(c);\n        }\n        else if (c == ']') {\n            if (s.empty()) {\n                return false;\n            }\n            else {\n                s.pop();\n            }\n        }\n    }\n    return s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmplvjgtgy0: /tmp/tmplvjgtgy0.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            s.push(string[i]);\n        }\n        else if (string[i] == ']') {\n            if (s.empty()) {\n                return false;\n            }\n            else if (s.top() == '[') {\n                s.pop();\n            }\n            else {\n                s.push(string[i]);\n            }\n        }\n    }\n    return s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpy7yv7d00: /tmp/tmpy7yv7d00.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            stack.push('[');\n        }\n        else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            }\n            else {\n                stack.push(']');\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpt8mf2irq: /tmp/tmpt8mf2irq.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.pop();\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpi9nuw1iz: /tmp/tmpi9nuw1iz.cpp:41: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0, j = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            if (j == 0) {\n                j = i;\n            }\n            else {\n                if (string[j] == ']') {\n                    if (string[i + 1] == '[') {\n                        i += 2;\n                        j = i;\n                    }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    j = i;\n                }\n            }\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmp_vf426kz: /tmp/tmp_vf426kz.cpp:47: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpc02qkmkb: /tmp/tmpc02qkmkb.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpc02qkmkb: /tmp/tmpc02qkmkb.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmp8gd_gsql: /tmp/tmp8gd_gsql.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpqxl28w72: /tmp/tmpqxl28w72.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpqxl28w72: /tmp/tmpqxl28w72.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.size()) {\n                i = j + 1;\n                j = i;\n                while (j < string.size() && string[j] != ']') {\n                    j++;\n                }\n                if (j < string.size()) {\n                    i = j + 1;\n                }\n            }\n        }\n        i++;\n    }\n    return i == string.size();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmp4g_ekpfv: /tmp/tmp4g_ekpfv.cpp:44: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpxhnnd0u4: /tmp/tmpxhnnd0u4.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(auto c : string) {\n        if(c == '[') {\n            stack.push(c);\n        } else {\n            if(stack.empty()) {\n                return false;\n            }\n            if(c == ']') {\n                if(stack.top() == '[') {\n                    stack.pop();\n                } else {\n                    return false;\n                }\n            } else {\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpyw24a9mc: /tmp/tmpyw24a9mc.cpp:44: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty()) return false;\n            if (stack.top() == '[' && i != string.size() - 1) {\n                stack.pop();\n            } else {\n                stack.pop();\n                if (!stack.empty()) stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpa7buf7x3: /tmp/tmpa7buf7x3.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) return false;\n            if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.pop();\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpysxk4012: /tmp/tmpysxk4012.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmptq43355w: /tmp/tmptq43355w.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.size() < 2) return false;\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') j++;\n            if (j < string.size() && string[j] == ']') {\n                i = j + 1;\n                continue;\n            }\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpl3yrqzox: /tmp/tmpl3yrqzox.cpp:39: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open_bracket = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open_bracket++;\n        } else if (string[i] == ']') {\n            open_bracket--;\n        }\n        if (open_bracket < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmp05s6c85r: /tmp/tmp05s6c85r.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n            count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n        }\n        if(count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293228,
      "stdout": "",
      "stderr": "tmpufpnbatn: /tmp/tmpufpnbatn.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpz49bik6j: /tmp/tmpz49bik6j.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        if (string[i] == ']') {\n            close++;\n        }\n        if (open > close) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp_x04h85m: /tmp/tmp_x04h85m.cpp:36: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpe_6uzv9q: /tmp/tmpe_6uzv9q.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmpc02qkmkb: /tmp/tmpc02qkmkb.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if(string.empty()) return false;\n    if(string[0]=='[') {\n        for(int i=1;i<string.size();i++) {\n            if(string[i]=='[') {\n                if(i+1<string.size() && string[i+1]=='[') {\n                    i++;\n                }\n                else {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmphn1nr5se: /tmp/tmphn1nr5se.cpp:37: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpdlq5hu95: /tmp/tmpdlq5hu95.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphxnnzz9d: /tmp/tmphxnnzz9d.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpqxl28w72: /tmp/tmpqxl28w72.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    int i = 0;\n    int j = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < len && string[j] != ']') j++;\n            if (j < len && string[j] == ']') {\n                i = j + 1;\n                j = i;\n                while (j < len && string[j] != ']') j++;\n                if (j < len && string[j] == ']') {\n                    i = j + 1;\n                    j = i;\n                    while (j < len && string[j] != ']') j++;\n                    if (j < len && string[j] == ']') {\n                        i = j + 1;\n                        j = i;\n                        while (j < len && string[j] != ']') j++;\n                        if (j < len && string[j] == ']') {\n                            i = j + 1;\n                            j = i;\n                            while (j < len && string[j] != ']') j++;\n                            if (j < len && string[j] == ']') {\n                                i = j + 1;\n                                j = i;\n                                while (j < len && string[j] != ']') j++;\n                                if (j < len && string[j] == ']') {\n                                    i = j + 1;\n                                    j = i;\n                                    while (j < len && string[j] != ']') j++;\n                                    if (j < len && string[j] == ']') {\n                                        i = j + 1;\n                                        j = i;\n                                        while (j < len && string[j] != ']') j++;\n                                        if (j < len && string[j] == ']') {\n                                            i = j + 1;\n                                            j = i;\n                                            while (j < len && string[j] != ']') j++;\n                                            if (j < len && string[j] == '\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "/tmp/tmprmnqpvl9.cpp:59:73: warning: missing terminating ' character\n   59 |                                             if (j < len && string[j] == '\n      |                                                                         ^\n/tmp/tmprmnqpvl9.cpp:59:73: error: missing terminating ' character\n/tmp/tmprmnqpvl9.cpp: In function \u2018bool is_nested(std::string)\u2019:\n/tmp/tmprmnqpvl9.cpp:60:1: error: expected primary-expression before \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmprmnqpvl9.cpp:59:72: error: expected \u2018)\u2019 before \u2018}\u2019 token\n   59 |                                             if (j < len && string[j] == '\n      |                                                ~                       ^\n      |                                                                        )\n   60 | }\n      | ~                                                                       \n/tmp/tmprmnqpvl9.cpp:60:1: error: expected primary-expression before \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmprmnqpvl9.cpp:61:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   61 | int main() {\n      |            ^\n/tmp/tmprmnqpvl9.cpp:77:1: error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmprmnqpvl9.cpp:51:70: note: to match this \u2018{\u2019\n   51 |                                     if (j < len && string[j] == ']') {\n      |                                                                      ^\n/tmp/tmprmnqpvl9.cpp:77:1: error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmprmnqpvl9.cpp:47:66: note: to match this \u2018{\u2019\n   47 |                                 if (j < len && string[j] == ']') {\n      |                                                                  ^\n/tmp/tmprmnqpvl9.cpp:77:1: error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmprmnqpvl9.cpp:43:62: note: to match this \u2018{\u2019\n   43 |                             if (j < len && string[j] == ']') {\n      |                                                              ^\n/tmp/tmprmnqpvl9.cpp:77:1: error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmprmn",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            }\n            else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpn7hitcol: /tmp/tmpn7hitcol.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n            i++;\n        } else if (string[i] == ']') {\n            count--;\n            i++;\n        } else {\n            i++;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpvmodv2vs: /tmp/tmpvmodv2vs.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.empty()) {\n                return false;\n            } else {\n                if (stack.top() == '[' && stack.size() > 1) {\n                    stack.pop();\n                } else {\n                    stack.pop();\n                }\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmp801y27d0: /tmp/tmp801y27d0.cpp:41: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphe5uzuhw: /tmp/tmphe5uzuhw.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpnrel24fs: /tmp/tmpnrel24fs.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    if (string[0] == '[') {\n        int count = 1;\n        for (int i = 1; i < len; i++) {\n            if (string[i] == '[') count++;\n            if (string[i] == ']') count--;\n            if (count == 0) return true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpcr_3rrj4: /tmp/tmpcr_3rrj4.cpp:34: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j < string.size() && string[j] == ']') {\n                i = j + 1;\n                j = i;\n                while (j < string.size() && string[j] != ']') {\n                    j++;\n                }\n                if (j < string.size() && string[j] == ']') {\n                    i = j + 1;\n                    j = i;\n                    while (j < string.size() && string[j] != ']') {\n                        j++;\n                    }\n                    if (j < string.size() && string[j] == ']') {\n                        i = j + 1;\n                        j = i;\n                        while (j < string.size() && string[j] != ']') {\n                            j++;\n                        }\n                        if (j < string.size() && string[j] == ']') {\n                            i = j + 1;\n                            j = i;\n                            while (j < string.size() && string[j] != ']') {\n                                j++;\n                            }\n                            if (j < string.size() && string[j] == ']') {\n                                i = j + 1;\n                                j = i;\n                                while (j < string.size() && string[j] != ']') {\n                                    j++;\n                                }\n                                if (j < string.size() && string[j] == ']') {\n                                    i = j + 1;\n                                    j = i;\n                                    while (j < string.size() && string[j] != ']') {\n                                        j++;\n                                    }\n                                    if (j < string.size() && string[j] == ']') {\n                                        i = j + 1;\n                                        j = i;\n                                        while (j < string.size() && string[j] != ']') {\n                                \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "/tmp/tmpauom3guq.cpp: In function \u2018bool is_nested(std::string)\u2019:\n/tmp/tmpauom3guq.cpp:69:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:63:80: note: to match this \u2018{\u2019\n   63 |                                     if (j < string.size() && string[j] == ']') {\n      |                                                                                ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:57:76: note: to match this \u2018{\u2019\n   57 |                                 if (j < string.size() && string[j] == ']') {\n      |                                                                            ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:51:72: note: to match this \u2018{\u2019\n   51 |                             if (j < string.size() && string[j] == ']') {\n      |                                                                        ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:45:68: note: to match this \u2018{\u2019\n   45 |                         if (j < string.size() && string[j] == ']') {\n      |                                                                    ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:39:64: note: to match this \u2018{\u2019\n   39 |                     if (j < string.size() && string[j] == ']') {\n      |                                                                ^\n/tmp/tmpauom3guq.cpp:85:1: error: expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpauom3guq.cpp:33:60: note: to match this \u2018{\u2019\n   33 |                 if (j < string.size() && string[j] == ']') {\n      |                                                            ^\n/tmp/tmpauom3guq.cpp:85:1: error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpqxl28w72: /tmp/tmpqxl28w72.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    if (string[0] == '[') {\n        for (int i = 1; i < len; i++) {\n            if (string[i] == '[') {\n                if (i + 1 < len && string[i + 1] == '[') {\n                    i++;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpcx0irsta: /tmp/tmpcx0irsta.cpp:37: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            }\n            open--;\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmph4lnkjuw: /tmp/tmph4lnkjuw.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n            if (open < 0) {\n                return false;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmp9kgikf5y: /tmp/tmp9kgikf5y.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push('[');\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            } else if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(']');\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmp6yxnbw7e: /tmp/tmp6yxnbw7e.cpp:39: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) {\n        return false;\n    }\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpffr7v7_k: /tmp/tmpffr7v7_k.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) return false;\n    if (string[0] == '[') {\n        int count = 1;\n        for (int i = 1; i < len; i++) {\n            if (string[i] == '[') {\n                count++;\n            } else if (string[i] == ']') {\n                count--;\n                if (count == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmp4acjysgu: /tmp/tmp4acjysgu.cpp:39: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            j = i;\n            while (j < string.size() && string[j] != ']') {\n                j++;\n            }\n            if (j == string.size()) {\n                return false;\n            }\n            if (string[j + 1] == '[') {\n                i = j + 1;\n            } else {\n                return true;\n            }\n        } else {\n            i++;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpoqaglaap: /tmp/tmpoqaglaap.cpp:44: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpe_6uzv9q: /tmp/tmpe_6uzv9q.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpxu6ke8z4: /tmp/tmpxu6ke8z4.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    if (string[0] == '[') {\n        for (int i = 1; i < string.size(); ++i) {\n            if (string[i] == '[') {\n                if (i + 1 < string.size() && string[i+1] == '[') {\n                    i += 2;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpvure9ckn: /tmp/tmpvure9ckn.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            if (open == 0) {\n                return false;\n            } else {\n                open--;\n            }\n        }\n    }\n    return open == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpnsn1teol: /tmp/tmpnsn1teol.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n            stack.push('[');\n        }\n        else if(string[i] == ']') {\n            if(stack.empty()) {\n                return false;\n            }\n            else if(stack.top() == '[' && stack.size() > 1) {\n                stack.pop();\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpinug94s1: /tmp/tmpinug94s1.cpp:42: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            if (stack.top() == '[') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpdq8a81ef: /tmp/tmpdq8a81ef.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c == ']') {\n            if (stack.empty()) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293226,
      "stdout": "",
      "stderr": "tmphgwnqrl6: /tmp/tmphgwnqrl6.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open_brackets = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open_brackets++;\n        }\n        else if (string[i] == ']') {\n            open_brackets--;\n        }\n        if (open_brackets < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpg0263z4t: /tmp/tmpg0263z4t.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            open++;\n        }\n        else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpz49bik6j: /tmp/tmpz49bik6j.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open_brackets = 0;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == '[') {\n            open_brackets++;\n        }\n        else if (string[i] == ']') {\n            open_brackets--;\n        }\n        if (open_brackets < 0) {\n            return false;\n        }\n    }\n    return open_brackets == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpb8s710o0: /tmp/tmpb8s710o0.cpp:37: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int open = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            open++;\n        } else if (string[i] == ']') {\n            open--;\n        }\n        if (open < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "tmpzt2qh3pf: /tmp/tmpzt2qh3pf.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    if (string.empty()) return false;\n    int i = 0, j = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            if (j == i) {\n                j++;\n                i++;\n            } else {\n                j = i;\n                i++;\n            }\n        } else if (string[i] == ']') {\n            if (j == i) {\n                j++;\n                i++;\n            } else {\n                j = i;\n                i++;\n            }\n        } else {\n            i++;\n        }\n    }\n    return j != i;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmp9h_g93qc: /tmp/tmp9h_g93qc.cpp:46: int main(): Assertion `candidate((\"[[]]\")) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmp7n1eohdi: /tmp/tmp7n1eohdi.cpp:40: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int len = string.length();\n    if (len == 0) {\n        return false;\n    }\n    if (string[0] == '[') {\n        return true;\n    }\n    for (int i = 1; i < len; i++) {\n        if (string[i] == '[') {\n            if (i + 1 < len && string[i + 1] == '[') {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293230,
      "stdout": "",
      "stderr": "tmpb0aqve0u: /tmp/tmpb0aqve0u.cpp:38: int main(): Assertion `candidate((\"[]]]]]]][[[[[]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested('[[]]') \n// True\n// >>> is_nested('[]]]]]]][[[[[]') \n// False\n// >>> is_nested('[][]') \n// False\n// >>> is_nested('[]') \n// False\n// >>> is_nested('[[][]]') \n// True\n// >>> is_nested('[[]][[') \n// True\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "tmpe_6uzv9q: /tmp/tmpe_6uzv9q.cpp:36: int main(): Assertion `candidate((\"[][]\")) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}