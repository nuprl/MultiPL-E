{
  "name": "HumanEval_109_move_one_ball",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n",
  "tests": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpnd9j3nta: /tmp/tmpnd9j3nta.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpxyyu0sbh: /tmp/tmpxyyu0sbh.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpdzklm3j3: /tmp/tmpdzklm3j3.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < arr[i + 1]) {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n            arr[i] = arr[i] - arr[i + 1];\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpi7v5dfs3': free(): invalid next size (fast): 0x0000000001faec20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b5a732d3329]\n/tmp/tmpi7v5dfs3[0x401e9c]\n/tmp/tmpi7v5dfs3[0x401ac1]\n/tmp/tmpi7v5dfs3[0x4016de]\n/tmp/tmpi7v5dfs3[0x40133e]\n/tmp/tmpi7v5dfs3[0x4012d5]\n/tmp/tmpi7v5dfs3[0x400bc4]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b5a73274555]\n/tmp/tmpi7v5dfs3[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 105                                /tmp/tmpi7v5dfs3\n00604000-00605000 r--p 00004000 08:02 105                                /tmp/tmpi7v5dfs3\n00605000-00606000 rw-p 00005000 08:02 105                                /tmp/tmpi7v5dfs3\n01f9d000-01fcf000 rw-p 00000000 00:00 0                                  [heap]\n2b5a7273b000-2b5a7275d000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b5a7275d000-2b5a72760000 rw-p 00000000 00:00 0 \n2b5a72778000-2b5a7277d000 rw-p 00000000 00:00 0 \n2b5a7295c000-2b5a7295d000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpkx9qjv3n: /tmp/tmpkx9qjv3n.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp89rxcqru': free(): invalid next size (fast): 0x0000000000efac20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b593084e329]\n/tmp/tmp89rxcqru[0x40173e]\n/tmp/tmp89rxcqru[0x401649]\n/tmp/tmp89rxcqru[0x4014a0]\n/tmp/tmp89rxcqru[0x4011f2]\n/tmp/tmp89rxcqru[0x401189]\n/tmp/tmp89rxcqru[0x400b67]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b59307ef555]\n/tmp/tmp89rxcqru[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2367                               /tmp/tmp89rxcqru\n00602000-00603000 r--p 00002000 08:02 2367                               /tmp/tmp89rxcqru\n00603000-00604000 rw-p 00003000 08:02 2367                               /tmp/tmp89rxcqru\n00ee9000-00f1b000 rw-p 00000000 00:00 0                                  [heap]\n2b592fcb6000-2b592fcd8000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b592fcd8000-2b592fcdb000 rw-p 00000000 00:00 0 \n2b592fcf3000-2b592fcf8000 rw-p 00000000 00:00 0 \n2b592fed7000-2b592fed8000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[i + 1] = 0;\n            if (i == n - 1) return true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpm8iw_ft_: /tmp/tmpm8iw_ft_.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmph_onlrub': free(): invalid next size (fast): 0x0000000000c07c20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2aeec3a81329]\n/tmp/tmph_onlrub[0x401e88]\n/tmp/tmph_onlrub[0x401aad]\n/tmp/tmph_onlrub[0x4016ca]\n/tmp/tmph_onlrub[0x40132a]\n/tmp/tmph_onlrub[0x4012c1]\n/tmp/tmph_onlrub[0x400baf]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2aeec3a22555]\n/tmp/tmph_onlrub[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 2443                               /tmp/tmph_onlrub\n00604000-00605000 r--p 00004000 08:02 2443                               /tmp/tmph_onlrub\n00605000-00606000 rw-p 00005000 08:02 2443                               /tmp/tmph_onlrub\n00bf6000-00c28000 rw-p 00000000 00:00 0                                  [heap]\n2aeec2ee9000-2aeec2f0b000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2aeec2f0b000-2aeec2f0e000 rw-p 00000000 00:00 0 \n2aeec2f26000-2aeec2f2b000 rw-p 00000000 00:00 0 \n2aeec310a000-2aeec310b000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpxp6j0p68': free(): invalid next size (fast): 0x000000000188dc20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b145108b329]\n/tmp/tmpxp6j0p68[0x401628]\n/tmp/tmpxp6j0p68[0x401533]\n/tmp/tmpxp6j0p68[0x4013b6]\n/tmp/tmpxp6j0p68[0x4011a6]\n/tmp/tmpxp6j0p68[0x40113d]\n/tmp/tmpxp6j0p68[0x400b5d]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b145102c555]\n/tmp/tmpxp6j0p68[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2355                               /tmp/tmpxp6j0p68\n00602000-00603000 r--p 00002000 08:02 2355                               /tmp/tmpxp6j0p68\n00603000-00604000 rw-p 00003000 08:02 2355                               /tmp/tmpxp6j0p68\n0187c000-018ae000 rw-p 00000000 00:00 0                                  [heap]\n2b14504f3000-2b1450515000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b1450515000-2b1450518000 rw-p 00000000 00:00 0 \n2b1450530000-2b1450535000 rw-p 00000000 00:00 0 \n2b1450714000-2b1450715000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x) { return x == 0; });\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpf4chnzst: /tmp/tmpf4chnzst.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    if (n == 1) return false;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpviku7b7g: /tmp/tmpviku7b7g.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] == arr[i+1]) {\n            arr[i] = arr[i+1] = 0;\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp45ml9701: /tmp/tmp45ml9701.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] == arr[i+1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i+1];\n            arr[i+1] = arr[i];\n            i = 0;\n        }\n    }\n    return arr[0] < arr[1];\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmptrvcsa98: /tmp/tmptrvcsa98.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpmkz1bfvp: /tmp/tmpmkz1bfvp.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            i = 0;\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpmkz1bfvp: /tmp/tmpmkz1bfvp.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpwce2m49d: /tmp/tmpwce2m49d.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpewiqvuzy: /tmp/tmpewiqvuzy.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp085bbkjo: /tmp/tmp085bbkjo.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] == arr[i+1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i+1];\n            arr[i+1] = arr[i];\n            i = 0;\n        }\n    }\n    return arr[0] == arr[1];\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmph61iax35: /tmp/tmph61iax35.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpnyas62fn: /tmp/tmpnyas62fn.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpb_a3q4s4: /tmp/tmpb_a3q4s4.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            std::swap(arr[i], arr[i + 1]);\n            i++;\n        } else {\n            i++;\n        }\n    }\n    return i == n;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpm7eyowwl: /tmp/tmpm7eyowwl.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpjw4y7zkk: /tmp/tmpjw4y7zkk.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpwuhx9hhq: /tmp/tmpwuhx9hhq.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + 1]) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpo00pd72b: /tmp/tmpo00pd72b.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmp0rc4dndl: /tmp/tmp0rc4dndl.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmp70m559qy: /tmp/tmp70m559qy.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpb_a3q4s4: /tmp/tmpb_a3q4s4.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[i + 1] = 0;\n            continue;\n        }\n        arr[i] = arr[i + 1];\n        arr[i + 1] = 0;\n        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpuwwnlx2l: /tmp/tmpuwwnlx2l.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpvuz30liv: /tmp/tmpvuz30liv.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpqwh60mq9: /tmp/tmpqwh60mq9.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        int j = i;\n        while(j >= 0 && arr[j] > arr[j+1]) {\n            arr[j] = arr[j] + arr[j+1];\n            arr[j+1] = arr[j] - arr[j+1];\n            arr[j] = arr[j] - arr[j+1];\n            j--;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpj6ea6hqa: /tmp/tmpj6ea6hqa.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmp75ezswc9: /tmp/tmp75ezswc9.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return i == n - 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpu3j6d_x9: /tmp/tmpu3j6d_x9.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpxyyu0sbh: /tmp/tmpxyyu0sbh.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else if(arr[i] > 0) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpcn9zs395': free(): invalid next size (fast): 0x0000000001628c20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b5d894b3329]\n/tmp/tmpcn9zs395[0x4017ca]\n/tmp/tmpcn9zs395[0x4016d5]\n/tmp/tmpcn9zs395[0x40152c]\n/tmp/tmpcn9zs395[0x40127e]\n/tmp/tmpcn9zs395[0x401215]\n/tmp/tmpcn9zs395[0x400bf3]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b5d89454555]\n/tmp/tmpcn9zs395[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2426                               /tmp/tmpcn9zs395\n00602000-00603000 r--p 00002000 08:02 2426                               /tmp/tmpcn9zs395\n00603000-00604000 rw-p 00003000 08:02 2426                               /tmp/tmpcn9zs395\n01617000-01649000 rw-p 00000000 00:00 0                                  [heap]\n2b5d8891b000-2b5d8893d000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b5d8893d000-2b5d88940000 rw-p 00000000 00:00 0 \n2b5d88958000-2b5d8895d000 rw-p 00000000 00:00 0 \n2b5d88b3c000-2b5d88b3d000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmp0n76dlga: /tmp/tmp0n76dlga.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmp10dwxzdy: /tmp/tmp10dwxzdy.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmph545ruz6: /tmp/tmph545ruz6.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpmkz1bfvp: /tmp/tmpmkz1bfvp.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpamayn1nx: /tmp/tmpamayn1nx.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] < arr[i + 1]) {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n            arr[i] = arr[i] - arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return arr[0] == 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpyda6c0yy: /tmp/tmpyda6c0yy.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpezgezkj0: /tmp/tmpezgezkj0.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        else {\n            i++;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292776,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmppeus32td: /tmp/tmppeus32td.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpxyyu0sbh: /tmp/tmpxyyu0sbh.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpxyyu0sbh: /tmp/tmpxyyu0sbh.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == 0) {\n            arr[i] = arr.back();\n            arr.pop_back();\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpfohij30_: /tmp/tmpfohij30_.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpdeys516_: /tmp/tmpdeys516_.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpc7sz627u: /tmp/tmpc7sz627u.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[i] + 1;\n            arr[i + 1] = arr[i + 1] - 1;\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpuwpnb1w7: /tmp/tmpuwpnb1w7.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmp0hk9y1z9: /tmp/tmp0hk9y1z9.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpwuhx9hhq: /tmp/tmpwuhx9hhq.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpue6sg6m6: /tmp/tmpue6sg6m6.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp0mumqzc3': free(): invalid next size (fast): 0x0000000001edec20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2afee8e93329]\n/tmp/tmp0mumqzc3[0x401694]\n/tmp/tmp0mumqzc3[0x40159f]\n/tmp/tmp0mumqzc3[0x401422]\n/tmp/tmp0mumqzc3[0x401212]\n/tmp/tmp0mumqzc3[0x4011a9]\n/tmp/tmp0mumqzc3[0x400bc8]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2afee8e34555]\n/tmp/tmp0mumqzc3[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2432                               /tmp/tmp0mumqzc3\n00602000-00603000 r--p 00002000 08:02 2432                               /tmp/tmp0mumqzc3\n00603000-00604000 rw-p 00003000 08:02 2432                               /tmp/tmp0mumqzc3\n01ecd000-01eff000 rw-p 00000000 00:00 0                                  [heap]\n2afee82fb000-2afee831d000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2afee831d000-2afee8320000 rw-p 00000000 00:00 0 \n2afee8338000-2afee833d000 rw-p 00000000 00:00 0 \n2afee851c000-2afee851d000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n) {\n        int j = i + 1;\n        while(j < n && arr[j] >= arr[i]) j++;\n        if(j < n) {\n            std::swap(arr[i], arr[j]);\n            i = j;\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmp90mqlz1l: /tmp/tmp90mqlz1l.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpwzv1whja: /tmp/tmpwzv1whja.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpb_a3q4s4: /tmp/tmpb_a3q4s4.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < arr[i + 1]) {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n            arr[i] = arr[i] - arr[i + 1];\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpi7v5dfs3': free(): invalid next size (fast): 0x0000000001faec20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b5a732d3329]\n/tmp/tmpi7v5dfs3[0x401e9c]\n/tmp/tmpi7v5dfs3[0x401ac1]\n/tmp/tmpi7v5dfs3[0x4016de]\n/tmp/tmpi7v5dfs3[0x40133e]\n/tmp/tmpi7v5dfs3[0x4012d5]\n/tmp/tmpi7v5dfs3[0x400bc4]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b5a73274555]\n/tmp/tmpi7v5dfs3[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 105                                /tmp/tmpi7v5dfs3\n00604000-00605000 r--p 00004000 08:02 105                                /tmp/tmpi7v5dfs3\n00605000-00606000 rw-p 00005000 08:02 105                                /tmp/tmpi7v5dfs3\n01f9d000-01fcf000 rw-p 00000000 00:00 0                                  [heap]\n2b5a7273b000-2b5a7275d000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b5a7275d000-2b5a72760000 rw-p 00000000 00:00 0 \n2b5a72778000-2b5a7277d000 rw-p 00000000 00:00 0 \n2b5a7295c000-2b5a7295d000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] == arr[i+1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i+1];\n            arr[i+1] = arr[i];\n        }\n    }\n    return arr[0] != arr[1];\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmp902fjbjv: /tmp/tmp902fjbjv.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n) {\n        int j = i;\n        while(j < n && arr[j] >= arr[j+1]) j++;\n        if(j < n) {\n            std::swap(arr[i], arr[j]);\n            i = j;\n        }\n        else i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292776,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] == arr[i - 1]) {\n            arr.erase(arr.begin() + i);\n        } else {\n            break;\n        }\n    }\n    return arr.empty();\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpl75gdfl9: /tmp/tmpl75gdfl9.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size() - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpeef52efj: /tmp/tmpeef52efj.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i] + arr[i + 1];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpu2ojwoxj: /tmp/tmpu2ojwoxj.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpnbed3z_a: /tmp/tmpnbed3z_a.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpj4fyf0tz: /tmp/tmpj4fyf0tz.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] != i+1) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmphch9xr82: /tmp/tmphch9xr82.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpnbed3z_a: /tmp/tmpnbed3z_a.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmphaab09wh: /tmp/tmphaab09wh.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmphbez4212: /tmp/tmphbez4212.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return i == n - 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i + 1];\n            arr[i + 1] = arr[i];\n            arr.erase(arr.begin() + i + 1);\n        }\n    }\n    return arr.size() == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpzqc8cy_q: /tmp/tmpzqc8cy_q.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpj4fyf0tz: /tmp/tmpj4fyf0tz.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpwkg0pc77: /tmp/tmpwkg0pc77.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i + 1];\n            arr[i + 1] = arr[i];\n        }\n    }\n    return arr[0] == 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpdrhak19q: /tmp/tmpdrhak19q.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmph_onlrub': free(): invalid next size (fast): 0x0000000000c07c20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2aeec3a81329]\n/tmp/tmph_onlrub[0x401e88]\n/tmp/tmph_onlrub[0x401aad]\n/tmp/tmph_onlrub[0x4016ca]\n/tmp/tmph_onlrub[0x40132a]\n/tmp/tmph_onlrub[0x4012c1]\n/tmp/tmph_onlrub[0x400baf]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2aeec3a22555]\n/tmp/tmph_onlrub[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 2443                               /tmp/tmph_onlrub\n00604000-00605000 r--p 00004000 08:02 2443                               /tmp/tmph_onlrub\n00605000-00606000 rw-p 00005000 08:02 2443                               /tmp/tmph_onlrub\n00bf6000-00c28000 rw-p 00000000 00:00 0                                  [heap]\n2aeec2ee9000-2aeec2f0b000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2aeec2f0b000-2aeec2f0e000 rw-p 00000000 00:00 0 \n2aeec2f26000-2aeec2f2b000 rw-p 00000000 00:00 0 \n2aeec310a000-2aeec310b000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpy5a44i05: /tmp/tmpy5a44i05.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmph_onlrub': free(): invalid next size (fast): 0x0000000000c07c20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2aeec3a81329]\n/tmp/tmph_onlrub[0x401e88]\n/tmp/tmph_onlrub[0x401aad]\n/tmp/tmph_onlrub[0x4016ca]\n/tmp/tmph_onlrub[0x40132a]\n/tmp/tmph_onlrub[0x4012c1]\n/tmp/tmph_onlrub[0x400baf]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2aeec3a22555]\n/tmp/tmph_onlrub[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 2443                               /tmp/tmph_onlrub\n00604000-00605000 r--p 00004000 08:02 2443                               /tmp/tmph_onlrub\n00605000-00606000 rw-p 00005000 08:02 2443                               /tmp/tmph_onlrub\n00bf6000-00c28000 rw-p 00000000 00:00 0                                  [heap]\n2aeec2ee9000-2aeec2f0b000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2aeec2f0b000-2aeec2f0e000 rw-p 00000000 00:00 0 \n2aeec2f26000-2aeec2f2b000 rw-p 00000000 00:00 0 \n2aeec310a000-2aeec310b000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](int x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpbfi_gbab: /tmp/tmpbfi_gbab.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpzkv72p1b: /tmp/tmpzkv72p1b.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpyz12y9iq: /tmp/tmpyz12y9iq.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty())\n        return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = arr.size() - 1; i >= 0; i--)\n        if(arr[i] != i + 1)\n            return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpzsxg5v47: /tmp/tmpzsxg5v47.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpxp6j0p68': free(): invalid next size (fast): 0x000000000188dc20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b145108b329]\n/tmp/tmpxp6j0p68[0x401628]\n/tmp/tmpxp6j0p68[0x401533]\n/tmp/tmpxp6j0p68[0x4013b6]\n/tmp/tmpxp6j0p68[0x4011a6]\n/tmp/tmpxp6j0p68[0x40113d]\n/tmp/tmpxp6j0p68[0x400b5d]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b145102c555]\n/tmp/tmpxp6j0p68[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2355                               /tmp/tmpxp6j0p68\n00602000-00603000 r--p 00002000 08:02 2355                               /tmp/tmpxp6j0p68\n00603000-00604000 rw-p 00003000 08:02 2355                               /tmp/tmpxp6j0p68\n0187c000-018ae000 rw-p 00000000 00:00 0                                  [heap]\n2b14504f3000-2b1450515000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b1450515000-2b1450518000 rw-p 00000000 00:00 0 \n2b1450530000-2b1450535000 rw-p 00000000 00:00 0 \n2b1450714000-2b1450715000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        int j = i + 1;\n        while (j < n && arr[j] >= arr[i]) {\n            if (arr[j] == arr[i]) {\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1] = arr[i];\n                arr[i] = arr[n - 1];\n                arr[n - 1] = arr[j];\n                arr[j] = arr[n - 1];\n                arr[n - 1\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "/tmp/tmpyvvhmn_j.cpp: In function \u2018bool move_one_ball(std::vector<long int>)\u2019:\n/tmp/tmpyvvhmn_j.cpp:65:26: error: expected \u2018]\u2019 before \u2018}\u2019 token\n   65 |                 arr[n - 1\n      |                          ^\n      |                          ]\n   66 | }\n      | ~                         \n/tmp/tmpyvvhmn_j.cpp:65:26: error: expected \u2018;\u2019 before \u2018}\u2019 token\n   65 |                 arr[n - 1\n      |                          ^\n      |                          ;\n   66 | }\n      | ~                         \n/tmp/tmpyvvhmn_j.cpp:67:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   67 | int main() {\n      |            ^\n/tmp/tmpyvvhmn_j.cpp:74:1: error: expected \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpyvvhmn_j.cpp:30:43: note: to match this \u2018{\u2019\n   30 |         while (j < n && arr[j] >= arr[i]) {\n      |                                           ^\n/tmp/tmpyvvhmn_j.cpp:74:1: error: expected \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpyvvhmn_j.cpp:28:19: note: to match this \u2018{\u2019\n   28 |     while (i < n) {\n      |                   ^\n/tmp/tmpyvvhmn_j.cpp:74:1: error: expected \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpyvvhmn_j.cpp:24:43: note: to match this \u2018{\u2019\n   24 | bool move_one_ball(std::vector<long> arr) {\n      |                                           ^\n/tmp/tmpyvvhmn_j.cpp:74:1: warning: control reaches end of non-void function [-Wreturn-type]\n   74 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return i == n - 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i = i + 2;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpr9ec3xr_: /tmp/tmpr9ec3xr_.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpr0g9btmf: /tmp/tmpr0g9btmf.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr.empty();\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmp901yr2yu: /tmp/tmp901yr2yu.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    if (n == 1) return false;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = 0;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmptffkf6rp: /tmp/tmptffkf6rp.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpiudm81el: /tmp/tmpiudm81el.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpr1y9db24: /tmp/tmpr1y9db24.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] < arr[i + 1]) {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n            arr[i] = arr[i] - arr[i + 1];\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpv23gaq16': free(): invalid next size (fast): 0x0000000001f8dc20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b312c13d329]\n/tmp/tmpv23gaq16[0x4016e2]\n/tmp/tmpv23gaq16[0x4015ed]\n/tmp/tmpv23gaq16[0x401470]\n/tmp/tmpv23gaq16[0x401260]\n/tmp/tmpv23gaq16[0x4011f7]\n/tmp/tmpv23gaq16[0x400c16]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b312c0de555]\n/tmp/tmpv23gaq16[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2415                               /tmp/tmpv23gaq16\n00602000-00603000 r--p 00002000 08:02 2415                               /tmp/tmpv23gaq16\n00603000-00604000 rw-p 00003000 08:02 2415                               /tmp/tmpv23gaq16\n01f7c000-01fae000 rw-p 00000000 00:00 0                                  [heap]\n2b312b5a5000-2b312b5c7000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b312b5c7000-2b312b5ca000 rw-p 00000000 00:00 0 \n2b312b5e2000-2b312b5e7000 rw-p 00000000 00:00 0 \n2b312b7c6000-2b312b7c7000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpwzv1whja: /tmp/tmpwzv1whja.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmprf5do_gd: /tmp/tmprf5do_gd.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpwce2m49d: /tmp/tmpwce2m49d.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    if (n == 1) return true;\n    if (n == 2) return true;\n    if (n == 3) return true;\n    if (n == 4) return true;\n    if (n == 5) return true;\n    if (n == 6) return true;\n    if (n == 7) return true;\n    if (n == 8) return true;\n    if (n == 9) return true;\n    if (n == 10) return true;\n    if (n == 11) return true;\n    if (n == 12) return true;\n    if (n == 13) return true;\n    if (n == 14) return true;\n    if (n == 15) return true;\n    if (n == 16) return true;\n    if (n == 17) return true;\n    if (n == 18) return true;\n    if (n == 19) return true;\n    if (n == 20) return true;\n    if (n == 21) return true;\n    if (n == 22) return true;\n    if (n == 23) return true;\n    if (n == 24) return true;\n    if (n == 25) return true;\n    if (n == 26) return true;\n    if (n == 27) return true;\n    if (n == 28) return true;\n    if (n == 29) return true;\n    if (n == 30) return true;\n    if (n == 31) return true;\n    if (n == 32) return true;\n    if (n == 33) return true;\n    if (n == 34) return true;\n    if (n == 35) return true;\n    if (n == 36) return true;\n    if (n == 37) return true;\n    if (n == 38) return true;\n    if (n == 39) return true;\n    if (n == 40) return true;\n    if (n == 41) return true;\n    if (n == 42) return true;\n    if (n == 43) return true;\n    if (n == 44) return true;\n    if (n == 45) return\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "/tmp/tmp8o4p04dr.cpp: In function \u2018bool move_one_ball(std::vector<long int>)\u2019:\n/tmp/tmp8o4p04dr.cpp:72:1: error: expected primary-expression before \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmp8o4p04dr.cpp:71:24: error: expected \u2018;\u2019 before \u2018}\u2019 token\n   71 |     if (n == 45) return\n      |                        ^\n      |                        ;\n   72 | }\n      | ~                       \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpj4fyf0tz: /tmp/tmpj4fyf0tz.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n    }\n    return arr[0] == 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpb59aq_3j: /tmp/tmpb59aq_3j.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292780,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + 1]) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmp0pwh3vvg: /tmp/tmp0pwh3vvg.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp89rxcqru': free(): invalid next size (fast): 0x0000000000efac20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b593084e329]\n/tmp/tmp89rxcqru[0x40173e]\n/tmp/tmp89rxcqru[0x401649]\n/tmp/tmp89rxcqru[0x4014a0]\n/tmp/tmp89rxcqru[0x4011f2]\n/tmp/tmp89rxcqru[0x401189]\n/tmp/tmp89rxcqru[0x400b67]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b59307ef555]\n/tmp/tmp89rxcqru[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2367                               /tmp/tmp89rxcqru\n00602000-00603000 r--p 00002000 08:02 2367                               /tmp/tmp89rxcqru\n00603000-00604000 rw-p 00003000 08:02 2367                               /tmp/tmp89rxcqru\n00ee9000-00f1b000 rw-p 00000000 00:00 0                                  [heap]\n2b592fcb6000-2b592fcd8000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b592fcd8000-2b592fcdb000 rw-p 00000000 00:00 0 \n2b592fcf3000-2b592fcf8000 rw-p 00000000 00:00 0 \n2b592fed7000-2b592fed8000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpyl3u6rtr: /tmp/tmpyl3u6rtr.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpw3yhnzzf: /tmp/tmpw3yhnzzf.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    if (n == 1) return true;\n    if (n == 2) return true;\n    if (n == 3) return true;\n    if (n == 4) return true;\n    if (n == 5) return true;\n    if (n == 6) return true;\n    if (n == 7) return true;\n    if (n == 8) return true;\n    if (n == 9) return true;\n    if (n == 10) return true;\n    if (n == 11) return true;\n    if (n == 12) return true;\n    if (n == 13) return true;\n    if (n == 14) return true;\n    if (n == 15) return true;\n    if (n == 16) return true;\n    if (n == 17) return true;\n    if (n == 18) return true;\n    if (n == 19) return true;\n    if (n == 20) return true;\n    if (n == 21) return true;\n    if (n == 22) return true;\n    if (n == 23) return true;\n    if (n == 24) return true;\n    if (n == 25) return true;\n    if (n == 26) return true;\n    if (n == 27) return true;\n    if (n == 28) return true;\n    if (n == 29) return true;\n    if (n == 30) return true;\n    if (n == 31) return true;\n    if (n == 32) return true;\n    if (n == 33) return true;\n    if (n == 34) return true;\n    if (n == 35) return true;\n    if (n == 36) return true;\n    if (n == 37) return true;\n    if (n == 38) return true;\n    if (n == 39) return true;\n    if (n == 40) return true;\n    if (n == 41) return true;\n    if (n == 42) return true;\n    if (n == 43) return true;\n    if (n == 44) return true;\n    if (n == 45) return\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "/tmp/tmp8o4p04dr.cpp: In function \u2018bool move_one_ball(std::vector<long int>)\u2019:\n/tmp/tmp8o4p04dr.cpp:72:1: error: expected primary-expression before \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmp8o4p04dr.cpp:71:24: error: expected \u2018;\u2019 before \u2018}\u2019 token\n   71 |     if (n == 45) return\n      |                        ^\n      |                        ;\n   72 | }\n      | ~                       \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpl7ngcq9y: /tmp/tmpl7ngcq9y.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292780,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpb_a3q4s4: /tmp/tmpb_a3q4s4.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i+1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i+1];\n            arr[i+1] = arr[0];\n        }\n    }\n    return arr[0] == arr[1];\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmp9rhuxp76: /tmp/tmp9rhuxp76.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmptvcbrvf3: /tmp/tmptvcbrvf3.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i = i + 2;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpya5sqv2w: /tmp/tmpya5sqv2w.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpw3yhnzzf: /tmp/tmpw3yhnzzf.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmpb_a3q4s4: /tmp/tmpb_a3q4s4.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i + 1];\n            arr[i + 1] = arr[n - 1];\n            arr[n - 1] = arr[i];\n            arr.erase(arr.begin() + i + 1);\n            n--;\n            i--;\n        }\n    }\n    return arr.empty();\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmpb5ler0qw: /tmp/tmpb5ler0qw.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "tmp49p7ai0o: /tmp/tmp49p7ai0o.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmph545ruz6: /tmp/tmph545ruz6.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp89rxcqru': free(): invalid next size (fast): 0x0000000000efac20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b593084e329]\n/tmp/tmp89rxcqru[0x40173e]\n/tmp/tmp89rxcqru[0x401649]\n/tmp/tmp89rxcqru[0x4014a0]\n/tmp/tmp89rxcqru[0x4011f2]\n/tmp/tmp89rxcqru[0x401189]\n/tmp/tmp89rxcqru[0x400b67]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b59307ef555]\n/tmp/tmp89rxcqru[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2367                               /tmp/tmp89rxcqru\n00602000-00603000 r--p 00002000 08:02 2367                               /tmp/tmp89rxcqru\n00603000-00604000 rw-p 00003000 08:02 2367                               /tmp/tmp89rxcqru\n00ee9000-00f1b000 rw-p 00000000 00:00 0                                  [heap]\n2b592fcb6000-2b592fcd8000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b592fcd8000-2b592fcdb000 rw-p 00000000 00:00 0 \n2b592fcf3000-2b592fcf8000 rw-p 00000000 00:00 0 \n2b592fed7000-2b592fed8000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmpgy0z7hnv: /tmp/tmpgy0z7hnv.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n    }\n    return std::all_of(arr.begin(), arr.end(), [](long x){return x == 0;});\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmpranwg7ak: /tmp/tmpranwg7ak.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[0];\n            arr[0] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmp3n2ahy2w: /tmp/tmp3n2ahy2w.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == i + 1) {\n            arr[i] = arr[arr.size() - 1];\n            arr.pop_back();\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmp8wxcgs0u: /tmp/tmp8wxcgs0u.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmpbmdo27dn: /tmp/tmpbmdo27dn.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpwce2m49d: /tmp/tmpwce2m49d.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp89rxcqru': free(): invalid next size (fast): 0x0000000000efac20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b593084e329]\n/tmp/tmp89rxcqru[0x40173e]\n/tmp/tmp89rxcqru[0x401649]\n/tmp/tmp89rxcqru[0x4014a0]\n/tmp/tmp89rxcqru[0x4011f2]\n/tmp/tmp89rxcqru[0x401189]\n/tmp/tmp89rxcqru[0x400b67]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b59307ef555]\n/tmp/tmp89rxcqru[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2367                               /tmp/tmp89rxcqru\n00602000-00603000 r--p 00002000 08:02 2367                               /tmp/tmp89rxcqru\n00603000-00604000 rw-p 00003000 08:02 2367                               /tmp/tmp89rxcqru\n00ee9000-00f1b000 rw-p 00000000 00:00 0                                  [heap]\n2b592fcb6000-2b592fcd8000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b592fcd8000-2b592fcdb000 rw-p 00000000 00:00 0 \n2b592fcf3000-2b592fcf8000 rw-p 00000000 00:00 0 \n2b592fed7000-2b592fed8000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmp9r770q48: /tmp/tmp9r770q48.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n) {\n        int j = i;\n        while(j < n && arr[j] > arr[j+1]) j++;\n        if(j == i) {\n            i++;\n            continue;\n        }\n        std::swap(arr[i], arr[j]);\n        i = j+1;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmpz0gvffux: /tmp/tmpz0gvffux.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292772,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmp75ezswc9: /tmp/tmp75ezswc9.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpvnmfmpdv': free(): invalid next size (fast): 0x0000000000f45c20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b2fcf64a329]\n/tmp/tmpvnmfmpdv[0x40173e]\n/tmp/tmpvnmfmpdv[0x401649]\n/tmp/tmpvnmfmpdv[0x4014a0]\n/tmp/tmpvnmfmpdv[0x4011f2]\n/tmp/tmpvnmfmpdv[0x401189]\n/tmp/tmpvnmfmpdv[0x400b67]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b2fcf5eb555]\n/tmp/tmpvnmfmpdv[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2366                               /tmp/tmpvnmfmpdv\n00602000-00603000 r--p 00002000 08:02 2366                               /tmp/tmpvnmfmpdv\n00603000-00604000 rw-p 00003000 08:02 2366                               /tmp/tmpvnmfmpdv\n00f34000-00f66000 rw-p 00000000 00:00 0                                  [heap]\n2b2fceab2000-2b2fcead4000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b2fcead4000-2b2fcead7000 rw-p 00000000 00:00 0 \n2b2fceaef000-2b2fceaf4000 rw-p 00000000 00:00 0 \n2b2fcecd3000-2b2fcecd4000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[i] + 1;\n            arr[i + 1] = arr[i] - 1;\n        } else {\n            arr[i] = arr[i] + 1;\n            arr[i + 1] = arr[i] - 1;\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp_tvaz5nr': free(): invalid next size (fast): 0x0000000001767c20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b72bbf27329]\n/tmp/tmp_tvaz5nr[0x401cce]\n/tmp/tmp_tvaz5nr[0x401945]\n/tmp/tmp_tvaz5nr[0x401602]\n/tmp/tmp_tvaz5nr[0x4012c8]\n/tmp/tmp_tvaz5nr[0x40125f]\n/tmp/tmp_tvaz5nr[0x400b8a]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b72bbec8555]\n/tmp/tmp_tvaz5nr[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 2414                               /tmp/tmp_tvaz5nr\n00604000-00605000 r--p 00004000 08:02 2414                               /tmp/tmp_tvaz5nr\n00605000-00606000 rw-p 00005000 08:02 2414                               /tmp/tmp_tvaz5nr\n01756000-01788000 rw-p 00000000 00:00 0                                  [heap]\n2b72bb38f000-2b72bb3b1000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b72bb3b1000-2b72bb3b4000 rw-p 00000000 00:00 0 \n2b72bb3cc000-2b72bb3d1000 rw-p 00000000 00:00 0 \n2b72bb5b0000-2b72bb5b1000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpxyyu0sbh: /tmp/tmpxyyu0sbh.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] == arr[i+1]) {\n            arr[i] = arr[i+1] = 0;\n            if(i == arr.size()-1) return true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmporzb0nza: /tmp/tmporzb0nza.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < arr[i + 1]) {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n            arr[i] = arr[i] - arr[i + 1];\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpn31dsuz3': free(): invalid next size (fast): 0x000000000236ec20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2ab23608a329]\n/tmp/tmpn31dsuz3[0x401d94]\n/tmp/tmpn31dsuz3[0x4019b9]\n/tmp/tmpn31dsuz3[0x401604]\n/tmp/tmpn31dsuz3[0x401302]\n/tmp/tmpn31dsuz3[0x401299]\n/tmp/tmpn31dsuz3[0x400bca]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2ab23602b555]\n/tmp/tmpn31dsuz3[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 2434                               /tmp/tmpn31dsuz3\n00604000-00605000 r--p 00004000 08:02 2434                               /tmp/tmpn31dsuz3\n00605000-00606000 rw-p 00005000 08:02 2434                               /tmp/tmpn31dsuz3\n0235d000-0238f000 rw-p 00000000 00:00 0                                  [heap]\n2ab2354f2000-2ab235514000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2ab235514000-2ab235517000 rw-p 00000000 00:00 0 \n2ab23552f000-2ab235534000 rw-p 00000000 00:00 0 \n2ab235713000-2ab235714000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        int j = i + 1;\n        while (j < n && arr[j] >= arr[i]) {\n            arr[j] -= arr[i];\n            j++;\n        }\n        i = j;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmpjzebl2g5: /tmp/tmpjzebl2g5.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        } else {\n            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp0mumqzc3': free(): invalid next size (fast): 0x0000000001edec20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2afee8e93329]\n/tmp/tmp0mumqzc3[0x401694]\n/tmp/tmp0mumqzc3[0x40159f]\n/tmp/tmp0mumqzc3[0x401422]\n/tmp/tmp0mumqzc3[0x401212]\n/tmp/tmp0mumqzc3[0x4011a9]\n/tmp/tmp0mumqzc3[0x400bc8]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2afee8e34555]\n/tmp/tmp0mumqzc3[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2432                               /tmp/tmp0mumqzc3\n00602000-00603000 r--p 00002000 08:02 2432                               /tmp/tmp0mumqzc3\n00603000-00604000 rw-p 00003000 08:02 2432                               /tmp/tmp0mumqzc3\n01ecd000-01eff000 rw-p 00000000 00:00 0                                  [heap]\n2afee82fb000-2afee831d000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2afee831d000-2afee8320000 rw-p 00000000 00:00 0 \n2afee8338000-2afee833d000 rw-p 00000000 00:00 0 \n2afee851c000-2afee851d000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i + 1];\n            arr[i + 1] = arr[0];\n        }\n    }\n    return arr[0] != arr[1];\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmpj054_6u0: /tmp/tmpj054_6u0.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i + 1];\n            arr[i + 1] = arr[i];\n            i = 0;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmprdzthuug: /tmp/tmprdzthuug.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < arr[i + 1]) {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i] - arr[i + 1];\n            arr[i] = arr[i] - arr[i + 1];\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpjpe7apdh': free(): invalid next size (fast): 0x0000000001787c20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b6096404329]\n/tmp/tmpjpe7apdh[0x401d84]\n/tmp/tmpjpe7apdh[0x4019a9]\n/tmp/tmpjpe7apdh[0x4015f4]\n/tmp/tmpjpe7apdh[0x4012f2]\n/tmp/tmpjpe7apdh[0x401289]\n/tmp/tmpjpe7apdh[0x400bba]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b60963a5555]\n/tmp/tmpjpe7apdh[0x400859]\n======= Memory map: ========\n00400000-00405000 r-xp 00000000 08:02 2423                               /tmp/tmpjpe7apdh\n00604000-00605000 r--p 00004000 08:02 2423                               /tmp/tmpjpe7apdh\n00605000-00606000 rw-p 00005000 08:02 2423                               /tmp/tmpjpe7apdh\n01776000-017a8000 rw-p 00000000 00:00 0                                  [heap]\n2b609586c000-2b609588e000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b609588e000-2b6095891000 rw-p 00000000 00:00 0 \n2b60958a9000-2b60958ae000 rw-p 00000000 00:00 0 \n2b6095a8d000-2b6095a8e000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292759,
      "stdout": "",
      "stderr": "tmp75ezswc9: /tmp/tmp75ezswc9.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmp3jckyghh: /tmp/tmp3jckyghh.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmppeus32td: /tmp/tmppeus32td.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    if (n == 1) return true;\n    if (n == 2) return true;\n    if (n == 3) return true;\n    if (n == 4) return true;\n    if (n == 5) return true;\n    if (n == 6) return true;\n    if (n == 7) return true;\n    if (n == 8) return true;\n    if (n == 9) return true;\n    if (n == 10) return true;\n    if (n == 11) return true;\n    if (n == 12) return true;\n    if (n == 13) return true;\n    if (n == 14) return true;\n    if (n == 15) return true;\n    if (n == 16) return true;\n    if (n == 17) return true;\n    if (n == 18) return true;\n    if (n == 19) return true;\n    if (n == 20) return true;\n    if (n == 21) return true;\n    if (n == 22) return true;\n    if (n == 23) return true;\n    if (n == 24) return true;\n    if (n == 25) return true;\n    if (n == 26) return true;\n    if (n == 27) return true;\n    if (n == 28) return true;\n    if (n == 29) return true;\n    if (n == 30) return true;\n    if (n == 31) return true;\n    if (n == 32) return true;\n    if (n == 33) return true;\n    if (n == 34) return true;\n    if (n == 35) return true;\n    if (n == 36) return true;\n    if (n == 37) return true;\n    if (n == 38) return true;\n    if (n == 39) return true;\n    if (n == 40) return true;\n    if (n == 41) return true;\n    if (n == 42) return true;\n    if (n == 43) return true;\n    if (n == 44) return true;\n    if (n == 45) return\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "/tmp/tmp8o4p04dr.cpp: In function \u2018bool move_one_ball(std::vector<long int>)\u2019:\n/tmp/tmp8o4p04dr.cpp:72:1: error: expected primary-expression before \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmp8o4p04dr.cpp:71:24: error: expected \u2018;\u2019 before \u2018}\u2019 token\n   71 |     if (n == 45) return\n      |                        ^\n      |                        ;\n   72 | }\n      | ~                       \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = 0;\n        }\n        else if(arr[i] > 0) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = 0;\n        }\n        else break;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmp6d6j_3h6: /tmp/tmp6d6j_3h6.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n-1) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpi_yrhj86: /tmp/tmpi_yrhj86.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmprwamoiio: /tmp/tmprwamoiio.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpwce2m49d: /tmp/tmpwce2m49d.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    for(int i=0;i<n;i++)\n        arr[i]=(arr[i]+arr[i+1])/2;\n    for(int i=1;i<n;i++)\n        if(arr[i]<arr[i-1]) return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmp5rv2a58q: /tmp/tmp5rv2a58q.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpcvlle_1y: /tmp/tmpcvlle_1y.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            i++;\n        }\n    }\n    if (arr[i] > 0) return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292784,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmpue6sg6m6: /tmp/tmpue6sg6m6.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[i] + 1;\n            arr[i + 1] = arr[i] - 1;\n        }\n    }\n    return std::is_sorted(arr.begin(), arr.end());\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmp75pltty5: /tmp/tmp75pltty5.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n-1) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpi_yrhj86: /tmp/tmpi_yrhj86.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        if(arr[i] == arr[i + 1]) {\n            arr[i] = arr[0];\n            arr[0] = arr[i + 1];\n            arr[i + 1] = arr[i];\n            arr.erase(arr.begin() + i + 1);\n        }\n    }\n    return arr.empty();\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpletepgw7: /tmp/tmpletepgw7.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = arr.size()-1; i >= 0; i--){\n        if(arr[i] == arr[i+1]){\n            arr[i] = arr[0];\n            arr.erase(arr.begin()+i+1);\n        }\n    }\n    return arr.empty();\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpilco3w1t: /tmp/tmpilco3w1t.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpwce2m49d: /tmp/tmpwce2m49d.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i] - arr[i+1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpnre7n3nc: /tmp/tmpnre7n3nc.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + 1]) {\n            arr[i] = arr[i] + 1;\n            arr[i + 1] = arr[i + 1] - 1;\n            if (arr[i] == arr[i + 1]) {\n                arr[i] = arr[i] + 1;\n                arr[i + 1] = arr[i + 1] - 1;\n            }\n        }\n    }\n    return arr[0] == 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpd9d9fw7k: /tmp/tmpd9d9fw7k.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    return arr.empty();\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpx6wxdmyo: /tmp/tmpx6wxdmyo.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292767,
      "stdout": "",
      "stderr": "tmpbmdo27dn: /tmp/tmpbmdo27dn.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "tmpfdc31t83: /tmp/tmpfdc31t83.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = arr.size()-1; i >= 0; i--) {\n        if(arr[i] == arr[i-1]) {\n            arr[i] = arr[i-1] = 0;\n        } else {\n            break;\n        }\n    }\n    return arr.empty();\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmpqcpuw143: /tmp/tmpqcpuw143.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] != i + 1) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmppjb1jhjf: /tmp/tmppjb1jhjf.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = arr.size()-1; i >= 0; i--){\n        if(arr[i] == arr[i+1]){\n            arr[i] = arr[0];\n            arr[0] = arr[i+1];\n            arr[i+1] = arr[i];\n        }\n    }\n    return arr[0] == arr[1];\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "tmp164zux_4: /tmp/tmp164zux_4.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int i = 0;\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        } else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292757,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmpxp6j0p68': free(): invalid next size (fast): 0x000000000188dc20 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b145108b329]\n/tmp/tmpxp6j0p68[0x401628]\n/tmp/tmpxp6j0p68[0x401533]\n/tmp/tmpxp6j0p68[0x4013b6]\n/tmp/tmpxp6j0p68[0x4011a6]\n/tmp/tmpxp6j0p68[0x40113d]\n/tmp/tmpxp6j0p68[0x400b5d]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b145102c555]\n/tmp/tmpxp6j0p68[0x400859]\n======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2355                               /tmp/tmpxp6j0p68\n00602000-00603000 r--p 00002000 08:02 2355                               /tmp/tmpxp6j0p68\n00603000-00604000 rw-p 00003000 08:02 2355                               /tmp/tmpxp6j0p68\n0187c000-018ae000 rw-p 00000000 00:00 0                                  [heap]\n2b14504f3000-2b1450515000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b1450515000-2b1450518000 rw-p 00000000 00:00 0 \n2b1450530000-2b1450535000 rw-p 00000000 00:00 0 \n2b1450714000-2b1450715000 r--p 00021000 08:0",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292771,
      "stdout": "",
      "stderr": "tmpwk2pajwn: /tmp/tmpwk2pajwn.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292771,
      "stdout": "",
      "stderr": "tmprj3mkd6u: /tmp/tmprj3mkd6u.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = arr[i + 1] + arr[i];\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = arr[i + 1] - arr[i];\n        }\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292763,
      "stdout": "",
      "stderr": "tmpzkv72p1b: /tmp/tmpzkv72p1b.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i+1]) {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i] - arr[i+1];\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292771,
      "stdout": "",
      "stderr": "tmpg2q3_sc8: /tmp/tmpg2q3_sc8.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([3, 4, 5, 1, 2])\n// True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball([3, 5, 4, 1, 2])\n// False\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] = arr[i] - arr[i + 1];\n            arr[i + 1] = 0;\n        }\n        else {\n            arr[i] = arr[i] + arr[i + 1];\n            arr[i + 1] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
      "timestamp": 1664292761,
      "stdout": "",
      "stderr": "tmp0hk9y1z9: /tmp/tmp0hk9y1z9.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}