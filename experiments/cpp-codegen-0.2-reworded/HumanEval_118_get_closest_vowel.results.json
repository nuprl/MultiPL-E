{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n",
  "tests": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0) {\n                result = \"\";\n                break;\n            }\n            if (i == word.size() - 1) {\n                result = \"\";\n                break;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n            if (vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp5mp2u4p3: /tmp/tmp5mp2u4p3.cpp:49: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpchy9b3c2: /tmp/tmpchy9b3c2.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            i++;\n        } else if (consonants.find(word[j]) != std::string::npos) {\n            j++;\n        } else {\n            break;\n        }\n    }\n    if (i == word.size() || j == word.size()) {\n        return \"\";\n    }\n    return word[i];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpz4td8t3k.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpz4td8t3k.cpp:34:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   34 |     return word[i];\n      |                  ^\n      |                  |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp02n24h4h: /tmp/tmp02n24h4h.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpwi09src7: /tmp/tmpwi09src7.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpr3zo8coy: /tmp/tmpr3zo8coy.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpw_j9x12c: /tmp/tmpw_j9x12c.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i > 0 && consonants.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n            else if (i < word.size() - 1 && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpuvkz5hhv: /tmp/tmpuvkz5hhv.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    i++;\n    while (i < word.length() && consonants.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    i++;\n    while (i < word.length() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    return word[i];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp6wj42cx5.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp6wj42cx5.cpp:41:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   41 |     return word[i];\n      |                  ^\n      |                  |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpchy9b3c2: /tmp/tmpchy9b3c2.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= 0 && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    if (j == -1) {\n        return \"\";\n    }\n    return word[j + 1];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpdhybnphv.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpdhybnphv.cpp:33:22: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)(j + 1)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   33 |     return word[j + 1];\n      |                      ^\n      |                      |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpgrp30sd7: /tmp/tmpgrp30sd7.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpk5hmatno: /tmp/tmpk5hmatno.cpp:33: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2l9d8fvm: /tmp/tmp2l9d8fvm.cpp:33: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    while (i < word.length() && j < word.length()) {\n        if (vowels.find(word[j]) != std::string::npos) {\n            i = j;\n        }\n        else if (vowels.find(word[i]) != std::string::npos) {\n            j = i;\n        }\n        else {\n            i++;\n            j++;\n        }\n    }\n    if (i == word.length() || j == word.length()) {\n        return \"\";\n    }\n    else {\n        return word[i];\n    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp4jviq3hh.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp4jviq3hh.cpp:37:22: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   37 |         return word[i];\n      |                      ^\n      |                      |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while (i >= 0 && vowels.find(word[i]) == std::string::npos) {\n        i--;\n    }\n    if (i < 0) {\n        return \"\";\n    }\n    int j = i + 1;\n    while (j < word.length() && vowels.find(word[j]) == std::string::npos) {\n        j++;\n    }\n    return word[i] + word[j];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpxcnlinae.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpxcnlinae.cpp:30:20: error: could not convert \u2018(((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) + ((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j))))\u2019 from \u2018int\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   30 |     return word[i] + word[j];\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpw5cgz47w: /tmp/tmpw5cgz47w.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpophyp3sf: /tmp/tmpophyp3sf.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpr3zo8coy: /tmp/tmpr3zo8coy.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpveet_din: /tmp/tmpveet_din.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    int i = 0;\n    while (i < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        else if (consonants.find(word[i]) != std::string::npos) {\n            i++;\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpnd37vhbl: /tmp/tmpnd37vhbl.cpp:38: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmprp9rteb8: /tmp/tmprp9rteb8.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpqxoe20je: /tmp/tmpqxoe20je.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpt9ypmm_p: /tmp/tmpt9ypmm_p.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= 0 && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    if (j == -1) {\n        return \"\";\n    }\n    return word[i] + word[j];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp20wje9nf.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp20wje9nf.cpp:33:20: error: could not convert \u2018(((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) + ((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j))))\u2019 from \u2018int\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   33 |     return word[i] + word[j];\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0) {\n                result = \"\";\n                break;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmp1scii5vd: /tmp/tmp1scii5vd.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmps6rwg4as: /tmp/tmps6rwg4as.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpeypt3u36: /tmp/tmpeypt3u36.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string res;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            res = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                res = word[i];\n                break;\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmp1vsns9ip: /tmp/tmp1vsns9ip.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() - 1) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            break;\n        }\n        i++;\n    }\n    if (i == word.length() - 1) {\n        return \"\";\n    }\n    int j = word.length() - 1;\n    while (j >= i) {\n        if (vowels.find(word[j]) != std::string::npos) {\n            return word[j];\n        }\n        j--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp6nakyzn8.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp6nakyzn8.cpp:32:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   32 |             return word[j];\n      |                          ^\n      |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmp3x0hi2xf: /tmp/tmp3x0hi2xf.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpr3zo8coy: /tmp/tmpr3zo8coy.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmp80m_as7c: /tmp/tmp80m_as7c.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpt9ypmm_p: /tmp/tmpt9ypmm_p.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpartc6hbq: /tmp/tmpartc6hbq.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (j == 0) {\n                result = word[i];\n                j++;\n            }\n            else {\n                result = \"\";\n                break;\n            }\n        }\n        else if (consonants.find(word[i]) != std::string::npos) {\n            if (j == 0) {\n                result = \"\";\n                break;\n            }\n            else {\n                result = \"\";\n                j = 0;\n            }\n        }\n        i++;\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmp32ks2zdb: /tmp/tmp32ks2zdb.cpp:50: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpbofx5y66: /tmp/tmpbofx5y66.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpw_j9x12c: /tmp/tmpw_j9x12c.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmphukbkkio: /tmp/tmphukbkkio.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string res;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            res = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpqgh4dmsg: /tmp/tmpqgh4dmsg.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpk5hmatno: /tmp/tmpk5hmatno.cpp:33: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            j = i;\n            break;\n        }\n        i++;\n    }\n    while (j < word.size()) {\n        if (vowels.find(word[j]) != std::string::npos) {\n            return word.substr(j, 1);\n        }\n        if (consonants.find(word[j]) != std::string::npos) {\n            break;\n        }\n        j++;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmp6s89tfln: /tmp/tmp6s89tfln.cpp:42: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmps08utqgq: /tmp/tmps08utqgq.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpdn0arvuf: /tmp/tmpdn0arvuf.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpartc6hbq: /tmp/tmpartc6hbq.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpky8uofgz: /tmp/tmpky8uofgz.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= 0 && consonants.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ? word[i] : word[j];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp5atmq6s_.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp5atmq6s_.cpp:31:99: error: could not convert \u2018((((((((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 97) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 101)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 105)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 111)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 117)) ? word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i)) : word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   31 |     return word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ? word[i] : word[j];\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= 0 && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ? word[i] : word[j];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp0mv9gi64.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp0mv9gi64.cpp:30:99: error: could not convert \u2018((((((((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 97) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 101)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 105)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 111)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 117)) ? word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i)) : word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   30 |     return word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ? word[i] : word[j];\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmp1wcs0851: /tmp/tmp1wcs0851.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n            if (i < word.length() - 1 && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpij2uhnp_: /tmp/tmpij2uhnp_.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i > 0 && consonants.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n            if (i < word.size() - 1 && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpa8dywnfs: /tmp/tmpa8dywnfs.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp5mgwu98z: /tmp/tmp5mgwu98z.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpwi09src7: /tmp/tmpwi09src7.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpx5d9mwsx: /tmp/tmpx5d9mwsx.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    i++;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    return word[i];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmp4bzgtnih.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp4bzgtnih.cpp:33:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   33 |     return word[i];\n      |                  ^\n      |                  |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpzsrgxmlt: /tmp/tmpzsrgxmlt.cpp:33: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmps2p5o7bj: /tmp/tmps2p5o7bj.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string res = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            res = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                res = word[i];\n                break;\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpl7lxfcne: /tmp/tmpl7lxfcne.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp5mgwu98z: /tmp/tmp5mgwu98z.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpx5d9mwsx: /tmp/tmpx5d9mwsx.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpartc6hbq: /tmp/tmpartc6hbq.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmphukbkkio: /tmp/tmphukbkkio.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    int j = word.length() - 1;\n    while (j >= 0 && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ? word[i] : word[j];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpzgaxbn7k.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpzgaxbn7k.cpp:30:99: error: could not convert \u2018((((((((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 97) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 101)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 105)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 111)) || (((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) == 117)) ? word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i)) : word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   30 |     return word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ? word[i] : word[j];\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpr3zo8coy: /tmp/tmpr3zo8coy.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpi_vpd0sh: /tmp/tmpi_vpd0sh.cpp:36: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpya6flbhj: /tmp/tmpya6flbhj.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpqlsst821: /tmp/tmpqlsst821.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpw5cgz47w: /tmp/tmpw5cgz47w.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            i++;\n        } else if (consonants.find(word[j]) != std::string::npos) {\n            j++;\n        } else {\n            return \"\";\n        }\n    }\n    return word.substr(i, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp2sey0mwp: /tmp/tmp2sey0mwp.cpp:35: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpuhkow8rn: /tmp/tmpuhkow8rn.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n            if (i < word.size() - 1 && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i + 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpct202nvx: /tmp/tmpct202nvx.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpchy9b3c2: /tmp/tmpchy9b3c2.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpbofx5y66: /tmp/tmpbofx5y66.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            j = i + 1;\n        }\n        else {\n            i++;\n        }\n    }\n    if (j == word.size()) {\n        return \"\";\n    }\n    else {\n        return word[j];\n    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpm1yu9x7k.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpm1yu9x7k.cpp:33:22: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   33 |         return word[j];\n      |                      ^\n      |                      |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int count = 0;\n    while (i < word.length()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            count++;\n            if (count == 1) {\n                i++;\n                continue;\n            }\n            if (count == 2) {\n                i++;\n                continue;\n            }\n            if (count == 3) {\n                i++;\n                continue;\n            }\n            if (count == 4) {\n                i++;\n                continue;\n            }\n            if (count == 5) {\n                i++;\n                continue;\n            }\n            if (count == 6) {\n                i++;\n                continue;\n            }\n            if (count == 7) {\n                i++;\n                continue;\n            }\n            if (count == 8) {\n                i++;\n                continue;\n            }\n            if (count == 9) {\n                i++;\n                continue;\n            }\n            if (count == 10) {\n                i++;\n                continue;\n            }\n            if (count == 11) {\n                i++;\n                continue;\n            }\n            if (count == 12) {\n                i++;\n                continue;\n            }\n            if (count == 13) {\n                i++;\n                continue;\n            }\n            if (count == 14) {\n                i++;\n                continue;\n            }\n            if (count == 15) {\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmp5nsdgepv.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp5nsdgepv.cpp:100:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n  100 | int main() {\n      |            ^\n/tmp/tmp5nsdgepv.cpp:115:1: error: expected \u2018}\u2019 at end of input\n  115 | }\n      | ^\n/tmp/tmp5nsdgepv.cpp:40:56: note: to match this \u2018{\u2019\n   40 |         if (vowels.find(word[i]) != std::string::npos) {\n      |                                                        ^\n/tmp/tmp5nsdgepv.cpp:115:1: error: expected \u2018}\u2019 at end of input\n  115 | }\n      | ^\n/tmp/tmp5nsdgepv.cpp:39:31: note: to match this \u2018{\u2019\n   39 |     while (i < word.length()) {\n      |                               ^\n/tmp/tmp5nsdgepv.cpp:115:1: error: expected \u2018}\u2019 at end of input\n  115 | }\n      | ^\n/tmp/tmp5nsdgepv.cpp:17:49: note: to match this \u2018{\u2019\n   17 | std::string get_closest_vowel(std::string word) {\n      |                                                 ^\n/tmp/tmp5nsdgepv.cpp:115:1: warning: no return statement in function returning non-void [-Wreturn-type]\n  115 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpkp6vxwik: /tmp/tmpkp6vxwik.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpt9ypmm_p: /tmp/tmpt9ypmm_p.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            i++;\n        } else if (consonants.find(word[j]) != std::string::npos) {\n            j++;\n        } else {\n            return \"\";\n        }\n    }\n    return word.substr(i, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp2sey0mwp: /tmp/tmp2sey0mwp.cpp:35: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            result = \"\";\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpihwljrkj: /tmp/tmpihwljrkj.cpp:35: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            i++;\n        } else if (consonants.find(word[j]) != std::string::npos) {\n            j++;\n        } else {\n            break;\n        }\n    }\n    if (i == word.size() || j == word.size()) {\n        return \"\";\n    }\n    return word[i];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpz4td8t3k.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpz4td8t3k.cpp:34:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   34 |     return word[i];\n      |                  ^\n      |                  |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= 0 && consonants.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    if (j == -1) {\n        return \"\";\n    }\n    std::string result = \"\";\n    while (i <= j) {\n        if (vowels.find(word[i]) != std::string::npos && vowels.find(word[j]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        i++;\n        j--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpb6ea66pu: /tmp/tmpb6ea66pu.cpp:48: int main(): Assertion `candidate((\"full\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp37neda6z: /tmp/tmp37neda6z.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    while (i < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            i++;\n            continue;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            j = i;\n            while (j < word.size() && vowels.find(word[j]) == std::string::npos) {\n                j++;\n            }\n            if (j - i > 1) {\n                k = j - 1;\n                while (k > i && consonants.find(word[k]) == std::string::npos) {\n                    k--;\n                }\n                if (k - i > 1) {\n                    l = k - 1;\n                    while (l > i && consonants.find(word[l]) == std::string::npos) {\n                        l--;\n                    }\n                    if (l - i > 1) {\n                        m = l - 1;\n                        while (m > i && consonants.find(word[m]) == std::string::npos) {\n                            m--;\n                        }\n                        if (m - i > 1) {\n                            n = m - 1;\n                            while (n > i && consonants.find(word[n]) == std::string::npos) {\n                                n--;\n                            }\n                            if (n - i > 1) {\n\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpkiwtflmq.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpkiwtflmq.cpp:71:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   71 | int main() {\n      |            ^\n/tmp/tmpkiwtflmq.cpp:86:1: error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpkiwtflmq.cpp:63:40: note: to match this \u2018{\u2019\n   63 |                         if (m - i > 1) {\n      |                                        ^\n/tmp/tmpkiwtflmq.cpp:86:1: error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpkiwtflmq.cpp:58:36: note: to match this \u2018{\u2019\n   58 |                     if (l - i > 1) {\n      |                                    ^\n/tmp/tmpkiwtflmq.cpp:86:1: error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpkiwtflmq.cpp:53:32: note: to match this \u2018{\u2019\n   53 |                 if (k - i > 1) {\n      |                                ^\n/tmp/tmpkiwtflmq.cpp:86:1: error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpkiwtflmq.cpp:48:28: note: to match this \u2018{\u2019\n   48 |             if (j - i > 1) {\n      |                            ^\n/tmp/tmpkiwtflmq.cpp:86:1: error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpkiwtflmq.cpp:43:60: note: to match this \u2018{\u2019\n   43 |         if (consonants.find(word[i]) != std::string::npos) {\n      |                                                            ^\n/tmp/tmpkiwtflmq.cpp:86:1: error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpkiwtflmq.cpp:38:29: note: to match this \u2018{\u2019\n   38 |     while (i < word.size()) {\n      |                             ^\n/tmp/tmpkiwtflmq.cpp:86:1: error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpkiwtflmq.cpp:17:49: note: to match this \u2018{\u2019\n   17 | std::string get_closest_vowel(std::string word) {\n      |                                                 ^\n/tmp/tmpkiwtflmq.cpp:86:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   86 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpu9eie7kd: /tmp/tmpu9eie7kd.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmpwwmalwmj: /tmp/tmpwwmalwmj.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp5mgwu98z: /tmp/tmp5mgwu98z.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2l9d8fvm: /tmp/tmp2l9d8fvm.cpp:33: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n            if (i < word.size() - 1 && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i + 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp03r3209q: /tmp/tmp03r3209q.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            j = i;\n            k = i + 1;\n            while (k < word.size() && consonants.find(word[k]) != std::string::npos) {\n                k++;\n            }\n            if (k - j > 1) {\n                return word.substr(j + 1, k - j - 1);\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmpi2eb45hg: /tmp/tmpi2eb45hg.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    int i = 0;\n    while (i < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            i++;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp197hfqek: /tmp/tmp197hfqek.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmpftsagafu: /tmp/tmpftsagafu.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpkp6vxwik: /tmp/tmpkp6vxwik.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n            if (i < word.size() - 1 && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i + 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp8d1amthi: /tmp/tmp8d1amthi.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                result = \"\";\n                break;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmpnuwwhg_c: /tmp/tmpnuwwhg_c.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (size_t i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpwi09src7: /tmp/tmpwi09src7.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmps2p5o7bj: /tmp/tmps2p5o7bj.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= 0 && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word[i] + word[j];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpv2ripuln.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpv2ripuln.cpp:30:20: error: could not convert \u2018(((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))) + ((int)word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)j))))\u2019 from \u2018int\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   30 |     return word[i] + word[j];\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= 0 && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word.substr(i, j - i + 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp0e39y6no: /tmp/tmp0e39y6no.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmphukbkkio: /tmp/tmphukbkkio.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (vowels.find(word[i - 1]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n            if (vowels.find(word[i + 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i + 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp6fxdb46m: /tmp/tmp6fxdb46m.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpk5hmatno: /tmp/tmpk5hmatno.cpp:33: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    i++;\n    while (i < word.length() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    return word[i];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpceoqqa5l.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpceoqqa5l.cpp:33:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   33 |     return word[i];\n      |                  ^\n      |                  |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp37neda6z: /tmp/tmp37neda6z.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpr3zo8coy: /tmp/tmpr3zo8coy.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 1) {\n                result = \"\";\n                break;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp20j5mw7u: /tmp/tmp20j5mw7u.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpgrp30sd7: /tmp/tmpgrp30sd7.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpartc6hbq: /tmp/tmpartc6hbq.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            result = \"\";\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmpihwljrkj: /tmp/tmpihwljrkj.cpp:35: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpartc6hbq: /tmp/tmpartc6hbq.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            k = i;\n            while (j < word.size() && consonants.find(word[j]) != std::string::npos) {\n                j++;\n            }\n            if (j == word.size()) {\n                return word.substr(k, 1);\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmppv60syu3: /tmp/tmppv60syu3.cpp:39: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.size()) {\n        return \"\";\n    }\n    int j = word.size() - 1;\n    while (j >= i && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word.substr(i, j - i + 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmpznl7sxmx: /tmp/tmpznl7sxmx.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2l9d8fvm: /tmp/tmp2l9d8fvm.cpp:33: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    int j = word.length() - 1;\n    while (j >= i && vowels.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word.substr(i, j - i + 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp2dlyenvo: /tmp/tmp2dlyenvo.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpr3zo8coy: /tmp/tmpr3zo8coy.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpbofx5y66: /tmp/tmpbofx5y66.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp38tj1tpy: /tmp/tmp38tj1tpy.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    while (i < word.length() && j < word.length()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            i++;\n        } else if (consonants.find(word[j]) != std::string::npos) {\n            j++;\n        } else {\n            return \"\";\n        }\n    }\n    return word[i];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpdv23yxzs.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpdv23yxzs.cpp:31:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   31 |     return word[i];\n      |                  ^\n      |                  |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == std::string::npos) {\n        i++;\n    }\n    if (i == word.length()) {\n        return \"\";\n    }\n    int j = word.length() - 1;\n    while (j >= 0 && consonants.find(word[j]) == std::string::npos) {\n        j--;\n    }\n    return word.substr(i, j - i + 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmpgg6bem1b: /tmp/tmpgg6bem1b.cpp:35: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp2b76csct: /tmp/tmp2b76csct.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmpbofx5y66: /tmp/tmpbofx5y66.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "tmps08utqgq: /tmp/tmps08utqgq.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    int j = 0;\n    while (i < word.size() && j < word.size()) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            i++;\n        } else if (consonants.find(word[j]) != std::string::npos) {\n            j++;\n        } else {\n            break;\n        }\n    }\n    if (i == word.size() || j == word.size()) {\n        return \"\";\n    }\n    return word[i];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpz4td8t3k.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpz4td8t3k.cpp:34:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   34 |     return word[i];\n      |                  ^\n      |                  |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmpjmdup1q1: /tmp/tmpjmdup1q1.cpp:37: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            if (vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "tmp37neda6z: /tmp/tmp37neda6z.cpp:40: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpjzf5_vx1: /tmp/tmpjzf5_vx1.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n            if (i < word.length() - 1 && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i + 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp6bzaxpil: /tmp/tmp6bzaxpil.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.size(); ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n            if (i < word.size() - 1 && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i + 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp03r3209q: /tmp/tmp03r3209q.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.length() - 1; ++i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmplfaaw1p6: /tmp/tmplfaaw1p6.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpvxjmxyo9: /tmp/tmpvxjmxyo9.cpp:34: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 1; i < word.size() - 1; i++) {\n        if (vowels.find(word[i]) != std::string::npos && consonants.find(word[i - 1]) != std::string::npos && consonants.find(word[i + 1]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpw_j9x12c: /tmp/tmpw_j9x12c.cpp:31: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n            break;\n        }\n        if (consonants.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) != std::string::npos) {\n                result = word[i - 1];\n                break;\n            }\n            if (i < word.length() - 1 && vowels.find(word[i + 1]) != std::string::npos) {\n                result = word[i + 1];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "tmp6bzaxpil: /tmp/tmp6bzaxpil.cpp:41: int main(): Assertion `candidate((\"yogurt\")) == (\"u\")' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}