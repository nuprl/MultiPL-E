language: swift
name: HumanEval_58_common
results:
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var result: [Int] = []\n    var i = 0\n    var j = 0\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let commonSet = set1.intersection(set2)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var result: [Int] = []\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var common = [Int]()\n    while\
    \ i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n            common.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var common = [Int]()\n    while\
    \ i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n            common.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var l3 = [Int]()\n    var i = 0\n    var j = 0\n    while i < l1.count &&\
    \ j < l2.count {\n        if l1[i] == l2[j] {\n            l3.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return l3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var result: [Int] = []\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var res = [Int]()\n    while\
    \ i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n            res.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdctwuh73.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2)))\n                \
    \ ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var l3 = [Int]()\n    var i = 0\n    var j = 0\n    while i < l1.count &&\
    \ j < l2.count {\n        if l1[i] == l2[j] {\n            l3.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return l3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if l2.contains(i) {\n            result.append(i)\n        }\n    }\n\
    \    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdctwuh73.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2)))\n                \
    \ ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var result: [Int] = []\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    return Array(l1Set.intersection(l2Set)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var result: [Int] = []\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var result: [Int] = []\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if l2.contains(i) {\n            result.append(i)\n        }\n    }\n\
    \    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l = l1\n    var r = l2\n    l.sort()\n\
    \    r.sort()\n    var i = 0\n    var j = 0\n    var result = [Int]()\n    while\
    \ i < l.count && j < r.count {\n        if l[i] == r[j] {\n            result.append(l[i])\n\
    \            i += 1\n            j += 1\n        } else if l[i] < r[j] {\n   \
    \         i += 1\n        } else {\n            j += 1\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l = [Int]()\n    for i in l1 {\n     \
    \   if l2.contains(i) {\n            l.append(i)\n        }\n    }\n    return\
    \ l.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var l1 = l1\n\
    \    var l2 = l2\n    l1.sort()\n    l2.sort()\n    var i = 0\n    var j = 0\n\
    \    while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n     \
    \       result.append(l1[i])\n            i += 1\n            j += 1\n       \
    \ } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n          \
    \  j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while\
    \ i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < l1.count\
    \ && j < l2.count {\n        if l1[i] == l2[j] {\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var i = 0\n    var j = 0\n    var result: [Int] = []\n    while i < l1.count\
    \ && j < l2.count {\n        if l1[i] == l2[j] {\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let intersection = l1Set.intersection(l2Set)\n    return Array(intersection).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var l1Index = 0\n    var l2Index = 0\n    var result: [Int] = []\n    while\
    \ l1Index < l1.count && l2Index < l2.count {\n        if l1[l1Index] == l2[l2Index]\
    \ {\n            result.append(l1[l1Index])\n            l1Index += 1\n      \
    \      l2Index += 1\n        } else if l1[l1Index] < l2[l2Index] {\n         \
    \   l1Index += 1\n        } else {\n            l2Index += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var result: [Int] = []\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var l3 = [Int]()\n    var i = 0\n    var j = 0\n    while i < l1.count &&\
    \ j < l2.count {\n        if l1[i] < l2[j] {\n            i += 1\n        } else\
    \ if l1[i] > l2[j] {\n            j += 1\n        } else {\n            l3.append(l1[i])\n\
    \            i += 1\n            j += 1\n        }\n    }\n    return l3\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var res = [Int]()\n    while\
    \ i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n            res.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var l1i = 0\n    var l2i = 0\n    var result: [Int] = []\n    while l1i <\
    \ l1.count && l2i < l2.count {\n        if l1[l1i] == l2[l2i] {\n            result.append(l1[l1i])\n\
    \            l1i += 1\n            l2i += 1\n        } else if l1[l1i] < l2[l2i]\
    \ {\n            l1i += 1\n        } else {\n            l2i += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n\
    \    let commonSet = l1Set.intersection(l2Set)\n    return Array(commonSet).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    return Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrd6rfzu.swift:4:26: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Array(Set(l1).intersect(Set(l2))).sorted()\n       \
    \          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n\
    \    let common = set1.intersection(set2)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   let s3 = s1.intersection(s2)\n    return Array(s3).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n \
    \   return Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n\
    \    l2.sort()\n    var i = 0\n    var j = 0\n    var result: [Int] = []\n   \
    \ while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n        \
    \    result.append(l1[i])\n            i += 1\n            j += 1\n        } else\
    \ if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979257
