language: swift
name: HumanEval_25_factorize
results:
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            result.append(i)\n         \
    \   n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var number = n\n    var i = 2\n    while number\
    \ > 1 {\n        while number % i == 0 {\n            factors.append(i)\n    \
    \        number /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var factor = 2\n    while factor\
    \ <= n {\n        if n % factor == 0 {\n            factors.append(factor)\n \
    \           n /= factor\n        } else {\n            factor += 1\n        }\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var i = 2\n    while number\
    \ > 1 {\n        while number % i == 0 {\n            result.append(i)\n     \
    \       number /= i\n        }\n        i += 1\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    for i in 2...n {\n        while\
    \ n % i == 0 {\n            factors.append(i)\n            n /= i\n        }\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var result = [Int]()\n    var i = 2\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            result.append(i)\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n\
    \        result.append(n)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var number = n\n    var i = 2\n    while i\
    \ * i <= number {\n        if number % i == 0 {\n            factors.append(i)\n\
    \            number /= i\n        } else {\n            i += 1\n        }\n  \
    \  }\n    if number > 1 {\n        factors.append(number)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            factors.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var number = n\n    var divisor = 2\n  \
    \  while number > 1 {\n        while number % divisor == 0 {\n            factors.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var result = [Int]()\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var number = n\n    var divisor = 2\n  \
    \  while number > 1 {\n        while number % divisor == 0 {\n            factors.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divider = 2\n    while\
    \ number > 1 {\n        while number % divider == 0 {\n            result.append(divider)\n\
    \            number /= divider\n        }\n        divider += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var i = 2\n    while i\
    \ * i <= number {\n        while number % i == 0 {\n            result.append(i)\n\
    \            number /= i\n        }\n        i += 1\n    }\n    if number > 1\
    \ {\n        result.append(number)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var result = [Int]()\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var result = [Int]()\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    for i in 2...n {\n        while\
    \ n % i == 0 {\n            result.append(i)\n            n /= i\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    for i in 2...n {\n        while\
    \ n % i == 0 {\n            result.append(i)\n            n /= i\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            result.append(i)\n         \
    \   n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var factor = 2\n    while factor\
    \ <= n {\n        if n % factor == 0 {\n            factors.append(factor)\n \
    \           n /= factor\n        } else {\n            factor += 1\n        }\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var number = n\n    var divider = 2\n   \
    \ while number > 1 {\n        while number % divider == 0 {\n            result.append(divider)\n\
    \            number /= divider\n        }\n        divider += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var n = n\n    var i = 2\n    while i *\
    \ i <= n {\n        while n % i == 0 {\n            factors.append(i)\n      \
    \      n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            factors.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            result.append(i)\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n\
    \        result.append(n)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var result = [Int]()\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var divisor = 2\n    while n\
    \ > 1 {\n        while n % divisor == 0 {\n            result.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var divisor = 2\n    while n\
    \ > 1 {\n        while n % divisor == 0 {\n            result.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            result.append(i)\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n\
    \        result.append(n)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var num = n\n    var i = 2\n    while num\
    \ > 1 {\n        while num % i == 0 {\n            factors.append(i)\n       \
    \     num /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var i = 2\n    while number\
    \ > 1 {\n        while number % i == 0 {\n            result.append(i)\n     \
    \       number /= i\n        }\n        i += 1\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var i = 2\n    while number\
    \ > 1 {\n        while number % i == 0 {\n            result.append(i)\n     \
    \       number /= i\n        }\n        i += 1\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var prime = 2\n    while\
    \ number > 1 {\n        while number % prime == 0 {\n            result.append(prime)\n\
    \            number /= prime\n        }\n        prime += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var result = [Int]()\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            factors.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divider = 2\n    while\
    \ number > 1 {\n        while number % divider == 0 {\n            result.append(divider)\n\
    \            number /= divider\n        }\n        divider += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var n = n\n    var i = 2\n    while n >\
    \ 1 {\n        while n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var num = n\n    var factor = 2\n    while\
    \ num > 1 {\n        while num % factor == 0 {\n            factors.append(factor)\n\
    \            num /= factor\n        }\n        factor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            factors.append(i)\n           \
    \ n /= i\n        } else {\n            i += 1\n        }\n    }\n    if n > 1\
    \ {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var i = 2\n    while number\
    \ > 1 {\n        while number % i == 0 {\n            result.append(i)\n     \
    \       number /= i\n        }\n        i += 1\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while n > 1\
    \ {\n        while n % i == 0 {\n            factors.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while n > 1 {\n\
    \        while n % i == 0 {\n            result.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var divisor = 2\n    while\
    \ n > 1 {\n        while n % divisor == 0 {\n            factors.append(divisor)\n\
    \            n /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var n = n\n    var factors = [Int]()\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var factor = 2\n    while\
    \ number > 1 {\n        while number % factor == 0 {\n            result.append(factor)\n\
    \            number /= factor\n        }\n        factor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var n = n\n    var i = 2\n    while i * i\
    \ <= n {\n        while n % i == 0 {\n            factors.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var n = n\n    var i = 2\n    while i * i <=\
    \ n {\n        while n % i == 0 {\n            result.append(i)\n            n\
    \ /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var result = [Int]()\n    var number = n\n    var divisor = 2\n    while\
    \ number > 1 {\n        while number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009163
