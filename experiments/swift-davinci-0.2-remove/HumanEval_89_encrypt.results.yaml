language: swift
name: HumanEval_89_encrypt
results:
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let encrypted = String(alphabet.dropFirst(2)\
    \ + alphabet.prefix(2))\n    var result = \"\"\n    for c in s {\n        if let\
    \ i = alphabet.firstIndex(of: c) {\n            result.append(encrypted[i])\n\
    \        } else {\n            result.append(c)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpikxhui2f/tmpikxhui2f.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8b2d62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8b2a59b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8b2a59988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8b2a587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpikxhui2f                        0x000055c857f78787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae8b2f4e460 __libc_start_main +
    245

    6    tmpikxhui2f                        0x000055c857f783c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let shift = 2 * 2\n\
    \    var encrypted = \"\"\n    for char in s {\n        if let idx = alphabet.index(of:\
    \ char) {\n            let newIdx = (alphabet.distance(from: alphabet.startIndex,\
    \ to: idx) + shift) % alphabet.count\n            encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIdx)])\n        } else {\n            encrypted.append(char)\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for character in s.characters {\n   \
    \     if let asciiValue = character.asciiValue {\n            let encryptedAsciiValue\
    \ = asciiValue + 2 * 2\n            if let encryptedCharacter = UnicodeScalar(encryptedAsciiValue)\
    \ {\n                encryptedString.append(Character(encryptedCharacter))\n \
    \           }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1njgsclb.swift:9:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in s.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp1njgsclb.swift:12:16:\
    \ error: initializer for conditional binding must have Optional type, not 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n            if let encryptedCharacter = UnicodeScalar(encryptedAsciiValue)\
    \ {\n               ^                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            let encryptedUnicode\
    \ = unicode + 2 * 2\n            let encryptedChar = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \            encryptedString += encryptedChar\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpe2mcgqa8/tmpe2mcgqa8.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afeadc8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afead986b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afead986988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afead9857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe2mcgqa8                        0x0000558f2bbb5e3e <unavailable> + 7742

    5    libc.so.6                          0x00002afeade7b460 __libc_start_main +
    245

    6    tmpe2mcgqa8                        0x0000558f2bbb5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ = encrypted + shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        result += String(char.unicodeScalars.first!.value\
    \ + 2 * 2)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp1zdv1hha/tmp1zdv1hha.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61da571c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61da268b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61da268988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61da2677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdv1hha                        0x0000564ff9587787 <unavailable> + 6023

    5    libc.so.6                          0x00002b61da75d460 __libc_start_main +
    245

    6    tmp1zdv1hha                        0x0000564ff95873c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2\n            let newChar =\
    \ alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n        \
    \    encrypted.append(newChar)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp9f4w7woj/tmp9f4w7woj.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06f31bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06f2eb6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06f2eb6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06f2eb57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9f4w7woj                        0x000055867943b6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b06f33ab460 __libc_start_main +
    245

    6    tmp9f4w7woj                        0x000055867943b2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 122 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 122) + 96\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if let ascii\
    \ = char.asciiValue {\n            let newAscii = ascii + 2 * 2\n            if\
    \ let newChar = UnicodeScalar(newAscii) {\n                encryptedString.append(Character(newChar))\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpimd_m0z7.swift:12:16: error: initializer for conditional binding\
    \ must have Optional type, not 'UnicodeScalar' (aka 'Unicode.Scalar')\n      \
    \      if let newChar = UnicodeScalar(newAscii) {\n               ^          \
    \   ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + 2\
    \ * 2\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            let encryptedUnicode\
    \ = unicode + (2 * 2)\n            let encryptedCharacter = Character(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \            encryptedString += String(encryptedCharacter)\n        }\n    }\n\
    \    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp_kmtxmin/tmp_kmtxmin.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23069c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23066b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23066b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23066b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_kmtxmin                        0x000055ef38a63e8e <unavailable> + 7822

    5    libc.so.6                          0x00002b2306bae460 __libc_start_main +
    245

    6    tmp_kmtxmin                        0x000055ef38a63689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let ascii =\
    \ char.asciiValue!\n        let newAscii = ascii + UInt8(2 * 2)\n        let newChar\
    \ = Character(UnicodeScalar(newAscii))\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp2__u8_oe/tmp2__u8_oe.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a63ebcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a63bb3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a63bb3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a63bb27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2__u8_oe                        0x000055ec962e8b8e <unavailable> + 7054

    5    libc.so.6                          0x00002b1a640a8460 __libc_start_main +
    245

    6    tmp2__u8_oe                        0x000055ec962e8389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        let encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter\
    \ = Character(UnicodeScalar(UInt8(encryptedUnicode)))\n        encrypted.append(encryptedCharacter)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpb_u_207s/tmpb_u_207s.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b13ea6eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13ea3e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13ea3e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13ea3e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb_u_207s                        0x000055938e02fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b13ea8da460 __libc_start_main +
    245

    6    tmpb_u_207s                        0x000055938e02f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + 2\
    \ * 2\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString.append(shiftedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        if let index\
    \ = alphabet.firstIndex(of: letter) {\n            let newIndex = index + (2 *\
    \ 2)\n            if newIndex > 25 {\n                let newIndex = newIndex\
    \ - 26\n                encryptedString.append(alphabet[newIndex])\n         \
    \   } else {\n                encryptedString.append(alphabet[newIndex])\n   \
    \         }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6xhk_bp4.swift:10:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: letter) {\n                  \
    \     ^~~~~~~~\n/tmp/tmp6xhk_bp4.swift:14:40: error: cannot find 'alphabet' in\
    \ scope\n                encryptedString.append(alphabet[newIndex])\n        \
    \                               ^~~~~~~~\n/tmp/tmp6xhk_bp4.swift:16:40: error:\
    \ cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[newIndex])\n\
    \                                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var encryptedUnicode = unicode + 2 * 2\n        if encryptedUnicode >\
    \ 90 {\n            encryptedUnicode = (encryptedUnicode % 90) + 64\n        }\n\
    \        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encrypted.append(encryptedCharacter)\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp0o1xbn_k/tmp0o1xbn_k.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b280f606c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b280f2fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b280f2fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b280f2fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0o1xbn_k                        0x000055dec0435907 <unavailable> + 6407

    5    libc.so.6                          0x00002b280f7f2460 __libc_start_main +
    245

    6    tmp0o1xbn_k                        0x000055dec0435549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let shift = 2 * 2\n\
    \    var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = alphabet.index(index, offsetBy: shift)\n\
    \            encrypted.append(alphabet[newIndex])\n        } else {\n        \
    \    encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002ae45912ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae458e21561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae458e21286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae458e2113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae458e20bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ae458f54ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002ae458f0d660 String.subscript.getter
    + 34

    7    tmpelbr0jt1                        0x0000562b93448ff4 <unavailable> + 8180

    8    tmpelbr0jt1                        0x0000562b9344894d <unavailable> + 6477

    9    libc.so.6                          0x00002ae459316460 __libc_start_main +
    245

    10   tmpelbr0jt1                        0x0000562b93448239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if let index\
    \ = alphabet.firstIndex(of: char) {\n            let newIndex = index + 2 * 2\n\
    \            if newIndex > alphabet.count - 1 {\n                let newIndex\
    \ = newIndex - alphabet.count\n                encryptedString.append(alphabet[newIndex])\n\
    \            } else {\n                encryptedString.append(alphabet[newIndex])\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpcr3iyo7c.swift:10:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmpcr3iyo7c.swift:12:27: error: cannot find 'alphabet' in scope\n\
    \            if newIndex > alphabet.count - 1 {\n                          ^~~~~~~~\n\
    /tmp/tmpcr3iyo7c.swift:13:43: error: cannot find 'alphabet' in scope\n       \
    \         let newIndex = newIndex - alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmpcr3iyo7c.swift:14:40: error: cannot find 'alphabet'\
    \ in scope\n                encryptedString.append(alphabet[newIndex])\n     \
    \                                  ^~~~~~~~\n/tmp/tmpcr3iyo7c.swift:16:40: error:\
    \ cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[newIndex])\n\
    \                                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2 * 2\n            let newChar\
    \ = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex % alphabet.count)]\n\
    \            encrypted.append(newChar)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            let encryptedUnicode\
    \ = unicode + 2 * 2\n            let encryptedChar = Character(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \            encryptedString += String(encryptedChar)\n        }\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpx47tgqih/tmpx47tgqih.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afacd75ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afacd451b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afacd451988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afacd4507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx47tgqih                        0x000055e792206e8e <unavailable> + 7822

    5    libc.so.6                          0x00002afacd946460 __libc_start_main +
    245

    6    tmpx47tgqih                        0x000055e792206689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted.append(char)\n        } else {\n            let unicode\
    \ = char.unicodeScalars.first!.value\n            var shiftedUnicode = unicode\
    \ + (2 * 2)\n            if shiftedUnicode > 90 {\n                shiftedUnicode\
    \ = shiftedUnicode - 26\n            }\n            let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \            encrypted.append(shiftedCharacter)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpdhv_tsmt/tmpdhv_tsmt.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abe1d025c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe1cd1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abe1cd1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abe1cd1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdhv_tsmt                        0x00005631594d8a47 <unavailable> + 6727

    5    libc.so.6                          0x00002abe1d211460 __libc_start_main +
    245

    6    tmpdhv_tsmt                        0x00005631594d8689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        result += String(c).uppercased()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjh4_p8og.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    // your code here\n    var result = \"\"\n    for char in s.characters\
    \ {\n        if let ascii = char.asciiValue {\n            if ascii >= 65 && ascii\
    \ <= 90 {\n                let newAscii = ascii + 2 * 2\n                if newAscii\
    \ > 90 {\n                    let diff = newAscii - 90\n                    result.append(Character(UnicodeScalar(64\
    \ + diff)!))\n                } else {\n                    result.append(Character(UnicodeScalar(newAscii)!))\n\
    \                }\n            } else if ascii >= 97 && ascii <= 122 {\n    \
    \            let newAscii = ascii + 2 * 2\n                if newAscii > 122 {\n\
    \                    let diff = newAscii - 122\n                    result.append(Character(UnicodeScalar(96\
    \ + diff)!))\n                } else {\n                    result.append(Character(UnicodeScalar(newAscii)!))\n\
    \                }\n            } else {\n                result.append(char)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6i6r72ob.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6i6r72ob.swift:16:69:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                    result.append(Character(UnicodeScalar(64 + diff)!))\n   \
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~^\n        \
    \                                                            \n/tmp/tmp6i6r72ob.swift:18:68:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                    result.append(Character(UnicodeScalar(newAscii)!))\n    \
    \                                        ~~~~~~~~~~~~~~~~~~~~~~~^\n          \
    \                                                         \n/tmp/tmp6i6r72ob.swift:24:69:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                    result.append(Character(UnicodeScalar(96 + diff)!))\n   \
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~^\n        \
    \                                                            \n/tmp/tmp6i6r72ob.swift:26:68:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                    result.append(Character(UnicodeScalar(newAscii)!))\n    \
    \                                        ~~~~~~~~~~~~~~~~~~~~~~~^\n          \
    \                                                         \n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.firstIndex(of: letter)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t1t3rux.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for character in s {\n        let unicode =\
    \ character.unicodeScalars.first!.value\n        var shiftedUnicode = unicode\
    \ + (2 * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encrypted = encrypted + shiftedCharacter\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for c in s.characters {\n        let unicode\
    \ = c.unicodeScalars.first!.value\n        let encryptedUnicode = unicode + 2\
    \ * 2\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode))\n\
    \        encrypted.append(encryptedCharacter)\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmptwac_7m3.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptwac_7m3.swift:12:44:\
    \ error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\
    \ must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode))\n\
    \                                           ^\n/tmp/tmptwac_7m3.swift:12:44: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode))\n\
    \                                           ^\n                              \
    \                                             ?? <#default value#>\n/tmp/tmptwac_7m3.swift:12:44:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode))\n\
    \                                           ^\n                              \
    \                                            !\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var rotatedUnicode = unicode + (2 * 2)\n        if rotatedUnicode > 90\
    \ {\n            rotatedUnicode = (rotatedUnicode % 90) + 64\n        }\n    \
    \    let rotatedCharacter = String(UnicodeScalar(UInt8(rotatedUnicode)))\n   \
    \     encrypted.append(rotatedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpyzxqp353/tmpyzxqp353.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b962dce9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b962d9e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b962d9e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b962d9df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyzxqp353                        0x000055a830529907 <unavailable> + 6407

    5    libc.so.6                          0x00002b962ded5460 __libc_start_main +
    245

    6    tmpyzxqp353                        0x000055a830529549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        let encryptedUnicode = unicode +\
    \ (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpyulj1kac/tmpyulj1kac.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5866926c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b586661db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b586661d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b586661c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyulj1kac                        0x0000561fab56fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b5866b12460 __libc_start_main +
    245

    6    tmpyulj1kac                        0x0000561fab56f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2\n            let newChar =\
    \ alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n        \
    \    encrypted.append(newChar)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp9f4w7woj/tmp9f4w7woj.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06f31bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06f2eb6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06f2eb6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06f2eb57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9f4w7woj                        0x000055867943b6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b06f33ab460 __libc_start_main +
    245

    6    tmp9f4w7woj                        0x000055867943b2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        if letter\
    \ == \"z\" {\n            encryptedString.append(\"b\")\n        } else if letter\
    \ == \"y\" {\n            encryptedString.append(\"a\")\n        } else {\n  \
    \          let unicode = letter.unicodeScalars.first!.value\n            let encryptedUnicode\
    \ = unicode + 2\n            let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \            encryptedString.append(encryptedLetter)\n        }\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmplftv9i58/tmplftv9i58.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fca9c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fca6bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fca6bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fca6bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplftv9i58                        0x000056391dfe29e7 <unavailable> + 6631

    5    libc.so.6                          0x00002b0fcabb1460 __libc_start_main +
    245

    6    tmplftv9i58                        0x000056391dfe2629 <unavailable> + 5673

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted.append(shiftedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let lowercase = s.lowercased()\n\
    \    var encrypted = \"\"\n    for char in lowercase {\n        if let index =\
    \ alphabet.index(of: char) {\n            let newIndex = index.encodedOffset +\
    \ 2\n            let newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)]\n            encrypted.append(newChar)\n        } else {\n      \
    \      encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp5y1vasel/tmp5y1vasel.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca0491bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca04612b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca04612988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca046117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5y1vasel                        0x0000562baa63f707 <unavailable> + 5895

    5    libc.so.6                          0x00002aca04b07460 __libc_start_main +
    245

    6    tmp5y1vasel                        0x0000562baa63f349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            let newChar\
    \ = alphabet[newIndex]\n            encrypted.append(newChar)\n        }\n   \
    \ }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpywag2jn6.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.index(of: letter) {\n\
    \            let newIndex = index.encodedOffset + 2\n            let newLetter\
    \ = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n      \
    \      encrypted.append(newLetter)\n        }\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpfktz8b7a/tmpfktz8b7a.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6c28b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6c25b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6c25b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6c25af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfktz8b7a                        0x0000561cd7fcd6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002af6c2aa5460 __libc_start_main +
    245

    6    tmpfktz8b7a                        0x0000561cd7fcd2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if let ascii = char.asciiValue\
    \ {\n            let newAscii = ascii + 2 * 2\n            if let newChar = UnicodeScalar(newAscii)\
    \ {\n                encrypted.append(Character(newChar))\n            }\n   \
    \     }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpu9ajn5e3.swift:12:16: error: initializer for conditional binding\
    \ must have Optional type, not 'UnicodeScalar' (aka 'Unicode.Scalar')\n      \
    \      if let newChar = UnicodeScalar(newAscii) {\n               ^          \
    \   ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for char in s {\n        if let index = alphabet.firstIndex(of: char) {\n\
    \            let newIndex = index.advanced(by: 2)\n            result.append(alphabet[newIndex])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpr8zcryox.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        var ascii = char.asciiValue!\n\
    \        if ascii >= 65 && ascii <= 90 {\n            ascii = (ascii - 65 + 2\
    \ * 2) % 26 + 65\n        } else if ascii >= 97 && ascii <= 122 {\n          \
    \  ascii = (ascii - 97 + 2 * 2) % 26 + 97\n        }\n        result.append(Character(UnicodeScalar(ascii)!))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqkxfr1hd.swift:16:53: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result.append(Character(UnicodeScalar(ascii)!))\n\
    \                                ~~~~~~~~~~~~~~~~~~~~^\n                     \
    \                               \n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.firstIndex(of: letter)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t1t3rux.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encryptedString\
    \ = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.advanced(by: 2)\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbmme06qz.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var rotatedUnicode = unicode + (2\
    \ * 2)\n        if rotatedUnicode > 122 {\n            rotatedUnicode = (rotatedUnicode\
    \ % 122) + 96\n        }\n        let rotatedCharacter = Character(UnicodeScalar(rotatedUnicode)!)\n\
    \        encryptedString.append(rotatedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = alphabet.index(index, offsetBy: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        } else {\n            encrypted.append(char)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0jcq6w6r/tmp0jcq6w6r.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7845b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7842abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7842ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7842aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jcq6w6r                        0x0000555d16c4e5e7 <unavailable> + 5607

    5    libc.so.6                          0x00002af7847a0460 __libc_start_main +
    245

    6    tmp0jcq6w6r                        0x0000555d16c4e229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var rotatedUnicode = unicode + (2 * 2)\n        if rotatedUnicode > 122\
    \ {\n            rotatedUnicode = 96 + (rotatedUnicode - 122)\n        }\n   \
    \     let rotatedCharacter = String(UnicodeScalar(UInt8(rotatedUnicode)))\n  \
    \      encrypted.append(rotatedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted += \" \"\n        } else {\n            let unicode = char.unicodeScalars.first!.value\n\
    \            let shiftedUnicode = unicode + 2 * 2\n            let shiftedCharacter\
    \ = String(UnicodeScalar(UInt8(shiftedUnicode)))\n            encrypted += shiftedCharacter\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmplpk0z260/tmplpk0z260.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf71e0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf71b01b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf71b01988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf71b007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplpk0z260                        0x0000557ba4840e3e <unavailable> + 7742

    5    libc.so.6                          0x00002adf71ff6460 __libc_start_main +
    245

    6    tmplpk0z260                        0x0000557ba4840639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted += \" \"\n        } else {\n            let unicode = char.unicodeScalars.first!.value\n\
    \            let encryptedUnicode = unicode + 2 * 2\n            let encryptedChar\
    \ = Character(UnicodeScalar(UInt8(encryptedUnicode)))\n            encrypted +=\
    \ String(encryptedChar)\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq7d004wy/tmpq7d004wy.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbb5f1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbb5c15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbb5c15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbb5c147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq7d004wy                        0x000055a23860de8e <unavailable> + 7822

    5    libc.so.6                          0x00002afbb610a460 __libc_start_main +
    245

    6    tmpq7d004wy                        0x000055a23860d689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + 2 * 2\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 90 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 90) + 64\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq_hqq6m_/tmpq_hqq6m_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70799ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af707691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af707691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7076907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_hqq6m_                        0x0000555d58ce59f7 <unavailable> + 6647

    5    libc.so.6                          0x00002af707b86460 __libc_start_main +
    245

    6    tmpq_hqq6m_                        0x0000555d58ce5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        encryptedString\
    \ += String(char).unicodeScalars.map {\n            UnicodeScalar(($0.value +\
    \ 2 * 2) % 26 + 65) ?? $0\n        }.reduce(\"\", { $0 + String($1) })\n    }\n\
    \    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpoaj_60y_/tmpoaj_60y_.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f81c11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f81908b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f81908988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f819077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaj_60y_                        0x000055d1104dc897 <unavailable> + 6295

    5    libc.so.6                          0x00002b7f81dfd460 __libc_start_main +
    245

    6    tmpoaj_60y_                        0x000055d1104dc4d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let lowercase = s.lowercased()\n\
    \    var encrypted = \"\"\n    for letter in lowercase {\n        if let index\
    \ = alphabet.index(of: letter) {\n            let newIndex = index.encodedOffset\
    \ + 2\n            let newLetter = alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)]\n            encrypted.append(newLetter)\n        } else\
    \ {\n            encrypted.append(letter)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpgddsmizd/tmpgddsmizd.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab67aa91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab67a788b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab67a788988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab67a7877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgddsmizd                        0x0000562e2e5d6707 <unavailable> + 5895

    5    libc.so.6                          0x00002ab67ac7d460 __libc_start_main +
    245

    6    tmpgddsmizd                        0x0000562e2e5d6349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for character in s.characters {\n   \
    \     let unicode = character.unicodeScalars.first!.value\n        var shiftedUnicode\
    \ = unicode + (2 * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode\
    \ = shiftedUnicode - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString.append(shiftedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxds0k163.swift:9:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in s.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var newString = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            newString += \" \"\n        } else {\n            let unicode = char.unicodeScalars.first!.value\n\
    \            let newUnicode = unicode + 2 * 2\n            let shiftedCharacter\
    \ = String(UnicodeScalar(UInt8(newUnicode)))\n            newString += shiftedCharacter\n\
    \        }\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpsrhl5kth/tmpsrhl5kth.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b791528bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7914f82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7914f82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7914f817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsrhl5kth                        0x0000556b93f40e3e <unavailable> + 7742

    5    libc.so.6                          0x00002b7915477460 __libc_start_main +
    245

    6    tmpsrhl5kth                        0x0000556b93f40639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + 2\
    \ * 2\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        if let ascii = char.asciiValue\
    \ {\n            let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n\
    \                let diff = newAscii - 122\n                result.append(Character(UnicodeScalar(97\
    \ + diff - 1)!))\n            } else {\n                result.append(Character(UnicodeScalar(newAscii)!))\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp12w70k38.swift:14:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                result.append(Character(UnicodeScalar(97\
    \ + diff - 1)!))\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmp12w70k38.swift:16:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                result.append(Character(UnicodeScalar(newAscii)!))\n        \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                             \n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let unicode =\
    \ c.unicodeScalars.first!.value\n        let unicodeString = String(unicode, radix:\
    \ 16)\n        if let asciiValue = Int(unicodeString, radix: 16) {\n         \
    \   let newAsciiValue = asciiValue + 2 * 2\n            let newUnicode = UnicodeScalar(newAsciiValue)\n\
    \            let newCharacter = Character(newUnicode!)\n            result.append(newCharacter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhd26b_y.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let lowercase = s.lowercased()\n\
    \    var encrypted = \"\"\n    for letter in lowercase {\n        if let index\
    \ = alphabet.index(of: letter) {\n            let newIndex = index.encodedOffset\
    \ + 2\n            let newLetter = alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)]\n            encrypted.append(newLetter)\n        } else\
    \ {\n            encrypted.append(letter)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpgddsmizd/tmpgddsmizd.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab67aa91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab67a788b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab67a788988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab67a7877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgddsmizd                        0x0000562e2e5d6707 <unavailable> + 5895

    5    libc.so.6                          0x00002ab67ac7d460 __libc_start_main +
    245

    6    tmpgddsmizd                        0x0000562e2e5d6349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        var unicode = char.unicodeScalars.first!.value\n\
    \        unicode += (unicode >= 65 && unicode <= 90) ? 13 : 0\n        unicode\
    \ += (unicode >= 97 && unicode <= 122) ? 13 : 0\n        encrypted.append(Character(UnicodeScalar(unicode)!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp29zzhjcg/tmp29zzhjcg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5a9a78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5a976fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5a976f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5a976e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29zzhjcg                        0x0000555b271d5737 <unavailable> + 5943

    5    libc.so.6                          0x00002af5a9c64460 __libc_start_main +
    245

    6    tmp29zzhjcg                        0x0000555b271d5379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted += \" \"\n        } else {\n            let unicode = char.unicodeScalars.first!.value\n\
    \            let encryptedUnicode = unicode + 2 * 2\n            let encryptedChar\
    \ = String(UnicodeScalar(UInt8(encryptedUnicode)))\n            encrypted += encryptedChar\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmptbp0hh2h/tmptbp0hh2h.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd6e3eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd6e0e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd6e0e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd6e0e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptbp0hh2h                        0x000055b173fc2e3e <unavailable> + 7742

    5    libc.so.6                          0x00002abd6e5d6460 __libc_start_main +
    245

    6    tmptbp0hh2h                        0x000055b173fc2639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2\n            let newChar =\
    \ alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n        \
    \    encrypted.append(newChar)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp9f4w7woj/tmp9f4w7woj.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06f31bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06f2eb6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06f2eb6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06f2eb57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9f4w7woj                        0x000055867943b6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b06f33ab460 __libc_start_main +
    245

    6    tmp9f4w7woj                        0x000055867943b2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encryptedString\
    \ = \"\"\n    for char in s {\n        if let index = alphabet.index(of: char)\
    \ {\n            let newIndex = index.encodedOffset + 2 * 2\n            encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n        }\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b404b301c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b404aff8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b404aff8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b404aff813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b404aff7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b404b12bec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b404b0e4660 String.subscript.getter
    + 34

    7    tmpe646efwf                        0x000056060e3110dc <unavailable> + 8412

    8    tmpe646efwf                        0x000056060e3109fd <unavailable> + 6653

    9    libc.so.6                          0x00002b404b4ed460 __libc_start_main +
    245

    10   tmpe646efwf                        0x000056060e3102e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \"z\" {\n\
    \            encrypted.append(\"b\")\n        } else if char == \"y\" {\n    \
    \        encrypted.append(\"a\")\n        } else {\n            encrypted.append(String(UnicodeScalar(UInt8(asciiValue(char:\
    \ char) + 2))!))\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbx28ajf1.swift:15:57: error: cannot find 'asciiValue' in scope\n\
    \            encrypted.append(String(UnicodeScalar(UInt8(asciiValue(char: char)\
    \ + 2))!))\n                                                        ^~~~~~~~~~\n\
    /tmp/tmpbx28ajf1.swift:15:85: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            encrypted.append(String(UnicodeScalar(UInt8(asciiValue(char:\
    \ char) + 2))!))\n                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \        \n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        let index = alphabet.index(of: char)\n      \
    \  let newIndex = index! + 2\n        let newChar = alphabet[newIndex]\n     \
    \   encrypted.append(newChar)\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4kz4l7e7.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: char)\n       \
    \                      ^\n/tmp/tmp4kz4l7e7.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)\n                    \
    \         ^~~~~\n                             firstIndex\n/tmp/tmp4kz4l7e7.swift:12:29:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index! + 2\n                            ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ = encrypted + shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        let encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter\
    \ = String(UnicodeScalar(UInt8(encryptedUnicode)))\n        encrypted.append(encryptedCharacter)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpjkia8hid/tmpjkia8hid.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b932477cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9324473b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9324473988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93244727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjkia8hid                        0x000055f53ec6cd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b9324968460 __libc_start_main +
    245

    6    tmpjkia8hid                        0x000055f53ec6c549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let i = alphabet.firstIndex(of: letter)\
    \ {\n            encrypted.append(alphabet[alphabet.index(i, offsetBy: 2 * 2)])\n\
    \        } else {\n            encrypted.append(letter)\n        }\n    }\n  \
    \  return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b066bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b063b5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8b063b5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8b063b513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8b063b4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b8b064e8ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b8b064a1660 String.subscript.getter
    + 34

    7    tmppe4zpibx                        0x000055851f0a6fda <unavailable> + 8154

    8    tmppe4zpibx                        0x000055851f0a694d <unavailable> + 6477

    9    libc.so.6                          0x00002b8b068aa460 __libc_start_main +
    245

    10   tmppe4zpibx                        0x000055851f0a6239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encryptedString\
    \ = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = (index.encodedOffset + 2) % alphabet.count\n\
    \            encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n        } else {\n            encryptedString.append(char)\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpse0kc7t6/tmpse0kc7t6.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a3c242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a3bf39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a3bf39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a3bf387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpse0kc7t6                        0x000056277a4c9797 <unavailable> + 6039

    5    libc.so.6                          0x00002b7a3c42e460 __libc_start_main +
    245

    6    tmpse0kc7t6                        0x000056277a4c93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        let encryptedUnicode = unicode +\
    \ 2 * 2\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpr3px33ns/tmpr3px33ns.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb4b07dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb4ad74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb4ad74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb4ad737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr3px33ns                        0x000055b83cc69b7e <unavailable> + 7038

    5    libc.so.6                          0x00002afb4b269460 __libc_start_main +
    245

    6    tmpr3px33ns                        0x000055b83cc69379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for character in s {\n        let unicode = character.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 90 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 90) + 64\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq_hqq6m_/tmpq_hqq6m_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70799ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af707691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af707691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7076907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_hqq6m_                        0x0000555d58ce59f7 <unavailable> + 6647

    5    libc.so.6                          0x00002af707b86460 __libc_start_main +
    245

    6    tmpq_hqq6m_                        0x0000555d58ce5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var rotatedUnicode = unicode + (2 * 2)\n        if rotatedUnicode > 122\
    \ {\n            rotatedUnicode = 96 + (rotatedUnicode - 122)\n        }\n   \
    \     let rotatedCharacter = String(UnicodeScalar(UInt8(rotatedUnicode)))\n  \
    \      encrypted.append(rotatedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let lowercase = s.lowercased()\n\
    \    var encrypted = \"\"\n    for letter in lowercase {\n        if let index\
    \ = alphabet.firstIndex(of: letter) {\n            let newIndex = index + 2\n\
    \            if newIndex >= alphabet.count {\n                let newIndex = newIndex\
    \ - alphabet.count\n                let newLetter = alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)]\n                encrypted.append(newLetter)\n        \
    \    } else {\n                let newLetter = alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)]\n                encrypted.append(newLetter)\n        \
    \    }\n        } else {\n            encrypted.append(letter)\n        }\n  \
    \  }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpm9j7mtb1.swift:13:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2\n    \
    \                       ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted.append(shiftedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2 * 2\n            let newChar\
    \ = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n      \
    \      encrypted.append(newChar)\n        }\n    }\n    return encrypted\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d68375c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d6806c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6d6806c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6d6806c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6d6806bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b6d6819fec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b6d68158660 String.subscript.getter
    + 34

    7    tmp4yggu7oz                        0x000055c6447270ef <unavailable> + 8431

    8    tmp4yggu7oz                        0x000055c6447269fd <unavailable> + 6653

    9    libc.so.6                          0x00002b6d68561460 __libc_start_main +
    245

    10   tmp4yggu7oz                        0x000055c6447262e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        encryptedString\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmph3naxqt1/tmph3naxqt1.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b6cc7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b6c975b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b6c975988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b6c9747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph3naxqt1                        0x00005645c0025787 <unavailable> + 6023

    5    libc.so.6                          0x00002b6b6ce6a460 __libc_start_main +
    245

    6    tmph3naxqt1                        0x00005645c00253c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        var unicode\
    \ = letter.unicodeScalars.first!.value\n        unicode += 2 * 2\n        let\
    \ encryptedLetter = String(UnicodeScalar(UInt8(unicode)))\n        encryptedString\
    \ += encryptedLetter\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpfqv6svo7/tmpfqv6svo7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8cdf5c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8cdf2b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8cdf2b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8cdf2b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfqv6svo7                        0x0000559179aecd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b8cdf7ae460 __libc_start_main +
    245

    6    tmpfqv6svo7                        0x0000559179aec549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 90\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ = encrypted + shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp1apr_q34/tmp1apr_q34.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b5b1f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b5aee9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b5aee9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b5aee87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1apr_q34                        0x0000556670b82907 <unavailable> + 6407

    5    libc.so.6                          0x00002b6b5b3de460 __libc_start_main +
    245

    6    tmp1apr_q34                        0x0000556670b82549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var rotatedUnicode = unicode + (2 * 2)\n        if rotatedUnicode > 122\
    \ {\n            rotatedUnicode = (rotatedUnicode % 122) + 96\n        }\n   \
    \     let rotatedCharacter = String(UnicodeScalar(UInt8(rotatedUnicode)))\n  \
    \      encrypted.append(rotatedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let shift = 2 * 2\n\
    \    var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = (index.encodedOffset + shift) % alphabet.count\n\
    \            encrypted.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)])\n        } else {\n            encrypted.append(char)\n        }\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted.append(char)\n        } else {\n            let unicode\
    \ = char.unicodeScalars.first!.value\n            let encryptedUnicode = unicode\
    \ + 2 * 2\n            let encryptedChar = Character(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \            encrypted.append(encryptedChar)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpm5fn3ovg/tmpm5fn3ovg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d952d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d94fcab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d94fca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d94fc97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm5fn3ovg                        0x000055dc8797ee2e <unavailable> + 7726

    5    libc.so.6                          0x00002b9d954bf460 __libc_start_main +
    245

    6    tmpm5fn3ovg                        0x000055dc8797e629 <unavailable> + 5673

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 90 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 90) + 64\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq_hqq6m_/tmpq_hqq6m_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70799ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af707691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af707691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7076907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_hqq6m_                        0x0000555d58ce59f7 <unavailable> + 6647

    5    libc.so.6                          0x00002af707b86460 __libc_start_main +
    245

    6    tmpq_hqq6m_                        0x0000555d58ce5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 90 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 90) + 64\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq_hqq6m_/tmpq_hqq6m_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70799ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af707691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af707691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7076907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_hqq6m_                        0x0000555d58ce59f7 <unavailable> + 6647

    5    libc.so.6                          0x00002af707b86460 __libc_start_main +
    245

    6    tmpq_hqq6m_                        0x0000555d58ce5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 90 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 90) + 64\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq_hqq6m_/tmpq_hqq6m_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70799ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af707691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af707691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7076907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_hqq6m_                        0x0000555d58ce59f7 <unavailable> + 6647

    5    libc.so.6                          0x00002af707b86460 __libc_start_main +
    245

    6    tmpq_hqq6m_                        0x0000555d58ce5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        var unicode = char.unicodeScalars.first!.value\n\
    \        unicode += 2 * 2\n        let encryptedChar = UnicodeScalar(unicode)\n\
    \        encrypted.append(Character(encryptedChar!))\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp3231e0it/tmp3231e0it.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b614c59bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b614c292b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b614c292988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b614c2917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3231e0it                        0x000055a4a3732b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b614c787460 __libc_start_main +
    245

    6    tmp3231e0it                        0x000055a4a3732379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let unicode =\
    \ c.unicodeScalars.first!.value\n        let encrypted = unicode + 2 * 2\n   \
    \     let encryptedChar = Character(UnicodeScalar(encrypted))\n        result.append(encryptedChar)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpntvrgkgb.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpntvrgkgb.swift:12:39:\
    \ error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\
    \ must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \        let encryptedChar = Character(UnicodeScalar(encrypted))\n           \
    \                           ^\n/tmp/tmpntvrgkgb.swift:12:39: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        let\
    \ encryptedChar = Character(UnicodeScalar(encrypted))\n                      \
    \                ^\n                                                         \
    \      ?? <#default value#>\n/tmp/tmpntvrgkgb.swift:12:39: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        let\
    \ encryptedChar = Character(UnicodeScalar(encrypted))\n                      \
    \                ^\n                                                         \
    \     !\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        let index = alphabet.index(of: char)\n      \
    \  if let index = index {\n            let newIndex = (index.encodedOffset + 2)\
    \ % alphabet.count\n            let newChar = alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)]\n            encrypted.append(newChar)\n        }\n   \
    \ }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxp2meqej/tmpxp2meqej.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adba378dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adba3484b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adba3484988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adba34837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxp2meqej                        0x0000558b7705f787 <unavailable> + 6023

    5    libc.so.6                          0x00002adba3979460 __libc_start_main +
    245

    6    tmpxp2meqej                        0x0000558b7705f3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for c in s.characters {\n        let unicode\
    \ = c.unicodeScalars.first!.value\n        let shifted = unicode + 2 * 2\n   \
    \     let encryptedCharacter = UnicodeScalar(UInt32(shifted))\n        encrypted.append(Character(encryptedCharacter!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpczwuxehn.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        let index = alphabet.index(of: char)\n      \
    \  let newIndex = index! + 2\n        let newChar = alphabet[newIndex]\n     \
    \   encrypted.append(newChar)\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4kz4l7e7.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: char)\n       \
    \                      ^\n/tmp/tmp4kz4l7e7.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)\n                    \
    \         ^~~~~\n                             firstIndex\n/tmp/tmp4kz4l7e7.swift:12:29:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index! + 2\n                            ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var rotatedUnicode = unicode + (2 * 2)\n        if rotatedUnicode > 122\
    \ {\n            rotatedUnicode = (rotatedUnicode % 122) + 96\n        }\n   \
    \     let rotated = String(UnicodeScalar(UInt8(rotatedUnicode)))\n        encrypted.append(rotated)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        var unicode = char.unicodeScalars.first!.value\n\
    \        unicode += (unicode >= 65 && unicode <= 90) ? 13 : 0\n        unicode\
    \ += (unicode >= 97 && unicode <= 122) ? 13 : 0\n        encrypted.append(Character(UnicodeScalar(unicode)!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp29zzhjcg/tmp29zzhjcg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5a9a78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5a976fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5a976f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5a976e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29zzhjcg                        0x0000555b271d5737 <unavailable> + 5943

    5    libc.so.6                          0x00002af5a9c64460 __libc_start_main +
    245

    6    tmp29zzhjcg                        0x0000555b271d5379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if let ascii = char.asciiValue\
    \ {\n            let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n\
    \                let diff = newAscii - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encrypted.append(newChar)\n            } else\
    \ {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n     \
    \           encrypted.append(newChar)\n            }\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9urwxj5.swift:14:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmpf9urwxj5.swift:17:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let newAlphabet =\
    \ \"cdefghijklmnopqrstuvwxyzab\"\n    var encryptedString = \"\"\n    for letter\
    \ in s {\n        if let index = alphabet.firstIndex(of: letter) {\n         \
    \   encryptedString.append(newAlphabet[index])\n        } else {\n           \
    \ encryptedString.append(letter)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpsw1qswue/tmpsw1qswue.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1dcfe36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1dcfb2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1dcfb2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1dcfb2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsw1qswue                        0x000055a2c1f3f587 <unavailable> + 5511

    5    libc.so.6                          0x00002b1dd0022460 __libc_start_main +
    245

    6    tmpsw1qswue                        0x000055a2c1f3f1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted.append(shiftedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        let unicode\
    \ = letter.unicodeScalars.first!.value\n        var unicodeScalar = UnicodeScalar(unicode\
    \ + 2)\n        if unicodeScalar > 90 {\n            unicodeScalar = UnicodeScalar(unicodeScalar.value\
    \ - 26)\n        }\n        encryptedString.append(Character(unicodeScalar))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmputb5v_18.swift:12:26: error: binary operator '>' cannot be applied\
    \ to operands of type 'Unicode.Scalar?' and 'Int'\n        if unicodeScalar >\
    \ 90 {\n           ~~~~~~~~~~~~~ ^ ~~\n/tmp/tmputb5v_18.swift:12:26: note: overloads\
    \ for '>' exist with these partially matching parameter lists: (Int, Int)\n  \
    \      if unicodeScalar > 90 {\n                         ^\n/tmp/tmputb5v_18.swift:13:43:\
    \ error: value of optional type 'Unicode.Scalar?' must be unwrapped to refer to\
    \ member 'value' of wrapped base type 'Unicode.Scalar'\n            unicodeScalar\
    \ = UnicodeScalar(unicodeScalar.value - 26)\n                                \
    \          ^\n/tmp/tmputb5v_18.swift:13:43: note: chain the optional using '?'\
    \ to access member 'value' only for non-'nil' base values\n            unicodeScalar\
    \ = UnicodeScalar(unicodeScalar.value - 26)\n                                \
    \          ^\n                                                       ?\n/tmp/tmputb5v_18.swift:13:43:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            unicodeScalar = UnicodeScalar(unicodeScalar.value - 26)\n\
    \                                          ^\n                               \
    \                        !\n/tmp/tmputb5v_18.swift:15:42: error: value of optional\
    \ type 'Unicode.Scalar?' must be unwrapped to a value of type 'Unicode.Scalar'\n\
    \        encryptedString.append(Character(unicodeScalar))\n                  \
    \                       ^\n/tmp/tmputb5v_18.swift:15:42: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        encryptedString.append(Character(unicodeScalar))\n\
    \                                         ^\n                                \
    \                       ?? <#default value#>\n/tmp/tmputb5v_18.swift:15:42: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        encryptedString.append(Character(unicodeScalar))\n                  \
    \                       ^\n                                                  \
    \    !\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        encryptedString\
    \ += String(char.unicodeScalars.first!.value + 2)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpkk9g3hom/tmpkk9g3hom.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3556ecdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3556bc4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3556bc4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3556bc37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkk9g3hom                        0x0000555e34bc7787 <unavailable> + 6023

    5    libc.so.6                          0x00002b35570b9460 __libc_start_main +
    245

    6    tmpkk9g3hom                        0x0000555e34bc73c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted += \" \"\n        } else {\n            let unicode = char.unicodeScalars.first!.value\n\
    \            let encryptedUnicode = unicode + 2 * 2\n            let encryptedChar\
    \ = String(UnicodeScalar(UInt8(encryptedUnicode)))\n            encrypted += encryptedChar\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmptbp0hh2h/tmptbp0hh2h.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd6e3eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd6e0e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd6e0e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd6e0e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptbp0hh2h                        0x000055b173fc2e3e <unavailable> + 7742

    5    libc.so.6                          0x00002abd6e5d6460 __libc_start_main +
    245

    6    tmptbp0hh2h                        0x000055b173fc2639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var rotatedUnicode = unicode + (2 * 2)\n        if rotatedUnicode > 122\
    \ {\n            rotatedUnicode = (rotatedUnicode % 122) + 96\n        }\n   \
    \     let rotatedCharacter = String(UnicodeScalar(UInt8(rotatedUnicode)))\n  \
    \      encrypted.append(rotatedCharacter)\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        let encryptedUnicode = unicode +\
    \ (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp4j27vik2/tmp4j27vik2.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1359bf4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13598ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13598eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13598ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4j27vik2                        0x0000558b155cbb7e <unavailable> + 7038

    5    libc.so.6                          0x00002b1359de0460 __libc_start_main +
    245

    6    tmp4j27vik2                        0x0000558b155cb379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            let newChar\
    \ = alphabet[newIndex]\n            encrypted.append(newChar)\n        }\n   \
    \ }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpywag2jn6.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            let newChar\
    \ = alphabet[newIndex]\n            encrypted.append(newChar)\n        }\n   \
    \ }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpywag2jn6.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.index(of: letter) {\n\
    \            let newIndex = index.encodedOffset + 2 * 2\n            let newLetter\
    \ = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex % alphabet.count)]\n\
    \            encrypted.append(newLetter)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let ascii =\
    \ char.asciiValue!\n        if ascii >= 65 && ascii <= 90 {\n            let newAscii\
    \ = ascii + (2 * 2)\n            if newAscii > 90 {\n                let diff\
    \ = newAscii - 90\n                let newChar = Character(UnicodeScalar(64 +\
    \ diff)!)\n                encryptedString.append(newChar)\n            } else\
    \ {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n     \
    \           encryptedString.append(newChar)\n            }\n        } else if\
    \ ascii >= 97 && ascii <= 122 {\n            let newAscii = ascii + (2 * 2)\n\
    \            if newAscii > 122 {\n                let diff = newAscii - 122\n\
    \                let newChar = Character(UnicodeScalar(96 + diff)!)\n        \
    \        encryptedString.append(newChar)\n            } else {\n             \
    \   let newChar = Character(UnicodeScalar(newAscii)!)\n                encryptedString.append(newChar)\n\
    \            }\n        } else {\n            encryptedString.append(char)\n \
    \       }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7l40en8a.swift:15:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(64\
    \ + diff)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                \n/tmp/tmp7l40en8a.swift:18:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n/tmp/tmp7l40en8a.swift:25:65: error:\
    \ cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(96 + diff)!)\n        \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~^\n                 \
    \                                               \n/tmp/tmp7l40en8a.swift:28:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        var ascii =\
    \ char.asciiValue!\n        ascii += 2 * 2\n        encryptedString.append(Character(UnicodeScalar(ascii)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9wr1wq34.swift:12:62: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(ascii)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~^\n            \
    \                                                 \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        let unicode\
    \ = letter.unicodeScalars.first!.value\n        var unicodeEncrypted = unicode\
    \ + 2 * 2\n        if unicodeEncrypted > 122 {\n            unicodeEncrypted =\
    \ (unicodeEncrypted % 122) + 96\n        }\n        let encryptedLetter = String(UnicodeScalar(UInt8(unicodeEncrypted)))\n\
    \        encryptedString += encryptedLetter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let lowercase = s.lowercased()\n\
    \    var encrypted = \"\"\n    for char in lowercase {\n        if let index =\
    \ alphabet.index(of: char) {\n            let newIndex = index.encodedOffset +\
    \ 2\n            let newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)]\n            encrypted.append(newChar)\n        } else {\n      \
    \      encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp5y1vasel/tmp5y1vasel.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca0491bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca04612b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca04612988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca046117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5y1vasel                        0x0000562baa63f707 <unavailable> + 5895

    5    libc.so.6                          0x00002aca04b07460 __libc_start_main +
    245

    6    tmp5y1vasel                        0x0000562baa63f349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + 2 * 2\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let shiftedAlphabet\
    \ = \"cdefghijklmnopqrstuvwxyzab\"\n    var encrypted = \"\"\n    for letter in\
    \ s {\n        if let i = alphabet.firstIndex(of: letter) {\n            encrypted.append(shiftedAlphabet[i])\n\
    \        } else {\n            encrypted.append(letter)\n        }\n    }\n  \
    \  return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp5_09vmq5/tmp5_09vmq5.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43c94e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43c91deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43c91de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43c91dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5_09vmq5                        0x000055dbbd100587 <unavailable> + 5511

    5    libc.so.6                          0x00002b43c96d3460 __libc_start_main +
    245

    6    tmp5_09vmq5                        0x000055dbbd1001c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let i = alphabet.firstIndex(of: char) {\n\
    \            let shifted = i + 2 * 2\n            let index = shifted % alphabet.count\n\
    \            let newChar = alphabet[index]\n            encrypted.append(newChar)\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpe4l7bv7_.swift:12:27: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let shifted = i + 2 * 2\n     \
    \                     ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if let ascii = char.asciiValue\
    \ {\n            let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n\
    \                let diff = newAscii - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encrypted.append(newChar)\n            } else\
    \ {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n     \
    \           encrypted.append(newChar)\n            }\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9urwxj5.swift:14:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmpf9urwxj5.swift:17:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            let newChar\
    \ = alphabet[newIndex]\n            encrypted.append(newChar)\n        }\n   \
    \ }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpywag2jn6.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        var ascii =\
    \ char.asciiValue!\n        if ascii >= 65 && ascii <= 90 {\n            ascii\
    \ += 2\n            if ascii > 90 {\n                ascii -= 26\n           \
    \ }\n        } else if ascii >= 97 && ascii <= 122 {\n            ascii += 2\n\
    \            if ascii > 122 {\n                ascii -= 26\n            }\n  \
    \      }\n        encryptedString.append(Character(UnicodeScalar(ascii)!))\n \
    \   }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmplw4c3vd7.swift:22:62: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(ascii)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~^\n            \
    \                                                 \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        } else {\n            encrypted.append(char)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphfihpapx.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encryptedString\
    \ = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.advanced(by: 2)\n            let newChar\
    \ = alphabet[newIndex]\n            encryptedString.append(newChar)\n        }\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpno4_sbjp.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        let index = alphabet.index(of: char)\n      \
    \  let newIndex = index! + 2 * 2\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpe7z1aqh1.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: char)\n       \
    \                      ^\n/tmp/tmpe7z1aqh1.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)\n                    \
    \         ^~~~~\n                             firstIndex\n/tmp/tmpe7z1aqh1.swift:12:29:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index! + 2 * 2\n                            ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.firstIndex(of: letter)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t1t3rux.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for character in s.characters {\n   \
    \     let unicode = character.unicodeScalars.first!.value\n        var shiftedUnicode\
    \ = unicode + (2 * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode\
    \ = shiftedUnicode - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString.append(shiftedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxds0k163.swift:9:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in s.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encryptedString\
    \ = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index + 2 * 2\n            let newLetter\
    \ = alphabet[newIndex % alphabet.count]\n            encryptedString.append(newLetter)\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoa9ljdm5.swift:12:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let letters = Array(s.characters)\n    var encrypted = [Character]()\n\
    \    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for letter in letters\
    \ {\n        if let index = alphabet.characters.index(of: letter) {\n        \
    \    let newIndex = index.advanced(by: 2)\n            let newLetter = alphabet[newIndex]\n\
    \            encrypted.append(newLetter)\n        }\n    }\n    return String(encrypted)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmporg8q5cu.swift:8:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = Array(s.characters)\n               \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmporg8q5cu.swift:12:33: error: 'characters' is unavailable: Please use String\
    \ directly\n        if let index = alphabet.characters.index(of: letter) {\n \
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmporg8q5cu.swift:12:44: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        if let index = alphabet.characters.index(of:\
    \ letter) {\n                                           ^\n/tmp/tmporg8q5cu.swift:12:44:\
    \ note: use 'firstIndex(of:)' instead\n        if let index = alphabet.characters.index(of:\
    \ letter) {\n                                           ^~~~~\n              \
    \                             firstIndex\n/tmp/tmporg8q5cu.swift:13:34: error:\
    \ value of type 'String.Index' has no member 'advanced'\n            let newIndex\
    \ = index.advanced(by: 2)\n                           ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ = encrypted + shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        let unicode\
    \ = letter.unicodeScalars.first!.value\n        let encryptedUnicode = unicode\
    \ + (2 * 2)\n        let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedLetter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpyz41_elq/tmpyz41_elq.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b03d7dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b03a74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b03a74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b03a737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyz41_elq                        0x00005645494e0d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b3b03f69460 __libc_start_main +
    245

    6    tmpyz41_elq                        0x00005645494e0549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if let ascii\
    \ = char.asciiValue {\n            let newAscii = ascii + 2 * 2\n            if\
    \ newAscii > 122 {\n                let diff = newAscii - 122\n              \
    \  let newChar = Character(UnicodeScalar(97 + diff - 1)!)\n                encryptedString.append(newChar)\n\
    \            } else {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                encryptedString.append(newChar)\n            }\n        }\n \
    \   }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppb9batw8.swift:14:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmppb9batw8.swift:17:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = (index.encodedOffset + 2) % alphabet.count\n      \
    \      encrypted.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)])\n        } else {\n            encrypted.append(char)\n        }\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp2kayn0no/tmp2kayn0no.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90ffc27c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90ff91eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90ff91e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90ff91d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2kayn0no                        0x0000557784e4a787 <unavailable> + 6023

    5    libc.so.6                          0x00002b90ffe13460 __libc_start_main +
    245

    6    tmp2kayn0no                        0x0000557784e4a3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = (index.encodedOffset + 2) % alphabet.count\n      \
    \      let newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n\
    \            encrypted.append(newChar)\n        } else {\n            encrypted.append(char)\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0g2oafe7/tmp0g2oafe7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4795b81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4795878b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4795878988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47958777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0g2oafe7                        0x000055c42dd40787 <unavailable> + 6023

    5    libc.so.6                          0x00002b4795d6d460 __libc_start_main +
    245

    6    tmp0g2oafe7                        0x000055c42dd403c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        } else {\n            encrypted.append(char)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphfihpapx.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        if let asciiValue\
    \ = letter.asciiValue {\n            let newAsciiValue = asciiValue + 2 * 2\n\
    \            if let newLetter = UnicodeScalar(newAsciiValue) {\n             \
    \   encryptedString.append(Character(newLetter))\n            }\n        }\n \
    \   }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn1c7ed8i.swift:12:16: error: initializer for conditional binding\
    \ must have Optional type, not 'UnicodeScalar' (aka 'Unicode.Scalar')\n      \
    \      if let newLetter = UnicodeScalar(newAsciiValue) {\n               ^   \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        var unicode = char.unicodeScalars.first!.value\n\
    \        unicode += (unicode >= 65 && unicode <= 90) ? 13 : 0\n        unicode\
    \ += (unicode >= 97 && unicode <= 122) ? 13 : 0\n        encrypted.append(Character(UnicodeScalar(unicode)!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp29zzhjcg/tmp29zzhjcg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5a9a78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5a976fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5a976f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5a976e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29zzhjcg                        0x0000555b271d5737 <unavailable> + 5943

    5    libc.so.6                          0x00002af5a9c64460 __libc_start_main +
    245

    6    tmp29zzhjcg                        0x0000555b271d5379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        let encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter\
    \ = String(UnicodeScalar(UInt8(encryptedUnicode)))\n        encrypted.append(encryptedCharacter)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpjkia8hid/tmpjkia8hid.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b932477cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9324473b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9324473988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93244727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjkia8hid                        0x000055f53ec6cd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b9324968460 __libc_start_main +
    245

    6    tmpjkia8hid                        0x000055f53ec6c549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for c in s.characters {\n        let\
    \ unicode = String(c).unicodeScalars\n        let unicodeValue = unicode[unicode.startIndex].value\n\
    \        if unicodeValue >= 65 && unicodeValue <= 90 {\n            let shiftedUnicode\
    \ = unicodeValue + (2 * 2)\n            if shiftedUnicode > 90 {\n           \
    \     let difference = shiftedUnicode - 90\n                let newUnicode = 64\
    \ + difference\n                encryptedString.append(Character(UnicodeScalar(newUnicode)!))\n\
    \            } else {\n                encryptedString.append(Character(UnicodeScalar(shiftedUnicode)!))\n\
    \            }\n        } else if unicodeValue >= 97 && unicodeValue <= 122 {\n\
    \            let shiftedUnicode = unicodeValue + (2 * 2)\n            if shiftedUnicode\
    \ > 122 {\n                let difference = shiftedUnicode - 122\n           \
    \     let newUnicode = 96 + difference\n                encryptedString.append(Character(UnicodeScalar(newUnicode)!))\n\
    \            } else {\n                encryptedString.append(Character(UnicodeScalar(shiftedUnicode)!))\n\
    \            }\n        } else {\n            encryptedString.append(c)\n    \
    \    }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xg3mbqm.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        let unicode\
    \ = letter.unicodeScalars.first!.value\n        var shiftedUnicode = unicode +\
    \ (2 * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 122 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 122) + 96\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let index =\
    \ alphabet.index(of: char)\n        if let index = index {\n            let newIndex\
    \ = (index + 2) % 26\n            encryptedString.append(alphabet[newIndex])\n\
    \        } else {\n            encryptedString.append(char)\n        }\n    }\n\
    \    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpp0fi3ule.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpp0fi3ule.swift:13:36: error: cannot find 'alphabet' in scope\n       \
    \     encryptedString.append(alphabet[newIndex])\n                           \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.firstIndex(of: letter)\
    \ {\n            let newIndex = index + 2 * 2\n            if newIndex < alphabet.count\
    \ {\n                encrypted.append(alphabet[newIndex])\n            } else\
    \ {\n                let newIndex = newIndex - alphabet.count\n              \
    \  encrypted.append(alphabet[newIndex])\n            }\n        } else {\n   \
    \         encrypted.append(letter)\n        }\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmksfyb7r.swift:12:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 90 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 90) + 64\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq_hqq6m_/tmpq_hqq6m_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70799ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af707691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af707691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7076907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_hqq6m_                        0x0000555d58ce59f7 <unavailable> + 6647

    5    libc.so.6                          0x00002af707b86460 __libc_start_main +
    245

    6    tmpq_hqq6m_                        0x0000555d58ce5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        } else {\n            encrypted.append(char)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphfihpapx.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.firstIndex(of: letter)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            let newLetter\
    \ = alphabet[newIndex]\n            encrypted.append(newLetter)\n        }\n \
    \   }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpraceq_k9.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.firstIndex(of: letter)\
    \ {\n            let newIndex = index.encodedOffset + 2 * 2\n            encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex % alphabet.count)])\n        } else {\n            encrypted.append(letter)\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let unicode =\
    \ c.unicodeScalars.first!.value\n        let shifted = unicode + 2 * 2\n     \
    \   let shiftedCharacter = Character(UnicodeScalar(UInt8(shifted)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprhxa7wbb.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        encryptedString\
    \ += String(char).unicodeScalars.map {\n            UnicodeScalar(($0.value +\
    \ 2 * 2) % 26 + 65) ?? $0\n        }.reduce(\"\", { $0 + String($1) })\n    }\n\
    \    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpoaj_60y_/tmpoaj_60y_.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f81c11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f81908b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f81908988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f819077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaj_60y_                        0x000055d1104dc897 <unavailable> + 6295

    5    libc.so.6                          0x00002b7f81dfd460 __libc_start_main +
    245

    6    tmpoaj_60y_                        0x000055d1104dc4d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.firstIndex(of: char)\
    \ {\n            let newIndex = index.advanced(by: 2)\n            let newChar\
    \ = alphabet[newIndex]\n            encrypted.append(newChar)\n        }\n   \
    \ }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpywag2jn6.swift:12:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + 2\
    \ * 2\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let shift = 2 * 2\n\
    \    var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = (index! + shift) % alphabet.count\n        let\
    \ newChar = alphabet[newIndex]\n        encrypted.append(newChar)\n    }\n   \
    \ return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7hssb523.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: char)\n       \
    \                      ^\n/tmp/tmp7hssb523.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)\n                    \
    \         ^~~~~\n                             firstIndex\n/tmp/tmp7hssb523.swift:13:30:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = (index! + shift) % alphabet.count\n          \
    \                   ^\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for character in s.characters {\n   \
    \     let unicode = character.unicodeScalars.first!.value\n        var shiftedUnicode\
    \ = unicode + (2 * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode\
    \ = shiftedUnicode - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString.append(shiftedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxds0k163.swift:9:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in s.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let lowercase = s.lowercased()\n\
    \    var encrypted = \"\"\n    for letter in lowercase {\n        if let index\
    \ = alphabet.index(of: letter) {\n            let newIndex = index.encodedOffset\
    \ + 2\n            let newLetter = alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)]\n            encrypted.append(newLetter)\n        } else\
    \ {\n            encrypted.append(letter)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpgddsmizd/tmpgddsmizd.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab67aa91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab67a788b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab67a788988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab67a7877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgddsmizd                        0x0000562e2e5d6707 <unavailable> + 5895

    5    libc.so.6                          0x00002ab67ac7d460 __libc_start_main +
    245

    6    tmpgddsmizd                        0x0000562e2e5d6349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let index = alphabet.index(of: letter) {\n\
    \            let newIndex = alphabet.index(index, offsetBy: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        } else {\n            encrypted.append(letter)\n        }\n    }\n  \
    \  return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz_ff1dr8/tmpz_ff1dr8.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5867ca7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b586799eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b586799e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b586799d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_ff1dr8                        0x000056053490a5e7 <unavailable> + 5607

    5    libc.so.6                          0x00002b5867e93460 __libc_start_main +
    245

    6    tmpz_ff1dr8                        0x000056053490a229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        var ascii =\
    \ char.asciiValue!\n        ascii += 2 * 2\n        encryptedString.append(Character(UnicodeScalar(ascii)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9wr1wq34.swift:12:62: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(ascii)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~^\n            \
    \                                                 \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 90 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 90) + 64\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpq_hqq6m_/tmpq_hqq6m_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70799ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af707691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af707691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7076907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_hqq6m_                        0x0000555d58ce59f7 <unavailable> + 6647

    5    libc.so.6                          0x00002af707b86460 __libc_start_main +
    245

    6    tmpq_hqq6m_                        0x0000555d58ce5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for letter in s {\n        let unicode\
    \ = letter.unicodeScalars.first!.value\n        var shiftedUnicode = unicode +\
    \ (2 * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for c in s.characters {\n        if let index\
    \ = alphabet.characters.indexOf(c) {\n            let newIndex = (index + 2) %\
    \ alphabet.characters.count\n            encrypted.append(alphabet[newIndex])\n\
    \        } else {\n            encrypted.append(c)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgoziwv5s.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgoziwv5s.swift:10:24:\
    \ error: cannot find 'alphabet' in scope\n        if let index = alphabet.characters.indexOf(c)\
    \ {\n                       ^~~~~~~~\n/tmp/tmpgoziwv5s.swift:11:42: error: cannot\
    \ find 'alphabet' in scope\n            let newIndex = (index + 2) % alphabet.characters.count\n\
    \                                         ^~~~~~~~\n/tmp/tmpgoziwv5s.swift:12:30:\
    \ error: cannot find 'alphabet' in scope\n            encrypted.append(alphabet[newIndex])\n\
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var rotatedUnicode =\
    \ unicode + (2 * 2)\n            if rotatedUnicode > 122 {\n                rotatedUnicode\
    \ = (rotatedUnicode % 122) + 96\n            }\n            let rotatedCharacter\
    \ = String(UnicodeScalar(UInt8(rotatedUnicode)))\n            encryptedString\
    \ += rotatedCharacter\n        }\n    }\n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if let ascii = char.asciiValue\
    \ {\n            let newAscii = ascii + 2 * 2\n            let newChar = Character(UnicodeScalar(newAscii))\n\
    \            encrypted.append(newChar)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpz_b_evvm/tmpz_b_evvm.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed139f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed136e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed136e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed136e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_b_evvm                        0x000055be2a6b697e <unavailable> + 6526

    5    libc.so.6                          0x00002aed13bde460 __libc_start_main +
    245

    6    tmpz_b_evvm                        0x000055be2a6b6179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = (shiftedUnicode % 122) + 96\n        }\n   \
    \     let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n  \
    \      encrypted += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if let ascii\
    \ = char.asciiValue {\n            if ascii >= 65 && ascii <= 90 {\n         \
    \       let newAscii = ascii + 2\n                if newAscii > 90 {\n       \
    \             let difference = newAscii - 90\n                    let newAscii\
    \ = 64 + difference\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                } else {\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                }\n            } else if ascii >= 97 && ascii <= 122 {\n    \
    \            let newAscii = ascii + 2\n                if newAscii > 122 {\n \
    \                   let difference = newAscii - 122\n                    let newAscii\
    \ = 96 + difference\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                } else {\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                }\n            } else {\n                encryptedString.append(char)\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprqs0ibxl.swift:16:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                     ~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n\
    /tmp/tmprqs0ibxl.swift:18:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                     ~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n\
    /tmp/tmprqs0ibxl.swift:25:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                     ~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n\
    /tmp/tmprqs0ibxl.swift:27:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                     ~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            result += \" \"\n        } else {\n            let unicode = char.unicodeScalars.first!.value\n\
    \            let shiftedUnicode = unicode + 2 * 2\n            let shiftedCharacter\
    \ = String(UnicodeScalar(UInt8(shiftedUnicode)))\n            result += shiftedCharacter\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp81b5hpxh/tmp81b5hpxh.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeac062ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeac0325b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeac0325988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeac03247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp81b5hpxh                        0x000055725a707e3e <unavailable> + 7742

    5    libc.so.6                          0x00002aeac081a460 __libc_start_main +
    245

    6    tmp81b5hpxh                        0x000055725a707639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if char == \"\
    \ \" {\n            encryptedString += \" \"\n        } else {\n            let\
    \ unicode = char.unicodeScalars.first!.value\n            var shiftedUnicode =\
    \ unicode + (2 * 2)\n            if shiftedUnicode > 90 {\n                shiftedUnicode\
    \ = shiftedUnicode - 26\n            }\n            let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \            encryptedString += shiftedCharacter\n        }\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp28_mdozu/tmp28_mdozu.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a5c7b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a5c4a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a5c4a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a5c4a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp28_mdozu                        0x0000560008ad19f7 <unavailable> + 6647

    5    libc.so.6                          0x00002b7a5c99e460 __libc_start_main +
    245

    6    tmp28_mdozu                        0x0000560008ad1639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ = encrypted + shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for letter in s {\n        if let idx = alphabet.firstIndex(of: letter)\
    \ {\n            let newIdx = idx.encodedOffset + 2 * 2\n            encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIdx % alphabet.count)])\n        } else {\n            encrypted.append(letter)\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let charIndex\
    \ = alphabet.index(of: char)\n        let newCharIndex = (charIndex! + 2 * 2)\
    \ % 26\n        encryptedString.append(alphabet[newCharIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmperr4pitt.swift:10:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.index(of: char)\n                        ^~~~~~~~\n\
    /tmp/tmperr4pitt.swift:12:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newCharIndex])\n                           \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + (2\
    \ * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = (shiftedUnicode\
    \ % 122) + 96\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        if let ascii\
    \ = char.asciiValue {\n            let newAscii = ascii + 2 * 2\n            if\
    \ newAscii > 122 {\n                let newAscii = newAscii - 26\n           \
    \     encryptedString.append(Character(UnicodeScalar(newAscii)!))\n          \
    \  } else {\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpv5b22qo_.swift:14:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n/tmp/tmpv5b22qo_.swift:16:73:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n"
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2 * 2\n            let newChar\
    \ = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n      \
    \      encrypted.append(newChar)\n        }\n    }\n    return encrypted\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d68375c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d6806c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6d6806c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6d6806c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6d6806bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b6d6819fec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b6d68158660 String.subscript.getter
    + 34

    7    tmp4yggu7oz                        0x000055c6447270ef <unavailable> + 8431

    8    tmp4yggu7oz                        0x000055c6447269fd <unavailable> + 6653

    9    libc.so.6                          0x00002b6d68561460 __libc_start_main +
    245

    10   tmp4yggu7oz                        0x000055c6447262e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + 2\
    \ * 2\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        var index = alphabet.index(of: char)\n      \
    \  if index != nil {\n            index = alphabet.index(index!, offsetBy: 2)\n\
    \            encrypted.append(alphabet[index!])\n        } else {\n          \
    \  encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpttae1g47/tmpttae1g47.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b767774fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7677446b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7677446988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76774457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpttae1g47                        0x000055f6eda67687 <unavailable> + 5767

    5    libc.so.6                          0x00002b767793b460 __libc_start_main +
    245

    6    tmpttae1g47                        0x000055f6eda672c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + (2 * 2)\n        if shiftedUnicode > 122\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted += \" \"\n        } else {\n            let unicode = char.unicodeScalars.first!.value\n\
    \            let shiftedUnicode = unicode + 2 * 2\n            let shiftedCharacter\
    \ = String(UnicodeScalar(UInt8(shiftedUnicode)))\n            encrypted += shiftedCharacter\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmplpk0z260/tmplpk0z260.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf71e0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf71b01b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf71b01988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf71b007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplpk0z260                        0x0000557ba4840e3e <unavailable> + 7742

    5    libc.so.6                          0x00002adf71ff6460 __libc_start_main +
    245

    6    tmplpk0z260                        0x0000557ba4840639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660028270
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2 * 2\n            if newIndex\
    \ > 25 {\n                let newIndex = newIndex - 26\n                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + 4\n        if shiftedUnicode > 122 {\n\
    \            shiftedUnicode = shiftedUnicode - 26\n        }\n        let shiftedCharacter\
    \ = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        result.append(shiftedCharacter)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\
    \"\n    for char in s {\n        if let index = alphabet.index(of: char) {\n \
    \           let newIndex = index.encodedOffset + 2 * 2\n            if newIndex\
    \ < alphabet.count {\n                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex - alphabet.count)])\n            }\n        } else {\n  \
    \          encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028271
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encrypted = \"\"\n    for char in s {\n        let unicode = char.unicodeScalars.first!.value\n\
    \        var shiftedUnicode = unicode + 2 * 2\n        if shiftedUnicode > 90\
    \ {\n            shiftedUnicode = shiftedUnicode - 26\n        }\n        let\
    \ shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n        encrypted\
    \ += shiftedCharacter\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpqh4b8y1d/tmpqh4b8y1d.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a9185ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a91551b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a91551988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a915507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqh4b8y1d                        0x000055d9e15db907 <unavailable> + 6407

    5    libc.so.6                          0x00002b8a91a46460 __libc_start_main +
    245

    6    tmpqh4b8y1d                        0x000055d9e15db549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660028271
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for char in s {\n        let unicode\
    \ = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode + 2\
    \ * 2\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028270
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var encryptedString = \"\"\n    for character in s.characters {\n   \
    \     let unicode = character.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqizortws.swift:9:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in s.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028271
