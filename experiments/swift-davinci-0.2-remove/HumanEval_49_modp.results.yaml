language: swift
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n \
    \       n /= 2\n        p = (p * p) % MODULO\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppojm7nem.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7bjwh985.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp7bjwh985.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp7bjwh985.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n \
    \       n /= 2\n        p = (p * p) % MODULO\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppojm7nem.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc5sxe41m.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmpc5sxe41m.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmpc5sxe41m.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * 2 % p\n               ^\n                n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 != 0 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002aac4882cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac48523561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aac48523286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aac4852313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aac48522bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpdpzuxrxb                        0x0000564bdafb36a5 <unavailable> + 5797

    6    tmpdpzuxrxb                        0x0000564bdafb31e0 <unavailable> + 4576

    7    libc.so.6                          0x00002aac48a18460 __libc_start_main +
    245

    8    tmpdpzuxrxb                        0x0000564bdafb2ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % modulus\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxem3mke3.swift:12:23: error: cannot find 'modulus' in scope\n \
    \       p = (p * p) % modulus\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % modulus\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxem3mke3.swift:12:23: error: cannot find 'modulus' in scope\n \
    \       p = (p * p) % modulus\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc5sxe41m.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmpc5sxe41m.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmpc5sxe41m.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * 2 % p\n               ^\n                n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n: n / 2, p: p)\n        return (x * x) % p\n    }\n   \
    \ return (2 * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n\
    \        let m = modp(n/2, p: p)\n        return (m*m) % p\n    } else {\n   \
    \     return (2 * modp(n-1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxgmcg5ar.swift:7:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n/2, p: p)\n                    ^\n                    \
    \ n: \n/tmp/tmpxgmcg5ar.swift:8:18: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m*m) % p\n                \
    \ ^\n/tmp/tmpxgmcg5ar.swift:10:25: error: missing argument label 'n:' in call\n\
    \        return (2 * modp(n-1, p: p)) % p\n                        ^\n       \
    \                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var n = n\n    var result = 1\n    while n > 0 {\n      \
    \  if n % 2 == 1 {\n            result = (result * 2) % p\n        }\n       \
    \ n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp10wahvnh/tmp10wahvnh.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ac6265c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ac5f5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6ac5f5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6ac5f5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp10wahvnh                        0x000056020db2124d <unavailable> + 4685

    5    libc.so.6                          0x00002b6ac6451460 __libc_start_main +
    245

    6    tmp10wahvnh                        0x000056020db20ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var r = 1\n    var k = n\n    var m = p\n    while k > 0\
    \ {\n        if k % 2 == 1 {\n            r = (r * n) % p\n        }\n       \
    \ k = k / 2\n        n = (n * n) % p\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp30_q4uus.swift:12:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n \
    \       return 2\n    }\n    if n % 2 == 0 {\n        return modp(n: n/2, p: p)\
    \ * modp(n: n/2, p: p) % p\n    }\n    return modp(n: n/2, p: p) * modp(n: n/2,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7bjwh985.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp7bjwh985.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp7bjwh985.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7bjwh985.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp7bjwh985.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp7bjwh985.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var nn = n\n    while nn > 0 {\n       \
    \ if nn & 1 != 0 {\n            res = (res * n) % p\n        }\n        nn >>=\
    \ 1\n        n = (n * n) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsh4ezbpd.swift:11:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var r = 1\n    var k = n\n    var m = p\n    while k > 0\
    \ {\n        if k & 1 == 1 {\n            r = (r * k) % m\n        }\n       \
    \ k = k >> 1\n        m = (m * m) % p\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6b9775c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6b946c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba6b946c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba6b946c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba6b946bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpnoioett1                        0x0000564c6821469d <unavailable> + 5789

    6    tmpnoioett1                        0x0000564c682141e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ba6b9961460 __libc_start_main +
    245

    8    tmpnoioett1                        0x0000564c68213ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    } else {\n\
    \        return (2 * modp(n - 1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbcqiv6bg.swift:7:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpbcqiv6bg.swift:8:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmpbcqiv6bg.swift:10:25: error: missing argument label 'n:' in call\n\
    \        return (2 * modp(n - 1, p: p)) % p\n                        ^\n     \
    \                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % modulus\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxem3mke3.swift:12:23: error: cannot find 'modulus' in scope\n \
    \       p = (p * p) % modulus\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n \
    \       n /= 2\n        p = (p * p) % MODULO\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppojm7nem.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if n % 2 == 0 {\n    return\
    \ modp(n/2, p: p) * modp(n/2, p: p) % p\n  }\n  return modp(n/2, p: p) * modp(n/2,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprd0vp8ua.swift:8:16: error: missing argument label 'n:' in call\n\
    \    return modp(n/2, p: p) * modp(n/2, p: p) % p\n               ^\n        \
    \        n: \n/tmp/tmprd0vp8ua.swift:8:34: error: missing argument label 'n:'\
    \ in call\n    return modp(n/2, p: p) * modp(n/2, p: p) % p\n                \
    \                 ^\n                                  n: \n/tmp/tmprd0vp8ua.swift:10:14:\
    \ error: missing argument label 'n:' in call\n  return modp(n/2, p: p) * modp(n/2,\
    \ p: p) * 2 % p\n             ^\n              n: \n/tmp/tmprd0vp8ua.swift:10:32:\
    \ error: missing argument label 'n:' in call\n  return modp(n/2, p: p) * modp(n/2,\
    \ p: p) * 2 % p\n                               ^\n                          \
    \      n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n \
    \       n /= 2\n        p = (p * p) % MODULO\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppojm7nem.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc5sxe41m.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmpc5sxe41m.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmpc5sxe41m.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * 2 % p\n               ^\n                n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n \
    \       n /= 2\n        p = (p * p) % MODULO\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppojm7nem.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var r = 1\n    var k = n\n    var m = p\n    while k > 0\
    \ {\n        if k % 2 == 1 {\n            r = (r * n) % p\n        }\n       \
    \ k = k / 2\n        n = (n * n) % p\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp30_q4uus.swift:12:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n == 1 {\n \
    \       return 2\n    } else if n % 2 == 0 {\n        let m = modp(n: n / 2, p:\
    \ p)\n        return (m * m) % p\n    } else {\n        return (2 * modp(n: n\
    \ - 1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var n = n\n    var p = p\n    var result = 1\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4mbe7joq.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * res) % p\n        }\n\
    \        n >>= 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt70anjw9/tmpt70anjw9.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae78d1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae78a11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae78a11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae78a107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt70anjw9                        0x00005599a401024d <unavailable> + 4685

    5    libc.so.6                          0x00002aae78f06460 __libc_start_main +
    245

    6    tmpt70anjw9                        0x00005599a400fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014395
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var r = 1\n    var n = n\n    var p = p\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            r = (r * 2) % p\n        }\n       \
    \ n /= 2\n        p = (p * 2) % MOD\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkn1o3zj0.swift:12:23: error: cannot find 'MOD' in scope\n     \
    \   p = (p * 2) % MOD\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n \
    \       n /= 2\n        p = (p * p) % MODULO\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppojm7nem.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7bjwh985.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp7bjwh985.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp7bjwh985.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n: n / 2, p: p)\n        return (x * x) % p\n    }\n   \
    \ return (2 * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    var result = modp(n\
    \ / 2, p: p)\n    result = (result * result) % p\n    if n % 2 == 1 {\n      \
    \  result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3tqczdb8.swift:7:22: error: missing argument label 'n:' in call\n\
    \    var result = modp(n / 2, p: p)\n                     ^\n                \
    \      n: \n/tmp/tmp3tqczdb8.swift:8:22: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n    result = (result * result) % p\n      \
    \               ^\n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let m = modp(n: n / 2, p: p)\n        return (m * m) % p\n    }\n   \
    \ return (2 * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    var res = modp(n\
    \ / 2, p: p)\n    res = (res * res) % p\n    if n % 2 == 1 {\n        res = (res\
    \ * 2) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2i4b_3vy.swift:7:19: error: missing argument label 'n:' in call\n\
    \    var res = modp(n / 2, p: p)\n                  ^\n                   n: \n\
    /tmp/tmp2i4b_3vy.swift:8:16: error: cannot convert value of type 'Duration' to\
    \ expected argument type 'Int'\n    res = (res * res) % p\n               ^\n"
  stdout: ''
  timestamp: 1660014395
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let m = modp(n: n / 2, p: p)\n        return (m * m) % p\n    }\n   \
    \ return (2 * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var k = n\n    var two = 2\n    while k\
    \ > 0 {\n        if k & 1 == 1 {\n            res = (res * two) % p\n        }\n\
    \        two = (two * two) % p\n        k >>= 1\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    } else {\n\
    \        return (2 * modp(n - 1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbcqiv6bg.swift:7:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpbcqiv6bg.swift:8:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmpbcqiv6bg.swift:10:25: error: missing argument label 'n:' in call\n\
    \        return (2 * modp(n - 1, p: p)) % p\n                        ^\n     \
    \                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n == 1 {\n \
    \       return 2\n    } else if n % 2 == 0 {\n        let m = modp(n: n / 2, p:\
    \ p)\n        return (m * m) % p\n    } else {\n        return (2 * modp(n: n\
    \ - 1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    } else {\n\
    \        return (2 * modp(n - 1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbcqiv6bg.swift:7:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpbcqiv6bg.swift:8:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmpbcqiv6bg.swift:10:25: error: missing argument label 'n:' in call\n\
    \        return (2 * modp(n - 1, p: p)) % p\n                        ^\n     \
    \                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var r = 1\n    var k = n\n    var m = p\n    while k > 0\
    \ {\n        if k % 2 == 1 {\n            r = (r * n) % p\n        }\n       \
    \ k /= 2\n        n = (n * n) % p\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu24sm3hm.swift:12:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var a = 2\n    var b = n\n    while b >\
    \ 0 {\n        if b % 2 == 1 {\n            res = (res * a) % p\n        }\n \
    \       a = (a * a) % p\n        b /= 2\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return\
    \ modp(n: n - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n == 1 {\n \
    \       return 2\n    } else if n % 2 == 0 {\n        let m = modp(n: n / 2, p:\
    \ p)\n        return (m * m) % p\n    } else {\n        return (2 * modp(n: n\
    \ - 1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n == 1 {\n \
    \       return 2\n    } else if n % 2 == 0 {\n        return modp(n / 2, p: p)\
    \ * modp(n / 2, p: p) % p\n    } else {\n        return modp(n / 2, p: p) * modp(n\
    \ / 2, p: p) * 2 % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpag15l68t.swift:9:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpag15l68t.swift:9:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpag15l68t.swift:11:20: error: missing argument label 'n:' in\
    \ call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n       \
    \            ^\n                    n: \n/tmp/tmpag15l68t.swift:11:40: error:\
    \ missing argument label 'n:' in call\n        return modp(n / 2, p: p) * modp(n\
    \ / 2, p: p) * 2 % p\n                                       ^\n             \
    \                           n: \n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    var result = modp(n\
    \ / 2, p: p)\n    result = (result * result) % p\n    if n % 2 == 1 {\n      \
    \  result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3tqczdb8.swift:7:22: error: missing argument label 'n:' in call\n\
    \    var result = modp(n / 2, p: p)\n                     ^\n                \
    \      n: \n/tmp/tmp3tqczdb8.swift:8:22: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n    result = (result * result) % p\n      \
    \               ^\n"
  stdout: ''
  timestamp: 1660014395
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    for _ in 0..<n {\n        res = (res * 2)\
    \ % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n & 1 == 1 {\n            result = (result * p) % MOD\n  \
    \      }\n        n = n >> 1\n        p = (p * p) % MOD\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3vqgo2ln.swift:9:37: error: cannot find 'MOD' in scope\n      \
    \      result = (result * p) % MOD\n                                    ^~~\n\
    /tmp/tmp3vqgo2ln.swift:12:23: error: cannot find 'MOD' in scope\n        p = (p\
    \ * p) % MOD\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % modulus\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxem3mke3.swift:12:23: error: cannot find 'modulus' in scope\n \
    \       p = (p * p) % modulus\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n/2,\
    \ p: p) * modp(n/2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdxtb0n4b.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmpdxtb0n4b.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmpdxtb0n4b.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n               ^\n    \
    \            n: \n/tmp/tmpdxtb0n4b.swift:10:34: error: missing argument label\
    \ 'n:' in call\n    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n       \
    \                          ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let t = modp(n: n / 2, p: p)\n        return (t * t) % p\n    }\n   \
    \ return (2 * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return\
    \ modp(n: n - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014400
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n \
    \       return 2\n    }\n    if n % 2 == 0 {\n        return modp(n/2, p: p) *\
    \ modp(n/2, p: p) % p\n    }\n    return modp(n/2, p: p) * modp(n/2, p: p) * 2\
    \ % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp83y5yi8f.swift:11:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp83y5yi8f.swift:11:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp83y5yi8f.swift:13:16: error: missing argument label 'n:' in call\n\
    \    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n               ^\n    \
    \            n: \n/tmp/tmp83y5yi8f.swift:13:34: error: missing argument label\
    \ 'n:' in call\n    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n       \
    \                          ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqqtkfo1k.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpqqtkfo1k.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpqqtkfo1k.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * 2 % p\n               ^\n             \
    \   n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return 2\
    \ * modp(n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6hmk71xr.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp6hmk71xr.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp6hmk71xr.swift:10:20: error: missing argument label 'n:' in\
    \ call\n    return 2 * modp(n - 1, p: p) % p\n                   ^\n         \
    \           n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return 2 * modp(n-1,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp690u8ffz.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp690u8ffz.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp690u8ffz.swift:10:20: error: missing argument label 'n:' in call\n\
    \    return 2 * modp(n-1, p: p) % p\n                   ^\n                  \
    \  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n\
    \ - 1, p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4jd1lfid.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp4jd1lfid.swift:8:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp4jd1lfid.swift:10:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n               ^\n \
    \               n: \n/tmp/tmp4jd1lfid.swift:10:36: error: missing argument label\
    \ 'n:' in call\n    return modp(n - 1, p: p) * modp(1, p: p) % p\n           \
    \                        ^\n                                    n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpanos6xsd.swift:12:23: error: cannot find 'MODULO' in scope\n  \
    \      p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    } else if n == 1 {\n \
    \       return 2\n    } else if n % 2 == 0 {\n        let x = modp(n / 2, p: p)\n\
    \        return (x * x) % p\n    } else {\n        return (2 * modp(n - 1, p:\
    \ p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6mssfofb.swift:9:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp6mssfofb.swift:10:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp6mssfofb.swift:12:25: error: missing argument label 'n:' in call\n\
    \        return (2 * modp(n - 1, p: p)) % p\n                        ^\n     \
    \                    n: \n"
  stdout: ''
  timestamp: 1660014395
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return\
    \ (2 * modp(n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9k1j1yil.swift:8:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp9k1j1yil.swift:9:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmp9k1j1yil.swift:11:21: error: missing argument label 'n:' in call\n\
    \    return (2 * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1,\
    \ p: p) * modp(1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmperqrgo7j.swift:8:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmperqrgo7j.swift:8:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmperqrgo7j.swift:10:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(1, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmperqrgo7j.swift:10:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(1, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014394
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014394
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var result = 1\n    var n = n\n    var p = p\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n /= 2\n        p = (p * p) % modulus\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxem3mke3.swift:12:23: error: cannot find 'modulus' in scope\n \
    \       p = (p * p) % modulus\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014394
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n    var res = 1\n    var n = n\n    var p = p\n    while n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6246418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b624610f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b624610f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b624610f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b624610ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx42d8w0r                        0x000055b7ef60b69d <unavailable> + 5789

    6    tmpx42d8w0r                        0x000055b7ef60b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b6246604460 __libc_start_main +
    245

    8    tmpx42d8w0r                        0x000055b7ef60aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014394
