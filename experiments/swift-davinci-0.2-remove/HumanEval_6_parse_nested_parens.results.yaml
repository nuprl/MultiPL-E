language: swift
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    var depth = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depths.append(depth)\n            depth -= 1\n        }\n    }\n\
    \    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmyh33rdl.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nested_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var current_nested_level\
    \ = 0\n        var max_nested_level = 0\n        for char in paren_group {\n \
    \           if char == \"(\" {\n                current_nested_level += 1\n  \
    \          } else if char == \")\" {\n                current_nested_level -=\
    \ 1\n            }\n            if current_nested_level > max_nested_level {\n\
    \                max_nested_level = current_nested_level\n            }\n    \
    \    }\n        max_nested_levels.append(max_nested_level)\n    }\n    return\
    \ max_nested_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpwjqmee6p.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var count = 0\n     \
    \   var max_count = 0\n        for paren in paren_group {\n            if paren\
    \ == \"(\" {\n                count += 1\n            } else if paren == \")\"\
    \ {\n                count -= 1\n            }\n            if count > max_count\
    \ {\n                max_count = count\n            }\n        }\n        result.append(max_count)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc_rgdu9g.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            if paren_stack.isEmpty()\
    \ {\n                max_depths.append(max_depth)\n                max_depth =\
    \ 0\n                depth = 0\n            } else {\n                paren_stack.pop()\n\
    \                depth -= 1\n            }\n        }\n    }\n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6n6pjuyb.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n            if current_nesting\
    \ == 0 {\n                max_nesting_list.append(max_nesting)\n             \
    \   max_nesting = 0\n            }\n        }\n    }\n    return max_nesting_list\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let groups = paren_string.components(separatedBy: \" \")\n \
    \   var result = [Int]()\n    for group in groups {\n        var count = 0\n \
    \       var max_count = 0\n        for char in group {\n            if char ==\
    \ \"(\" {\n                count += 1\n            } else if char == \")\" {\n\
    \                count -= 1\n            }\n            if count > max_count {\n\
    \                max_count = count\n            }\n        }\n        result.append(max_count)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpbfp574wc.swift:6:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var curr_depth = 0\n    var result =\
    \ [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n      \
    \      curr_depth += 1\n            max_depth = max(max_depth, curr_depth)\n \
    \       } else if char == \")\" {\n            curr_depth -= 1\n        } else\
    \ if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            curr_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_level = 0\n    var level = 0\n    var result = [Int]()\n\
    \    for paren in paren_string {\n        if paren == \"(\" {\n            level\
    \ += 1\n            max_level = max(max_level, level)\n        } else if paren\
    \ == \")\" {\n            level -= 1\n        } else if paren == \" \" {\n   \
    \         result.append(max_level)\n            max_level = 0\n            level\
    \ = 0\n        }\n    }\n    result.append(max_level)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_array = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_array = [Int]()\n    for paren in paren_array {\n     \
    \   var max_nesting = 0\n        var current_nesting = 0\n        for char in\
    \ paren {\n            if char == \"(\" {\n                current_nesting +=\
    \ 1\n            } else if char == \")\" {\n                current_nesting -=\
    \ 1\n            }\n            if current_nesting > max_nesting {\n         \
    \       max_nesting = current_nesting\n            }\n        }\n        max_nesting_array.append(max_nesting)\n\
    \    }\n    return max_nesting_array\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpajp9l2nw.swift:6:36: error: value of type 'String' has no member\
    \ 'components'\n    var paren_array = paren_string.components(separatedBy: \"\
    \ \")\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for paren in paren_group {\n       \
    \     if paren == \"(\" {\n                current_nesting += 1\n            }\
    \ else if paren == \")\" {\n                current_nesting -= 1\n           \
    \ }\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting\n            }\n        }\n        result.append(max_nesting)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5jahpydq.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_level = 0\n \
    \       var current_level = 0\n        for char in paren_group {\n           \
    \ if char == \"(\" {\n                current_level += 1\n            } else if\
    \ char == \")\" {\n                current_level -= 1\n            }\n       \
    \     if current_level > max_level {\n                max_level = current_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_level)\n    }\n\
    \    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2qasarjm.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var current_depth = 0\n        for char in group {\n            if char == \"\
    (\" {\n                current_depth += 1\n                if current_depth >\
    \ max_depth {\n                    max_depth = current_depth\n               \
    \ }\n            } else if char == \")\" {\n                current_depth -= 1\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0wd8bt03.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for group in paren_groups {\n        var\
    \ nesting_count = 0\n        var max_nesting_count = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                nesting_count += 1\n    \
    \        } else if char == \")\" {\n                nesting_count -= 1\n     \
    \       }\n            if nesting_count > max_nesting_count {\n              \
    \  max_nesting_count = nesting_count\n            }\n        }\n        max_nesting.append(max_nesting_count)\n\
    \    }\n    return max_nesting\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0p78wpuj.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      current_depth += 1\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth\n            }\n        } else if paren ==\
    \ \")\" {\n            paren_stack.pop()\n            current_depth -= 1\n   \
    \     }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjqz23ijm.swift:7:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_level = 0\n       \
    \ var level = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                level += 1\n            } else if char == \")\" {\n         \
    \       level -= 1\n            }\n            if level > max_level {\n      \
    \          max_level = level\n            }\n        }\n        result.append(max_level)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2u5xdyml.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_count = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_count += 1\n            if nesting_count > max_nesting {\n  \
    \              max_nesting = nesting_count\n            }\n        } else if char\
    \ == \")\" {\n            nesting_count -= 1\n        } else if char == \" \"\
    \ {\n            result.append(max_nesting)\n            max_nesting = 0\n   \
    \         nesting_count = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var curr_depth = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            curr_depth\
    \ += 1\n            if curr_depth > max_depth {\n                max_depth = curr_depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            curr_depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            curr_depth = 0\n        }\n    }\n   \
    \ result.append(max_depth)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8j0vl39a.swift:7:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n    \
    \    var current_nesting = 0\n        var max_nesting_in_group = 0\n        for\
    \ char in paren_group {\n            if char == \"(\" {\n                current_nesting\
    \ += 1\n            } else if char == \")\" {\n                current_nesting\
    \ -= 1\n            }\n            if current_nesting > max_nesting_in_group {\n\
    \                max_nesting_in_group = current_nesting\n            }\n     \
    \   }\n        max_nesting.append(max_nesting_in_group)\n    }\n    return max_nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpcmyfl0ci.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack: [Character] = []\n    var max_depth: [Int]\
    \ = []\n    var current_depth = 0\n    var current_max = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      current_depth += 1\n            if current_depth > current_max {\n    \
    \            current_max = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            paren_stack.popLast()\n            current_depth -=\
    \ 1\n        } else if char == \" \" {\n            max_depth.append(current_max)\n\
    \            current_max = 0\n            current_depth = 0\n        }\n    }\n\
    \    return max_depth\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp8xiz49_0/tmp8xiz49_0.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade3fc8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade3f982b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade3f982988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade3f9817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8xiz49_0                        0x000055c291d007be <unavailable> + 6078

    5    libc.so.6                          0x00002ade3fe77460 __libc_start_main +
    245

    6    tmp8xiz49_0                        0x000055c291d003d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_array = paren_string.components(separatedBy: \" \"\
    )\n    var result = [Int]()\n    for paren in paren_array {\n        var max_level\
    \ = 0\n        var level = 0\n        for char in paren {\n            if char\
    \ == \"(\" {\n                level += 1\n            } else if char == \")\"\
    \ {\n                level -= 1\n            }\n            if level > max_level\
    \ {\n                max_level = level\n            }\n        }\n        result.append(max_level)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpkzfivrvp.swift:6:36: error: value of type 'String' has no member\
    \ 'components'\n    var paren_array = paren_string.components(separatedBy: \"\
    \ \")\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    var current_depth = 0\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            depths.append(current_depth)\n\
    \            current_depth -= 1\n        }\n    }\n    \n    return depths\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp7hn9bdzb.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var is_nested = false\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            is_nested = true\n        } else if char == \")\" {\n    \
    \        current_nesting_level -= 1\n        } else if char == \" \" {\n     \
    \       if is_nested {\n                max_nesting_levels.append(max_nesting_level)\n\
    \                max_nesting_level = 0\n                is_nested = false\n  \
    \          }\n        }\n        max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: Exception
  stderr: 'tmpnrtheczj/tmpnrtheczj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b621b835c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b621b52cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b621b52c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b621b52b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnrtheczj                        0x00005639cfd1271e <unavailable> + 5918

    5    libc.so.6                          0x00002b621ba21460 __libc_start_main +
    245

    6    tmpnrtheczj                        0x00005639cfd12339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        } else if char == \")\" {\n            current_depth -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var stack = Stack<Character>()\n    var max_depth = 0\n    var\
    \ current_depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_depth -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_depth)\n            max_depth = 0\n    \
    \        current_depth = 0\n        }\n    }\n    result.append(max_depth)\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5ddn_tcq.swift:6:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var paren_stack = Stack<Character>()\n\
    \        var max_depth = 0\n        var depth = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                depth += 1\n           \
    \     if depth > max_depth {\n                    max_depth = depth\n        \
    \        }\n                paren_stack.push(paren)\n            } else if paren\
    \ == \")\" {\n                depth -= 1\n                paren_stack.pop()\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplan0lux9.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmplan0lux9.swift:9:27:\
    \ error: cannot find 'Stack' in scope\n        var paren_stack = Stack<Character>()\n\
    \                          ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_depth = 0\n    var current_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_depth += 1\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            current_depth -= 1\n        } else if char == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var depth_array =\
    \ [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            depth_array.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    depth_array.append(max_depth)\n\
    \    return depth_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var max_nesting = 0\n        var\
    \ current_nesting = 0\n        for char in group {\n            if char == \"\
    (\" {\n                current_nesting += 1\n            } else if char == \"\
    )\" {\n                current_nesting -= 1\n            }\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        }\n        result.append(max_nesting)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp1rcomi7q.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = [Int]()\n    var depth = 0\n    var max_depth_so_far\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  depth += 1\n            if depth > max_depth_so_far {\n                max_depth_so_far\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            max_depth.append(max_depth_so_far)\n\
    \            max_depth_so_far = 0\n            depth = 0\n        }\n    }\n \
    \   max_depth.append(max_depth_so_far)\n    return max_depth\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_count = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_count += 1\n            if nesting_count > max_nesting {\n  \
    \              max_nesting = nesting_count\n            }\n        } else if char\
    \ == \")\" {\n            nesting_count -= 1\n        } else if char == \" \"\
    \ {\n            result.append(max_nesting)\n            max_nesting = 0\n   \
    \         nesting_count = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                depth += 1\n                if depth > max_depth\
    \ {\n                    max_depth = depth\n                }\n            } else\
    \ if char == \")\" {\n                depth -= 1\n            }\n        }\n \
    \       result.append(max_depth)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp678j7tn7.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var current_depth = 0\n    var depths = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            current_depth -= 1\n       \
    \     if paren_stack.isEmpty() {\n                depths.append(max_depth)\n \
    \               max_depth = 0\n                current_depth = 0\n           \
    \ }\n        }\n    }\n    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpzpv9e_6t.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for paren in paren_group {\n            if paren\
    \ == \"(\" {\n                depth += 1\n            } else if paren == \")\"\
    \ {\n                depth -= 1\n            }\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpui1fuu8e.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var nesting_level = 0\n\
    \        var max_nesting_level = 0\n        for paren in paren_group {\n     \
    \       if paren == \"(\" {\n                nesting_level += 1\n            }\
    \ else if paren == \")\" {\n                nesting_level -= 1\n            }\n\
    \            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5w_ahopb.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                depth += 1\n                if depth > max_depth\
    \ {\n                    max_depth = depth\n                }\n            } else\
    \ if char == \")\" {\n                depth -= 1\n            }\n        }\n \
    \       result.append(max_depth)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp678j7tn7.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var current_depth = 0\n    var output = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            if paren_stack.isEmpty() {\n                print(\"Error:\
    \ mismatched parentheses\")\n                return []\n            } else {\n\
    \                paren_stack.pop()\n                current_depth -= 1\n     \
    \       }\n        } else if char == \" \" {\n            output.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        }\n    }\n\
    \    output.append(max_depth)\n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptmsnr_9t.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth_stack\
    \ = Stack<Int>()\n    var max_depth = 0\n    var max_depth_array = [Int]()\n \
    \   \n    for char in paren_string {\n        if char == \"(\" {\n           \
    \ paren_stack.push(char)\n            max_depth += 1\n            max_depth_stack.push(max_depth)\n\
    \        } else if char == \")\" {\n            paren_stack.pop()\n          \
    \  max_depth_array.append(max_depth_stack.pop()!)\n            max_depth -= 1\n\
    \        }\n    }\n    \n    return max_depth_array\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprsztdxf6.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n/tmp/tmprsztdxf6.swift:7:27:\
    \ error: cannot find 'Stack' in scope\n    var max_depth_stack = Stack<Int>()\n\
    \                          ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \          if depth == 0 {\n                max_depths.append(max_depth)\n   \
    \             max_depth = 0\n            }\n        }\n    }\n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var nesting_level = 0\n\
    \        var max_nesting_level = 0\n        for paren in paren_group {\n     \
    \       if paren == \"(\" {\n                nesting_level += 1\n            }\
    \ else if paren == \")\" {\n                nesting_level -= 1\n            }\n\
    \            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5w_ahopb.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var current_depth = 0\n        for paren in paren_group {\n          \
    \  if paren == \"(\" {\n                current_depth += 1\n            } else\
    \ if paren == \")\" {\n                current_depth -= 1\n            }\n   \
    \         if current_depth > max_depth {\n                max_depth = current_depth\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var stack = [Int]()\n    var max_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  stack.append(1)\n            max_depth += 1\n        } else if char == \")\"\
    \ {\n            stack.removeLast()\n            if stack.isEmpty {\n        \
    \        result.append(max_depth)\n                max_depth = 0\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: Exception
  stderr: 'tmp4nipiky4/tmp4nipiky4.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2601f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba25feedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba25feed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba25feec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4nipiky4                        0x000055aec3ad880e <unavailable> + 6158

    5    libc.so.6                          0x00002ba2603e2460 __libc_start_main +
    245

    6    tmp4nipiky4                        0x000055aec3ad8429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            current_depth -= 1\n       \
    \ } else if char == \" \" {\n            result.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8v92es42.swift:7:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_array = paren_string.components(separatedBy: \" \"\
    )\n    var result = [Int]()\n    for paren in paren_array {\n        var max_level\
    \ = 0\n        var current_level = 0\n        for char in paren {\n          \
    \  if char == \"(\" {\n                current_level += 1\n            } else\
    \ if char == \")\" {\n                current_level -= 1\n            }\n    \
    \        if current_level > max_level {\n                max_level = current_level\n\
    \            }\n        }\n        result.append(max_level)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpia_p4j2k.swift:6:36: error: value of type 'String' has no member\
    \ 'components'\n    var paren_array = paren_string.components(separatedBy: \"\
    \ \")\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ nesting_level = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            nesting_level += 1\n            if nesting_level > max_nesting\
    \ {\n                max_nesting = nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            nesting_levels.append(nesting_level)\n     \
    \       nesting_level -= 1\n        }\n    }\n    return nesting_levels\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmpc114ctv0/tmpc114ctv0.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2040dcfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2040ac6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2040ac6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2040ac57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc114ctv0                        0x00005573629fa68e <unavailable> + 5774

    5    libc.so.6                          0x00002b2040fbb460 __libc_start_main +
    245

    6    tmpc114ctv0                        0x00005573629fa2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            paren_stack.push(char)\n            max_depth += 1\n  \
    \      } else if char == \")\" {\n            paren_stack.pop()\n            max_depth\
    \ -= 1\n        } else if char == \" \" {\n            depths.append(max_depth)\n\
    \            max_depth = 0\n        }\n    }\n    depths.append(max_depth)\n \
    \   return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6fa13o9u.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var is_paren_open = false\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            is_paren_open = true\n\
    \            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            is_paren_open =\
    \ false\n            current_nesting_level -= 1\n        } else if char == \"\
    \ \" && !is_paren_open {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var depth = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                depth += 1\n            } else if char == \")\" {\n         \
    \       depth -= 1\n            }\n            if depth > max_depth {\n      \
    \          max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp4y0rw1ma.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = [Character]()\n\
    \    var current_level = 0\n    var max_level = 0\n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.append(paren)\n    \
    \        current_level += 1\n            if current_level > max_level {\n    \
    \            max_level = current_level\n            }\n        } else if paren\
    \ == \")\" {\n            if paren_stack.last == \"(\" {\n                paren_stack.removeLast()\n\
    \                current_level -= 1\n            } else {\n                print(\"\
    Invalid input\")\n                return []\n            }\n        } else {\n\
    \            if paren_stack.isEmpty {\n                result.append(max_level)\n\
    \                max_level = 0\n                current_level = 0\n          \
    \  } else {\n                print(\"Invalid input\")\n                return\
    \ []\n            }\n        }\n    }\n    if paren_stack.isEmpty {\n        result.append(max_level)\n\
    \    } else {\n        print(\"Invalid input\")\n        return []\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            if paren_stack.isEmpty() {\n                result.append(0)\n\
    \                max_depth = 0\n                current_depth = 0\n          \
    \  } else {\n                paren_stack.pop()\n                current_depth\
    \ -= 1\n            }\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        }\n    }\n\
    \    result.append(max_depth)\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpu42t65pe.swift:7:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var levels = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            levels.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    levels.append(max_level)\n\
    \    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var nesting_level = 0\n\
    \        var max_nesting_level = 0\n        for paren in paren_group {\n     \
    \       if paren == \"(\" {\n                nesting_level += 1\n            }\
    \ else if paren == \")\" {\n                nesting_level -= 1\n            }\n\
    \            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5w_ahopb.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvfqhq747.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        } else if char == \")\" {\n            current_depth -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var depth = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                depth += 1\n            } else if char == \")\" {\n         \
    \       depth -= 1\n            }\n            if depth > max_depth {\n      \
    \          max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp4y0rw1ma.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var stack = [Character]()\n     \
    \   var max_depth = 0\n        var current_depth = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                stack.append(char)\n    \
    \            current_depth += 1\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth\n                }\n      \
    \      } else if char == \")\" {\n                stack.popLast()\n          \
    \      current_depth -= 1\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpy39t4xua.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_level = 0\n    var current_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var current_level = 0\n        var\
    \ max_level = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                current_level += 1\n            } else if char == \")\" {\n \
    \               current_level -= 1\n            }\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      }\n        max_levels.append(max_level)\n    }\n    return max_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi9cy6kyx.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for paren in paren_string {\n        if paren == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if paren\
    \ == \")\" {\n            depth -= 1\n        } else if paren == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_level = 0\n    var current_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            if current_nesting_level\
    \ > 0 {\n                current_nesting_level -= 1\n            } else {\n  \
    \              max_nesting_levels.append(max_nesting_level)\n                max_nesting_level\
    \ = 0\n                current_nesting_level = 0\n            }\n        }\n \
    \   }\n    max_nesting_levels.append(max_nesting_level)\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmpspui2eye/tmpspui2eye.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9534cc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95349bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95349ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95349b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpspui2eye                        0x00005631c32ff68e <unavailable> + 5774

    5    libc.so.6                          0x00002b9534eaf460 __libc_start_main +
    245

    6    tmpspui2eye                        0x00005631c32ff2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl0u4462j.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_counts = [Int]()\n    var paren_count = 0\n    var\
    \ max_paren_count = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            paren_count += 1\n            max_paren_count = max(max_paren_count,\
    \ paren_count)\n        } else if char == \")\" {\n            paren_count -=\
    \ 1\n        } else if char == \" \" {\n            paren_counts.append(max_paren_count)\n\
    \            max_paren_count = 0\n            paren_count = 0\n        }\n   \
    \ }\n    paren_counts.append(max_paren_count)\n    return paren_counts\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var current_depth = 0\n        for char in group {\n            if char == \"\
    (\" {\n                current_depth += 1\n                if current_depth >\
    \ max_depth {\n                    max_depth = current_depth\n               \
    \ }\n            } else if char == \")\" {\n                current_depth -= 1\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var paren_stack: [Character] = []\n\
    \    var max_depth = 0\n    var depth = 0\n    for char in paren_string {\n  \
    \      if char == \"(\" {\n            paren_stack.append(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.popLast()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var curr_max = 0\n    var curr_count\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  curr_count += 1\n            curr_max = max(curr_max, curr_count)\n       \
    \ } else if char == \")\" {\n            curr_count -= 1\n        } else if char\
    \ == \" \" {\n            result.append(curr_max)\n            curr_max = 0\n\
    \            curr_count = 0\n        }\n    }\n    result.append(curr_max)\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var result\
    \ = [Int]()\n    var paren_array = Array(paren_string)\n    for paren in paren_array\
    \ {\n        if paren == \"(\" {\n            current_depth += 1\n           \
    \ if current_depth > max_depth {\n                max_depth = current_depth\n\
    \            }\n        } else if paren == \")\" {\n            current_depth\
    \ -= 1\n        } else if paren == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        }\n    }\n\
    \    result.append(max_depth)\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ current_nesting = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n            if current_nesting\
    \ == 0 {\n                nesting_levels.append(max_nesting)\n               \
    \ max_nesting = 0\n            }\n        }\n    }\n    return nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_level = 0\n \
    \       var level = 0\n        for paren in paren_group {\n            if paren\
    \ == \"(\" {\n                level += 1\n            } else if paren == \")\"\
    \ {\n                level -= 1\n            }\n            if level > max_level\
    \ {\n                max_level = level\n            }\n        }\n        result.append(max_level)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp55budq4n.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var depths = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depths.append(max_depth)\n            depth -= 1\n            max_depth\
    \ = 0\n        }\n    }\n    return depths\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8wy1z5dc.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \          if depth == 0 {\n                depths.append(max_depth)\n       \
    \         max_depth = 0\n            }\n        }\n    }\n    return depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var current_level = 0\n        var\
    \ max_level = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                current_level += 1\n            } else if char == \")\" {\n \
    \               current_level -= 1\n            }\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      }\n        max_nesting_levels.append(max_level)\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp05plxg_9.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n    \
    \    var current_nesting = 0\n        var max_nesting_level = 0\n        for paren\
    \ in paren_group {\n            if paren == \"(\" {\n                current_nesting\
    \ += 1\n            } else if paren == \")\" {\n                current_nesting\
    \ -= 1\n            }\n            if current_nesting > max_nesting_level {\n\
    \                max_nesting_level = current_nesting\n            }\n        }\n\
    \        max_nesting.append(max_nesting_level)\n    }\n    return max_nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptlhjedmn.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_nesting =\
    \ 0\n    var nesting_levels = [Int]()\n    for char in paren_string {\n      \
    \  if char == \"(\" {\n            paren_stack.push(char)\n            max_nesting\
    \ += 1\n        } else if char == \")\" {\n            paren_stack.pop()\n   \
    \         if paren_stack.isEmpty() {\n                nesting_levels.append(max_nesting)\n\
    \                max_nesting = 0\n            }\n        }\n    }\n    return\
    \ nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprcgbb2o9.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var level = 0\n     \
    \   var max_level = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                level += 1\n            } else if char == \")\"\
    \ {\n                level -= 1\n            }\n            if level > max_level\
    \ {\n                max_level = level\n            }\n        }\n        max_levels.append(max_level)\n\
    \    }\n    return max_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi1nh4hy7.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ current_nesting = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n            if current_nesting\
    \ == 0 {\n                nesting_levels.append(max_nesting)\n               \
    \ max_nesting = 0\n            }\n        }\n    }\n    return nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var paren_string_array = Array(paren_string)\n\
    \    for paren in paren_string_array {\n        if paren == \"(\" {\n        \
    \    current_nesting_level += 1\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        } else if paren == \")\" {\n            current_nesting_level -= 1\n\
    \        } else if paren == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl0u4462j.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_levels = [Int]()\n    var level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  level += 1\n            if level > max_level {\n                max_level =\
    \ level\n            }\n        } else if char == \")\" {\n            level -=\
    \ 1\n        } else if char == \" \" {\n            max_levels.append(max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    max_levels.append(max_level)\n\
    \    return max_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var stack = [Character]()\n     \
    \   var max_depth = 0\n        var current_depth = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                stack.append(char)\n    \
    \            current_depth += 1\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth\n                }\n      \
    \      } else if char == \")\" {\n                if stack.count > 0 {\n     \
    \               stack.removeLast()\n                    current_depth -= 1\n \
    \               }\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphe6hf75z.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                depth += 1\n                if depth > max_depth\
    \ {\n                    max_depth = depth\n                }\n            } else\
    \ if char == \")\" {\n                depth -= 1\n            }\n        }\n \
    \       result.append(max_depth)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp678j7tn7.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var output = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            output.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    output.append(max_depth)\n\
    \    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpazjmjifk.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_level = 0\n    var nesting_level = 0\n    var\
    \ max_nesting_levels = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            nesting_level += 1\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  } else if char == \")\" {\n            nesting_level -= 1\n            if nesting_level\
    \ == 0 {\n                max_nesting_levels.append(max_nesting_level)\n     \
    \           max_nesting_level = 0\n            }\n        }\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_level = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level_for_current_group = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            current_nesting_level += 1\n    \
    \        max_nesting_level_for_current_group = max(max_nesting_level_for_current_group,\
    \ current_nesting_level)\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_level.append(max_nesting_level_for_current_group)\n\
    \            max_nesting_level_for_current_group = 0\n        }\n    }\n    max_nesting_level.append(max_nesting_level_for_current_group)\n\
    \    return max_nesting_level\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                depth += 1\n            } else if char == \")\"\
    \ {\n                depth -= 1\n            }\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdj7hxs14.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var depths\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            depths.append(max_depth)\n            max_depth = 0\n       \
    \     current_depth = 0\n        }\n    }\n    depths.append(max_depth)\n    return\
    \ depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var current_depth = 0\n        for char in group {\n            if char == \"\
    (\" {\n                current_depth += 1\n                if current_depth >\
    \ max_depth {\n                    max_depth = current_depth\n               \
    \ }\n            } else if char == \")\" {\n                current_depth -= 1\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp7at3lbu5.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for group in paren_groups {\n        var\
    \ max_depth = 0\n        var current_depth = 0\n        for char in group {\n\
    \            if char == \"(\" {\n                current_depth += 1\n        \
    \    } else if char == \")\" {\n                current_depth -= 1\n         \
    \   }\n            if current_depth > max_depth {\n                max_depth =\
    \ current_depth\n            }\n        }\n        max_nesting.append(max_depth)\n\
    \    }\n    return max_nesting\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8mccipmw.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var results\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            results.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    results.append(max_nesting)\n\
    \    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl0u4462j.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var current_depth = 0\n    var max_depths = [Int]()\n    \n    for paren\
    \ in paren_string {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n\
    \            current_depth += 1\n            if current_depth > max_depth {\n\
    \                max_depth = current_depth\n            }\n        } else if paren\
    \ == \")\" {\n            paren_stack.pop()\n            current_depth -= 1\n\
    \            if paren_stack.isEmpty() {\n                max_depths.append(max_depth)\n\
    \                max_depth = 0\n                current_depth = 0\n          \
    \  }\n        }\n    }\n    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpgywh9u2n.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    var depth = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            depth += 1\n            max_depth = max(max_depth,\
    \ depth)\n            paren_stack.push(char)\n        } else if char == \")\"\
    \ {\n            depth -= 1\n            paren_stack.pop()\n        } else if\
    \ char == \" \" {\n            depths.append(max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpatf8v2vy.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var result = [Int]()\n    for group in paren_groups {\n        var max_level\
    \ = 0\n        var current_level = 0\n        for char in group.characters {\n\
    \            if char == \"(\" {\n                current_level += 1\n        \
    \    } else if char == \")\" {\n                current_level -= 1\n         \
    \   }\n            if current_level > max_level {\n                max_level =\
    \ current_level\n            }\n        }\n        result.append(max_level)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpivbdygux.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var stack = Stack<Character>()\n    var max_depth = 0\n    var\
    \ depths = [Int]()\n    var depth = 0\n    for c in paren_string {\n        if\
    \ c == \"(\" {\n            stack.push(c)\n            depth += 1\n          \
    \  if depth > max_depth {\n                max_depth = depth\n            }\n\
    \        } else if c == \")\" {\n            if stack.peek() == \"(\" {\n    \
    \            stack.pop()\n                depths.append(depth)\n             \
    \   depth -= 1\n            }\n        }\n    }\n    return depths\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpt_4nvl30.swift:6:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack: [Character] = []\n    var max_depth: [Int]\
    \ = []\n    var depth = 0\n    for c in paren_string {\n        if c == \"(\"\
    \ {\n            paren_stack.append(c)\n            depth += 1\n        } else\
    \ if c == \")\" {\n            paren_stack.removeLast()\n            depth -=\
    \ 1\n        } else if c == \" \" {\n            max_depth.append(depth)\n   \
    \         depth = 0\n        }\n    }\n    max_depth.append(depth)\n    return\
    \ max_depth\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp9bqdrli4/tmp9bqdrli4.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70b3cadc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70b39a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70b39a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70b39a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9bqdrli4                        0x00005575ca9137be <unavailable> + 6078

    5    libc.so.6                          0x00002b70b3e99460 __libc_start_main +
    245

    6    tmp9bqdrli4                        0x00005575ca9133d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_levels = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var current_level = 0\n    var max_level = 0\n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      current_level += 1\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if paren ==\
    \ \")\" {\n            paren_stack.pop()\n            current_level -= 1\n   \
    \     }\n    }\n    max_levels.append(max_level)\n    return max_levels\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp82wbglzd.swift:7:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_nesting_level = 0\n\
    \        var current_nesting_level = 0\n        for char in group {\n        \
    \    if char == \"(\" {\n                current_nesting_level += 1\n        \
    \    } else if char == \")\" {\n                current_nesting_level -= 1\n \
    \           }\n            if current_nesting_level > max_nesting_level {\n  \
    \              max_nesting_level = current_nesting_level\n            }\n    \
    \    }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc41ipdzr.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_level = 0\n       \
    \ var level = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                level += 1\n            } else if char == \")\" {\n         \
    \       level -= 1\n            }\n            if level > max_level {\n      \
    \          max_level = level\n            }\n        }\n        result.append(max_level)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2u5xdyml.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var current_depth = 0\n        for paren in paren_group {\n          \
    \  if paren == \"(\" {\n                current_depth += 1\n            } else\
    \ if paren == \")\" {\n                current_depth -= 1\n            }\n   \
    \         if current_depth > max_depth {\n                max_depth = current_depth\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpu2m09whl.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n            if current_nesting\
    \ == 0 {\n                max_nesting_list.append(max_nesting)\n             \
    \   max_nesting = 0\n            }\n        }\n    }\n    return max_nesting_list\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var nesting_level = 0\n        var max_nesting_level = 0\n        for\
    \ char in paren_group {\n            if char == \"(\" {\n                nesting_level\
    \ += 1\n            } else if char == \")\" {\n                nesting_level -=\
    \ 1\n            }\n            if nesting_level > max_nesting_level {\n     \
    \           max_nesting_level = nesting_level\n            }\n        }\n    \
    \    max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphoeyrntl.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_depth = 0\n    var current_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        } else if char == \")\" {\n            current_depth -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var level = 0\n     \
    \   var max_level = 0\n        for paren in paren_group {\n            if paren\
    \ == \"(\" {\n                level += 1\n            } else if paren == \")\"\
    \ {\n                level -= 1\n            }\n            if level > max_level\
    \ {\n                max_level = level\n            }\n        }\n        result.append(max_level)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6imcfom4.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_nesting = 0\n    var current_nesting = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_nesting += 1\n            if current_nesting > max_nesting {\n  \
    \              max_nesting = current_nesting\n            }\n        } else if\
    \ char == \")\" {\n            paren_stack.pop()\n            current_nesting\
    \ -= 1\n        }\n    }\n    result.append(max_nesting)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6gwifcq8.swift:7:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack: [Character] = []\n    var max_depth: [Int]\
    \ = []\n    var current_depth = 0\n    var current_max = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      current_depth += 1\n            if current_depth > current_max {\n    \
    \            current_max = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            paren_stack.popLast()\n            current_depth -=\
    \ 1\n        } else if char == \" \" {\n            max_depth.append(current_max)\n\
    \            current_max = 0\n            current_depth = 0\n        }\n    }\n\
    \    max_depth.append(current_max)\n    return max_depth\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                depth += 1\n            } else if char == \")\"\
    \ {\n                depth -= 1\n            }\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdj7hxs14.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var stack = [Character]()\n    var\
    \ max_depth = 0\n    var depth = 0\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            stack.append(char)\n            depth += 1\n  \
    \          max_depth = max(max_depth, depth)\n        } else if char == \")\"\
    \ {\n            stack.removeLast()\n            depth -= 1\n        } else if\
    \ char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var nesting_level = 0\n\
    \        var max_nesting_level = 0\n        for paren in paren_group {\n     \
    \       if paren == \"(\" {\n                nesting_level += 1\n            }\
    \ else if paren == \")\" {\n                nesting_level -= 1\n            }\n\
    \            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5w_ahopb.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var max_depth_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depth_list.append(max_depth)\n            max_depth = 0\n\
    \            current_depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = [Int]()\n    var depth = 0\n    var max_depth_so_far\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  depth += 1\n            if depth > max_depth_so_far {\n                max_depth_so_far\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            max_depth.append(max_depth_so_far)\n\
    \            max_depth_so_far = 0\n            depth = 0\n        }\n    }\n \
    \   max_depth.append(max_depth_so_far)\n    return max_depth\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var is_open_paren = false\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            is_open_paren = true\n\
    \            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            is_open_paren =\
    \ false\n            current_nesting_level -= 1\n        } else if char == \"\
    \ \" && !is_open_paren {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var paren_string_array = Array(paren_string)\n\
    \    for i in 0..<paren_string_array.count {\n        if paren_string_array[i]\
    \ == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if paren_string_array[i] == \")\" {\n         \
    \   current_nesting_level -= 1\n        } else if paren_string_array[i] == \"\
    \ \" {\n            max_nesting_levels.append(max_nesting_level)\n           \
    \ max_nesting_level = 0\n            current_nesting_level = 0\n        }\n  \
    \  }\n    max_nesting_levels.append(max_nesting_level)\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var level = 0\n        var max_level\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       level += 1\n            } else if char == \")\" {\n                level\
    \ -= 1\n            }\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        }\n        max_levels.append(max_level)\n  \
    \  }\n    return max_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpr4i5x689.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var max_depth_array\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depth_array.append(max_depth)\n            max_depth = 0\n\
    \            current_depth = 0\n        }\n    }\n    max_depth_array.append(max_depth)\n\
    \    return max_depth_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_nesting =\
    \ 0\n    var curr_nesting = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    curr_nesting += 1\n            if curr_nesting > max_nesting {\n        \
    \        max_nesting = curr_nesting\n            }\n        } else if char ==\
    \ \")\" {\n            paren_stack.pop()\n            curr_nesting -= 1\n    \
    \    } else if char == \" \" {\n            result.append(max_nesting)\n     \
    \       max_nesting = 0\n            curr_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpynvf4gg3.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ current_nesting = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            nesting_levels.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    nesting_levels.append(max_nesting)\n\
    \    return nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_array = [Int]()\n    var paren_stack = [Character]()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      current_depth += 1\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth\n            }\n        } else if char ==\
    \ \")\" {\n            if paren_stack.last == \"(\" {\n                paren_stack.removeLast()\n\
    \                current_depth -= 1\n            }\n        }\n    }\n    paren_array.append(max_depth)\n\
    \    return paren_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp5uxl54mu/tmp5uxl54mu.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b900492bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9004622b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9004622988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90046217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5uxl54mu                        0x0000563849a3187e <unavailable> + 6270

    5    libc.so.6                          0x00002b9004b17460 __libc_start_main +
    245

    6    tmp5uxl54mu                        0x0000563849a31499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      depth += 1\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        }\n        \n        if depth > max_depth {\n\
    \            max_depth = depth\n        }\n        \n        if paren == \" \"\
    \ {\n            max_depths.append(max_depth)\n            max_depth = 0\n   \
    \         depth = 0\n        }\n    }\n    \n    return max_depths\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpn1tq0wlh.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var nesting_level = 0\n        var max_nesting_level = 0\n        for\
    \ paren in paren_group {\n            if paren == \"(\" {\n                nesting_level\
    \ += 1\n            } else if paren == \")\" {\n                nesting_level\
    \ -= 1\n            }\n            if nesting_level > max_nesting_level {\n  \
    \              max_nesting_level = nesting_level\n            }\n        }\n \
    \       max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmhmuj9q6.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var stack = Stack<Character>()\n    var max_depth = 0\n    var\
    \ current_depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    if stack.isEmpty() {\n                result.append(0)\n                current_depth\
    \ = 0\n                max_depth = 0\n            } else {\n                stack.pop()\n\
    \                current_depth -= 1\n            }\n        } else if char ==\
    \ \" \" {\n            result.append(max_depth)\n            current_depth = 0\n\
    \            max_depth = 0\n        }\n    }\n    result.append(max_depth)\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0yn27jmx.swift:6:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_level = 0\n \
    \       var current_level = 0\n        for char in paren_group {\n           \
    \ if char == \"(\" {\n                current_level += 1\n                if current_level\
    \ > max_level {\n                    max_level = current_level\n             \
    \   }\n            } else if char == \")\" {\n                current_level -=\
    \ 1\n            }\n        }\n        result.append(max_level)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmtckbzsp.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_level = 0\n \
    \       var current_level = 0\n        for char in paren_group {\n           \
    \ if char == \"(\" {\n                current_level += 1\n                if current_level\
    \ > max_level {\n                    max_level = current_level\n             \
    \   }\n            } else if char == \")\" {\n                current_level -=\
    \ 1\n            }\n        }\n        result.append(max_level)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpn2yhnsul.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvfqhq747.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack: [Character] = []\n    var max_depth: [Int]\
    \ = []\n    var current_depth = 0\n    var current_group = 0\n    for char in\
    \ paren_string {\n        if char == \"(\" {\n            paren_stack.append(char)\n\
    \            current_depth += 1\n        } else if char == \")\" {\n         \
    \   paren_stack.popLast()\n            current_depth -= 1\n        } else if char\
    \ == \" \" {\n            max_depth.append(current_depth)\n            current_depth\
    \ = 0\n            current_group += 1\n        }\n    }\n    max_depth.append(current_depth)\n\
    \    return max_depth\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp8q_ucol0/tmp8q_ucol0.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af1b51d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af1b4ec9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af1b4ec9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af1b4ec87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8q_ucol0                        0x00005561ef36d7be <unavailable> + 6078

    5    libc.so.6                          0x00002af1b53be460 __libc_start_main +
    245

    6    tmp8q_ucol0                        0x00005561ef36d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            paren_stack.push(char)\n            max_depth += 1\n  \
    \      } else if char == \")\" {\n            paren_stack.pop()\n            max_depth\
    \ -= 1\n        } else if char == \" \" {\n            depths.append(max_depth)\n\
    \            max_depth = 0\n        }\n    }\n    depths.append(max_depth)\n \
    \   return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6fa13o9u.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        } else if char == \")\" {\n            current_depth -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    var current_depth = 0\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            current_depth -= 1\n       \
    \     if paren_stack.isEmpty() {\n                depths.append(max_depth)\n \
    \               max_depth = 0\n                current_depth = 0\n           \
    \ }\n        }\n    }\n    \n    return depths\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpbpw00nc9.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ current_nesting = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n            if current_nesting\
    \ == 0 {\n                nesting_levels.append(max_nesting)\n               \
    \ max_nesting = 0\n            }\n        }\n    }\n    return nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ current_nesting = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            nesting_levels.append(current_nesting)\n   \
    \         current_nesting -= 1\n        }\n    }\n    return nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp11dkzoy_/tmp11dkzoy_.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d263ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d260e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d260e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d260e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp11dkzoy_                        0x000055ccc03e568e <unavailable> + 5774

    5    libc.so.6                          0x00002b2d265d7460 __libc_start_main +
    245

    6    tmp11dkzoy_                        0x000055ccc03e52a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var current_level = 0\n        var\
    \ max_level = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                current_level += 1\n            } else if char == \")\" {\n \
    \               current_level -= 1\n            }\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      }\n        max_levels.append(max_level)\n    }\n    return max_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi9cy6kyx.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl0u4462j.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level: Int = 0\n   \
    \ var max_level: Int = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var result = [Int]()\n    for group in paren_groups {\n        var max_depth\
    \ = 0\n        var depth = 0\n        for char in group.characters {\n       \
    \     if char == \"(\" {\n                depth += 1\n            } else if char\
    \ == \")\" {\n                depth -= 1\n            }\n            if depth\
    \ > max_depth {\n                max_depth = depth\n            }\n        }\n\
    \        result.append(max_depth)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpiyafy6p_.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_levels = [Int]()\n    for paren_group in paren_groups {\n     \
    \   var level = 0\n        var max_level = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                level += 1\n           \
    \ } else if paren == \")\" {\n                level -= 1\n            }\n    \
    \        if level > max_level {\n                max_level = level\n         \
    \   }\n        }\n        max_levels.append(max_level)\n    }\n    return max_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6etkgpe7.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                depth += 1\n                if depth > max_depth\
    \ {\n                    max_depth = depth\n                }\n            } else\
    \ if char == \")\" {\n                depth -= 1\n            }\n        }\n \
    \       result.append(max_depth)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp678j7tn7.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var nesting_level = 0\n        var\
    \ max_nesting_level = 0\n        for char in group {\n            if char == \"\
    (\" {\n                nesting_level += 1\n            } else if char == \")\"\
    \ {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpb4mmf1gc.swift:7:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_levels = [Int]()\n    var current_level = 0\n    var\
    \ max_level = 0\n    for char in paren_string {\n        if char == \"(\" {\n\
    \            current_level += 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if char\
    \ == \")\" {\n            current_level -= 1\n        } else if char == \" \"\
    \ {\n            max_levels.append(max_level)\n            max_level = 0\n   \
    \         current_level = 0\n        }\n    }\n    max_levels.append(max_level)\n\
    \    return max_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var paren_string_array = Array(paren_string)\n\
    \    for char in paren_string_array {\n        if char == \"(\" {\n          \
    \  current_nesting_level += 1\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        } else if char == \")\" {\n            current_nesting_level -= 1\n \
    \       } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var count = 0\n        var\
    \ max_count = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                count += 1\n            } else if char == \")\" {\n         \
    \       count -= 1\n            }\n            if count > max_count {\n      \
    \          max_count = count\n            }\n        }\n        result.append(max_count)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpv3mkjh5r.swift:7:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    \n    return max_depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc9ym_3pn.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            current_depth -= 1\n       \
    \ } else if char == \" \" {\n            result.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8v92es42.swift:7:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var max_depths\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depths.append(max_depth)\n            max_depth = 0\n   \
    \         current_depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var nesting_level = 0\n        var max_nesting_level = 0\n        for\
    \ paren in paren_group {\n            if paren == \"(\" {\n                nesting_level\
    \ += 1\n            } else if paren == \")\" {\n                nesting_level\
    \ -= 1\n            }\n            if nesting_level > max_nesting_level {\n  \
    \              max_nesting_level = nesting_level\n            }\n        }\n \
    \       max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmhmuj9q6.swift:6:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for c in paren_string {\n        if c == \"(\" {\n            current_level\
    \ += 1\n            max_level = max(max_level, current_level)\n        } else\
    \ if c == \")\" {\n            current_level -= 1\n        } else if c == \" \"\
    \ {\n            result.append(max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result.append(max_level)\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_nesting =\
    \ 0\n    var curr_nesting = 0\n    var max_nesting_list = [Int]()\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            paren_stack.push(char)\n\
    \            curr_nesting += 1\n            if curr_nesting > max_nesting {\n\
    \                max_nesting = curr_nesting\n            }\n        } else if\
    \ char == \")\" {\n            paren_stack.pop()\n            curr_nesting -=\
    \ 1\n            if paren_stack.isEmpty() {\n                max_nesting_list.append(max_nesting)\n\
    \                max_nesting = 0\n                curr_nesting = 0\n         \
    \   }\n        }\n    }\n    return max_nesting_list\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpap7guf8o.swift:6:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009227
