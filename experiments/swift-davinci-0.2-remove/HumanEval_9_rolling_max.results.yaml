language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var max_numbers = [Int]()\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        max_numbers.append(max_so_far)\n    }\n    return\
    \ max_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abc7ca17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc7c70e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abc7c70e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abc7c70e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abc7c70dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abc7c50de83 <unavailable> + 188035

    6    tmpivggcvvk                        0x00005556c9430a52 <unavailable> + 6738

    7    tmpivggcvvk                        0x00005556c943052d <unavailable> + 5421

    8    libc.so.6                          0x00002abc7cc03460 __libc_start_main +
    245

    9    tmpivggcvvk                        0x00005556c9430239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc5ef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc5be8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8bc5be8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8bc5be813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8bc5be7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8bc59e7e83 <unavailable> + 188035

    6    tmpxfp6x26o                        0x000055920be05ab3 <unavailable> + 6835

    7    tmpxfp6x26o                        0x000055920be0556d <unavailable> + 5485

    8    libc.so.6                          0x00002b8bc60dd460 __libc_start_main +
    245

    9    tmpxfp6x26o                        0x000055920be05279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0731f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab072ee7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab072ee7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab072ee713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab072ee6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab072ce6e83 <unavailable> + 188035

    6    tmp13gj4pvx                        0x000055ef0b2a9a5f <unavailable> + 6751

    7    tmp13gj4pvx                        0x000055ef0b2a952d <unavailable> + 5421

    8    libc.so.6                          0x00002ab0733dc460 __libc_start_main +
    245

    9    tmp13gj4pvx                        0x000055ef0b2a9239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac10fb00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac10f7f7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac10f7f7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac10f7f713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac10f7f6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac10f5f6e83 <unavailable> + 188035

    6    tmp1vj5zaxc                        0x0000563031675af8 <unavailable> + 6904

    7    tmp1vj5zaxc                        0x00005630316755bd <unavailable> + 5565

    8    libc.so.6                          0x00002ac10fcec460 __libc_start_main +
    245

    9    tmp1vj5zaxc                        0x00005630316752c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e6624dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e65f44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8e65f44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8e65f4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8e65f43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8e65d43e83 <unavailable> + 188035

    6    tmp37b2ccrp                        0x000055dadbd20b23 <unavailable> + 6947

    7    tmp37b2ccrp                        0x000055dadbd205dd <unavailable> + 5597

    8    libc.so.6                          0x00002b8e66439460 __libc_start_main +
    245

    9    tmp37b2ccrp                        0x000055dadbd202e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4459343c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445903a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b445903a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b445903a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4459039bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4458e39e83 <unavailable> + 188035

    6    tmpr_4v89c4                        0x000055b69a11ca93 <unavailable> + 6803

    7    tmpr_4v89c4                        0x000055b69a11c54d <unavailable> + 5453

    8    libc.so.6                          0x00002b445952f460 __libc_start_main +
    245

    9    tmpr_4v89c4                        0x000055b69a11c259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e6624dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e65f44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8e65f44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8e65f4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8e65f43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8e65d43e83 <unavailable> + 188035

    6    tmp37b2ccrp                        0x000055dadbd20b23 <unavailable> + 6947

    7    tmp37b2ccrp                        0x000055dadbd205dd <unavailable> + 5597

    8    libc.so.6                          0x00002b8e66439460 __libc_start_main +
    245

    9    tmp37b2ccrp                        0x000055dadbd202e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af788a11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af788708561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af788708286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af78870813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af788707bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af788507e83 <unavailable> + 188035

    6    tmp59w3b8k7                        0x000056138d4c8ae8 <unavailable> + 6888

    7    tmp59w3b8k7                        0x000056138d4c85ad <unavailable> + 5549

    8    libc.so.6                          0x00002af788bfd460 __libc_start_main +
    245

    9    tmp59w3b8k7                        0x000056138d4c82b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f9d16ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f9ce65561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1f9ce65286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1f9ce6513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1f9ce64bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1f9cc64e83 <unavailable> + 188035

    6    tmpdetiqovu                        0x000055c2d3799a5f <unavailable> + 6751

    7    tmpdetiqovu                        0x000055c2d379952d <unavailable> + 5421

    8    libc.so.6                          0x00002b1f9d35a460 __libc_start_main +
    245

    9    tmpdetiqovu                        0x000055c2d3799239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab19c6e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab19c3dc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab19c3dc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab19c3dc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab19c3dbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab19c1dbe83 <unavailable> + 188035

    6    tmpddzpn_gy                        0x000055c9aa238a93 <unavailable> + 6803

    7    tmpddzpn_gy                        0x000055c9aa23854d <unavailable> + 5453

    8    libc.so.6                          0x00002ab19c8d1460 __libc_start_main +
    245

    9    tmpddzpn_gy                        0x000055c9aa238259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c45b13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c4580a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0c4580a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0c4580a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0c45809bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0c45609e83 <unavailable> + 188035

    6    tmpcv0hjulj                        0x000056537c008b23 <unavailable> + 6947

    7    tmpcv0hjulj                        0x000056537c0085dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0c45cff460 __libc_start_main +
    245

    9    tmpcv0hjulj                        0x000056537c0082e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f9d16ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f9ce65561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1f9ce65286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1f9ce6513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1f9ce64bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1f9cc64e83 <unavailable> + 188035

    6    tmpdetiqovu                        0x000055c2d3799a5f <unavailable> + 6751

    7    tmpdetiqovu                        0x000055c2d379952d <unavailable> + 5421

    8    libc.so.6                          0x00002b1f9d35a460 __libc_start_main +
    245

    9    tmpdetiqovu                        0x000055c2d3799239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8dc6acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8dc3a3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8dc3a3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8dc3a313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8dc3a2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8dc1a2e83 <unavailable> + 188035

    6    tmpi0_47wtl                        0x000055e4c7776b68 <unavailable> + 7016

    7    tmpi0_47wtl                        0x000055e4c777662d <unavailable> + 5677

    8    libc.so.6                          0x00002ae8dc898460 __libc_start_main +
    245

    9    tmpi0_47wtl                        0x000055e4c7776339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var current_max = 0\n   \
    \ for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ n in numbers {\n        if n > max_so_far {\n            max_so_far = n\n  \
    \      }\n        result.append(max_so_far)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var max_numbers = [Int]()\n \
    \   for number in numbers {\n        max_so_far = max(max_so_far, number)\n  \
    \      max_numbers.append(max_so_far)\n    }\n    return max_numbers\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4459343c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445903a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b445903a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b445903a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4459039bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4458e39e83 <unavailable> + 188035

    6    tmpr_4v89c4                        0x000055b69a11ca93 <unavailable> + 6803

    7    tmpr_4v89c4                        0x000055b69a11c54d <unavailable> + 5453

    8    libc.so.6                          0x00002b445952f460 __libc_start_main +
    245

    9    tmpr_4v89c4                        0x000055b69a11c259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max: Int = Int.min\n\
    \    for n in numbers {\n        if n > max {\n            max = n\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc5ef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc5be8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8bc5be8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8bc5be813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8bc5be7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8bc59e7e83 <unavailable> + 188035

    6    tmpxfp6x26o                        0x000055920be05ab3 <unavailable> + 6835

    7    tmpxfp6x26o                        0x000055920be0556d <unavailable> + 5485

    8    libc.so.6                          0x00002b8bc60dd460 __libc_start_main +
    245

    9    tmpxfp6x26o                        0x000055920be05279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var rolling_max = [Int]()\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        rolling_max.append(max_so_far)\n    }\n    return\
    \ rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b504d6cdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b504d3c4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b504d3c4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b504d3c413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b504d3c3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b504d1c3e83 <unavailable> + 188035

    6    tmpdwdoxmsq                        0x0000562e54160a52 <unavailable> + 6738

    7    tmpdwdoxmsq                        0x0000562e5416052d <unavailable> + 5421

    8    libc.so.6                          0x00002b504d8b9460 __libc_start_main +
    245

    9    tmpdwdoxmsq                        0x0000562e54160239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac10fb00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac10f7f7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac10f7f7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac10f7f713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac10f7f6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac10f5f6e83 <unavailable> + 188035

    6    tmp1vj5zaxc                        0x0000563031675af8 <unavailable> + 6904

    7    tmp1vj5zaxc                        0x00005630316755bd <unavailable> + 5565

    8    libc.so.6                          0x00002ac10fcec460 __libc_start_main +
    245

    9    tmp1vj5zaxc                        0x00005630316752c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc5ef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc5be8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8bc5be8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8bc5be813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8bc5be7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8bc59e7e83 <unavailable> + 188035

    6    tmpxfp6x26o                        0x000055920be05ab3 <unavailable> + 6835

    7    tmpxfp6x26o                        0x000055920be0556d <unavailable> + 5485

    8    libc.so.6                          0x00002b8bc60dd460 __libc_start_main +
    245

    9    tmpxfp6x26o                        0x000055920be05279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpahq_oe_z.swift:9:15: error: cannot call value of non-function type\
    \ 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c45b13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c4580a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0c4580a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0c4580a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0c45809bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0c45609e83 <unavailable> + 188035

    6    tmpcv0hjulj                        0x000056537c008b23 <unavailable> + 6947

    7    tmpcv0hjulj                        0x000056537c0085dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0c45cff460 __libc_start_main +
    245

    9    tmpcv0hjulj                        0x000056537c0082e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc5ef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc5be8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8bc5be8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8bc5be813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8bc5be7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8bc59e7e83 <unavailable> + 188035

    6    tmpxfp6x26o                        0x000055920be05ab3 <unavailable> + 6835

    7    tmpxfp6x26o                        0x000055920be0556d <unavailable> + 5485

    8    libc.so.6                          0x00002b8bc60dd460 __libc_start_main +
    245

    9    tmpxfp6x26o                        0x000055920be05279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f9d16ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f9ce65561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1f9ce65286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1f9ce6513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1f9ce64bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1f9cc64e83 <unavailable> + 188035

    6    tmpdetiqovu                        0x000055c2d3799a5f <unavailable> + 6751

    7    tmpdetiqovu                        0x000055c2d379952d <unavailable> + 5421

    8    libc.so.6                          0x00002b1f9d35a460 __libc_start_main +
    245

    9    tmpdetiqovu                        0x000055c2d3799239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab19c6e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab19c3dc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab19c3dc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab19c3dc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab19c3dbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab19c1dbe83 <unavailable> + 188035

    6    tmpddzpn_gy                        0x000055c9aa238a93 <unavailable> + 6803

    7    tmpddzpn_gy                        0x000055c9aa23854d <unavailable> + 5453

    8    libc.so.6                          0x00002ab19c8d1460 __libc_start_main +
    245

    9    tmpddzpn_gy                        0x000055c9aa238259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    result.append(current_max)\n    for i in 1..<numbers.count {\n        current_max\
    \ = max(current_max, numbers[i])\n        result.append(current_max)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4756e2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4756b23561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4756b23286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4756b2313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4756b22bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4756922e83 <unavailable> + 188035

    6    tmpijjb2rkh                        0x000055d9bc5aeb68 <unavailable> + 7016

    7    tmpijjb2rkh                        0x000055d9bc5ae62d <unavailable> + 5677

    8    libc.so.6                          0x00002b4757018460 __libc_start_main +
    245

    9    tmpijjb2rkh                        0x000055d9bc5ae339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_element: Int = numbers[0]\n\
    \    for number in numbers {\n        if number > max_element {\n            max_element\
    \ = number\n        }\n        result.append(max_element)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f50617c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f5030e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f5030e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f5030e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f5030dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f5010de83 <unavailable> + 188035

    6    tmpaq134699                        0x000055c4b9e03a1a <unavailable> + 6682

    7    tmpaq134699                        0x000055c4b9e034dd <unavailable> + 5341

    8    libc.so.6                          0x00002b8f50803460 __libc_start_main +
    245

    9    tmpaq134699                        0x000055c4b9e031e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n\
    \    result.append(max_value)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_value {\n            max_value = numbers[i]\n        }\n        result.append(max_value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7eb3659c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7eb3350561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7eb3350286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7eb335013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7eb334fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7eb314fe83 <unavailable> + 188035

    6    tmp_kzc6jcs                        0x0000565508ec9ae8 <unavailable> + 6888

    7    tmp_kzc6jcs                        0x0000565508ec95ad <unavailable> + 5549

    8    libc.so.6                          0x00002b7eb3845460 __libc_start_main +
    245

    9    tmp_kzc6jcs                        0x0000565508ec92b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var max_so_far_index\
    \ = 0\n    var result = [Int]()\n    for (index, number) in numbers.enumerated()\
    \ {\n        if number > max_so_far {\n            max_so_far = number\n     \
    \       max_so_far_index = index\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b170f64fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b170f346561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b170f346286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b170f34613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b170f345bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b170f145e83 <unavailable> + 188035

    6    tmpcdiim77y                        0x000055c873facb28 <unavailable> + 6952

    7    tmpcdiim77y                        0x000055c873fac5dd <unavailable> + 5597

    8    libc.so.6                          0x00002b170f83b460 __libc_start_main +
    245

    9    tmpcdiim77y                        0x000055c873fac2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac10fb00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac10f7f7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac10f7f7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac10f7f713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac10f7f6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac10f5f6e83 <unavailable> + 188035

    6    tmp1vj5zaxc                        0x0000563031675af8 <unavailable> + 6904

    7    tmp1vj5zaxc                        0x00005630316755bd <unavailable> + 5565

    8    libc.so.6                          0x00002ac10fcec460 __libc_start_main +
    245

    9    tmp1vj5zaxc                        0x00005630316752c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc5ef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc5be8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8bc5be8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8bc5be813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8bc5be7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8bc59e7e83 <unavailable> + 188035

    6    tmpxfp6x26o                        0x000055920be05ab3 <unavailable> + 6835

    7    tmpxfp6x26o                        0x000055920be0556d <unavailable> + 5485

    8    libc.so.6                          0x00002b8bc60dd460 __libc_start_main +
    245

    9    tmpxfp6x26o                        0x000055920be05279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae300788c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae30047f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae30047f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae30047f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae30047ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae30027ee83 <unavailable> + 188035

    6    tmpf3u4khsn                        0x000055eb4c842ae8 <unavailable> + 6888

    7    tmpf3u4khsn                        0x000055eb4c8425ad <unavailable> + 5549

    8    libc.so.6                          0x00002ae300974460 __libc_start_main +
    245

    9    tmpf3u4khsn                        0x000055eb4c8422b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_value = numbers[0]\n\
    \    result.append(max_value)\n    for i in 1..<numbers.count {\n        max_value\
    \ = max(max_value, numbers[i])\n        result.append(max_value)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aad0909cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad08d93561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aad08d93286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aad08d9313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aad08d92bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aad08b92e83 <unavailable> + 188035

    6    tmprlx3zpn2                        0x000055b18fe97b23 <unavailable> + 6947

    7    tmprlx3zpn2                        0x000055b18fe975dd <unavailable> + 5597

    8    libc.so.6                          0x00002aad09288460 __libc_start_main +
    245

    9    tmprlx3zpn2                        0x000055b18fe972e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        if numbers[i] > max {\n            max = numbers[i]\n\
    \        }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac32d130c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac32ce27561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac32ce27286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac32ce2713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac32ce26bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac32cc26e83 <unavailable> + 188035

    6    tmp2otzlcgr                        0x00005589b2d2bae8 <unavailable> + 6888

    7    tmp2otzlcgr                        0x00005589b2d2b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ac32d31c460 __libc_start_main +
    245

    9    tmp2otzlcgr                        0x00005589b2d2b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e6624dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e65f44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8e65f44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8e65f4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8e65f43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8e65d43e83 <unavailable> + 188035

    6    tmp37b2ccrp                        0x000055dadbd20b23 <unavailable> + 6947

    7    tmp37b2ccrp                        0x000055dadbd205dd <unavailable> + 5597

    8    libc.so.6                          0x00002b8e66439460 __libc_start_main +
    245

    9    tmp37b2ccrp                        0x000055dadbd202e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e6624dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e65f44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8e65f44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8e65f4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8e65f43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8e65d43e83 <unavailable> + 188035

    6    tmp37b2ccrp                        0x000055dadbd20b23 <unavailable> + 6947

    7    tmp37b2ccrp                        0x000055dadbd205dd <unavailable> + 5597

    8    libc.so.6                          0x00002b8e66439460 __libc_start_main +
    245

    9    tmp37b2ccrp                        0x000055dadbd202e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae300788c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae30047f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae30047f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae30047f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae30047ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae30027ee83 <unavailable> + 188035

    6    tmpf3u4khsn                        0x000055eb4c842ae8 <unavailable> + 6888

    7    tmpf3u4khsn                        0x000055eb4c8425ad <unavailable> + 5549

    8    libc.so.6                          0x00002ae300974460 __libc_start_main +
    245

    9    tmpf3u4khsn                        0x000055eb4c8422b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e6624dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e65f44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8e65f44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8e65f4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8e65f43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8e65d43e83 <unavailable> + 188035

    6    tmp37b2ccrp                        0x000055dadbd20b23 <unavailable> + 6947

    7    tmp37b2ccrp                        0x000055dadbd205dd <unavailable> + 5597

    8    libc.so.6                          0x00002b8e66439460 __libc_start_main +
    245

    9    tmp37b2ccrp                        0x000055dadbd202e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3b23a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3b209e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab3b209e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab3b209e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab3b209dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab3b1e9de83 <unavailable> + 188035

    6    tmp553svn4y                        0x0000560f28123a1a <unavailable> + 6682

    7    tmp553svn4y                        0x0000560f281234dd <unavailable> + 5341

    8    libc.so.6                          0x00002ab3b2593460 __libc_start_main +
    245

    9    tmp553svn4y                        0x0000560f281231e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e6624dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e65f44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8e65f44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8e65f4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8e65f43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8e65d43e83 <unavailable> + 188035

    6    tmp37b2ccrp                        0x000055dadbd20b23 <unavailable> + 6947

    7    tmp37b2ccrp                        0x000055dadbd205dd <unavailable> + 5597

    8    libc.so.6                          0x00002b8e66439460 __libc_start_main +
    245

    9    tmp37b2ccrp                        0x000055dadbd202e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for n in numbers {\n        if n > max_so_far {\n            max_so_far =\
    \ n\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpahq_oe_z.swift:9:15: error: cannot call value of non-function type\
    \ 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var rolling_max = [Int]()\n \
    \   for number in numbers {\n        max_so_far = max(max_so_far, number)\n  \
    \      rolling_max.append(max_so_far)\n    }\n    return rolling_max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f9d16ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f9ce65561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1f9ce65286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1f9ce6513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1f9ce64bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1f9cc64e83 <unavailable> + 188035

    6    tmpdetiqovu                        0x000055c2d3799a5f <unavailable> + 6751

    7    tmpdetiqovu                        0x000055c2d379952d <unavailable> + 5421

    8    libc.so.6                          0x00002b1f9d35a460 __libc_start_main +
    245

    9    tmpdetiqovu                        0x000055c2d3799239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f9d16ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f9ce65561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1f9ce65286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1f9ce6513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1f9ce64bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1f9cc64e83 <unavailable> + 188035

    6    tmpdetiqovu                        0x000055c2d3799a5f <unavailable> + 6751

    7    tmpdetiqovu                        0x000055c2d379952d <unavailable> + 5421

    8    libc.so.6                          0x00002b1f9d35a460 __libc_start_main +
    245

    9    tmpdetiqovu                        0x000055c2d3799239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc5ef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc5be8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8bc5be8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8bc5be813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8bc5be7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8bc59e7e83 <unavailable> + 188035

    6    tmpxfp6x26o                        0x000055920be05ab3 <unavailable> + 6835

    7    tmpxfp6x26o                        0x000055920be0556d <unavailable> + 5485

    8    libc.so.6                          0x00002b8bc60dd460 __libc_start_main +
    245

    9    tmpxfp6x26o                        0x000055920be05279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4459343c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445903a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b445903a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b445903a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4459039bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4458e39e83 <unavailable> + 188035

    6    tmpr_4v89c4                        0x000055b69a11ca93 <unavailable> + 6803

    7    tmpr_4v89c4                        0x000055b69a11c54d <unavailable> + 5453

    8    libc.so.6                          0x00002b445952f460 __libc_start_main +
    245

    9    tmpr_4v89c4                        0x000055b69a11c259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af35949cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af359193561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af359193286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af35919313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af359192bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af358f92e83 <unavailable> + 188035

    6    tmpwv9yaxh_                        0x000055a256c54a5f <unavailable> + 6751

    7    tmpwv9yaxh_                        0x000055a256c5452d <unavailable> + 5421

    8    libc.so.6                          0x00002af359688460 __libc_start_main +
    245

    9    tmpwv9yaxh_                        0x000055a256c54239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3b23a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3b209e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab3b209e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab3b209e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab3b209dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab3b1e9de83 <unavailable> + 188035

    6    tmp553svn4y                        0x0000560f28123a1a <unavailable> + 6682

    7    tmp553svn4y                        0x0000560f281234dd <unavailable> + 5341

    8    libc.so.6                          0x00002ab3b2593460 __libc_start_main +
    245

    9    tmp553svn4y                        0x0000560f281231e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae300788c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae30047f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae30047f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae30047f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae30047ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae30027ee83 <unavailable> + 188035

    6    tmpf3u4khsn                        0x000055eb4c842ae8 <unavailable> + 6888

    7    tmpf3u4khsn                        0x000055eb4c8425ad <unavailable> + 5549

    8    libc.so.6                          0x00002ae300974460 __libc_start_main +
    245

    9    tmpf3u4khsn                        0x000055eb4c8422b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for n in numbers {\n        if n > max_so_far {\n            max_so_far =\
    \ n\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af788a11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af788708561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af788708286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af78870813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af788707bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af788507e83 <unavailable> + 188035

    6    tmp59w3b8k7                        0x000056138d4c8ae8 <unavailable> + 6888

    7    tmp59w3b8k7                        0x000056138d4c85ad <unavailable> + 5549

    8    libc.so.6                          0x00002af788bfd460 __libc_start_main +
    245

    9    tmp59w3b8k7                        0x000056138d4c82b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fe5b02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fe57f9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1fe57f9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1fe57f913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1fe57f8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1fe55f8e83 <unavailable> + 188035

    6    tmpc923k0m3                        0x000055891be17ae8 <unavailable> + 6888

    7    tmpc923k0m3                        0x000055891be175ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1fe5cee460 __libc_start_main +
    245

    9    tmpc923k0m3                        0x000055891be172b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c45b13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c4580a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0c4580a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0c4580a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0c45809bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0c45609e83 <unavailable> + 188035

    6    tmpcv0hjulj                        0x000056537c008b23 <unavailable> + 6947

    7    tmpcv0hjulj                        0x000056537c0085dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0c45cff460 __libc_start_main +
    245

    9    tmpcv0hjulj                        0x000056537c0082e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fe5b02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fe57f9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1fe57f9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1fe57f913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1fe57f8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1fe55f8e83 <unavailable> + 188035

    6    tmpc923k0m3                        0x000055891be17ae8 <unavailable> + 6888

    7    tmpc923k0m3                        0x000055891be175ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1fe5cee460 __libc_start_main +
    245

    9    tmpc923k0m3                        0x000055891be172b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c45b13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c4580a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0c4580a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0c4580a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0c45809bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0c45609e83 <unavailable> + 188035

    6    tmpcv0hjulj                        0x000056537c008b23 <unavailable> + 6947

    7    tmpcv0hjulj                        0x000056537c0085dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0c45cff460 __libc_start_main +
    245

    9    tmpcv0hjulj                        0x000056537c0082e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae300788c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae30047f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae30047f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae30047f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae30047ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae30027ee83 <unavailable> + 188035

    6    tmpf3u4khsn                        0x000055eb4c842ae8 <unavailable> + 6888

    7    tmpf3u4khsn                        0x000055eb4c8425ad <unavailable> + 5549

    8    libc.so.6                          0x00002ae300974460 __libc_start_main +
    245

    9    tmpf3u4khsn                        0x000055eb4c8422b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_value = numbers[0]\n\
    \    for number in numbers {\n        max_value = max(max_value, number)\n   \
    \     result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3e57a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3e54a0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba3e54a0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba3e54a013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba3e549fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba3e529fe83 <unavailable> + 188035

    6    tmpavuxkazd                        0x000055b877f3fab3 <unavailable> + 6835

    7    tmpavuxkazd                        0x000055b877f3f56d <unavailable> + 5485

    8    libc.so.6                          0x00002ba3e5995460 __libc_start_main +
    245

    9    tmpavuxkazd                        0x000055b877f3f279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0731f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab072ee7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab072ee7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab072ee713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab072ee6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab072ce6e83 <unavailable> + 188035

    6    tmp13gj4pvx                        0x000055ef0b2a9a5f <unavailable> + 6751

    7    tmp13gj4pvx                        0x000055ef0b2a952d <unavailable> + 5421

    8    libc.so.6                          0x00002ab0733dc460 __libc_start_main +
    245

    9    tmp13gj4pvx                        0x000055ef0b2a9239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3b23a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3b209e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab3b209e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab3b209e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab3b209dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab3b1e9de83 <unavailable> + 188035

    6    tmp553svn4y                        0x0000560f28123a1a <unavailable> + 6682

    7    tmp553svn4y                        0x0000560f281234dd <unavailable> + 5341

    8    libc.so.6                          0x00002ab3b2593460 __libc_start_main +
    245

    9    tmp553svn4y                        0x0000560f281231e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for n in numbers {\n        max_so_far = max(max_so_far, n)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n\
    \    result.append(max_value)\n    for i in 1..<numbers.count {\n        max_value\
    \ = max(max_value, numbers[i])\n        result.append(max_value)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b61a16b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61a13b0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b61a13b0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b61a13b013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b61a13afbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b61a11afe83 <unavailable> + 188035

    6    tmpgmjg8zyw                        0x00005652f127db68 <unavailable> + 7016

    7    tmpgmjg8zyw                        0x00005652f127d62d <unavailable> + 5677

    8    libc.so.6                          0x00002b61a18a5460 __libc_start_main +
    245

    9    tmpgmjg8zyw                        0x00005652f127d339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af35949cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af359193561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af359193286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af35919313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af359192bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af358f92e83 <unavailable> + 188035

    6    tmpwv9yaxh_                        0x000055a256c54a5f <unavailable> + 6751

    7    tmpwv9yaxh_                        0x000055a256c5452d <unavailable> + 5421

    8    libc.so.6                          0x00002af359688460 __libc_start_main +
    245

    9    tmpwv9yaxh_                        0x000055a256c54239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af35949cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af359193561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af359193286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af35919313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af359192bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af358f92e83 <unavailable> + 188035

    6    tmpwv9yaxh_                        0x000055a256c54a5f <unavailable> + 6751

    7    tmpwv9yaxh_                        0x000055a256c5452d <unavailable> + 5421

    8    libc.so.6                          0x00002af359688460 __libc_start_main +
    245

    9    tmpwv9yaxh_                        0x000055a256c54239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0731f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab072ee7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab072ee7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab072ee713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab072ee6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab072ce6e83 <unavailable> + 188035

    6    tmp13gj4pvx                        0x000055ef0b2a9a5f <unavailable> + 6751

    7    tmp13gj4pvx                        0x000055ef0b2a952d <unavailable> + 5421

    8    libc.so.6                          0x00002ab0733dc460 __libc_start_main +
    245

    9    tmp13gj4pvx                        0x000055ef0b2a9239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fe5b02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fe57f9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1fe57f9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1fe57f913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1fe57f8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1fe55f8e83 <unavailable> + 188035

    6    tmpc923k0m3                        0x000055891be17ae8 <unavailable> + 6888

    7    tmpc923k0m3                        0x000055891be175ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1fe5cee460 __libc_start_main +
    245

    9    tmpc923k0m3                        0x000055891be172b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4459343c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445903a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b445903a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b445903a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4459039bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4458e39e83 <unavailable> + 188035

    6    tmpr_4v89c4                        0x000055b69a11ca93 <unavailable> + 6803

    7    tmpr_4v89c4                        0x000055b69a11c54d <unavailable> + 5453

    8    libc.so.6                          0x00002b445952f460 __libc_start_main +
    245

    9    tmpr_4v89c4                        0x000055b69a11c259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0731f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab072ee7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab072ee7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab072ee713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab072ee6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab072ce6e83 <unavailable> + 188035

    6    tmp13gj4pvx                        0x000055ef0b2a9a5f <unavailable> + 6751

    7    tmp13gj4pvx                        0x000055ef0b2a952d <unavailable> + 5421

    8    libc.so.6                          0x00002ab0733dc460 __libc_start_main +
    245

    9    tmp13gj4pvx                        0x000055ef0b2a9239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fe5b02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fe57f9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1fe57f9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1fe57f913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1fe57f8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1fe55f8e83 <unavailable> + 188035

    6    tmpc923k0m3                        0x000055891be17ae8 <unavailable> + 6888

    7    tmpc923k0m3                        0x000055891be175ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1fe5cee460 __libc_start_main +
    245

    9    tmpc923k0m3                        0x000055891be172b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae300788c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae30047f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae30047f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae30047f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae30047ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae30027ee83 <unavailable> + 188035

    6    tmpf3u4khsn                        0x000055eb4c842ae8 <unavailable> + 6888

    7    tmpf3u4khsn                        0x000055eb4c8425ad <unavailable> + 5549

    8    libc.so.6                          0x00002ae300974460 __libc_start_main +
    245

    9    tmpf3u4khsn                        0x000055eb4c8422b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0731f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab072ee7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab072ee7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab072ee713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab072ee6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab072ce6e83 <unavailable> + 188035

    6    tmp13gj4pvx                        0x000055ef0b2a9a5f <unavailable> + 6751

    7    tmp13gj4pvx                        0x000055ef0b2a952d <unavailable> + 5421

    8    libc.so.6                          0x00002ab0733dc460 __libc_start_main +
    245

    9    tmp13gj4pvx                        0x000055ef0b2a9239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n \
    \   for number in numbers {\n        if number > max_value {\n            max_value\
    \ = number\n        }\n        result.append(max_value)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4479fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc44496561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acc44496286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acc4449613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acc44495bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acc44295e83 <unavailable> + 188035

    6    tmpgf10ulzz                        0x0000564038b73ad8 <unavailable> + 6872

    7    tmpgf10ulzz                        0x0000564038b735ad <unavailable> + 5549

    8    libc.so.6                          0x00002acc4498b460 __libc_start_main +
    245

    9    tmpgf10ulzz                        0x0000564038b732b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad865fe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad865cdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad865cdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad865cdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad865cdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad865adee83 <unavailable> + 188035

    6    tmp0cfh3vdg                        0x000055d13b98ab68 <unavailable> + 7016

    7    tmp0cfh3vdg                        0x000055d13b98a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad8661d4460 __libc_start_main +
    245

    9    tmp0cfh3vdg                        0x000055d13b98a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979906
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var max_so_far = numbers[0]\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3b23a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3b209e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab3b209e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab3b209e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab3b209dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab3b1e9de83 <unavailable> + 188035

    6    tmp553svn4y                        0x0000560f28123a1a <unavailable> + 6682

    7    tmp553svn4y                        0x0000560f281234dd <unavailable> + 5341

    8    libc.so.6                          0x00002ab3b2593460 __libc_start_main +
    245

    9    tmp553svn4y                        0x0000560f281231e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979907
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7874af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78747ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78747ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78747ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78747eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78745eee83 <unavailable> + 188035

    6    tmpmd0h9hlr                        0x000055a10fd15b58 <unavailable> + 7000

    7    tmpmd0h9hlr                        0x000055a10fd1562d <unavailable> + 5677

    8    libc.so.6                          0x00002b7874ce4460 __libc_start_main +
    245

    9    tmpmd0h9hlr                        0x000055a10fd15339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979906
