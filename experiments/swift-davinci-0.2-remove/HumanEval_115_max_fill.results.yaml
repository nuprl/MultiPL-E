language: swift
name: HumanEval_115_max_fill
results:
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n\
    \            sum += col\n        }\n        result += sum / capacity\n       \
    \ if sum % capacity > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    grid[i][j] = 0\n     \
    \               filled = true\n                }\n            }\n        }\n \
    \       if !filled {\n            break\n        }\n        count += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbx9avjcn/tmpbx9avjcn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ad6e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ad6b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ad6b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ad6b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbx9avjcn                        0x000055eabc072706 <unavailable> + 5894

    5    libc.so.6                          0x00002b9ad7014460 __libc_start_main +
    245

    6    tmpbx9avjcn                        0x000055eabc072299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    grid[i][j] = 0\n     \
    \               filled = true\n                }\n            }\n        }\n \
    \       if !filled {\n            break\n        }\n        count += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbx9avjcn/tmpbx9avjcn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ad6e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ad6b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ad6b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ad6b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbx9avjcn                        0x000055eabc072706 <unavailable> + 5894

    5    libc.so.6                          0x00002b9ad7014460 __libc_start_main +
    245

    6    tmpbx9avjcn                        0x000055eabc072299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row_max = 0\n    for row in grid {\n        row_max = 0\n     \
    \   for col in row {\n            if col > row_max {\n                row_max\
    \ = col\n            }\n        }\n        result += row_max\n    }\n    return\
    \ result / capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxp3rjnhd/tmpxp3rjnhd.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68b8b5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b68b8856b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b68b8856988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b68b88557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxp3rjnhd                        0x00005592333b75d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b68b8d4b460 __libc_start_main +
    245

    6    tmpxp3rjnhd                        0x00005592333b7169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        var row = grid[i]\n\
    \        var sum = 0\n        for j in 0..<row.count {\n            sum += row[j]\n\
    \        }\n        if sum > capacity {\n            count += 1\n            for\
    \ j in 0..<row.count {\n                if row[j] == 1 {\n                   \
    \ row[j] = 0\n                }\n            }\n        }\n        grid[i] = row\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkdshcfcn/tmpkdshcfcn.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d587ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d584d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d584d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d584d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdshcfcn                        0x000055736b00e706 <unavailable> + 5894

    5    libc.so.6                          0x00002b4d589c9460 __libc_start_main +
    245

    6    tmpkdshcfcn                        0x000055736b00e299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill_bucket(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpacpn5__w.swift:24:17: error: cannot find 'fill_bucket' in scope\n\
    \                fill_bucket(grid: &grid, i: i, j: j, capacity: capacity)\n  \
    \              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for row in 0..<grid.count {\n        for col in\
    \ 0..<grid[row].count {\n            if grid[row][col] == 1 {\n              \
    \  grid[row][col] = 0\n                count += 1\n                fill_bucket(grid:\
    \ &grid, row: row, col: col, capacity: capacity)\n            }\n        }\n \
    \   }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1yvqgiat.swift:25:17: error: cannot find 'fill_bucket' in scope\n\
    \                fill_bucket(grid: &grid, row: row, col: col, capacity: capacity)\n\
    \                ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for i in 0..<row.count {\n            if row[i] == 1 {\n               \
    \ max_fill += 1\n            } else {\n                if max_fill > 0 {\n   \
    \                 result += 1\n                    max_fill = 0\n            \
    \    }\n            }\n        }\n        if max_fill > 0 {\n            result\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpe5_op05f/tmpe5_op05f.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade85d39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade85a30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade85a30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade85a2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe5_op05f                        0x000055c4163a6776 <unavailable> + 6006

    5    libc.so.6                          0x00002ade85f25460 __libc_start_main +
    245

    6    tmpe5_op05f                        0x000055c4163a6309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    grid[i][j] = 0\n     \
    \               filled = true\n                }\n            }\n        }\n \
    \       if filled {\n            count += 1\n        } else {\n            break\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpf9n5yu80/tmpf9n5yu80.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14725b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14722aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14722ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14722ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf9n5yu80                        0x0000565477fc6706 <unavailable> + 5894

    5    libc.so.6                          0x00002b14727a3460 __libc_start_main +
    245

    6    tmpf9n5yu80                        0x0000565477fc6299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for i in 0..<row.count {\n            if row[i] == 1 {\n               \
    \ max_fill += 1\n            } else {\n                max_fill = 0\n        \
    \    }\n            if max_fill == capacity {\n                result += 1\n \
    \               max_fill = 0\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpunj3ym5g/tmpunj3ym5g.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14a51a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14a4e9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14a4e9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14a4e9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpunj3ym5g                        0x000055ac9d592947 <unavailable> + 6471

    5    libc.so.6                          0x00002b14a5394460 __libc_start_main +
    245

    6    tmpunj3ym5g                        0x000055ac9d592309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var water =\
    \ 0\n    var count = 0\n    for row in grid {\n        for cell in row {\n   \
    \         if cell == 1 {\n                water += 1\n            }\n        }\n\
    \    }\n    while water > 0 {\n        count += 1\n        water -= capacity\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpc7zqtbox/tmpc7zqtbox.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b51d57fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51d54f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51d54f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51d54f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc7zqtbox                        0x0000562a5b693b44 <unavailable> + 6980

    5    libc.so.6                          0x00002b51d59e7460 __libc_start_main +
    245

    6    tmpc7zqtbox                        0x0000562a5b6930d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for i in 0..<grid.count {\n        var sum = 0\n        for j in 0..<grid[i].count\
    \ {\n            sum += grid[i][j]\n        }\n        result += sum / capacity\n\
    \        if sum % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for col in row {\n            if col == 1 {\n                max_fill +=\
    \ 1\n            }\n        }\n        result += max_fill / capacity\n       \
    \ if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row_max = Array(repeating: 0, count: grid[0].count)\n    for row\
    \ in grid {\n        for col in 0..<row.count {\n            if row[col] == 1\
    \ {\n                row_max[col] += 1\n            }\n        }\n    }\n    for\
    \ col in 0..<row_max.count {\n        result += row_max[col] / capacity\n    \
    \    if row_max[col] % capacity != 0 {\n            result += 1\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1862az34/tmp1862az34.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2d89d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2d86ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2d86ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2d86cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1862az34                        0x000055f2ec1e1a57 <unavailable> + 6743

    5    libc.so.6                          0x00002ac2d8bc3460 __libc_start_main +
    245

    6    tmp1862az34                        0x000055f2ec1e1419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    var row_max = [Int](repeating: 0, count: grid.count)\n\
    \    for row in 0..<grid.count {\n        for col in 0..<grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                row_max[row] = col\n   \
    \         }\n        }\n    }\n    var max_col = row_max.max()!\n    while max_col\
    \ > 0 {\n        for row in 0..<grid.count {\n            if row_max[row] > 0\
    \ {\n                row_max[row] -= 1\n            }\n        }\n        max_col\
    \ -= 1\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdsu6ykpe/tmpdsu6ykpe.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c13d60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c13a57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c13a57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c13a567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdsu6ykpe                        0x000055d09f9367b6 <unavailable> + 6070

    5    libc.so.6                          0x00002b3c13f4c460 __libc_start_main +
    245

    6    tmpdsu6ykpe                        0x000055d09f936349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for col in row {\n \
    \           if col == 1 {\n                max_fill += 1\n            }\n    \
    \    }\n    }\n    while max_fill > 0 {\n        for row in grid {\n         \
    \   for col in row {\n                if col == 1 {\n                    max_fill\
    \ -= 1\n                }\n            }\n        }\n        count += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjiid2ycv/tmpjiid2ycv.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3cc7e2bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3cc7b22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3cc7b22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3cc7b217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjiid2ycv                        0x0000562686096546 <unavailable> + 5446

    5    libc.so.6                          0x00002b3cc8017460 __libc_start_main +
    245

    6    tmpjiid2ycv                        0x00005626860960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var i = 0\n    while i < grid.count {\n        var j = 0\n        var\
    \ current_capacity = capacity\n        while j < grid[i].count {\n           \
    \ if grid[i][j] == 1 {\n                if current_capacity > 0 {\n          \
    \          current_capacity -= 1\n                } else {\n                 \
    \   current_capacity = capacity\n                    result += 1\n           \
    \     }\n            }\n            j += 1\n        }\n        i += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpt3akbj2g/tmpt3akbj2g.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf2af19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf2ac10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf2ac10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf2ac0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt3akbj2g                        0x0000560c0e6544d6 <unavailable> + 5334

    5    libc.so.6                          0x00002acf2b105460 __libc_start_main +
    245

    6    tmpt3akbj2g                        0x0000560c0e654069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var row = 0\n    var col = 0\n    while row < grid.count {\n        col\
    \ = 0\n        while col < grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                count += 1\n                var row_ = row\n          \
    \      var col_ = col\n                while row_ < grid.count && col_ < grid[row_].count\
    \ && grid[row_][col_] == 1 {\n                    grid[row_][col_] = 0\n     \
    \               row_ += 1\n                    col_ += 1\n                }\n\
    \            }\n            col += 1\n        }\n        row += 1\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpagxc4xbb.swift:29:31: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[row_][col_] = 0\n            \
    \        ~~~~      ^\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            if well == 1 {\n                fill += 1\n            }\n      \
    \  }\n        if fill > max_fill {\n            max_fill = fill\n        }\n \
    \   }\n    return max_fill / capacity + (max_fill % capacity > 0 ? 1 : 0)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp65k2_p59/tmp65k2_p59.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b369db0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b369d806b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b369d806988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b369d8057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp65k2_p59                        0x0000559f938685d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b369dcfb460 __libc_start_main +
    245

    6    tmp65k2_p59                        0x0000559f93868169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    while true {\n        var filled = false\n     \
    \   for i in 0..<grid.count {\n            var row = grid[i]\n            if row.contains(1)\
    \ {\n                filled = true\n                row = row.map { $0 == 1 ?\
    \ 0 : $0 }\n                grid[i] = row\n                if i > 0 {\n      \
    \              var row = grid[i-1]\n                    row = row.map { $0 ==\
    \ capacity ? capacity : $0 + 1 }\n                    grid[i-1] = row\n      \
    \          }\n                if i < grid.count - 1 {\n                    var\
    \ row = grid[i+1]\n                    row = row.map { $0 == capacity ? capacity\
    \ : $0 + 1 }\n                    grid[i+1] = row\n                }\n       \
    \     }\n        }\n        if !filled {\n            break\n        }\n     \
    \   count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n  \
    \          sum += col\n            if sum == capacity {\n                count\
    \ += 1\n                sum = 0\n            }\n        }\n        if sum > 0\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    var max_water = 0\n    for i in 0..<wells.count\
    \ {\n        for j in 0..<wells[i].count {\n            if wells[i][j] == 1 {\n\
    \                max_water += 1\n            }\n        }\n    }\n    while max_water\
    \ > 0 {\n        var water = 0\n        for i in 0..<wells.count {\n         \
    \   for j in 0..<wells[i].count {\n                if wells[i][j] == 1 {\n   \
    \                 water += 1\n                    wells[i][j] = 0\n          \
    \      }\n            }\n        }\n        max_water -= water\n        count\
    \ += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpd0lykren/tmpd0lykren.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ccc2c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ccbfbab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6ccbfba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6ccbfb97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd0lykren                        0x0000564bc84fb706 <unavailable> + 5894

    5    libc.so.6                          0x00002b6ccc4af460 __libc_start_main +
    245

    6    tmpd0lykren                        0x0000564bc84fb299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for col in row {\n            if col == 1 {\n                max_fill +=\
    \ 1\n            }\n        }\n        result += max_fill / capacity\n       \
    \ if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var min_row = -1\n      \
    \  var min_col = -1\n        var min_val = capacity + 1\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] <\
    \ min_val {\n                    min_val = grid[i][j]\n                    min_row\
    \ = i\n                    min_col = j\n                }\n            }\n   \
    \     }\n        if min_val == capacity {\n            break\n        }\n    \
    \    count += 1\n        for i in 0..<grid.count {\n            grid[i][min_col]\
    \ = min(grid[i][min_col] + min_val, capacity)\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_row = 0\n    var max_col = 0\n    var max_val = 0\n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                max_row = row\n                max_col\
    \ = col\n                max_val = 1\n                break\n            }\n \
    \       }\n    }\n    var grid = grid\n    while max_val > 0 {\n        for row\
    \ in 0...max_row {\n            for col in 0...max_col {\n                if grid[row][col]\
    \ == 1 {\n                    grid[row][col] = 0\n                    count +=\
    \ 1\n                }\n            }\n        }\n        max_val = 0\n      \
    \  for row in 0..<grid.count {\n            for col in 0..<grid[row].count {\n\
    \                if grid[row][col] == 1 {\n                    max_row = row\n\
    \                    max_col = col\n                    max_val = 1\n        \
    \            break\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpnp3tv7f2/tmpnp3tv7f2.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e57bd3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e578cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e578ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e578c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnp3tv7f2                        0x000055af13d809c7 <unavailable> + 6599

    5    libc.so.6                          0x00002b1e57dbf460 __libc_start_main +
    245

    6    tmpnp3tv7f2                        0x000055af13d80389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var wells = grid\n    var buckets = Array(repeating: capacity, count:\
    \ wells.count)\n    while true {\n        var filled = false\n        for i in\
    \ 0..<wells.count {\n            if wells[i].isEmpty {\n                continue\n\
    \            }\n            if wells[i][0] == 1 {\n                filled = true\n\
    \                wells[i].removeFirst()\n                buckets[i] = capacity\n\
    \            } else if buckets[i] > 0 {\n                filled = true\n     \
    \           wells[i].removeFirst()\n                buckets[i] -= 1\n        \
    \    }\n        }\n        if filled {\n            result += 1\n        } else\
    \ {\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk_1ecmdi/tmpk_1ecmdi.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4595289c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4594f80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4594f80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4594f7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk_1ecmdi                        0x0000560726e2a846 <unavailable> + 6214

    5    libc.so.6                          0x00002b4595475460 __libc_start_main +
    245

    6    tmpk_1ecmdi                        0x0000560726e2a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row_max = 0\n    for row in grid {\n        row_max = max(row_max,\
    \ row.max()!)\n    }\n    for _ in 0..<row_max {\n        var col_max = 0\n  \
    \      for col in 0..<grid[0].count {\n            col_max = max(col_max, grid.map{$0[col]}.max()!)\n\
    \        }\n        for _ in 0..<col_max {\n            for row in 0..<grid.count\
    \ {\n                for col in 0..<grid[0].count {\n                    if grid[row][col]\
    \ > 0 {\n                        grid[row][col] -= 1\n                    }\n\
    \                }\n            }\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpf63h7leu.swift:32:40: error: left side of mutating operator isn't\
    \ mutable: 'grid' is a 'let' constant\n                        grid[row][col]\
    \ -= 1\n                        ~~~~           ^\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var total =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                total += 1\n            }\n     \
    \   }\n        max_fill = max(max_fill, total)\n        total = 0\n    }\n   \
    \ return max_fill / capacity + (max_fill % capacity > 0 ? 1 : 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7udkpul5/tmp7udkpul5.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb881d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb87ecfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb87ecf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb87ece7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7udkpul5                        0x0000563b38f51676 <unavailable> + 5750

    5    libc.so.6                          0x00002acb883c4460 __libc_start_main +
    245

    6    tmp7udkpul5                        0x0000563b38f51209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        var fill = 0\n   \
    \     for cell in row {\n            if cell == 1 {\n                fill += 1\n\
    \            }\n        }\n        max_fill = max(max_fill, fill)\n        if\
    \ max_fill > capacity {\n            result += 1\n            max_fill = fill\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpr1ft_ulo/tmpr1ft_ulo.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7fd55d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7fd52c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7fd52c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7fd52c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr1ft_ulo                        0x00005586531c35d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b7fd57be460 __libc_start_main +
    245

    6    tmpr1ft_ulo                        0x00005586531c3169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2_t_fdg6.swift:24:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var water =\
    \ 0\n    var count = 0\n    for row in grid {\n        for cell in row {\n   \
    \         if cell == 1 {\n                water += 1\n            }\n        }\n\
    \    }\n    while water > 0 {\n        count += 1\n        water -= capacity\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpc7zqtbox/tmpc7zqtbox.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b51d57fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51d54f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51d54f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51d54f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc7zqtbox                        0x0000562a5b693b44 <unavailable> + 6980

    5    libc.so.6                          0x00002b51d59e7460 __libc_start_main +
    245

    6    tmpc7zqtbox                        0x0000562a5b6930d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var current_fill = 0\n        for cell in\
    \ row {\n            if cell == 1 {\n                current_fill += 1\n     \
    \       } else {\n                if current_fill > 0 {\n                    result\
    \ += 1\n                    current_fill = 0\n                }\n            }\n\
    \        }\n        if current_fill > 0 {\n            result += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuqfy53xv/tmpuqfy53xv.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9fd2f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9fcfe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9fcfe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9fcfe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuqfy53xv                        0x000055f63d910546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae9fd4de460 __libc_start_main +
    245

    6    tmpuqfy53xv                        0x000055f63d9100d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                result += 1\n         \
    \       let bucket = Array(repeating: capacity, count: grid[i].count)\n      \
    \          fill_bucket(grid: &grid, bucket: bucket, i: i, j: j)\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5eenuquc.swift:25:17: error: cannot find 'fill_bucket' in scope\n\
    \                fill_bucket(grid: &grid, bucket: bucket, i: i, j: j)\n      \
    \          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for cell in row {\n\
    \            if cell == 1 {\n                fill += 1\n            } else {\n\
    \                if fill > 0 {\n                    result += 1\n            \
    \        fill = 0\n                }\n            }\n        }\n        if fill\
    \ > 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppuexnode/tmppuexnode.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b6d55fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b6d256b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b6d256988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b6d2557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppuexnode                        0x000055c9a3121546 <unavailable> + 5446

    5    libc.so.6                          0x00002b7b6d74b460 __libc_start_main +
    245

    6    tmppuexnode                        0x000055c9a31210d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var bucket = capacity\n    for row in grid {\n        for cell in row\
    \ {\n            if cell == 1 {\n                bucket -= 1\n            }\n\
    \            if bucket == 0 {\n                result += 1\n                bucket\
    \ = capacity\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_mhevg3r/tmp_mhevg3r.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af104a09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af104700b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af104700988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af1046ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_mhevg3r                        0x000055f340a2a717 <unavailable> + 5911

    5    libc.so.6                          0x00002af104bf5460 __libc_start_main +
    245

    6    tmp_mhevg3r                        0x000055f340a2a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var fill = false\n      \
    \  for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n     \
    \           if grid[i][j] == 1 {\n                    fill = true\n          \
    \          grid[i][j] = 0\n                    if i > 0 {\n                  \
    \      grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                    }\n\
    \                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !fill {\n\
    \            break\n        }\n        count += 1\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978558
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      if i > 0 {\n                    grid[i - 1][j] = 1\n                }\n\
    \                if i < grid.count - 1 {\n                    grid[i + 1][j] =\
    \ 1\n                }\n                if j > 0 {\n                    grid[i][j\
    \ - 1] = 1\n                }\n                if j < grid[i].count - 1 {\n  \
    \                  grid[i][j + 1] = 1\n                }\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpy0zuzt9s/tmpy0zuzt9s.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5196adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51967d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51967d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51967d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy0zuzt9s                        0x0000563c92e36706 <unavailable> + 5894

    5    libc.so.6                          0x00002b5196cc7460 __libc_start_main +
    245

    6    tmpy0zuzt9s                        0x0000563c92e36299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    var row = 0\n    var col = 0\n    while row < grid.count\
    \ {\n        if grid[row][col] == 1 {\n            grid[row][col] = 0\n      \
    \      count += 1\n        }\n        if col == grid[row].count - 1 {\n      \
    \      row += 1\n            col = 0\n        } else {\n            col += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpk0rplgdj/tmpk0rplgdj.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2648e73c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2648b6ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2648b6a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2648b697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk0rplgdj                        0x000055b53c158747 <unavailable> + 5959

    5    libc.so.6                          0x00002b264905f460 __libc_start_main +
    245

    6    tmpk0rplgdj                        0x000055b53c158109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n  \
    \          sum += col\n            if sum == capacity {\n                count\
    \ += 1\n                sum = 0\n            }\n        }\n        if sum > 0\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var row = 0\n    while row < grid.count {\n        var col = 0\n    \
    \    while col < grid[row].count {\n            if grid[row][col] == 1 {\n   \
    \             count += 1\n                var i = row\n                while i\
    \ < grid.count && grid[i][col] == 1 {\n                    grid[i][col] = 0\n\
    \                    i += 1\n                }\n            }\n            col\
    \ += 1\n        }\n        row += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4kwe4zmp.swift:27:28: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[i][col] = 0\n                \
    \    ~~~~   ^\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var water =\
    \ 0\n    var fill = 0\n    for row in grid {\n        for well in row {\n    \
    \        water += well\n        }\n    }\n    while water > 0 {\n        water\
    \ -= capacity\n        fill += 1\n    }\n    return fill\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxxxaf8b2/tmpxxxaf8b2.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af025127c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af024e1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af024e1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af024e1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxxxaf8b2                        0x000056001088ab44 <unavailable> + 6980

    5    libc.so.6                          0x00002af025313460 __libc_start_main +
    245

    6    tmpxxxaf8b2                        0x000056001088a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for well in row {\n            if well == 1 {\n                max_fill\
    \ += 1\n            }\n        }\n        result += max_fill / capacity\n    \
    \    if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for cell in row {\n            if cell == 1 {\n                max_fill\
    \ += 1\n            }\n        }\n        result += max_fill / capacity\n    \
    \    if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row = 0\n    var col = 0\n    while row < grid.count {\n      \
    \  col = 0\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                result += 1\n                var i = row\n         \
    \       while i < grid.count && grid[i][col] == 1 {\n                    grid[i][col]\
    \ = 0\n                    i += 1\n                }\n            }\n        \
    \    col += 1\n        }\n        row += 1\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdw66hgbd.swift:28:28: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[i][col] = 0\n                \
    \    ~~~~   ^\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var bucket = capacity\n    for row in grid {\n        for well in row\
    \ {\n            if well == 1 {\n                if bucket == 0 {\n          \
    \          result += 1\n                    bucket = capacity\n              \
    \  }\n                bucket -= 1\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7yxh_tdc/tmp7yxh_tdc.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b64176efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64173e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b64173e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b64173e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7yxh_tdc                        0x000056048b0e0546 <unavailable> + 5446

    5    libc.so.6                          0x00002b64178db460 __libc_start_main +
    245

    6    tmp7yxh_tdc                        0x000056048b0e00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var buckets = Array(repeating: capacity, count: grid[0].count)\n  \
    \  for row in grid {\n        for (i, well) in row.enumerated() {\n          \
    \  if well == 1 {\n                buckets[i] -= 1\n            }\n        }\n\
    \        if buckets.contains(0) {\n            result += 1\n            buckets\
    \ = Array(repeating: capacity, count: grid[0].count)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpfsll8u_q/tmpfsll8u_q.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bfb3a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bfb0a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9bfb0a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9bfb09f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfsll8u_q                        0x0000561660653926 <unavailable> + 6438

    5    libc.so.6                          0x00002b9bfb595460 __libc_start_main +
    245

    6    tmpfsll8u_q                        0x00005616606534b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n\
    \            sum += cell\n        }\n        result += sum / capacity\n      \
    \  if sum % capacity != 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for i in 0..<row.count {\n            if row[i] == 1 {\n               \
    \ max_fill += 1\n            } else {\n                if max_fill > 0 {\n   \
    \                 result += 1\n                    max_fill = 0\n            \
    \    }\n            }\n        }\n        if max_fill > 0 {\n            result\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpe5_op05f/tmpe5_op05f.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade85d39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade85a30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade85a30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade85a2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe5_op05f                        0x000055c4163a6776 <unavailable> + 6006

    5    libc.so.6                          0x00002ade85f25460 __libc_start_main +
    245

    6    tmpe5_op05f                        0x000055c4163a6309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    while true {\n        var filled = false\n     \
    \   for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n    \
    \            if grid[i][j] == 1 {\n                    filled = true\n       \
    \             grid[i][j] = 0\n                    if i > 0 && grid[i-1][j] ==\
    \ 0 {\n                        grid[i-1][j] = 1\n                    }\n     \
    \               if i < grid.count-1 && grid[i+1][j] == 0 {\n                 \
    \       grid[i+1][j] = 1\n                    }\n                    if j > 0\
    \ && grid[i][j-1] == 0 {\n                        grid[i][j-1] = 1\n         \
    \           }\n                    if j < grid[i].count-1 && grid[i][j+1] == 0\
    \ {\n                        grid[i][j+1] = 1\n                    }\n       \
    \         }\n            }\n        }\n        if filled {\n            count\
    \ += 1\n        } else {\n            break\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978558
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for cell in row {\n\
    \            if cell == 1 {\n                fill += 1\n            } else {\n\
    \                if fill > 0 {\n                    result += 1\n            \
    \        fill = 0\n                }\n            }\n        }\n        if fill\
    \ > 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppuexnode/tmppuexnode.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b6d55fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b6d256b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b6d256988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b6d2557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppuexnode                        0x000055c9a3121546 <unavailable> + 5446

    5    libc.so.6                          0x00002b7b6d74b460 __libc_start_main +
    245

    6    tmppuexnode                        0x000055c9a31210d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for cell in row {\n            if cell == 1 {\n                max_fill\
    \ += 1\n            }\n        }\n        result += max_fill / capacity\n    \
    \    if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                result += 1\n         \
    \       grid = fill(grid: grid, capacity: capacity, row: i, col: j)\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwz6vzrwm.swift:24:24: error: cannot find 'fill' in scope\n    \
    \            grid = fill(grid: grid, capacity: capacity, row: i, col: j)\n   \
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var fill_count\
    \ = 0\n    var grid = grid\n    var row_max = [Int]()\n    for row in grid {\n\
    \        var max = 0\n        for cell in row {\n            if cell > max {\n\
    \                max = cell\n            }\n        }\n        row_max.append(max)\n\
    \    }\n    while row_max.max()! > 0 {\n        for i in 0..<grid.count {\n  \
    \          for j in 0..<grid[i].count {\n                if grid[i][j] > 0 {\n\
    \                    grid[i][j] -= capacity\n                    if grid[i][j]\
    \ < 0 {\n                        grid[i][j] = 0\n                    }\n     \
    \           }\n            }\n        }\n        fill_count += 1\n        for\
    \ i in 0..<grid.count {\n            var max = 0\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] > max {\n                    max = grid[i][j]\n\
    \                }\n            }\n            row_max[i] = max\n        }\n \
    \   }\n    return fill_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpde0hv97v/tmpde0hv97v.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91ff14dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91fee44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91fee44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91fee437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpde0hv97v                        0x000055f78f4659b6 <unavailable> + 6582

    5    libc.so.6                          0x00002b91ff339460 __libc_start_main +
    245

    6    tmpde0hv97v                        0x000055f78f465549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var water = 0\n    for row in grid {\n        for well in row {\n \
    \           water += well\n            if water == capacity {\n              \
    \  result += 1\n                water = 0\n            } else if water > capacity\
    \ {\n                result += 1\n                water = well\n            }\n\
    \        }\n        if water > 0 {\n            result += 1\n            water\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var water = 0\n    for row in grid {\n        for well in row {\n \
    \           water += well\n            if water == capacity {\n              \
    \  result += 1\n                water = 0\n            } else if water > capacity\
    \ {\n                result += 1\n                water = well\n            }\n\
    \        }\n        if water > 0 {\n            result += 1\n            water\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, capacity: capacity, i: i, j: j)\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfxbq9i34.swift:24:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n\
    \            sum += cell\n        }\n        result += sum / capacity\n      \
    \  if sum % capacity > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var bucket = 0\n    for row in grid {\n        for well in row {\n\
    \            bucket += well\n            if bucket > capacity {\n            \
    \    result += 1\n                bucket = well\n            }\n        }\n  \
    \      result += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpcwsik3z8/tmpcwsik3z8.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfee0ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfedde2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfedde2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfedde17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcwsik3z8                        0x000055b9c70f1546 <unavailable> + 5446

    5    libc.so.6                          0x00002abfee2d7460 __libc_start_main +
    245

    6    tmpcwsik3z8                        0x000055b9c70f10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for i in row {\n    \
    \        sum += i\n        }\n        count += sum / capacity\n        if sum\
    \ % capacity != 0 {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    grid[i][j] = 0\n     \
    \               filled = true\n                }\n            }\n        }\n \
    \       if filled {\n            count += 1\n        } else {\n            break\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpf9n5yu80/tmpf9n5yu80.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14725b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14722aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14722ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14722ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf9n5yu80                        0x0000565477fc6706 <unavailable> + 5894

    5    libc.so.6                          0x00002b14727a3460 __libc_start_main +
    245

    6    tmpf9n5yu80                        0x0000565477fc6299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var wells = grid\n    var buckets = Array(repeating: capacity, count:\
    \ wells.count)\n    var i = 0\n    while i < wells.count {\n        var j = 0\n\
    \        while j < wells[i].count {\n            if wells[i][j] == 1 {\n     \
    \           if buckets[i] > 0 {\n                    buckets[i] -= 1\n       \
    \             wells[i][j] = 0\n                } else {\n                    break\n\
    \                }\n            }\n            j += 1\n        }\n        if j\
    \ < wells[i].count {\n            i = 0\n            result += 1\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978558
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                max_fill += 1\n            }\n  \
    \      }\n    }\n    while max_fill > 0 {\n        count += 1\n        var fill\
    \ = 0\n        for row in grid {\n            var filled = 0\n            for\
    \ cell in row {\n                if cell == 1 {\n                    filled +=\
    \ 1\n                }\n            }\n            if filled > capacity {\n  \
    \              fill += capacity\n            } else {\n                fill +=\
    \ filled\n            }\n        }\n        max_fill -= fill\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkpzhlcs7/tmpkpzhlcs7.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2da473bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2da4432b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2da4432988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2da44317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkpzhlcs7                        0x0000559f57ece546 <unavailable> + 5446

    5    libc.so.6                          0x00002b2da4927460 __libc_start_main +
    245

    6    tmpkpzhlcs7                        0x0000559f57ece0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for col in row {\n            if col == 1 {\n                max_fill +=\
    \ 1\n            }\n        }\n        result += max_fill / capacity\n       \
    \ if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for i in 0..<grid.count {\n        var sum = 0\n        for j in 0..<grid[i].count\
    \ {\n            sum += grid[i][j]\n        }\n        result += sum / capacity\n\
    \        if sum % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    var row = 0\n    var col = 0\n    while row < grid.count\
    \ {\n        col = 0\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                count += 1\n                fill(grid: &grid, row: row,\
    \ col: col, capacity: capacity)\n            }\n            col += 1\n       \
    \ }\n        row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpii6gq849.swift:27:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, row: row, col: col, capacity: capacity)\n     \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n\
    \            sum += col\n        }\n        result += sum / capacity\n       \
    \ if sum % capacity != 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var current_fill = 0\n        for cell in\
    \ row {\n            if cell == 1 {\n                current_fill += 1\n     \
    \       } else {\n                if current_fill > 0 {\n                    result\
    \ += 1\n                    current_fill = 0\n                }\n            }\n\
    \        }\n        if current_fill > 0 {\n            result += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuqfy53xv/tmpuqfy53xv.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9fd2f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9fcfe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9fcfe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9fcfe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuqfy53xv                        0x000055f63d910546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae9fd4de460 __libc_start_main +
    245

    6    tmpuqfy53xv                        0x000055f63d9100d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    var well_length = wells[0].count\n    var well_count\
    \ = wells.count\n    var well_index = 0\n    var well_level = 0\n    var well_level_max\
    \ = 0\n    while well_index < well_count {\n        well_level = 0\n        well_level_max\
    \ = 0\n        for i in 0..<well_length {\n            if wells[well_index][i]\
    \ == 1 {\n                well_level += 1\n            } else {\n            \
    \    well_level_max = max(well_level_max, well_level)\n                well_level\
    \ = 0\n            }\n        }\n        well_level_max = max(well_level_max,\
    \ well_level)\n        count += well_level_max / capacity\n        if well_level_max\
    \ % capacity != 0 {\n            count += 1\n        }\n        well_index +=\
    \ 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            if well == 1 {\n                fill += 1\n            } else {\n\
    \                if fill > 0 {\n                    count += 1\n             \
    \       fill = 0\n                }\n            }\n        }\n        if fill\
    \ > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2jb_xu2v/tmp2jb_xu2v.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b851d0d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b851cdcab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b851cdca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b851cdc97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2jb_xu2v                        0x000055657773e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b851d2bf460 __libc_start_main +
    245

    6    tmp2jb_xu2v                        0x000055657773e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for col in row {\n            if col == 1 {\n                max_fill +=\
    \ 1\n            }\n        }\n        result += max_fill / capacity\n       \
    \ if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    var buckets = Array(repeating: capacity, count:\
    \ grid[0].count)\n    for i in 0..<wells.count {\n        for j in 0..<wells[i].count\
    \ {\n            if wells[i][j] == 1 {\n                if buckets[j] > 0 {\n\
    \                    buckets[j] -= 1\n                    wells[i][j] = 0\n  \
    \              } else {\n                    count += 1\n                }\n \
    \           }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdb44h58b/tmpdb44h58b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf9d343c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf9d03ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf9d03a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf9d0397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdb44h58b                        0x000056385001a766 <unavailable> + 5990

    5    libc.so.6                          0x00002acf9d52f460 __libc_start_main +
    245

    6    tmpdb44h58b                        0x000056385001a2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var water = 0\n        for col in row {\n\
    \            water += col\n            if water == capacity {\n              \
    \  result += 1\n                water = 0\n            }\n        }\n        if\
    \ water > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var water = 0\n        for cell in row {\n\
    \            water += cell\n            if water == capacity {\n             \
    \   result += 1\n                water = 0\n            }\n        }\n       \
    \ if water > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var fill_count\
    \ = 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                fill_count += 1\n     \
    \           let bucket_fill = min(capacity, grid[i].reduce(0, +))\n          \
    \      for k in 0..<grid[i].count {\n                    grid[i][k] = max(0, grid[i][k]\
    \ - bucket_fill)\n                }\n            }\n        }\n    }\n    return\
    \ fill_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3lux3vib/tmp3lux3vib.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bad2fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bacff3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bacff3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bacff27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3lux3vib                        0x0000555b63ad9856 <unavailable> + 6230

    5    libc.so.6                          0x00002b2bad4e8460 __libc_start_main +
    245

    6    tmp3lux3vib                        0x0000555b63ad93e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n  \
    \          sum += col\n            if sum == capacity {\n                count\
    \ += 1\n                sum = 0\n            }\n        }\n        if sum > 0\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        var row = grid[i]\n\
    \        var sum = 0\n        for j in 0..<row.count {\n            sum += row[j]\n\
    \        }\n        if sum > capacity {\n            count += 1\n            for\
    \ j in 0..<row.count {\n                if row[j] == 1 {\n                   \
    \ row[j] = 0\n                }\n            }\n        }\n        grid[i] = row\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpw13tkldy/tmpw13tkldy.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af837cfdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8379f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8379f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8379f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw13tkldy                        0x000055f3a03c6706 <unavailable> + 5894

    5    libc.so.6                          0x00002af837ee9460 __libc_start_main +
    245

    6    tmpw13tkldy                        0x000055f3a03c6299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            if well == 1 {\n                fill += 1\n            }\n      \
    \  }\n        max_fill = max(max_fill, fill)\n    }\n    return max_fill / capacity\
    \ + (max_fill % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpcx7mr724/tmpcx7mr724.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73a7e7dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73a7b74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73a7b74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73a7b737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcx7mr724                        0x000055e54e009676 <unavailable> + 5750

    5    libc.so.6                          0x00002b73a8069460 __libc_start_main +
    245

    6    tmpcx7mr724                        0x000055e54e009209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    while !wells.isEmpty {\n        wells = wells.map\
    \ { $0.map { $0 - capacity } }\n        wells = wells.filter { !$0.allSatisfy\
    \ { $0 <= 0 } }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgg0118b1/tmpgg0118b1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb875d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb872c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb872c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb872c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgg0118b1                        0x00005598ca773606 <unavailable> + 5638

    5    libc.so.6                          0x00002acb877be460 __libc_start_main +
    245

    6    tmpgg0118b1                        0x00005598ca773199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var max_fill = 0\n      \
    \  var max_fill_row = 0\n        var max_fill_col = 0\n        for row in 0..<grid.count\
    \ {\n            for col in 0..<grid[row].count {\n                if grid[row][col]\
    \ > max_fill {\n                    max_fill = grid[row][col]\n              \
    \      max_fill_row = row\n                    max_fill_col = col\n          \
    \      }\n            }\n        }\n        if max_fill == 0 {\n            break\n\
    \        }\n        count += 1\n        for row in 0..<grid.count {\n        \
    \    grid[row][max_fill_col] = max(0, grid[row][max_fill_col] - capacity)\n  \
    \      }\n        for col in 0..<grid[max_fill_row].count {\n            grid[max_fill_row][col]\
    \ = max(0, grid[max_fill_row][col] - capacity)\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl1guig8f/tmpl1guig8f.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1506c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1503bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1503bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1503bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1guig8f                        0x0000562cb9789796 <unavailable> + 6038

    5    libc.so.6                          0x00002ba1508b2460 __libc_start_main +
    245

    6    tmpl1guig8f                        0x0000562cb9789329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var fill_count\
    \ = 0\n    var fill_level = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well == 1 {\n                fill_level += 1\n           \
    \ }\n            if fill_level == capacity {\n                fill_count += 1\n\
    \                fill_level = 0\n            }\n        }\n    }\n    return fill_count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp46sjmt8l/tmp46sjmt8l.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b54071c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b53d68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b53d68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b53d677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp46sjmt8l                        0x00005615950b2717 <unavailable> + 5911

    5    libc.so.6                          0x00002b7b5425d460 __libc_start_main +
    245

    6    tmp46sjmt8l                        0x00005615950b20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for i in 0..<row.count\
    \ {\n            sum += row[i]\n            if sum == capacity {\n           \
    \     result += 1\n                sum = 0\n            }\n        }\n       \
    \ if sum > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n\
    \            sum += col\n        }\n        result += sum / capacity\n       \
    \ if sum % capacity != 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill_bucket(grid: &grid, capacity: capacity, i: i, j: j)\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0zpxn6cy.swift:24:17: error: cannot find 'fill_bucket' in scope\n\
    \                fill_bucket(grid: &grid, capacity: capacity, i: i, j: j)\n  \
    \              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    var row = 0\n    while row < grid.count {\n    \
    \    var col = 0\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                grid[row][col] = 0\n                count += 1\n   \
    \             var water = capacity - 1\n                while water > 0 {\n  \
    \                  if row + 1 < grid.count && grid[row + 1][col] == 1 {\n    \
    \                    grid[row + 1][col] = 0\n                        water -=\
    \ 1\n                    }\n                    if col + 1 < grid[row].count &&\
    \ grid[row][col + 1] == 1 {\n                        grid[row][col + 1] = 0\n\
    \                        water -= 1\n                    }\n                 \
    \   if row - 1 >= 0 && grid[row - 1][col] == 1 {\n                        grid[row\
    \ - 1][col] = 0\n                        water -= 1\n                    }\n \
    \                   if col - 1 >= 0 && grid[row][col - 1] == 1 {\n           \
    \             grid[row][col - 1] = 0\n                        water -= 1\n   \
    \                 }\n                }\n            }\n            col += 1\n\
    \        }\n        row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978558
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for col in row {\n            if col == 1 {\n                max_fill +=\
    \ 1\n            }\n        }\n        if max_fill > capacity {\n            result\
    \ += max_fill - capacity\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8y7by2py/tmp8y7by2py.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac50512fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac504e26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac504e26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac504e257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8y7by2py                        0x00005654fb8b7546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac50531b460 __libc_start_main +
    245

    6    tmp8y7by2py                        0x00005654fb8b70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for i in 0..<grid.count {\n        var sum = 0\n        for j in 0..<grid[i].count\
    \ {\n            sum += grid[i][j]\n        }\n        count += sum / capacity\n\
    \        if sum % capacity != 0 {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for well in row {\n\
    \            sum += well\n        }\n        result += sum / capacity\n      \
    \  if sum % capacity != 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    var row = 0\n    var col = 0\n    while row < grid.count\
    \ {\n        col = 0\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                grid[row][col] = 0\n                count += 1\n   \
    \             var i = row\n                while i < grid.count && capacity >\
    \ 0 {\n                    if grid[i][col] == 1 {\n                        grid[i][col]\
    \ = 0\n                        capacity -= 1\n                    }\n        \
    \            i += 1\n                }\n            }\n            col += 1\n\
    \        }\n        row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp55fgo70j.swift:32:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2_t_fdg6.swift:24:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var max_fill = 0\n      \
    \  var max_fill_index = -1\n        for i in 0..<grid.count {\n            let\
    \ fill = grid[i].reduce(0, +)\n            if fill > max_fill {\n            \
    \    max_fill = fill\n                max_fill_index = i\n            }\n    \
    \    }\n        if max_fill == 0 {\n            break\n        }\n        count\
    \ += 1\n        for i in 0..<grid[max_fill_index].count {\n            if grid[max_fill_index][i]\
    \ == 1 {\n                grid[max_fill_index][i] = 0\n                if max_fill_index\
    \ - 1 >= 0 {\n                    grid[max_fill_index - 1][i] = 1\n          \
    \      }\n                if max_fill_index + 1 < grid.count {\n             \
    \       grid[max_fill_index + 1][i] = 1\n                }\n            }\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978558
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var water = 0\n        for cell in row {\n\
    \            water += cell\n            if water >= capacity {\n             \
    \   result += 1\n                water = 0\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0a81sm9a/tmp0a81sm9a.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4543be2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45438d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45438d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45438d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0a81sm9a                        0x0000561363a5d717 <unavailable> + 5911

    5    libc.so.6                          0x00002b4543dce460 __libc_start_main +
    245

    6    tmp0a81sm9a                        0x0000561363a5d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var water = 0\n    for row in grid {\n        for cell in row {\n \
    \           water += cell\n            if water == capacity {\n              \
    \  result += 1\n                water = 0\n            } else if water > capacity\
    \ {\n                result += 1\n                water = cell\n            }\n\
    \        }\n        if water > 0 {\n            result += 1\n            water\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            fill += well\n            if fill == capacity {\n               \
    \ max_fill += 1\n                fill = 0\n            }\n        }\n        if\
    \ fill > 0 {\n            max_fill += 1\n        }\n    }\n    return max_fill\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var row_count = 0\n        for cell in row\
    \ {\n            if cell == 1 {\n                row_count += 1\n            }\n\
    \        }\n        count += row_count / capacity\n        if row_count % capacity\
    \ != 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        var row = grid[i]\n\
    \        var sum = 0\n        for j in 0..<row.count {\n            sum += row[j]\n\
    \        }\n        if sum > capacity {\n            count += 1\n            for\
    \ j in 0..<row.count {\n                row[j] = 0\n            }\n        }\n\
    \        grid[i] = row\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp47t_d9cy/tmp47t_d9cy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e68f65c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e68c5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e68c5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e68c5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp47t_d9cy                        0x00005569ebb0c706 <unavailable> + 5894

    5    libc.so.6                          0x00002b1e69151460 __libc_start_main +
    245

    6    tmp47t_d9cy                        0x00005569ebb0c299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var water = 0\n        for cell in row {\n\
    \            water += cell\n            if water == capacity {\n             \
    \   result += 1\n                water = 0\n            }\n        }\n       \
    \ if water > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            if well == 1 {\n                fill += 1\n            } else {\n\
    \                if fill > 0 {\n                    result += 1\n            \
    \        fill = 0\n                }\n            }\n        }\n        if fill\
    \ > 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp6jqwo85s/tmp6jqwo85s.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfd1cf5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfd19ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfd19ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfd19eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6jqwo85s                        0x000055acb7743546 <unavailable> + 5446

    5    libc.so.6                          0x00002abfd1ee1460 __libc_start_main +
    245

    6    tmp6jqwo85s                        0x000055acb77430d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    grid[i][j] = 0\n     \
    \               filled = true\n                }\n            }\n        }\n \
    \       if !filled {\n            break\n        }\n        count += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbx9avjcn/tmpbx9avjcn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ad6e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ad6b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ad6b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ad6b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbx9avjcn                        0x000055eabc072706 <unavailable> + 5894

    5    libc.so.6                          0x00002b9ad7014460 __libc_start_main +
    245

    6    tmpbx9avjcn                        0x000055eabc072299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = 1\n                    }\n                    if i <\
    \ grid.count - 1 {\n                        grid[i+1][j] = 1\n               \
    \     }\n                    if j > 0 {\n                        grid[i][j-1]\
    \ = 1\n                    }\n                    if j < grid[i].count - 1 {\n\
    \                        grid[i][j+1] = 1\n                    }\n           \
    \     }\n            }\n        }\n        if filled {\n            count += 1\n\
    \        } else {\n            break\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978558
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n   \
    \         if grid[i][j] == 1 {\n                count += 1\n            }\n  \
    \      }\n    }\n    return count / capacity + (count % capacity > 0 ? 1 : 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpv0xc2ent/tmpv0xc2ent.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16b3bd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16b38ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16b38ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16b38cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0xc2ent                        0x00005651d1408c54 <unavailable> + 7252

    5    libc.so.6                          0x00002b16b3dc3460 __libc_start_main +
    245

    6    tmpv0xc2ent                        0x00005651d14081e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        count += grid[i].reduce(0,\
    \ +) / capacity\n        if grid[i].reduce(0, +) % capacity != 0 {\n         \
    \   count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        let max_row = grid.max {\
    \ (a, b) -> Bool in\n            a.reduce(0, +) < b.reduce(0, +)\n        }!\n\
    \        let max_row_index = grid.firstIndex(of: max_row)!\n        let max_row_sum\
    \ = max_row.reduce(0, +)\n        if max_row_sum == 0 {\n            break\n \
    \       }\n        if max_row_sum <= capacity {\n            count += 1\n    \
    \        grid[max_row_index] = [Int](repeating: 0, count: grid[max_row_index].count)\n\
    \        } else {\n            count += max_row_sum / capacity\n            if\
    \ max_row_sum % capacity != 0 {\n                count += 1\n            }\n \
    \           grid[max_row_index] = [Int](repeating: 0, count: grid[max_row_index].count)\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var fill_count\
    \ = 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                fill_count += 1\n     \
    \           fill_bucket(grid: &grid, i: i, j: j, capacity: capacity)\n       \
    \     }\n        }\n    }\n    return fill_count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4g20774v.swift:24:17: error: cannot find 'fill_bucket' in scope\n\
    \                fill_bucket(grid: &grid, i: i, j: j, capacity: capacity)\n  \
    \              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row_max = [Int](repeating: 0, count: grid.count)\n    for i in\
    \ 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                row_max[i] = j\n            }\n        }\n    }\n  \
    \  var col_max = [Int](repeating: 0, count: grid[0].count)\n    for j in 0..<grid[0].count\
    \ {\n        for i in 0..<grid.count {\n            if grid[i][j] == 1 {\n   \
    \             col_max[j] = i\n            }\n        }\n    }\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                let row_fill = row_max[i] - j\n                let col_fill =\
    \ col_max[j] - i\n                let fill = min(row_fill, col_fill)\n       \
    \         if fill > 0 {\n                    result += 1\n                   \
    \ for k in 0..<fill {\n                        grid[i+k][j+k] = 0\n          \
    \          }\n                }\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9h4b_k80.swift:44:34: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                        grid[i+k][j+k] = 0\n          \
    \              ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n \
    \           sum += cell\n            if sum == capacity {\n                count\
    \ += 1\n                sum = 0\n            }\n        }\n        if sum > 0\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for col in row {\n \
    \           if col == 1 {\n                max_fill += 1\n            }\n    \
    \    }\n    }\n    while max_fill > 0 {\n        for row in grid {\n         \
    \   for col in row {\n                if col == 1 {\n                    count\
    \ += 1\n                    max_fill -= 1\n                }\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp1acsevkf/tmp1acsevkf.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f42e7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f42b73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f42b73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f42b727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1acsevkf                        0x000055a9ff628717 <unavailable> + 5911

    5    libc.so.6                          0x00002b8f43068460 __libc_start_main +
    245

    6    tmp1acsevkf                        0x000055a9ff6280d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var row = 0\n        while\
    \ row < grid.count {\n            var col = 0\n            while col < grid[row].count\
    \ {\n                if grid[row][col] == 1 {\n                    var fill =\
    \ capacity\n                    while fill > 0 {\n                        if row\
    \ + 1 < grid.count {\n                            if grid[row + 1][col] == 0 {\n\
    \                                grid[row + 1][col] = 1\n                    \
    \            fill -= 1\n                            }\n                      \
    \  }\n                        if col + 1 < grid[row].count {\n               \
    \             if grid[row][col + 1] == 0 {\n                                grid[row][col\
    \ + 1] = 1\n                                fill -= 1\n                      \
    \      }\n                        }\n                        if row - 1 >= 0 {\n\
    \                            if grid[row - 1][col] == 0 {\n                  \
    \              grid[row - 1][col] = 1\n                                fill -=\
    \ 1\n                            }\n                        }\n              \
    \          if col - 1 >= 0 {\n                            if grid[row][col - 1]\
    \ == 0 {\n                                grid[row][col - 1] = 1\n           \
    \                     fill -= 1\n                            }\n             \
    \           }\n                    }\n                }\n                col +=\
    \ 1\n            }\n            row += 1\n        }\n        count += 1\n    \
    \    if grid.reduce(0, { $0 + $1.reduce(0, +) }) == 0 {\n            break\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978559
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for i in 0..<grid.count {\n        var fill = 0\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                fill += 1\n           \
    \ }\n        }\n        max_fill = max(max_fill, fill)\n    }\n    return max_fill\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxcg4y8ys/tmpxcg4y8ys.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e06dc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e06abcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e06abc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e06abb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxcg4y8ys                        0x0000555ba18c26f6 <unavailable> + 5878

    5    libc.so.6                          0x00002b6e06fb1460 __libc_start_main +
    245

    6    tmpxcg4y8ys                        0x0000555ba18c2289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row = 0\n    while row < grid.count {\n        var col = 0\n  \
    \      while col < grid[row].count {\n            if grid[row][col] == 1 {\n \
    \               result += 1\n                var bucket = capacity\n         \
    \       while bucket > 0 {\n                    if row + 1 < grid.count && grid[row\
    \ + 1][col] == 1 {\n                        row += 1\n                       \
    \ bucket -= 1\n                    } else {\n                        break\n \
    \                   }\n                }\n            }\n            col += 1\n\
    \        }\n        row += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprjtxq7q3/tmprjtxq7q3.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af774ac4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7747bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7747bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7747ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprjtxq7q3                        0x000055e9f31824d6 <unavailable> + 5334

    5    libc.so.6                          0x00002af774cb0460 __libc_start_main +
    245

    6    tmprjtxq7q3                        0x000055e9f3182069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var water =\
    \ 0\n    for row in grid {\n        var count = 0\n        for well in row {\n\
    \            if well == 1 {\n                count += 1\n            }\n     \
    \   }\n        water += count / capacity\n        if count % capacity != 0 {\n\
    \            water += 1\n        }\n    }\n    return water\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var current_capacity = capacity\n    for row in grid {\n        for well\
    \ in row {\n            if well == 1 {\n                if current_capacity ==\
    \ 0 {\n                    count += 1\n                    current_capacity =\
    \ capacity\n                }\n                current_capacity -= 1\n       \
    \     }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmps8j_0hti/tmps8j_0hti.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f59eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f59bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f59bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f59baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps8j_0hti                        0x0000562a9cfcc546 <unavailable> + 5446

    5    libc.so.6                          0x00002b9f5a0a5460 __libc_start_main +
    245

    6    tmps8j_0hti                        0x0000562a9cfcc0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for col in row {\n \
    \           if col == 1 {\n                max_fill += 1\n            }\n    \
    \    }\n    }\n    var fill = 0\n    while fill < max_fill {\n        for row\
    \ in grid {\n            for col in row {\n                if col == 1 {\n   \
    \                 fill += 1\n                    if fill == max_fill {\n     \
    \                   return count\n                    }\n                }\n \
    \           }\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpyi3itaxl/tmpyi3itaxl.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad337e4dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad337b44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad337b44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad337b437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyi3itaxl                        0x000055bfccae4546 <unavailable> + 5446

    5    libc.so.6                          0x00002ad338039460 __libc_start_main +
    245

    6    tmpyi3itaxl                        0x000055bfccae40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpon_en_ud.swift:24:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        var row = grid[i]\n\
    \        for j in 0..<row.count {\n            if row[j] == 1 {\n            \
    \    count += 1\n                var k = i\n                while k < grid.count\
    \ && grid[k][j] == 1 {\n                    grid[k][j] = 0\n                 \
    \   k += 1\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjwxvqci4/tmpjwxvqci4.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b229abc4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b229a8bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b229a8bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b229a8ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjwxvqci4                        0x0000555d208fb706 <unavailable> + 5894

    5    libc.so.6                          0x00002b229adb0460 __libc_start_main +
    245

    6    tmpjwxvqci4                        0x0000555d208fb299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            if well == 1 {\n                fill += 1\n            }\n      \
    \  }\n        if fill > max_fill {\n            max_fill = fill\n        }\n \
    \   }\n    return max_fill / capacity + (max_fill % capacity > 0 ? 1 : 0)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp65k2_p59/tmp65k2_p59.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b369db0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b369d806b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b369d806988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b369d8057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp65k2_p59                        0x0000559f938685d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b369dcfb460 __libc_start_main +
    245

    6    tmp65k2_p59                        0x0000559f93868169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var water =\
    \ 0\n    for row in grid {\n        var bucket = capacity\n        for well in\
    \ row {\n            bucket -= well\n            if bucket < 0 {\n           \
    \     water += 1\n                bucket = capacity - well\n            }\n  \
    \      }\n    }\n    return water\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwjhof8e6/tmpwjhof8e6.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2acc195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2acbe8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2acbe8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2acbe8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwjhof8e6                        0x0000562b52a8d546 <unavailable> + 5446

    5    libc.so.6                          0x00002b2acc381460 __libc_start_main +
    245

    6    tmpwjhof8e6                        0x0000562b52a8d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for i in 0..<grid.count {\n        var row = grid[i]\n        var filled\
    \ = 0\n        for j in 0..<row.count {\n            if row[j] == 1 {\n      \
    \          filled += 1\n            }\n        }\n        count += filled / capacity\n\
    \        if filled % capacity != 0 {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, capacity: capacity, i: i, j: j)\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfxbq9i34.swift:24:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var wells = grid\n    let well_count = wells.count\n    let well_length\
    \ = wells[0].count\n    var well_index = 0\n    while well_index < well_count\
    \ {\n        var bucket_index = 0\n        while bucket_index < well_length {\n\
    \            if wells[well_index][bucket_index] == 1 {\n                wells[well_index][bucket_index]\
    \ = 0\n                var bucket_capacity = capacity\n                while bucket_capacity\
    \ > 0 {\n                    if well_index + 1 < well_count {\n              \
    \          if wells[well_index + 1][bucket_index] == 1 {\n                   \
    \         wells[well_index + 1][bucket_index] = 0\n                          \
    \  bucket_capacity -= 1\n                        }\n                    }\n  \
    \                  if bucket_index + 1 < well_length {\n                     \
    \   if wells[well_index][bucket_index + 1] == 1 {\n                          \
    \  wells[well_index][bucket_index + 1] = 0\n                            bucket_capacity\
    \ -= 1\n                        }\n                    }\n                   \
    \ if bucket_capacity > 0 {\n                        if well_index - 1 >= 0 {\n\
    \                            if wells[well_index - 1][bucket_index] == 1 {\n \
    \                               wells[well_index - 1][bucket_index] = 0\n    \
    \                            bucket_capacity -= 1\n                          \
    \  }\n                        }\n                        if bucket_index - 1 >=\
    \ 0 {\n                            if wells[well_index][bucket_index - 1] == 1\
    \ {\n                                wells[well_index][bucket_index - 1] = 0\n\
    \                                bucket_capacity -= 1\n                      \
    \      }\n                        }\n                    }\n                }\n\
    \                result += 1\n            }\n            bucket_index += 1\n \
    \       }\n        well_index += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978559
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var row_max = 0\n    for row in grid {\n        row_max = row.max()!\n\
    \        count += row_max / capacity\n        if row_max % capacity != 0 {\n \
    \           count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpemghtdot/tmpemghtdot.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2b29f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2b26edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2b26ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2b26ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpemghtdot                        0x0000563bade69676 <unavailable> + 5750

    5    libc.so.6                          0x00002ba2b2be2460 __libc_start_main +
    245

    6    tmpemghtdot                        0x0000563bade69209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row = grid.count\n    var col = grid[0].count\n    var i = 0\n\
    \    var j = 0\n    while i < row {\n        while j < col {\n            if grid[i][j]\
    \ == 1 {\n                result += 1\n                j += capacity\n       \
    \     } else {\n                j += 1\n            }\n        }\n        i +=\
    \ 1\n        j = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var count = 0\n        for cell in row {\n\
    \            if cell == 1 {\n                count += 1\n            }\n     \
    \   }\n        result += count / capacity\n        if count % capacity != 0 {\n\
    \            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var buckets = [Int](repeating: 0, count: grid[0].count)\n    for row\
    \ in grid {\n        for (index, well) in row.enumerated() {\n            if well\
    \ == 1 {\n                buckets[index] += 1\n            }\n        }\n    \
    \    for (index, bucket) in buckets.enumerated() {\n            if bucket > capacity\
    \ {\n                buckets[index] = bucket - capacity\n                result\
    \ += 1\n            } else {\n                buckets[index] = 0\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpkfg75rn2/tmpkfg75rn2.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49c4289c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49c3f80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49c3f80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49c3f7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkfg75rn2                        0x000055c06cc5f8b6 <unavailable> + 6326

    5    libc.so.6                          0x00002b49c4475460 __libc_start_main +
    245

    6    tmpkfg75rn2                        0x000055c06cc5f449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n \
    \           sum += cell\n            if sum > capacity {\n                count\
    \ += 1\n                sum = cell\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmph8v9kcj_/tmph8v9kcj_.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1f8910c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1f8607b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1f8607988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1f86067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8v9kcj_                        0x00005653c1956546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba1f8afc460 __libc_start_main +
    245

    6    tmph8v9kcj_                        0x00005653c19560d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var total_water\
    \ = 0\n    for row in grid {\n        let row_water = row.reduce(0, +)\n     \
    \   total_water += row_water\n    }\n    return total_water / capacity\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4oper24k/tmp4oper24k.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b609ab1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b609a815b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b609a815988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b609a8147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4oper24k                        0x000055d0ecb63817 <unavailable> + 6167

    5    libc.so.6                          0x00002b609ad0a460 __libc_start_main +
    245

    6    tmp4oper24k                        0x000055d0ecb631d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var row_sum = 0\n        for cell in row\
    \ {\n            row_sum += cell\n        }\n        result += row_sum / capacity\n\
    \        if row_sum % capacity != 0 {\n            result += 1\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            fill += well\n            if fill == capacity {\n               \
    \ max_fill += 1\n                fill = 0\n            }\n        }\n        if\
    \ fill > 0 {\n            max_fill += 1\n        }\n    }\n    return max_fill\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                max_fill += 1\n            }\n  \
    \      }\n    }\n    var current_fill = 0\n    while current_fill < max_fill {\n\
    \        for row in grid {\n            for cell in row {\n                if\
    \ cell == 1 {\n                    current_fill += 1\n                }\n    \
    \        }\n            if current_fill < max_fill {\n                result +=\
    \ 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn9cf4tb5/tmpn9cf4tb5.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ad397dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ad3674b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ad3674988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ad36737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn9cf4tb5                        0x0000557e7c55e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b2ad3b69460 __libc_start_main +
    245

    6    tmpn9cf4tb5                        0x0000557e7c55e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n\
    \            sum += cell\n        }\n        result += sum / capacity\n      \
    \  if sum % capacity > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    var fill = 0\n    for row in grid {\n        for\
    \ col in row {\n            if col == 1 {\n                fill += 1\n       \
    \     }\n        }\n        if fill > max_fill {\n            max_fill = fill\n\
    \        }\n        fill = 0\n    }\n    if max_fill > capacity {\n        count\
    \ = max_fill / capacity\n        if max_fill % capacity != 0 {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpazeef7kg/tmpazeef7kg.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d32d1bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d32a12b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d32a12988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d32a117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpazeef7kg                        0x00005592f66315d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b3d32f07460 __libc_start_main +
    245

    6    tmpazeef7kg                        0x00005592f6631169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    var max_fill_index = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n            }\n        }\n        if count > max_fill\
    \ {\n            max_fill = count\n            max_fill_index = i\n        }\n\
    \        count = 0\n    }\n    return max_fill_index\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpygno7e_o/tmpygno7e_o.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a7af02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a7abf9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a7abf9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a7abf87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpygno7e_o                        0x0000564456866656 <unavailable> + 5718

    5    libc.so.6                          0x00002b6a7b0ee460 __libc_start_main +
    245

    6    tmpygno7e_o                        0x00005644568661e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpon_en_ud.swift:24:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while !grid.isEmpty {\n        var i = 0\n    \
    \    while i < grid.count {\n            if grid[i].reduce(0, +) == 0 {\n    \
    \            grid.remove(at: i)\n            } else {\n                i += 1\n\
    \            }\n        }\n        if grid.isEmpty {\n            break\n    \
    \    }\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    grid[i][j] = 0\n\
    \                    break\n                }\n            }\n        }\n    \
    \    count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp3we86k02/tmp3we86k02.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d0c9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d0996b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3d0996988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3d09957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3we86k02                        0x0000561ea33f5866 <unavailable> + 6246

    5    libc.so.6                          0x00002ac3d0e8b460 __libc_start_main +
    245

    6    tmp3we86k02                        0x0000561ea33f53f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var water = 0\n        for well in row {\n\
    \            water += well\n            if water == capacity {\n             \
    \   result += 1\n                water = 0\n            }\n        }\n       \
    \ if water > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n \
    \           sum += cell\n            if sum == capacity {\n                count\
    \ += 1\n                sum = 0\n            }\n        }\n        if sum > 0\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    var buckets = [Int](repeating: 0, count: wells.count)\n\
    \    while true {\n        var filled = false\n        for i in 0..<wells.count\
    \ {\n            if wells[i][0] == 1 {\n                filled = true\n      \
    \          wells[i][0] = 0\n                buckets[i] += 1\n            }\n \
    \       }\n        if !filled {\n            break\n        }\n        count +=\
    \ 1\n        for i in 0..<buckets.count {\n            if buckets[i] > capacity\
    \ {\n                for j in 0..<wells.count {\n                    if i == j\
    \ {\n                        continue\n                    }\n               \
    \     if wells[j][0] == 0 {\n                        wells[j][0] = 1\n       \
    \                 buckets[i] -= 1\n                        break\n           \
    \         }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ljt3pog/tmp4ljt3pog.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6771494c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b677118bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b677118b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b677118a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ljt3pog                        0x000055b57f084766 <unavailable> + 5990

    5    libc.so.6                          0x00002b6771680460 __libc_start_main +
    245

    6    tmp4ljt3pog                        0x000055b57f0842f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        var row = grid[i]\n\
    \        var sum = 0\n        for j in 0..<row.count {\n            sum += row[j]\n\
    \        }\n        if sum > capacity {\n            count += 1\n            for\
    \ j in 0..<row.count {\n                if row[j] == 1 {\n                   \
    \ row[j] = 0\n                }\n            }\n        }\n        grid[i] = row\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkdshcfcn/tmpkdshcfcn.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d587ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d584d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d584d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d584d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdshcfcn                        0x000055736b00e706 <unavailable> + 5894

    5    libc.so.6                          0x00002b4d589c9460 __libc_start_main +
    245

    6    tmpkdshcfcn                        0x000055736b00e299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    var buckets = Array(repeating: capacity, count:\
    \ wells.count)\n    while !wells.isEmpty {\n        for i in 0..<wells.count {\n\
    \            if wells[i].isEmpty {\n                wells.remove(at: i)\n    \
    \            buckets.remove(at: i)\n            }\n        }\n        for i in\
    \ 0..<wells.count {\n            if wells[i][0] == 1 {\n                buckets[i]\
    \ -= 1\n            }\n            wells[i].remove(at: 0)\n        }\n       \
    \ count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba679235c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba678f2c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba678f2c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba678f2c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba678f2bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ba678f1548a <unavailable> + 1340554

    6    tmpls9qsy5x                        0x00005571b4432100 <unavailable> + 8448

    7    tmpls9qsy5x                        0x00005571b4431788 <unavailable> + 6024

    8    libc.so.6                          0x00002ba679421460 __libc_start_main +
    245

    9    tmpls9qsy5x                        0x00005571b4431399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var current_fill = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well == 1 {\n                current_fill += 1\n         \
    \   }\n        }\n        if current_fill > 0 {\n            result += 1\n   \
    \         current_fill = max(0, current_fill - capacity)\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpfbo_f3zv/tmpfbo_f3zv.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee37952c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee37649b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee37649988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee376487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfbo_f3zv                        0x0000561cb2d595d6 <unavailable> + 5590

    5    libc.so.6                          0x00002aee37b3e460 __libc_start_main +
    245

    6    tmpfbo_f3zv                        0x0000561cb2d59169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var fill =\
    \ 0\n    var wells = grid.map { $0.reduce(0, +) }\n    while wells.reduce(0, +)\
    \ > 0 {\n        for i in 0..<wells.count {\n            if wells[i] > 0 {\n \
    \               wells[i] -= min(wells[i], capacity)\n                fill += 1\n\
    \            }\n        }\n    }\n    return fill\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n\
    \            sum += col\n        }\n        result += sum / capacity\n       \
    \ if sum % capacity != 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                max_fill += 1\n            }\n  \
    \      }\n    }\n    while max_fill > 0 {\n        for row in grid {\n       \
    \     var fill = 0\n            for cell in row {\n                if cell ==\
    \ 1 {\n                    fill += 1\n                }\n            }\n     \
    \       if fill > 0 {\n                count += 1\n                max_fill -=\
    \ fill\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbe0v4q0w/tmpbe0v4q0w.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6a8da5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6a8a9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6a8a9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6a8a9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbe0v4q0w                        0x000056015c11b546 <unavailable> + 5446

    5    libc.so.6                          0x00002af6a8f91460 __libc_start_main +
    245

    6    tmpbe0v4q0w                        0x000056015c11b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i + 1 < grid.count {\n \
    \                       grid[i + 1][j] = 1\n                    }\n          \
    \      }\n            }\n        }\n        if filled {\n            count +=\
    \ 1\n        } else {\n            break\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpfe1raryu/tmpfe1raryu.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7eb41cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7eb3ec2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7eb3ec2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7eb3ec17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfe1raryu                        0x000055f2c12bc706 <unavailable> + 5894

    5    libc.so.6                          0x00002b7eb43b7460 __libc_start_main +
    245

    6    tmpfe1raryu                        0x000055f2c12bc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for col in row {\n\
    \            if col == 1 {\n                fill += 1\n            }\n       \
    \ }\n        max_fill = max(max_fill, fill)\n    }\n    return max_fill / capacity\
    \ + (max_fill % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpn_1cuwi0/tmpn_1cuwi0.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a16cdcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a169d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a169d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a169d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn_1cuwi0                        0x0000564c0d7c5676 <unavailable> + 5750

    5    libc.so.6                          0x00002b0a16ec8460 __libc_start_main +
    245

    6    tmpn_1cuwi0                        0x0000564c0d7c5209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var water = 0\n        for well in row {\n\
    \            water += well\n            if water >= capacity {\n             \
    \   result += 1\n                water = 0\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl72sbk7s/tmpl72sbk7s.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27732bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2772fb2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2772fb2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2772fb17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl72sbk7s                        0x000055c027a38717 <unavailable> + 5911

    5    libc.so.6                          0x00002b27734a7460 __libc_start_main +
    245

    6    tmpl72sbk7s                        0x000055c027a380d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var current_fill = 0\n        for cell in\
    \ row {\n            if cell == 1 {\n                current_fill += 1\n     \
    \       } else {\n                if current_fill > 0 {\n                    result\
    \ += 1\n                    current_fill = 0\n                }\n            }\n\
    \        }\n        if current_fill > 0 {\n            result += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuqfy53xv/tmpuqfy53xv.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9fd2f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9fcfe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9fcfe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9fcfe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuqfy53xv                        0x000055f63d910546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae9fd4de460 __libc_start_main +
    245

    6    tmpuqfy53xv                        0x000055f63d9100d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var current_fill = 0\n        for well in\
    \ row {\n            if well == 1 {\n                current_fill += 1\n     \
    \       } else {\n                if current_fill > 0 {\n                    result\
    \ += 1\n                    current_fill = 0\n                }\n            }\n\
    \        }\n        if current_fill > 0 {\n            result += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp123gbk_7/tmp123gbk_7.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5cf3576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5cf326db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5cf326d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5cf326c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp123gbk_7                        0x000055a582a0f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5cf3762460 __libc_start_main +
    245

    6    tmp123gbk_7                        0x000055a582a0f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var wells = grid\n    var buckets = [Int](repeating: 0, count: wells.count)\n\
    \    while true {\n        var filled = false\n        for i in 0..<wells.count\
    \ {\n            if wells[i][0] == 1 {\n                wells[i][0] = 0\n    \
    \            buckets[i] += 1\n                filled = true\n            }\n \
    \       }\n        if !filled {\n            break\n        }\n        result\
    \ += 1\n        for i in 0..<buckets.count {\n            if buckets[i] > capacity\
    \ {\n                let overflow = buckets[i] - capacity\n                buckets[i]\
    \ = capacity\n                for j in 0..<wells.count {\n                   \
    \ if i != j {\n                        let to_fill = min(overflow, capacity -\
    \ buckets[j])\n                        buckets[j] += to_fill\n               \
    \         overflow -= to_fill\n                    }\n                }\n    \
    \        }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmfqb4gx_.swift:42:34: error: left side of mutating operator isn't\
    \ mutable: 'overflow' is a 'let' constant\n                        overflow -=\
    \ to_fill\n                        ~~~~~~~~ ^\n/tmp/tmpmfqb4gx_.swift:36:17: note:\
    \ change 'let' to 'var' to make it mutable\n                let overflow = buckets[i]\
    \ - capacity\n                ^~~\n                var\n"
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for i in row {\n    \
    \        sum += i\n        }\n        count += sum / capacity\n        if sum\
    \ % capacity != 0 {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            if well == 1 {\n                fill += 1\n            }\n      \
    \  }\n        max_fill = max(max_fill, fill)\n    }\n    return max_fill / capacity\
    \ + (max_fill % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpcx7mr724/tmpcx7mr724.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73a7e7dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73a7b74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73a7b74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73a7b737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcx7mr724                        0x000055e54e009676 <unavailable> + 5750

    5    libc.so.6                          0x00002b73a8069460 __libc_start_main +
    245

    6    tmpcx7mr724                        0x000055e54e009209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        var row = grid[i]\n\
    \        var sum = 0\n        for j in 0..<row.count {\n            sum += row[j]\n\
    \        }\n        if sum > capacity {\n            count += 1\n            for\
    \ j in 0..<row.count {\n                if row[j] == 1 {\n                   \
    \ row[j] = 0\n                } else {\n                    row[j] = 1\n     \
    \           }\n            }\n        }\n        grid[i] = row\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqa7mtpxd/tmpqa7mtpxd.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad988c92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad988989b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad988989988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9889887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqa7mtpxd                        0x00005654317e8706 <unavailable> + 5894

    5    libc.so.6                          0x00002ad988e7e460 __libc_start_main +
    245

    6    tmpqa7mtpxd                        0x00005654317e8299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 1 {\n                max_fill += 1\n            }\n   \
    \     }\n    }\n    result = max_fill / capacity\n    if max_fill % capacity !=\
    \ 0 {\n        result += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_o7f957h/tmp_o7f957h.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4d6a42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4d6739b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4d6739988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4d67387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_o7f957h                        0x0000560cbc3babd4 <unavailable> + 7124

    5    libc.so.6                          0x00002ab4d6c2e460 __libc_start_main +
    245

    6    tmp_o7f957h                        0x0000560cbc3ba169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        var sum = 0\n\
    \        for j in 0..<grid[i].count {\n            sum += grid[i][j]\n       \
    \ }\n        if sum > capacity {\n            count += 1\n            for j in\
    \ 0..<grid[i].count {\n                grid[i][j] = 0\n            }\n       \
    \ }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpz3floh9b/tmpz3floh9b.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b026ecf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b026e9e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b026e9e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b026e9e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz3floh9b                        0x000055c3207aa706 <unavailable> + 5894

    5    libc.so.6                          0x00002b026eede460 __libc_start_main +
    245

    6    tmpz3floh9b                        0x000055c3207aa299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    filled = true\n      \
    \              grid[i][j] = 0\n                    if i > 0 {\n              \
    \          grid[i-1][j] = min(grid[i-1][j] + 1, capacity)\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ = min(grid[i+1][j] + 1, capacity)\n                    }\n                 \
    \   if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1] + 1, capacity)\n\
    \                    }\n                    if j < grid[i].count - 1 {\n     \
    \                   grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n         \
    \           }\n                }\n            }\n        }\n        if !filled\
    \ {\n            break\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978557
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var wells = grid\n    var buckets = Array(repeating: capacity, count:\
    \ wells.count)\n    var i = 0\n    while i < wells.count {\n        var j = 0\n\
    \        while j < wells[i].count {\n            if wells[i][j] == 1 {\n     \
    \           if buckets[i] > 0 {\n                    buckets[i] -= 1\n       \
    \             wells[i][j] = 0\n                } else {\n                    break\n\
    \                }\n            }\n            j += 1\n        }\n        i +=\
    \ 1\n    }\n    for i in 0..<wells.count {\n        for j in 0..<wells[i].count\
    \ {\n            if wells[i][j] == 1 {\n                result += 1\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp9u33chyf/tmp9u33chyf.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba98dd25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba98da1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba98da1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba98da1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9u33chyf                        0x0000563fe605a766 <unavailable> + 5990

    5    libc.so.6                          0x00002ba98df11460 __libc_start_main +
    245

    6    tmp9u33chyf                        0x0000563fe605a2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for col in row {\n            if col == 1 {\n                max_fill +=\
    \ 1\n            }\n        }\n        result += max_fill / capacity\n       \
    \ if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    var row_max = [Int](repeating: 0, count: wells.count)\n\
    \    var col_max = [Int](repeating: 0, count: wells[0].count)\n    for i in 0..<wells.count\
    \ {\n        for j in 0..<wells[i].count {\n            row_max[i] = max(row_max[i],\
    \ wells[i][j])\n            col_max[j] = max(col_max[j], wells[i][j])\n      \
    \  }\n    }\n    for i in 0..<wells.count {\n        for j in 0..<wells[i].count\
    \ {\n            let max_water = min(row_max[i], col_max[j])\n            if wells[i][j]\
    \ < max_water {\n                count += max_water - wells[i][j]\n          \
    \  }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp2c14r1xt/tmp2c14r1xt.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3fe16b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3fe13aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3fe13aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3fe13a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2c14r1xt                        0x000055750cb6f9d7 <unavailable> + 6615

    5    libc.so.6                          0x00002b3fe189f460 __libc_start_main +
    245

    6    tmp2c14r1xt                        0x000055750cb6f399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                max_fill += 1\n            }\n  \
    \      }\n    }\n    var fill = 0\n    for row in grid {\n        for cell in\
    \ row {\n            if cell == 1 {\n                fill += 1\n            }\n\
    \        }\n        if fill == max_fill {\n            break\n        }\n    \
    \    result += 1\n        fill = 0\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxju3v9u9/tmpxju3v9u9.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1de1b04c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1de17fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1de17fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1de17fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxju3v9u9                        0x00005596e271a546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1de1cf0460 __libc_start_main +
    245

    6    tmpxju3v9u9                        0x00005596e271a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n  \
    \          sum += col\n            if sum == capacity {\n                count\
    \ += 1\n                sum = 0\n            }\n        }\n        if sum > 0\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var current_capacity = capacity\n    for row in grid {\n        for\
    \ well in row {\n            if well == 1 {\n                if current_capacity\
    \ == 0 {\n                    result += 1\n                    current_capacity\
    \ = capacity\n                }\n                current_capacity -= 1\n     \
    \       }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpitb1t6bi/tmpitb1t6bi.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba55770bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba557402b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba557402988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5574017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpitb1t6bi                        0x000055e0d7aa3546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba5578f7460 __libc_start_main +
    245

    6    tmpitb1t6bi                        0x000055e0d7aa30d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n  \
    \          sum += col\n            if sum > capacity {\n                count\
    \ += 1\n                sum = col\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgv5n0gu_/tmpgv5n0gu_.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b186326bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1862f62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1862f62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1862f617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgv5n0gu_                        0x00005583ec3b2546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1863457460 __libc_start_main +
    245

    6    tmpgv5n0gu_                        0x00005583ec3b20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var filled = false\n    \
    \    for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n   \
    \             if grid[i][j] == 1 {\n                    grid[i][j] = 0\n     \
    \               filled = true\n                }\n            }\n        }\n \
    \       if !filled {\n            break\n        }\n        count += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbx9avjcn/tmpbx9avjcn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ad6e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ad6b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ad6b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ad6b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbx9avjcn                        0x000055eabc072706 <unavailable> + 5894

    5    libc.so.6                          0x00002b9ad7014460 __libc_start_main +
    245

    6    tmpbx9avjcn                        0x000055eabc072299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var current_capacity = capacity\n      \
    \  for well in row {\n            if well == 1 {\n                current_capacity\
    \ -= 1\n            }\n            if current_capacity == 0 {\n              \
    \  result += 1\n                current_capacity = capacity\n            }\n \
    \       }\n        if current_capacity < capacity {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var row_sum = 0\n        for cell in row\
    \ {\n            row_sum += cell\n        }\n        result += row_sum / capacity\n\
    \        if row_sum % capacity != 0 {\n            result += 1\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 1 {\n                max_fill += 1\n            }\n   \
    \     }\n    }\n    result = max_fill / capacity\n    if max_fill % capacity >\
    \ 0 {\n        result += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe5frmsqu/tmpe5frmsqu.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bbb1d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bbaec9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bbaec9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bbaec87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe5frmsqu                        0x000055b2949d8bd4 <unavailable> + 7124

    5    libc.so.6                          0x00002b0bbb3be460 __libc_start_main +
    245

    6    tmpe5frmsqu                        0x000055b2949d8169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row_max = 0\n    for row in grid {\n        row_max = 0\n     \
    \   for col in row {\n            if col > row_max {\n                row_max\
    \ = col\n            }\n        }\n        result += row_max\n    }\n    return\
    \ result / capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxp3rjnhd/tmpxp3rjnhd.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68b8b5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b68b8856b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b68b8856988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b68b88557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxp3rjnhd                        0x00005592333b75d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b68b8d4b460 __libc_start_main +
    245

    6    tmpxp3rjnhd                        0x00005592333b7169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row_max = [Int](repeating: 0, count: grid.count)\n    var col_max\
    \ = [Int](repeating: 0, count: grid[0].count)\n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            row_max[i] = max(row_max[i],\
    \ grid[i][j])\n            col_max[j] = max(col_max[j], grid[i][j])\n        }\n\
    \    }\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n\
    \            result += min(row_max[i], col_max[j]) - grid[i][j]\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp02xd5vis/tmp02xd5vis.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af29f393c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af29f08ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af29f08a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af29f0897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp02xd5vis                        0x000055da861469d7 <unavailable> + 6615

    5    libc.so.6                          0x00002af29f57f460 __libc_start_main +
    245

    6    tmp02xd5vis                        0x000055da86146399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n\
    \            sum += cell\n        }\n        result += (sum / capacity)\n    \
    \    if sum % capacity != 0 {\n            result += 1\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for col in row {\n \
    \           if col == 1 {\n                max_fill += 1\n            }\n    \
    \    }\n    }\n    while max_fill > 0 {\n        for row in grid {\n         \
    \   for col in row {\n                if col == 1 {\n                    count\
    \ += 1\n                    max_fill -= 1\n                }\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp1acsevkf/tmp1acsevkf.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f42e7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f42b73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f42b73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f42b727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1acsevkf                        0x000055a9ff628717 <unavailable> + 5911

    5    libc.so.6                          0x00002b8f43068460 __libc_start_main +
    245

    6    tmp1acsevkf                        0x000055a9ff6280d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for col in row {\n            if col == 1 {\n                max_fill +=\
    \ 1\n            }\n        }\n        if max_fill > capacity {\n            result\
    \ += max_fill / capacity\n            if max_fill % capacity != 0 {\n        \
    \        result += 1\n            }\n        } else {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp4a9z98sa/tmp4a9z98sa.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5495733c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b549542ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b549542a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54954297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4a9z98sa                        0x000055a64883f7a7 <unavailable> + 6055

    5    libc.so.6                          0x00002b549591f460 __libc_start_main +
    245

    6    tmp4a9z98sa                        0x000055a64883f169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for cell in row {\n\
    \            sum += cell\n        }\n        result += sum / capacity\n      \
    \  if sum % capacity != 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var current_fill = 0\n        for well in\
    \ row {\n            current_fill += well\n            if current_fill >= capacity\
    \ {\n                count += 1\n                current_fill = 0\n          \
    \  }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp_ikbwyj2/tmp_ikbwyj2.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed6f05ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed6ed51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed6ed51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed6ed507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ikbwyj2                        0x000056166a842717 <unavailable> + 5911

    5    libc.so.6                          0x00002aed6f246460 __libc_start_main +
    245

    6    tmp_ikbwyj2                        0x000056166a8420d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for col in row {\n \
    \           if col == 1 {\n                count += 1\n            }\n       \
    \ }\n        if count > max_fill {\n            max_fill = count\n        }\n\
    \        count = 0\n    }\n    return max_fill / capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx0024pn8/tmpx0024pn8.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2265283c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2264f7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2264f7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2264f797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx0024pn8                        0x0000558788b825d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b226546f460 __libc_start_main +
    245

    6    tmpx0024pn8                        0x0000558788b82169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n  \
    \          sum += col\n            if sum == capacity {\n                count\
    \ += 1\n                sum = 0\n            }\n        }\n        if sum > 0\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    for i in 0..<grid.count {\n        var row = grid[i]\n\
    \        var sum = 0\n        for j in 0..<row.count {\n            sum += row[j]\n\
    \        }\n        if sum > capacity {\n            count += 1\n            for\
    \ j in 0..<row.count {\n                if row[j] == 1 {\n                   \
    \ grid[i][j] = 0\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkjzllzz2/tmpkjzllzz2.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c56212c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c55f09b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c55f09988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c55f087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkjzllzz2                        0x00005647c4f50706 <unavailable> + 5894

    5    libc.so.6                          0x00002b5c563fe460 __libc_start_main +
    245

    6    tmpkjzllzz2                        0x00005647c4f50299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n\
    \            sum += col\n        }\n        result += sum / capacity\n       \
    \ if sum % capacity != 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978553
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var row_max = 0\n    var row_sum = 0\n    for row in grid {\n     \
    \   row_max = 0\n        row_sum = 0\n        for col in row {\n            row_sum\
    \ += col\n            if col > row_max {\n                row_max = col\n    \
    \        }\n        }\n        result += row_max\n        if row_sum < capacity\
    \ {\n            result += capacity - row_sum\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk15m1prv/tmpk15m1prv.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f2e4a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f2e199b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f2e199988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f2e1987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk15m1prv                        0x00005563ac650546 <unavailable> + 5446

    5    libc.so.6                          0x00002b9f2e68e460 __libc_start_main +
    245

    6    tmpk15m1prv                        0x00005563ac6500d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    for row in grid {\n        var current = 0\n        for col in row {\n\
    \            current += col\n            if current == capacity {\n          \
    \      count += 1\n                current = 0\n            }\n        }\n   \
    \     if current > 0 {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978555
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var grid = grid\n    var row = 0\n    while row < grid.count {\n    \
    \    var col = 0\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                var i = row\n                while i < grid.count &&\
    \ grid[i][col] == 1 {\n                    grid[i][col] = 0\n                \
    \    i += 1\n                }\n                count += 1\n            }\n  \
    \          col += 1\n        }\n        row += 1\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2e1w25la/tmp2e1w25la.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c112cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c10fc2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c10fc2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c10fc17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2e1w25la                        0x00005640e6951576 <unavailable> + 5494

    5    libc.so.6                          0x00002b2c114b7460 __libc_start_main +
    245

    6    tmp2e1w25la                        0x00005640e6951109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \  }\n        }\n        max_fill = max(max_fill, count)\n        count = 0\n\
    \    }\n    return max_fill / capacity + (max_fill % capacity > 0 ? 1 : 0)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvngic1w9/tmpvngic1w9.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade3cb57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade3c84eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade3c84e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade3c84d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvngic1w9                        0x0000562c96b1e6f6 <unavailable> + 5878

    5    libc.so.6                          0x00002ade3cd43460 __libc_start_main +
    245

    6    tmpvngic1w9                        0x0000562c96b1e289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var water = 0\n        for well in row {\n\
    \            water += well\n            if water == capacity {\n             \
    \   result += 1\n                water = 0\n            }\n        }\n       \
    \ if water > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978554
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var total =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                total += 1\n            }\n     \
    \   }\n        max_fill = max(max_fill, total)\n        total = 0\n    }\n   \
    \ return max_fill / capacity + (max_fill % capacity > 0 ? 1 : 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7udkpul5/tmp7udkpul5.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb881d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb87ecfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb87ecf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb87ece7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7udkpul5                        0x0000563b38f51676 <unavailable> + 5750

    5    libc.so.6                          0x00002acb883c4460 __libc_start_main +
    245

    6    tmp7udkpul5                        0x0000563b38f51209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max_fill = 0\n    for row in grid {\n        max_fill = 0\n   \
    \     for column in row {\n            if column == 1 {\n                max_fill\
    \ += 1\n            }\n        }\n        result += max_fill / capacity\n    \
    \    if max_fill % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978555
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var current_fill = 0\n        for well in\
    \ row {\n            if well == 1 {\n                current_fill += 1\n     \
    \       } else {\n                if current_fill > 0 {\n                    result\
    \ += 1\n                    current_fill = 0\n                }\n            }\n\
    \        }\n        if current_fill > 0 {\n            result += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp123gbk_7/tmp123gbk_7.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5cf3576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5cf326db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5cf326d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5cf326c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp123gbk_7                        0x000055a582a0f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5cf3762460 __libc_start_main +
    245

    6    tmp123gbk_7                        0x000055a582a0f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978554
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        var sum = 0\n        for col in row {\n\
    \            sum += col\n        }\n        result += sum / capacity\n       \
    \ if sum % capacity > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var max_fill = 0\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                max_fill += 1\n            }\n  \
    \      }\n    }\n    while max_fill > 0 {\n        for row in grid {\n       \
    \     for cell in row {\n                if cell == 1 {\n                    max_fill\
    \ -= 1\n                }\n            }\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1uoei99w/tmp1uoei99w.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31ada09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31ad700b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31ad700988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31ad6ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1uoei99w                        0x000055b73d273546 <unavailable> + 5446

    5    libc.so.6                          0x00002b31adbf5460 __libc_start_main +
    245

    6    tmp1uoei99w                        0x000055b73d2730d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978555
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var count =\
    \ 0\n    var wells = grid\n    var max_fill = capacity\n    for i in 0..<wells.count\
    \ {\n        var fill = 0\n        for j in 0..<wells[i].count {\n           \
    \ if wells[i][j] == 1 {\n                fill += 1\n            }\n        }\n\
    \        if fill > max_fill {\n            max_fill = fill\n        }\n    }\n\
    \    while max_fill > 0 {\n        for i in 0..<wells.count {\n            var\
    \ fill = 0\n            for j in 0..<wells[i].count {\n                if wells[i][j]\
    \ == 1 {\n                    fill += 1\n                }\n            }\n  \
    \          if fill > 0 {\n                count += 1\n                for j in\
    \ 0..<wells[i].count {\n                    if wells[i][j] == 1 {\n          \
    \              wells[i][j] = 0\n                    }\n                }\n   \
    \         }\n        }\n        max_fill -= 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpyj0ncvj6/tmpyj0ncvj6.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dee22dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dedf24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dedf24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dedf237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyj0ncvj6                        0x0000560757081706 <unavailable> + 5894

    5    libc.so.6                          0x00002b2dee419460 __libc_start_main +
    245

    6    tmpyj0ncvj6                        0x0000560757081299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978555
