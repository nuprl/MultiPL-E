language: swift
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    let reversed_string = String(string_characters.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_characters\
    \ = Array(reversed_string.characters)\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    var current_palindrome_length = 0\n\
    \    var current_palindrome_index = 0\n    var i = 0\n    var j = 0\n    while\
    \ i < string_length {\n        j = 0\n        while j < reversed_string_length\
    \ {\n            if string_characters[i] == reversed_string_characters[j] {\n\
    \                current_palindrome_length += 1\n                current_palindrome_index\
    \ = i\n                i += 1\n                j += 1\n            } else {\n\
    \                if current_palindrome_length > longest_palindrome_length {\n\
    \                    longest_palindrome_length = current_palindrome_length\n \
    \                   longest_palindrome_index = current_palindrome_index\n    \
    \            }\n                current_palindrome_length = 0\n              \
    \  current_palindrome_index = 0\n                i = i - current_palindrome_length\
    \ + 1\n                break\n            }\n        }\n    }\n    if current_palindrome_length\
    \ > longest_palindrome_length {\n        longest_palindrome_length = current_palindrome_length\n\
    \        longest_palindrome_index = current_palindrome_index\n    }\n    let prefix\
    \ = String(string_characters[0..<longest_palindrome_index])\n    let reversed_prefix\
    \ = String(prefix.characters.reverse())\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3f4bd0to.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp3f4bd0to.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp3f4bd0to.swift:9:27: error: no exact matches\
    \ in call to initializer \n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp3f4bd0to.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp3f4bd0to.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp3f4bd0to.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp3f4bd0to.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp3f4bd0to.swift:43:52: error: value of type\
    \ 'String' has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var palindrome_length = 0\n   \
    \ var palindrome_start = 0\n    var palindrome_end = 0\n    var i = 0\n    while\
    \ i < string_length {\n        var j = 0\n        while i - j >= 0 && i + j <\
    \ string_length && string_array[i - j] == string_array[i + j] {\n            j\
    \ += 1\n        }\n        if j * 2 - 1 > palindrome_length {\n            palindrome_length\
    \ = j * 2 - 1\n            palindrome_start = i - j + 1\n            palindrome_end\
    \ = i + j - 1\n        }\n        j = 0\n        while i - j >= 0 && i + j + 1\
    \ < string_length && string_array[i - j] == string_array[i + j + 1] {\n      \
    \      j += 1\n        }\n        if j * 2 > palindrome_length {\n           \
    \ palindrome_length = j * 2\n            palindrome_start = i - j + 1\n      \
    \      palindrome_end = i + j\n        }\n        i += 1\n    }\n    var result\
    \ = \"\"\n    for i in 0..<palindrome_start {\n        result.append(string_array[i])\n\
    \    }\n    for i in (0..<string_length - palindrome_end - 1).reversed() {\n \
    \       result.append(string_array[i])\n    }\n    for i in palindrome_start..<palindrome_end\
    \ + 1 {\n        result.append(string_array[i])\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprk3t44_l.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmprk3t44_l.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let z = z_function(concatenated)\n\
    \    let z_max = z.maxElement()!\n    let z_max_index = z.indexOf(z_max)!\n  \
    \  let prefix = String(string.characters.prefix(string.characters.count - z_max_index))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpkii_79eh.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpkii_79eh.swift:9:13: error:\
    \ cannot find 'z_function' in scope\n    let z = z_function(concatenated)\n  \
    \          ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let lps = longest_palindromic_substring(string:\
    \ concatenated)\n    let prefix = String(string.characters.dropLast(lps.characters.count))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return prefix\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpe1_5qbfx.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpe1_5qbfx.swift:9:15: error:\
    \ cannot find 'longest_palindromic_substring' in scope\n    let lps = longest_palindromic_substring(string:\
    \ concatenated)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let reversed_string_length\
    \ = reversed_string.characters.count\n    var lps = [Int](count: reversed_string_length,\
    \ repeatedValue: 0)\n    var i = 1\n    var j = 0\n    while i < reversed_string_length\
    \ {\n        if reversed_string[i] == reversed_string[j] {\n            lps[i]\
    \ = j + 1\n            i += 1\n            j += 1\n        } else if j > 0 {\n\
    \            j = lps[j - 1]\n        } else {\n            lps[i] = 0\n      \
    \      i += 1\n        }\n    }\n    let prefix_length = string_length - lps[reversed_string_length\
    \ - 1]\n    let prefix = String(string.characters.prefix(prefix_length))\n   \
    \ let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmplhs0un82.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmplhs0un82.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmplhs0un82.swift:10:67:\
    \ error: extra argument 'repeatedValue' in call\n    var lps = [Int](count: reversed_string_length,\
    \ repeatedValue: 0)\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps_h8owoz.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmps_h8owoz.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let str = string.characters.map { String($0) }\n  \
    \  let reversed = str.reverse()\n    let reversed_string = reversed.joinWithSeparator(\"\
    \")\n    let concatenated = string + reversed_string\n    let concatenated_length\
    \ = concatenated.characters.count\n    let concatenated_str = concatenated.characters.map\
    \ { String($0) }\n    let concatenated_suffix_array = suffix_array(concatenated_str)\n\
    \    let concatenated_lcp_array = lcp_array(concatenated_str, suffix_array: concatenated_suffix_array)\n\
    \    var max_lcp_index = 0\n    var max_lcp = 0\n    for i in 0..<concatenated_lcp_array.count\
    \ {\n        let lcp = concatenated_lcp_array[i]\n        if lcp > max_lcp {\n\
    \            max_lcp = lcp\n            max_lcp_index = i\n        }\n    }\n\
    \    let palindrome_suffix_index = concatenated_suffix_array[max_lcp_index]\n\
    \    let palindrome_suffix = concatenated.substringFromIndex(concatenated.startIndex.advancedBy(palindrome_suffix_index))\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - palindrome_suffix.characters.count))\n    let reversed_prefix = prefix.characters.reverse().map\
    \ { String($0) }.joinWithSeparator(\"\")\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8my9_k8k.swift:7:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let str = string.characters.map { String($0) }\n  \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8my9_k8k.swift:8:24: error: cannot use mutating member on immutable\
    \ value: 'str' is a 'let' constant\n    let reversed = str.reverse()\n       \
    \            ~~~ ^\n/tmp/tmp8my9_k8k.swift:7:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let str = string.characters.map { String($0) }\n    ^~~\n\
    \    var\n/tmp/tmp8my9_k8k.swift:13:37: error: cannot find 'suffix_array' in scope\n\
    \    let concatenated_suffix_array = suffix_array(concatenated_str)\n        \
    \                            ^~~~~~~~~~~~\n/tmp/tmp8my9_k8k.swift:14:34: error:\
    \ cannot find 'lcp_array' in scope\n    let concatenated_lcp_array = lcp_array(concatenated_str,\
    \ suffix_array: concatenated_suffix_array)\n                                 ^~~~~~~~~\n\
    /tmp/tmp8my9_k8k.swift:26:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - palindrome_suffix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp8my9_k8k.swift:26:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - palindrome_suffix.characters.count))\n                                   \
    \      ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.last!))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpruqq2sk5.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpruqq2sk5.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_palindromic_substring(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.characters.count))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpvovusgqc.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpvovusgqc.swift:9:15: error:\
    \ cannot find 'longest_palindromic_substring' in scope\n    let lps = longest_palindromic_substring(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_chars = Array(reversed_string.characters)\n    \n   \
    \ var longest_palindrome_suffix_length = 0\n    var longest_palindrome_suffix_index\
    \ = 0\n    \n    for i in 0..<string_length {\n        let suffix_length = string_length\
    \ - i\n        let suffix = String(string_chars[i..<string_length])\n        let\
    \ reversed_suffix = String(reversed_string_chars[0..<suffix_length])\n       \
    \ \n        if suffix == reversed_suffix {\n            longest_palindrome_suffix_length\
    \ = suffix_length\n            longest_palindrome_suffix_index = i\n        }\n\
    \    }\n    \n    let prefix = String(string_chars[0..<longest_palindrome_suffix_index])\n\
    \    let reversed_prefix = String(reversed_string_chars[longest_palindrome_suffix_length..<string_length])\n\
    \    \n    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpfaylryzn.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpfaylryzn.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfaylryzn.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpfaylryzn.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpfaylryzn.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpfaylryzn.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpfaylryzn.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \    \n    var longest_palindrome_length = 0\n    var longest_palindrome_index\
    \ = 0\n    \n    for i in 0..<string_length {\n        var j = 0\n        while\
    \ j < string_length - i && string_array[i + j] == reversed_string_array[j] {\n\
    \            j += 1\n        }\n        if j > longest_palindrome_length {\n \
    \           longest_palindrome_length = j\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    \n    var result = string\n    for i in 0..<string_length\
    \ - longest_palindrome_length {\n        result.append(reversed_string_array[i])\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmprap26e07.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmprap26e07.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprap26e07.swift:9:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmprap26e07.swift:12:9: warning: variable\
    \ 'longest_palindrome_index' was written to, but never read\n    var longest_palindrome_index\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let z = z_function(combined)\n\
    \    let z_max = z.maxElement()!\n    let z_max_index = z.indexOf(z_max)!\n  \
    \  let prefix = string[string.startIndex..<string.startIndex.advancedBy(z_max_index)]\n\
    \    let suffix = reversed[reversed.startIndex..<reversed.startIndex.advancedBy(z_max)]\n\
    \    return string + String(prefix.characters.reverse()) + suffix\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprzcjdp4y.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmprzcjdp4y.swift:9:13: error:\
    \ cannot find 'z_function' in scope\n    let z = z_function(combined)\n      \
    \      ^~~~~~~~~~\n/tmp/tmprzcjdp4y.swift:12:63: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n    let prefix = string[string.startIndex..<string.startIndex.advancedBy(z_max_index)]\n\
    \                                            ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps_h8owoz.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmps_h8owoz.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    var\
    \ longest_prefix_suffix_length = 0\n    for i in 1..<string_with_reversed_prefix_length\
    \ {\n        var j = longest_prefix_suffix[i - 1]\n        while j > 0 && string_with_reversed_prefix[i]\
    \ != string_with_reversed_prefix[j] {\n            j = longest_prefix_suffix[j\
    \ - 1]\n        }\n        if string_with_reversed_prefix[i] == string_with_reversed_prefix[j]\
    \ {\n            j += 1\n        }\n        longest_prefix_suffix[i] = j\n   \
    \     if j > longest_prefix_suffix_length {\n            longest_prefix_suffix_length\
    \ = j\n        }\n    }\n    let prefix_length = string_length - longest_prefix_suffix_length\n\
    \    let prefix = reversed_string[0..<prefix_length]\n    return string + prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbreijwlf.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpbreijwlf.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpbreijwlf.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_start = 0\n    var longest_palindrome_end = 0\n\
    \    var is_palindrome = Array(count: string_length, repeatedValue: Array(count:\
    \ string_length, repeatedValue: false))\n    for i in 0..<string_length {\n  \
    \      is_palindrome[i][i] = true\n    }\n    for i in 0..<string_length - 1 {\n\
    \        if string_array[i] == string_array[i + 1] {\n            is_palindrome[i][i\
    \ + 1] = true\n            longest_palindrome_length = 2\n            longest_palindrome_start\
    \ = i\n            longest_palindrome_end = i + 1\n        }\n    }\n    for i\
    \ in 2..<string_length {\n        for j in 0..<string_length - i {\n         \
    \   if string_array[j] == string_array[j + i] && is_palindrome[j + 1][j + i -\
    \ 1] {\n                is_palindrome[j][j + i] = true\n                longest_palindrome_length\
    \ = i + 1\n                longest_palindrome_start = j\n                longest_palindrome_end\
    \ = j + i\n            }\n        }\n    }\n    var result = \"\"\n    for i in\
    \ 0..<longest_palindrome_start {\n        result.append(string_array[i])\n   \
    \ }\n    for i in (longest_palindrome_end + 1).stride(to: string_length, by: 1)\
    \ {\n        result.append(string_array[i])\n    }\n    for i in (longest_palindrome_start\
    \ - 1).stride(to: -1, by: -1) {\n        result.append(string_array[i])\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp3k971at8.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp3k971at8.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3k971at8.swift:12:25: error: no exact matches in call\
    \ to initializer \n    var is_palindrome = Array(count: string_length, repeatedValue:\
    \ Array(count: string_length, repeatedValue: false))\n                       \
    \ ^\n/tmp/tmp3k971at8.swift:12:25: note: candidate has partially matching parameter\
    \ list (repeating: _, count: Int)\n    var is_palindrome = Array(count: string_length,\
    \ repeatedValue: Array(count: string_length, repeatedValue: false))\n        \
    \                ^\n/tmp/tmp3k971at8.swift:12:25: note: candidate has partially\
    \ matching parameter list (repeating: _, count: Int)\n    var is_palindrome =\
    \ Array(count: string_length, repeatedValue: Array(count: string_length, repeatedValue:\
    \ false))\n                        ^\n/tmp/tmp3k971at8.swift:12:111: error: extra\
    \ argument 'repeatedValue' in call\n    var is_palindrome = Array(count: string_length,\
    \ repeatedValue: Array(count: string_length, repeatedValue: false))\n        \
    \                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmp3k971at8.swift:12:74: error: missing argument for parameter 'repeating'\
    \ in call\n    var is_palindrome = Array(count: string_length, repeatedValue:\
    \ Array(count: string_length, repeatedValue: false))\n                       \
    \                                                  ^\n                       \
    \                                                  repeating: <#_#>, \nSwift."
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    let reversed_string = String(string_characters.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_characters\
    \ = Array(reversed_string.characters)\n    let reversed_string_characters_length\
    \ = reversed_string_characters.count\n    var longest_prefix_length = 0\n    var\
    \ longest_prefix_index = 0\n    var longest_suffix_length = 0\n    var longest_suffix_index\
    \ = 0\n    var longest_prefix_suffix_length = 0\n    var longest_prefix_suffix_index\
    \ = 0\n    var longest_suffix_prefix_length = 0\n    var longest_suffix_prefix_index\
    \ = 0\n    var longest_prefix_suffix_length_index = 0\n    var longest_suffix_prefix_length_index\
    \ = 0\n    var longest_prefix_suffix_length_index_length = 0\n    var longest_suffix_prefix_length_index_length\
    \ = 0\n    var longest_prefix_suffix_length_index_length_index = 0\n    var longest_suffix_prefix_length_index_length_index\
    \ = 0\n    var longest_prefix_suffix_length_index_length_index_length = 0\n  \
    \  var longest_suffix_prefix_length_index_length_index_length = 0\n    var longest_prefix_suffix_length_index_length_index_length_index\
    \ = 0\n    var longest_suffix_prefix_length_index_length_index_length_index =\
    \ 0\n    var longest_prefix_suffix_length_index_length_index_length_index_length\
    \ = 0\n    var longest_suffix_prefix_length_index_length_index_length_index_length\
    \ = 0\n    var longest_prefix_suffix_length_index_length_index_length_index_length_index\
    \ = 0\n    var longest_suffix_prefix_length_index_length_index_length_index_length_index\
    \ = 0\n    var longest_prefix_suffix_length_index_length_index_length_index_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmph5_eehyy.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmph5_eehyy.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmph5_eehyy.swift:9:27: error: no exact matches\
    \ in call to initializer \n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmph5_eehyy.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmph5_eehyy.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmph5_eehyy.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmph5_eehyy.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmph5_eehyy.swift:35:9: error: type annotation\
    \ missing in pattern\n    var longest_prefix_suffix_length_index_length_index_length_index_\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let longest_common_postfix = longest_common_substring(string, reversed)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_postfix.characters.count))\n    return prefix + reversed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpegai5v_y.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpegai5v_y.swift:8:34: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_postfix\
    \ = longest_common_substring(string, reversed)\n                             \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpegai5v_y.swift:9:25: error: value of type\
    \ 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_postfix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpegai5v_y.swift:9:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_postfix.characters.count))\n                              \
    \           ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    var longest_palindrome_end =\
    \ 0\n    var palindrome_length = 0\n    var palindrome_start = 0\n    var palindrome_end\
    \ = 0\n    var i = 0\n    while i < string_length {\n        // Find the longest\
    \ palindrome that starts at i.\n        palindrome_length = 1\n        palindrome_start\
    \ = i\n        palindrome_end = i\n        while palindrome_start > 0 && palindrome_end\
    \ < string_length - 1 && string_characters[palindrome_start - 1] == string_characters[palindrome_end\
    \ + 1] {\n            palindrome_length += 2\n            palindrome_start -=\
    \ 1\n            palindrome_end += 1\n        }\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_start = palindrome_start\n            longest_palindrome_end\
    \ = palindrome_end\n        }\n        // Find the longest palindrome that starts\
    \ at i and i + 1.\n        if i < string_length - 1 && string_characters[i] ==\
    \ string_characters[i + 1] {\n            palindrome_length = 2\n            palindrome_start\
    \ = i\n            palindrome_end = i + 1\n            while palindrome_start\
    \ > 0 && palindrome_end < string_length - 1 && string_characters[palindrome_start\
    \ - 1] == string_characters[palindrome_end + 1] {\n                palindrome_length\
    \ += 2\n                palindrome_start -= 1\n                palindrome_end\
    \ += 1\n            }\n            if palindrome_length > longest_palindrome_length\
    \ {\n                longest_palindrome_length = palindrome_length\n         \
    \       longest_palindrome_start = palindrome_start\n                longest_palindrome_end\
    \ = palind\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp7g3jz6b2.swift:64:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmp7g3jz6b2.swift:32:86: note:\
    \ to match this opening '{'\n        if i < string_length - 1 && string_characters[i]\
    \ == string_characters[i + 1] {\n                                            \
    \                                         ^\n/tmp/tmp7g3jz6b2.swift:64:56: error:\
    \ expected '}' at end of brace statement\nassert(make_palindrome(string: \"jerry\"\
    ) == \"jerryrrej\")\n                                                       ^\n\
    /tmp/tmp7g3jz6b2.swift:16:29: note: to match this opening '{'\n    while i < string_length\
    \ {\n                            ^\n/tmp/tmp7g3jz6b2.swift:64:56: error: expected\
    \ '}' at end of brace statement\nassert(make_palindrome(string: \"jerry\") ==\
    \ \"jerryrrej\")\n                                                       ^\n/tmp/tmp7g3jz6b2.swift:6:48:\
    \ note: to match this opening '{'\nfunc make_palindrome(string: String) -> String\
    \ {\n                                               ^\n/tmp/tmp7g3jz6b2.swift:7:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp7g3jz6b2.swift:8:42: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp7g3jz6b2.swift:44:42: error: cannot find\
    \ 'palind' in scope\n                longest_palindrome_end = palind\n       \
    \                                  ^~~~~~\n/tmp/tmp7g3jz6b2.swift:48:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    "
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    if string.isEmpty {\n        return \"\"\n    }\n \
    \   let reversed = String(string.reversed())\n    let string_length = string.count\n\
    \    let reversed_length = reversed.count\n    let max_length = string_length\
    \ + reversed_length\n    let string_with_reversed = string + \"#\" + reversed\n\
    \    let z_function = z_function_naive(string: string_with_reversed)\n    var\
    \ max_palindrome_length = 0\n    var max_palindrome_index = 0\n    for index in\
    \ 0..<max_length {\n        if z_function[index] == string_length {\n        \
    \    max_palindrome_length = string_length\n            max_palindrome_index =\
    \ index\n            break\n        }\n    }\n    if max_palindrome_length ==\
    \ 0 {\n        for index in 0..<max_length {\n            if z_function[index]\
    \ > max_palindrome_length {\n                max_palindrome_length = z_function[index]\n\
    \                max_palindrome_index = index\n            }\n        }\n    }\n\
    \    let prefix = String(string[..<string.index(string.startIndex, offsetBy: string_length\
    \ - max_palindrome_length)])\n    let reversed_prefix = String(prefix.reversed())\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpp3_w3yza.swift:15:22: error: cannot find 'z_function_naive' in\
    \ scope\n    let z_function = z_function_naive(string: string_with_reversed)\n\
    \                     ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb4b27fj1.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpb4b27fj1.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb4b27fj1.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpb4b27fj1.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmsmg4uzf.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpmsmg4uzf.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmsmg4uzf.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n       \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpmsmg4uzf.swift:10:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.characters.reverse()\n    let\
    \ reversed_string = String(reversed)\n    let string_length = string.characters.count\n\
    \    let reversed_string_length = reversed_string.characters.count\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var table = [[Int]](count: string_length,\
    \ repeatedValue: [Int](count: reversed_string_length, repeatedValue: 0))\n   \
    \ for i in 0..<string_length {\n        for j in 0..<reversed_string_length {\n\
    \            if string[i] == reversed_string[j] {\n                if i == 0 ||\
    \ j == 0 {\n                    table[i][j] = 1\n                } else {\n  \
    \                  table[i][j] = table[i - 1][j - 1] + 1\n                }\n\
    \                if table[i][j] > longest_palindrome_length {\n              \
    \      longest_palindrome_length = table[i][j]\n                    longest_palindrome_index\
    \ = i\n                }\n            }\n        }\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + 1))\n    let reversed_prefix = prefix.characters.reverse()\n    let reversed_prefix_string\
    \ = String(reversed_prefix)\n    return prefix + reversed_prefix_string\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpuw255dwl.swift:7:38: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.characters.reverse()\n                \
    \   ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpuw255dwl.swift:9:32: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpuw255dwl.swift:13:17: error: no exact matches in call\
    \ to initializer \n    var table = [[Int]](count: string_length, repeatedValue:\
    \ [Int](count: reversed_string_length, repeatedValue: 0))\n                ^\n\
    /tmp/tmpuw255dwl.swift:13:17: note: found candidate with type '([Int], Int) ->\
    \ [[Int]]'\n    var table = [[Int]](count: string_length, repeatedValue: [Int](count:\
    \ reversed_string_length, repeatedValue: 0))\n                ^\n/tmp/tmpuw255dwl.swift:13:114:\
    \ error: extra argument 'repeatedValue' in call\n    var table = [[Int]](count:\
    \ string_length, repeatedValue: [Int](count: reversed_string_length, repeatedValue:\
    \ 0))\n                                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpuw255dwl.swift:29:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + 1))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpuw255dwl.swift:29:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + 1))\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    var palindrome_array = [Character]()\n    var\
    \ i = 0\n    while i < string_length {\n        var j = 0\n        while i - j\
    \ >= 0 && i + j < string_length && string_array[i - j] == string_array[i + j]\
    \ {\n            j += 1\n        }\n        j -= 1\n        if j > palindrome_length\
    \ {\n            palindrome_length = j\n            palindrome_index = i\n   \
    \     }\n        i += 1\n    }\n    i = 0\n    while i < string_length {\n   \
    \     var j = 0\n        while i - j >= 0 && i + j + 1 < string_length && string_array[i\
    \ - j] == string_array[i + j + 1] {\n            j += 1\n        }\n        j\
    \ -= 1\n        if j > palindrome_length {\n            palindrome_length = j\n\
    \            palindrome_index = i\n        }\n        i += 1\n    }\n    i = 0\n\
    \    while i < palindrome_index - palindrome_length {\n        palindrome_array.append(string_array[palindrome_index\
    \ - palindrome_length - i - 1])\n        i += 1\n    }\n    i = 0\n    while i\
    \ < string_length {\n        palindrome_array.append(string_array[i])\n      \
    \  i += 1\n    }\n    i = 0\n    while i < palindrome_index - palindrome_length\
    \ {\n        palindrome_array.append(string_array[palindrome_index - palindrome_length\
    \ - i - 1])\n        i += 1\n    }\n    return String(palindrome_array)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpruba_eka.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpruba_eka.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_array\
    \ = Array(string)\n    var string_reversed = string_array.reversed()\n    var\
    \ longest_palindrome_length = 0\n    var longest_palindrome_position = 0\n   \
    \ var current_palindrome_length = 0\n    var current_palindrome_position = 0\n\
    \    var current_palindrome_position_reversed = 0\n    var current_palindrome_length_reversed\
    \ = 0\n    var i = 0\n    var j = 0\n    while i < string_length {\n        j\
    \ = 0\n        while j < string_length - i {\n            if string_array[i +\
    \ j] == string_reversed[j] {\n                current_palindrome_length += 1\n\
    \                current_palindrome_position = i\n            } else {\n     \
    \           break\n            }\n            j += 1\n        }\n        if current_palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = current_palindrome_length\n\
    \            longest_palindrome_position = current_palindrome_position\n     \
    \   }\n        current_palindrome_length = 0\n        i += 1\n    }\n    i = 0\n\
    \    while i < string_length {\n        j = 0\n        while j < string_length\
    \ - i {\n            if string_array[i + j] == string_reversed[string_length -\
    \ 1 - i - j] {\n                current_palindrome_length_reversed += 1\n    \
    \            current_palindrome_position_reversed = i\n            } else {\n\
    \                break\n            }\n            j += 1\n        }\n       \
    \ if current_palindrome_length_reversed > longest_palindrome_length {\n      \
    \      longest_palindrome_length = current_palindrome_length_reversed\n      \
    \      longest_palindrome_position = current_palindrome_position_reversed\n  \
    \      }\n        current_palindrome_length_reversed = 0\n        i += 1\n   \
    \ }\n    let prefix = string_array[0..<longest_palindrome_position].\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpcsl7lno1.swift:55:63: error: expected member name following '.'\n\
    \    let prefix = string_array[0..<longest_palindrome_position].\n           \
    \                                                   ^\n/tmp/tmpcsl7lno1.swift:21:55:\
    \ error: cannot convert value of type 'Int' to expected argument type 'ReversedCollection<[String.Element]>.Index'\
    \ (aka 'ReversedCollection<Array<Character>>.Index')\n            if string_array[i\
    \ + j] == string_reversed[j] {\n                                             \
    \         ^\n/tmp/tmpcsl7lno1.swift:40:77: error: cannot convert value of type\
    \ 'Int' to expected argument type 'ReversedCollection<[String.Element]>.Index'\
    \ (aka 'ReversedCollection<Array<Character>>.Index')\n            if string_array[i\
    \ + j] == string_reversed[string_length - 1 - i - j] {\n                     \
    \                                                       ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ suffix_is_palindrome = false\n    while !suffix_is_palindrome {\n        suffix_length\
    \ += 1\n        suffix_is_palindrome = true\n        for i in 0..<suffix_length/2\
    \ {\n            if string_chars[string_length - suffix_length + i] != string_chars[string_length\
    \ - i - 1] {\n                suffix_is_palindrome = false\n                break\n\
    \            }\n        }\n    }\n    var prefix_length = string_length - suffix_length\n\
    \    var prefix_chars = [Character](repeating: \" \", count: prefix_length)\n\
    \    for i in 0..<prefix_length {\n        prefix_chars[i] = string_chars[i]\n\
    \    }\n    return String(string_chars + prefix_chars.reversed())\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5oachqqo.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5oachqqo.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5oachqqo.swift:21:9: warning: variable 'prefix_length'\
    \ was never mutated; consider changing to 'let' constant\n    var prefix_length\
    \ = string_length - suffix_length\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps.last!))\n    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9ylv10h7.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp9ylv10h7.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = reversed.substringFromIndex(reversed.startIndex.advancedBy(lps))\n\
    \    return prefix + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpmft9s6a4.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpmft9s6a4.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmft9s6a4.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpmft9s6a4.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string: string_characters,\
    \ start: 0, end: string_length - i - 1) {\n            palindrome_suffix_length\
    \ = string_length - i\n            break\n        }\n    }\n    var result = string\n\
    \    for i in 0..<string_length - palindrome_suffix_length {\n        result.append(string_characters[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpltvbjz7b.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpltvbjz7b.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpltvbjz7b.swift:11:12: error: cannot find\
    \ 'is_palindrome' in scope\n        if is_palindrome(string: string_characters,\
    \ start: 0, end: string_length - i - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var prefix_length = 0\n  \
    \  var suffix_length = 0\n    var suffix_start = 0\n    var suffix_end = 0\n \
    \   var prefix_start = 0\n    var prefix_end = 0\n    var palindrome_length =\
    \ 0\n    var palindrome_start = 0\n    var palindrome_end = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var m = 0\n    var n = 0\n    var p = 0\n \
    \   var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n  \
    \  var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n   \
    \ var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae = 0\n\
    \    var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj =\
    \ 0\n    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var ao\
    \ = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n    var\
    \ at = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n   \
    \ var ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc = 0\n\
    \    var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh =\
    \ 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var bm\
    \ = 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n    var\
    \ br = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n   \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxqwwkegn.swift:52:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpxqwwkegn.swift:52:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpxqwwkegn.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpxqwwkegn.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpxqwwkegn.swift:7:9: warning: initialization\
    \ of immutable value 'string_length' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let string_length = string.characters.count\n   \
    \ ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpxqwwkegn.swift:8:9: warning: initialization\
    \ of immutable value 'string_characters' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    let string_characters = Array(string.characters)\n\
    \    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpxqwwkegn.swift:9:9: warning: initialization\
    \ of variable 'prefix_length' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var prefix_length = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmpxqwwkegn.swift:10:9: warning: initialization of variable 'suffix_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var suffix_length = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpxqwwkegn.swift:11:9:\
    \ warning: initialization of variable 'suffix_start' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var suffix_start = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpxqwwkegn.swift:12:9: warning: initialization\
    \ of variable 's"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_chars\
    \ = Array(reversed_string.characters)\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_start = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = 0\n        while j < reversed_string_length {\n         \
    \   var k = 0\n            while k < string_length - i && k < reversed_string_length\
    \ - j && string_chars[i + k] == reversed_string_chars[j + k] {\n             \
    \   k += 1\n            }\n            if k > longest_palindrome_length {\n  \
    \              longest_palindrome_length = k\n                longest_palindrome_start\
    \ = i\n            }\n            j += 1\n        }\n        i += 1\n    }\n \
    \   return string + String(string_chars[0..<longest_palindrome_start].reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpl6ytlzrt.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpl6ytlzrt.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpl6ytlzrt.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpl6ytlzrt.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpl6ytlzrt.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpl6ytlzrt.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpl6ytlzrt.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpl6ytlzrt.swift:30:21: error: type '()' cannot\
    \ conform to 'LosslessStringConvertible'\n    return string + String(string_chars[0..<longest_palindrome_start].reverse())\n\
    \                    ^\n/tmp/tmpl6ytlzrt.swift:30:21: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n    return string\
    \ + String(string_chars[0..<longest_palindrome_start].reverse())\n           \
    \         ^\n/tmp/tmpl6ytlzrt.swift:30:21: note: required by initializer 'init(_:)'\
    \ where 'T' = '()'\n    return string + String(string_chars[0..<longest_palindrome_start].reverse())\n\
    \              "
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    var suffix_length = 0\n    var suffix_start = 0\n    var\
    \ prefix_length = 0\n    var prefix_start = 0\n    var palindrome_length = 0\n\
    \    var palindrome_start = 0\n    var palindrome_end = 0\n    var i = 0\n   \
    \ var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t\
    \ = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y =\
    \ 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad\
    \ = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n    var\
    \ ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n   \
    \ var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n\
    \    var as = 0\n    var at = 0\n    var au = 0\n    var av = 0\n    var aw =\
    \ 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba = 0\n    var bb\
    \ = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n    var\
    \ bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n   \
    \ var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n\
    \    var bq = 0\n    var br = 0\n    var bs = 0\n    var bt = 0\n    var bu =\
    \ 0\n    var bv = 0\n    var bw = 0\n    var bx\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp0n0pmfb3.swift:52:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmp0n0pmfb3.swift:52:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmp0n0pmfb3.swift:83:9: error: type annotation missing in\
    \ pattern\n    var bx\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    var\
    \ longest_prefix_suffix_length = 0\n    for i in 1..<string_with_reversed_prefix_length\
    \ {\n        var j = longest_prefix_suffix[i - 1]\n        while j > 0 && string_with_reversed_prefix[i]\
    \ != string_with_reversed_prefix[j] {\n            j = longest_prefix_suffix[j\
    \ - 1]\n        }\n        if string_with_reversed_prefix[i] == string_with_reversed_prefix[j]\
    \ {\n            j += 1\n        }\n        longest_prefix_suffix[i] = j\n   \
    \     if j > longest_prefix_suffix_length {\n            longest_prefix_suffix_length\
    \ = j\n        }\n    }\n    let prefix_length = string_length - longest_prefix_suffix_length\n\
    \    let prefix = reversed_string[0..<prefix_length]\n    return string + prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbreijwlf.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpbreijwlf.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpbreijwlf.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_end = 0\n    var longest_palindrome_start = 0\n\
    \    var longest_palindrome_end_index = 0\n    var longest_palindrome_start_index\
    \ = 0\n    var longest_palindrome_length_array = [Int](count: string_length, repeatedValue:\
    \ 0)\n    for i in 0..<string_length {\n        longest_palindrome_length_array[i]\
    \ = 0\n    }\n    for i in 0..<string_length {\n        let mirror_index = 2 *\
    \ string_length - i - 1\n        if i > longest_palindrome_end {\n           \
    \ longest_palindrome_length_array[i] = 0\n        } else {\n            longest_palindrome_length_array[i]\
    \ = min(longest_palindrome_end - i, longest_palindrome_length_array[mirror_index])\n\
    \        }\n        while i - 1 - longest_palindrome_length_array[i] >= 0 && i\
    \ + 1 + longest_palindrome_length_array[i] < string_length && string_array[i -\
    \ 1 - longest_palindrome_length_array[i]] == string_array[i + 1 + longest_palindrome_length_array[i]]\
    \ {\n            longest_palindrome_length_array[i] += 1\n        }\n        if\
    \ i + longest_palindrome_length_array[i] > longest_palindrome_end {\n        \
    \    longest_palindrome_end = i + longest_palindrome_length_array[i]\n       \
    \     longest_palindrome_start = i - longest_palindrome_length_array[i]\n    \
    \    }\n        if longest_palindrome_length_array[i] > longest_palindrome_length\
    \ {\n            longest_palindrome_length = longest_palindrome_length_array[i]\n\
    \            longest_palindrome_end_index = i\n            longest_palindrome_start_index\
    \ = i - longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp6oihaquv.swift:55:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmp6oihaquv.swift:18:32: note:\
    \ to match this opening '{'\n    for i in 0..<string_length {\n              \
    \                 ^\n/tmp/tmp6oihaquv.swift:55:56: error: expected '}' at end\
    \ of brace statement\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )\n                                                       ^\n/tmp/tmp6oihaquv.swift:6:48:\
    \ note: to match this opening '{'\nfunc make_palindrome(string: String) -> String\
    \ {\n                                               ^\n/tmp/tmp6oihaquv.swift:7:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp6oihaquv.swift:8:37: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6oihaquv.swift:14:43: error: no exact matches in call\
    \ to initializer \n    var longest_palindrome_length_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n                                          ^\n/tmp/tmp6oihaquv.swift:14:43:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var longest_palindrome_length_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n                                          ^\n/tmp/tmp6oihaquv.swift:14:43:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var longest_palindrome_length_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n                                          ^\n/tmp/tmp6oihaquv.swift:35:50:\
    \ error: cannot find 'longest'"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_chars = Array(reversed_string.characters)\n    \n   \
    \ let lps = longest_palindromic_suffix(string: string)\n    let lps_length = lps.characters.count\n\
    \    \n    let prefix = String(string_chars[0..<(string_length - lps_length)])\n\
    \    let prefix_chars = Array(prefix.characters)\n    let reversed_prefix = String(prefix_chars.reverse())\n\
    \    \n    return prefix + reversed_prefix + lps\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphs89wunw.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmphs89wunw.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphs89wunw.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmphs89wunw.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmphs89wunw.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmphs89wunw.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmphs89wunw.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmphs89wunw.swift:12:15: error: cannot find\
    \ 'longest_palindromic_suffix' in scope\n    let lps = longest_palindromic_suffix(string:\
    \ string)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.characters.reverse()\n    let\
    \ combined = string + \"#\" + String(reversed)\n    let z = z_function(combined)\n\
    \    let z_max = z.maxElement()!\n    let end_index = z.indexOf(z_max)!\n    let\
    \ prefix = string.substringToIndex(string.startIndex.advancedBy(end_index))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp4v1q7icp.swift:7:38: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.characters.reverse()\n                \
    \   ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp4v1q7icp.swift:9:13: error: cannot find\
    \ 'z_function' in scope\n    let z = z_function(combined)\n            ^~~~~~~~~~\n\
    /tmp/tmp4v1q7icp.swift:12:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(end_index))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp4v1q7icp.swift:12:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(end_index))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmsmg4uzf.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpmsmg4uzf.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmsmg4uzf.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n       \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpmsmg4uzf.swift:10:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ suffix_palindrome_length = 0\n    var suffix_palindrome_start = 0\n    var suffix_palindrome_end\
    \ = 0\n    var prefix_length = 0\n    var prefix_palindrome_length = 0\n    var\
    \ prefix_palindrome_start = 0\n    var prefix_palindrome_end = 0\n    var palindrome_length\
    \ = 0\n    var palindrome_start = 0\n    var palindrome_end = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac = 0\n \
    \   var ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n\
    \    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n    var am =\
    \ 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n    var ar\
    \ = 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var av = 0\n    var\
    \ aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba = 0\n   \
    \ var bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n\
    \    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n    var bk =\
    \ 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6yq5bmsb.swift:56:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmp6yq5bmsb.swift:56:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmp6yq5bmsb.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6yq5bmsb.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6yq5bmsb.swift:78:9: error: type annotation missing\
    \ in pattern\n    var bo\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var string_array_reversed = string_array.reverse()\n\
    \    var string_array_reversed_length = string_array_reversed.count\n    var string_array_reversed_index\
    \ = 0\n    var string_array_index = 0\n    var string_array_index_max = 0\n  \
    \  var string_array_index_max_length = 0\n    var string_array_index_max_length_max\
    \ = 0\n    var string_array_index_max_length_max_index = 0\n    var string_array_index_max_length_max_index_max\
    \ = 0\n    var string_array_index_max_length_max_index_max_length = 0\n    var\
    \ string_array_index_max_length_max_index_max_length_max = 0\n    var string_array_index_max_length_max_index_max_length_max_index\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max_length\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max_length_max\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max_length_max_index\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max_length_max_index_max\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max_length_max_index_max_length\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max_length_max_index_max_length_max\
    \ = 0\n    var string_array_index_max_length_max_index_max_length_max_index_max_length_max_index\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpco70czyn.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpco70czyn.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpco70czyn.swift:9:46: error: cannot use mutating member\
    \ on immutable value: 'string_array' is a 'let' constant\n    var string_array_reversed\
    \ = string_array.reverse()\n                                ~~~~~~~~~~~~ ^\n/tmp/tmpco70czyn.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let string_array = Array(string.characters)\n\
    \    ^~~\n    var\n/tmp/tmpco70czyn.swift:28:9: error: type annotation missing\
    \ in pattern\n    var string_array_index_max_length_max_index_max_length_max_index_max_length_max_index\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var i = 0\n    var j = string_length\
    \ - 1\n    while i < j {\n        if string_array[i] != string_array[j] {\n  \
    \          break\n        }\n        i += 1\n        j -= 1\n    }\n    if i >=\
    \ j {\n        return string\n    }\n    var prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: i))\n    var suffix = string.substring(from: string.index(string.startIndex,\
    \ offsetBy: j + 1))\n    return prefix + String(suffix.characters.reversed())\
    \ + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpzc0nk5ps.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpzc0nk5ps.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpzc0nk5ps.swift:21:25: error: value of type 'String'\
    \ has no member 'substring'\n    var prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: i))\n                 ~~~~~~ ^~~~~~~~~\n/tmp/tmpzc0nk5ps.swift:22:25:\
    \ error: value of type 'String' has no member 'substring'\n    var suffix = string.substring(from:\
    \ string.index(string.startIndex, offsetBy: j + 1))\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    if\
    \ string_length == 0 {\n        return \"\"\n    }\n    if string_length == 1\
    \ {\n        return string\n    }\n    let string_array = Array(string.characters)\n\
    \    let reversed_string_array = Array(string.characters.reversed())\n    var\
    \ longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n    var\
    \ current_palindrome_length = 0\n    var current_palindrome_index = 0\n    for\
    \ i in 0..<string_length {\n        if string_array[i] == reversed_string_array[i]\
    \ {\n            current_palindrome_length += 1\n            if current_palindrome_length\
    \ > longest_palindrome_length {\n                longest_palindrome_length = current_palindrome_length\n\
    \                longest_palindrome_index = current_palindrome_index\n       \
    \     }\n        } else {\n            current_palindrome_length = 0\n       \
    \     current_palindrome_index = i + 1\n        }\n    }\n    let prefix = string.substring(to:\
    \ string.index(string.startIndex, offsetBy: longest_palindrome_index))\n    let\
    \ reversed_prefix = String(prefix.characters.reversed())\n    return string +\
    \ reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmph93mmqae.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmph93mmqae.swift:14:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph93mmqae.swift:15:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmph93mmqae.swift:32:25: error: value of type\
    \ 'String' has no member 'substring'\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: longest_palindrome_index))\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reversed()\n    let string_length\
    \ = string.count\n    let reversed_length = reversed.count\n    let string_chars\
    \ = Array(string)\n    let reversed_chars = Array(reversed)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_end = 0\n    var dp = Array(repeating: Array(repeating:\
    \ 0, count: reversed_length + 1), count: string_length + 1)\n    for i in 1...string_length\
    \ {\n        for j in 1...reversed_length {\n            if string_chars[i - 1]\
    \ == reversed_chars[j - 1] {\n                dp[i][j] = dp[i - 1][j - 1] + 1\n\
    \                if dp[i][j] > longest_palindrome_length {\n                 \
    \   longest_palindrome_length = dp[i][j]\n                    longest_palindrome_end\
    \ = i\n                }\n            }\n        }\n    }\n    return string +\
    \ String(string_chars[0..<(string_length - longest_palindrome_end)].reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae311b83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae31187a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae31187a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae31187a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae311879bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpabd4vlzq                        0x00005648a9a754cb <unavailable> + 9419

    6    tmpabd4vlzq                        0x00005648a9a74b85 <unavailable> + 7045

    7    libc.so.6                          0x00002ae311d6f460 __libc_start_main +
    245

    8    tmpabd4vlzq                        0x00005648a9a74889 <unavailable> + 6281

    '
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_start = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = i\n        var k = i\n        while k < string_length - 1\
    \ && string_array[k + 1] == string_array[k] {\n            k += 1\n        }\n\
    \        i = k + 1\n        while k < string_length - 1 && j > 0 && string_array[k\
    \ + 1] == string_array[j - 1] {\n            k += 1\n            j -= 1\n    \
    \    }\n        let new_palindrome_length = k - j + 1\n        if new_palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = new_palindrome_length\n\
    \            longest_palindrome_start = j\n        }\n    }\n    let prefix =\
    \ String(string_array[0..<longest_palindrome_start])\n    let suffix = String(string_array[longest_palindrome_start..<longest_palindrome_start\
    \ + longest_palindrome_length])\n    return prefix + String(suffix.characters.reversed())\
    \ + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmptv59nh8y.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmptv59nh8y.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmptv59nh8y.swift:31:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    return prefix + String(suffix.characters.reversed())\
    \ + suffix\n                                  ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.last!))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpruqq2sk5.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpruqq2sk5.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ suffix_start = 0\n    var prefix_start = 0\n    var prefix_length = 0\n    var\
    \ palindrome_length = 0\n    var palindrome_start = 0\n    var palindrome_end\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n\
    \    var ac = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag =\
    \ 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al\
    \ = 0\n    var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var\
    \ aq = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n   \
    \ var av = 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n\
    \    var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be =\
    \ 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj\
    \ = 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var\
    \ bo = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n   \
    \ var bt = 0\n    var bu = 0\n    var bv = 0\n    var bw =\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmps0ix0gob.swift:52:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmps0ix0gob.swift:52:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmps0ix0gob.swift:82:13: error: expected initial value after\
    \ '='\n    var bw =\n            ^\n/tmp/tmps0ix0gob.swift:7:32: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmps0ix0gob.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \    \n    var longest_palindrome_length = 0\n    var longest_palindrome_index\
    \ = 0\n    \n    // Find the longest palindrome suffix.\n    for i in 0..<string_length\
    \ {\n        var j = 0\n        var k = string_length - 1 - i\n        \n    \
    \    while j < k && string_array[j] == reversed_string_array[k] {\n          \
    \  j += 1\n            k -= 1\n        }\n        \n        if j >= k && string_length\
    \ - i > longest_palindrome_length {\n            longest_palindrome_length = string_length\
    \ - i\n            longest_palindrome_index = i\n        }\n    }\n    \n    //\
    \ Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    var result = string\n    for i in 0..<longest_palindrome_index\
    \ {\n        result.append(reversed_string_array[i])\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmprtkajlcu.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmprtkajlcu.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprtkajlcu.swift:9:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"|\" + reversed\n    let z_array = z_function(combined)\n\
    \    let z_array_without_first_element = Array(z_array[1..<z_array.count])\n \
    \   let max_z_value = z_array_without_first_element.maxElement()!\n    let max_z_index\
    \ = z_array_without_first_element.indexOf(max_z_value)!\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - max_z_index))\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \    return prefix + string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpom3t_28h.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpom3t_28h.swift:9:19: error:\
    \ cannot find 'z_function' in scope\n    let z_array = z_function(combined)\n\
    \                  ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_start = 0\n    var longest_palindrome_end = 0\n\
    \    for i in 0..<string_length {\n        var j = 0\n        while i - j >= 0\
    \ && i + j < string_length && string_array[i - j] == string_array[i + j] {\n \
    \           j += 1\n        }\n        if j > longest_palindrome_length {\n  \
    \          longest_palindrome_length = j\n            longest_palindrome_start\
    \ = i - j + 1\n            longest_palindrome_end = i + j - 1\n        }\n   \
    \ }\n    var result = string\n    for i in longest_palindrome_start - 1..<string_length\
    \ - (longest_palindrome_end - longest_palindrome_start + 1) {\n        result.insert(string_array[i],\
    \ at: result.startIndex)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmplusoruny.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmplusoruny.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    var longest_palindrome_suffix_length = 0\n    for i in\
    \ 0..<string_length {\n        if is_palindrome(string: string_chars[0..<i]) {\n\
    \            longest_palindrome_suffix_length = i\n        }\n    }\n    var prefix\
    \ = Array(string_chars[0..<(string_length - longest_palindrome_suffix_length)])\n\
    \    prefix.reverse()\n    return String(string_chars) + String(prefix)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpfutedi9z.swift:11:12: error: cannot find 'is_palindrome' in scope\n\
    \        if is_palindrome(string: string_chars[0..<i]) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"|\" + reversed\n    let z_array = z_function(combined)\n\
    \    let z_array_reversed = z_array.reverse()\n    let z_array_reversed_without_first\
    \ = Array(z_array_reversed.dropFirst())\n    let z_array_without_last = Array(z_array.dropLast())\n\
    \    let z_array_without_last_and_first = zip(z_array_without_last, z_array_reversed_without_first)\n\
    \    let z_array_without_last_and_first_filtered = z_array_without_last_and_first.filter\
    \ { $0.0 == $0.1 }\n    let z_array_without_last_and_first_filtered_max = z_array_without_last_and_first_filtered.maxElement\
    \ { $0.0 < $1.0 }\n    let z_array_without_last_and_first_filtered_max_value =\
    \ z_array_without_last_and_first_filtered_max?.0\n    let z_array_without_last_and_first_filtered_max_index\
    \ = z_array_without_last_and_first_filtered_max?.1\n    let z_array_without_last_and_first_filtered_max_index_plus_one\
    \ = z_array_without_last_and_first_filtered_max_index! + 1\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - z_array_without_last_and_first_filtered_max_index_plus_one))\n    let prefix_reversed\
    \ = String(prefix.characters.reverse())\n    return string + prefix_reversed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpn0_4awxv.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpn0_4awxv.swift:9:19: error:\
    \ cannot find 'z_function' in scope\n    let z_array = z_function(combined)\n\
    \                  ^~~~~~~~~~\n/tmp/tmpn0_4awxv.swift:16:106: error: type of expression\
    \ is ambiguous without more context\n    let z_array_without_last_and_first_filtered_max_value\
    \ = z_array_without_last_and_first_filtered_max?.0\n                         \
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    /tmp/tmpn0_4awxv.swift:17:106: error: type of expression is ambiguous without\
    \ more context\n    let z_array_without_last_and_first_filtered_max_index = z_array_without_last_and_first_filtered_max?.1\n\
    \                                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let z = z_function(combined)\n\
    \    let z_max = z.maxElement()!\n    let z_max_index = z.indexOf(z_max)!\n  \
    \  let prefix = string[string.startIndex..<string.startIndex.advancedBy(z_max_index)]\n\
    \    let suffix = reversed[reversed.startIndex..<reversed.startIndex.advancedBy(z_max)]\n\
    \    return string + String(prefix.characters.reverse()) + suffix\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprzcjdp4y.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmprzcjdp4y.swift:9:13: error:\
    \ cannot find 'z_function' in scope\n    let z = z_function(combined)\n      \
    \      ^~~~~~~~~~\n/tmp/tmprzcjdp4y.swift:12:63: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n    let prefix = string[string.startIndex..<string.startIndex.advancedBy(z_max_index)]\n\
    \                                            ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var palindrome_length = 0\n   \
    \ var palindrome_start = 0\n    var palindrome_end = 0\n    var i = 0\n    while\
    \ i < string_length {\n        var j = 0\n        while i - j >= 0 && i + j <\
    \ string_length && string_array[i - j] == string_array[i + j] {\n            j\
    \ += 1\n        }\n        if j > palindrome_length {\n            palindrome_length\
    \ = j\n            palindrome_start = i - j + 1\n            palindrome_end =\
    \ i + j - 1\n        }\n        i += 1\n    }\n    var result = string\n    for\
    \ i in 0..<palindrome_start {\n        result.append(string_array[palindrome_start\
    \ - i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpaqia79az.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpaqia79az.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpaqia79az.swift:11:9: warning: variable 'palindrome_end'\
    \ was written to, but never read\n    var palindrome_end = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb4b27fj1.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpb4b27fj1.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var i = 0\n    var j = string_length\
    \ - 1\n    while i < j {\n        if string_characters[i] != string_characters[j]\
    \ {\n            break\n        }\n        i += 1\n        j -= 1\n    }\n   \
    \ if i >= j {\n        return string\n    }\n    let suffix = String(string_characters[i...j])\n\
    \    let prefix = String(string_characters[0..<i])\n    return prefix + suffix\
    \ + String(suffix.characters.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpx4jy9glb.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpx4jy9glb.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpx4jy9glb.swift:23:44: error: 'characters'\
    \ is unavailable: Please use String directly\n    return prefix + suffix + String(suffix.characters.reversed())\n\
    \                                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = i\n        var k = i\n        while k < string_length - 1\
    \ && string_array[k] == string_array[k + 1] {\n            k += 1\n        }\n\
    \        i = k + 1\n        while j > 0 && k < string_length - 1 && string_array[j\
    \ - 1] == string_array[k + 1] {\n            j -= 1\n            k += 1\n    \
    \    }\n        if k - j + 1 > longest_palindrome_length {\n            longest_palindrome_length\
    \ = k - j + 1\n            longest_palindrome_index = j\n        }\n    }\n  \
    \  let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \    let reverse_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reverse_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmptb255hix.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmptb255hix.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmptb255hix.swift:28:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmptb255hix.swift:28:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reverse()\n    let concatenated\
    \ = string + \"#\" + reversed\n    let z_array = z_algorithm(string: concatenated)\n\
    \    let z_array_without_first_element = Array(z_array[1..<z_array.count])\n \
    \   let max_z_value = z_array_without_first_element.maxElement()!\n    let max_z_index\
    \ = z_array_without_first_element.indexOf(max_z_value)!\n    let prefix = string[0..<(string.characters.count\
    \ - max_z_index)]\n    let reversed_prefix = prefix.reverse()\n    return reversed_prefix\
    \ + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp9tpm6y5w.swift:7:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmp9tpm6y5w.swift:9:19: error: cannot find 'z_algorithm' in scope\n    let\
    \ z_array = z_algorithm(string: concatenated)\n                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpk9zy2tuv.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpk9zy2tuv.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk9zy2tuv.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n       \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpk9zy2tuv.swift:10:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpe8u03yv9.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpe8u03yv9.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe8u03yv9.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpe8u03yv9.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_plus_reversed\
    \ = string + \"#\" + reversed_string\n    let string_plus_reversed_length = string_plus_reversed.characters.count\n\
    \    var longest_palindrome_suffix = [Int](count: string_plus_reversed_length,\
    \ repeatedValue: 0)\n    var current_longest_palindrome_suffix_length = 0\n  \
    \  for i in 1..<string_plus_reversed_length {\n        let mirror_i = current_longest_palindrome_suffix_length\
    \ + 1\n        if i < mirror_i {\n            longest_palindrome_suffix[i] = min(mirror_i\
    \ - i, longest_palindrome_suffix[2 * current_longest_palindrome_suffix_length\
    \ - i])\n        }\n        while i + 1 + longest_palindrome_suffix[i] < string_plus_reversed_length\
    \ && i - 1 - longest_palindrome_suffix[i] >= 0 && string_plus_reversed[string_plus_reversed.startIndex.advancedBy(i\
    \ + 1 + longest_palindrome_suffix[i])] == string_plus_reversed[string_plus_reversed.startIndex.advancedBy(i\
    \ - 1 - longest_palindrome_suffix[i])] {\n            longest_palindrome_suffix[i]\
    \ += 1\n        }\n        if i + longest_palindrome_suffix[i] > current_longest_palindrome_suffix_length\
    \ + longest_palindrome_suffix[current_longest_palindrome_suffix_length] {\n  \
    \          current_longest_palindrome_suffix_length = i\n        }\n    }\n  \
    \  let longest_palindrome_suffix_length = longest_palindrome_suffix[current_longest_palindrome_suffix_length]\n\
    \    let prefix_length = string_length - longest_palindrome_suffix_length\n  \
    \  let prefix = string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpump0u6xu.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpump0u6xu.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpump0u6xu.swift:11:94:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_palindrome_suffix\
    \ = [Int](count: string_plus_reversed_length, repeatedValue: 0)\n            \
    \                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var i = 0\n    var j = string_length\
    \ - 1\n    while i < j {\n        if string_chars[i] != string_chars[j] {\n  \
    \          break\n        }\n        i += 1\n        j -= 1\n    }\n    if i >=\
    \ j {\n        return string\n    }\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: i))\n    let suffix = string.substring(from: string.index(string.startIndex,\
    \ offsetBy: i))\n    return prefix + String(suffix.characters.reversed()) + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5k18skf1.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5k18skf1.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5k18skf1.swift:21:25: error: value of type 'String'\
    \ has no member 'substring'\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: i))\n                 ~~~~~~ ^~~~~~~~~\n/tmp/tmp5k18skf1.swift:22:25:\
    \ error: value of type 'String' has no member 'substring'\n    let suffix = string.substring(from:\
    \ string.index(string.startIndex, offsetBy: i))\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_end = 0\n    var palindrome_lengths = [Int](count:\
    \ string_length, repeatedValue: 0)\n    for i in 0..<string_length {\n       \
    \ let mirror = 2 * longest_palindrome_end - i\n        if i < longest_palindrome_end\
    \ {\n            palindrome_lengths[i] = min(longest_palindrome_length - i, palindrome_lengths[mirror])\n\
    \        }\n        while i - palindrome_lengths[i] - 1 >= 0 && i + palindrome_lengths[i]\
    \ + 1 < string_length && string_characters[i - palindrome_lengths[i] - 1] == string_characters[i\
    \ + palindrome_lengths[i] + 1] {\n            palindrome_lengths[i] += 1\n   \
    \     }\n        if i + palindrome_lengths[i] > longest_palindrome_end {\n   \
    \         longest_palindrome_end = i + palindrome_lengths[i]\n            longest_palindrome_length\
    \ = palindrome_lengths[i]\n        }\n    }\n    let palindrome_end = longest_palindrome_end\n\
    \    let palindrome_length = longest_palindrome_length\n    let palindrome_start\
    \ = palindrome_end - palindrome_length\n    let prefix_start = palindrome_start\
    \ - 1\n    let prefix_end = palindrome_end\n    let prefix_length = prefix_end\
    \ - prefix_start\n    let prefix_characters = Array(string_characters[prefix_start..<prefix_end])\n\
    \    let prefix_reversed = prefix_characters.reverse()\n    let palindrome = string_characters[0..<palindrome_start]\
    \ + prefix_reversed\n    return String(palindrome)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpz4j89q69.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpz4j89q69.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpz4j89q69.swift:11:30: error: no exact matches\
    \ in call to initializer \n    var palindrome_lengths = [Int](count: string_length,\
    \ repeatedValue: 0)\n                             ^\n/tmp/tmpz4j89q69.swift:11:30:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmpz4j89q69.swift:11:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmpz4j89q69.swift:32:45: error: cannot use mutating\
    \ member on immutable value: 'prefix_characters' is a 'let' constant\n    let\
    \ prefix_reversed = prefix_characters.reverse()\n                          ~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpz4j89q69.swift:31:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix_characters = Array(string_characters[prefix_start..<prefix_end])\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    var suffix_length = 0\n    var suffix_start = 0\n    var\
    \ suffix_end = 0\n    var prefix_start = 0\n    var prefix_end = 0\n    var prefix_length\
    \ = 0\n    var prefix_palindrome_length = 0\n    var suffix_palindrome_length\
    \ = 0\n    var palindrome_length = 0\n    var palindrome_start = 0\n    var palindrome_end\
    \ = 0\n    var palindrome_length_max = 0\n    var palindrome_start_max = 0\n \
    \   var palindrome_end_max = 0\n    var prefix_palindrome_length_max = 0\n   \
    \ var suffix_palindrome_length_max = 0\n    var prefix_length_max = 0\n    var\
    \ prefix_start_max = 0\n    var prefix_end_max = 0\n    var suffix_length_max\
    \ = 0\n    var suffix_start_max = 0\n    var suffix_end_max = 0\n    var palindrome_length_max_max\
    \ = 0\n    var palindrome_start_max_max = 0\n    var palindrome_end_max_max =\
    \ 0\n    var prefix_palindrome_length_max_max = 0\n    var suffix_palindrome_length_max_max\
    \ = 0\n    var prefix_length_max_max = 0\n    var prefix_start_max_max = 0\n \
    \   var prefix_end_max_max = 0\n    var suffix_length_max_max = 0\n    var suffix_start_max_max\
    \ = 0\n    var suffix_end_max_max = 0\n    var palindrome_length_max_max_max =\
    \ 0\n    var palindrome_start_max_max_max = 0\n    var palindrome_end_max_max_max\
    \ = 0\n    var prefix_palindrome_length_max_max_max = 0\n    var suffix_palindrome_length_max_max_max\
    \ = 0\n    var prefix_length_max_max_max = 0\n    var prefix_start_max_max_max\
    \ = 0\n    var prefix_end\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp8049ydu5.swift:49:9: error: type annotation missing in pattern\n\
    \    var prefix_end\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_array = [Int](count:\
    \ string_length, repeatedValue: 0)\n    var prefix_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n    var i = 0\n    var j = 0\n    var k = 0\n    var m =\
    \ 0\n    var n = 0\n    var longest_suffix_length = 0\n    var longest_suffix_index\
    \ = 0\n    var longest_prefix_length = 0\n    var longest_prefix_index = 0\n \
    \   var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    var palindrome_length = 0\n    var palindrome_index = 0\n    var palindrome_suffix_length\
    \ = 0\n    var palindrome_suffix_index = 0\n    var palindrome_prefix_length =\
    \ 0\n    var palindrome_prefix_index = 0\n    var palindrome_prefix_end_index\
    \ = 0\n    var palindrome_prefix_end_length = 0\n    var palindrome_prefix_start_index\
    \ = 0\n    var palindrome_prefix_start_length = 0\n    var palindrome_suffix_start_index\
    \ = 0\n    var palindrome_suffix_start_length = 0\n    var palindrome_suffix_end_index\
    \ = 0\n    var palindrome_suffix_end_length = 0\n    var palindrome_prefix_start_char\
    \ = \"\"\n    var palindrome_prefix_end_char = \"\"\n    var palindrome_suffix_start_char\
    \ = \"\"\n    var palindrome_suffix_end_char = \"\"\n    var palindrome_prefix_start_char_index\
    \ = 0\n    var palindrome_prefix_end_char_index = 0\n    var palindrome_suffix_start_char_index\
    \ = 0\n    var palindrome_suffix_end_char_index = 0\n    var palindrome_prefix_start_char_length\
    \ = 0\n    var palindrome_prefix_end_char_length = 0\n    var palind\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvgj3juyg.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvgj3juyg.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvgj3juyg.swift:9:24: error: no exact matches in call\
    \ to initializer \n    var suffix_array = [Int](count: string_length, repeatedValue:\
    \ 0)\n                       ^\n/tmp/tmpvgj3juyg.swift:9:24: note: candidate has\
    \ partially matching parameter list (repeating: Int, count: Int)\n    var suffix_array\
    \ = [Int](count: string_length, repeatedValue: 0)\n                       ^\n\
    /tmp/tmpvgj3juyg.swift:9:24: note: candidate has partially matching parameter\
    \ list (repeating: Int, count: Int)\n    var suffix_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n                       ^\n/tmp/tmpvgj3juyg.swift:10:24: error:\
    \ no exact matches in call to initializer \n    var prefix_array = [Int](count:\
    \ string_length, repeatedValue: 0)\n                       ^\n/tmp/tmpvgj3juyg.swift:10:24:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var prefix_array = [Int](count: string_length, repeatedValue: 0)\n\
    \                       ^\n/tmp/tmpvgj3juyg.swift:10:24: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var prefix_array =\
    \ [Int](count: string_length, repeatedValue: 0)\n                       ^\n/tmp/tmpvgj3juyg.swift:46:9:\
    \ error: type annotation missing in pattern\n    var palind\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let s = string.characters.map { String($0) }\n    let\
    \ n = s.count\n    var i = 0\n    var j = n - 1\n    while i < j {\n        if\
    \ s[i] != s[j] {\n            break\n        }\n        i += 1\n        j -= 1\n\
    \    }\n    if i >= j {\n        return string\n    }\n    var suffix = Array(s[i...j])\n\
    \    suffix.reverse()\n    return string + suffix.joinWithSeparator(\"\")\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvq7aqxup.swift:7:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let s = string.characters.map { String($0) }\n    \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvq7aqxup.swift:23:28: error: value of type '[String]' has no member\
    \ 'joinWithSeparator'\n    return string + suffix.joinWithSeparator(\"\")\n  \
    \                  ~~~~~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    if\
    \ string_length <= 1 {\n        return string\n    }\n    let string_array = Array(string.characters)\n\
    \    let string_array_reversed = Array(string.characters.reversed())\n    var\
    \ longest_palindrome_length = 0\n    var longest_palindrome_end = 0\n    var palindrome_lengths\
    \ = [Int](repeating: 0, count: string_length)\n    for i in 1..<string_length\
    \ {\n        if string_array[i] == string_array_reversed[i] {\n            palindrome_lengths[i]\
    \ = palindrome_lengths[i - 1] + 1\n            if palindrome_lengths[i] > longest_palindrome_length\
    \ {\n                longest_palindrome_length = palindrome_lengths[i]\n     \
    \           longest_palindrome_end = i\n            }\n        }\n    }\n    if\
    \ longest_palindrome_length == string_length {\n        return string\n    }\n\
    \    let prefix_start = string_length - longest_palindrome_end - 1\n    let prefix\
    \ = string.substring(to: string.index(string.startIndex, offsetBy: prefix_start))\n\
    \    let prefix_reversed = String(prefix.characters.reversed())\n    return prefix_reversed\
    \ + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmptizje2b5.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmptizje2b5.swift:11:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmptizje2b5.swift:12:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array_reversed = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmptizje2b5.swift:29:25: error: value of type\
    \ 'String' has no member 'substring'\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: prefix_start))\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.characters.reverse()\n    let\
    \ reversed_string = String(reversed)\n    let lps = longest_palindromic_substring(string\
    \ + \"#\" + reversed_string)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lps.characters.count))\n    let reversed_prefix = prefix.characters.reverse()\n\
    \    let reversed_prefix_string = String(reversed_prefix)\n    return string +\
    \ reversed_prefix_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpab4mghoo.swift:7:38: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.characters.reverse()\n                \
    \   ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpab4mghoo.swift:9:15: error: cannot find\
    \ 'longest_palindromic_substring' in scope\n    let lps = longest_palindromic_substring(string\
    \ + \"#\" + reversed_string)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpab4mghoo.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lps.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpab4mghoo.swift:10:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lps.characters.count))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_array\
    \ = Array(string)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    var longest_palindrome_end = 0\n    for i in 0..<string_length {\n\
    \        var j = 0\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        if j >\
    \ longest_palindrome_length {\n            longest_palindrome_length = j\n   \
    \         longest_palindrome_start = i - j + 1\n            longest_palindrome_end\
    \ = i + j - 1\n        }\n    }\n    for i in 0..<string_length - 1 {\n      \
    \  var j = 0\n        while i - j >= 0 && i + 1 + j < string_length && string_array[i\
    \ - j] == string_array[i + 1 + j] {\n            j += 1\n        }\n        if\
    \ j > longest_palindrome_length {\n            longest_palindrome_length = j\n\
    \            longest_palindrome_start = i - j + 1\n            longest_palindrome_end\
    \ = i + j\n        }\n    }\n    var result = string\n    for i in 0..<string_length\
    \ - longest_palindrome_end - 1 {\n        result.append(string_array[string_length\
    \ - i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002aec832a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec82f9d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aec82f9d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aec82f9d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aec82f9cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpddcuzy0o                        0x0000563d25b8f1c2 <unavailable> + 8642

    6    tmpddcuzy0o                        0x0000563d25b8e685 <unavailable> + 5765

    7    libc.so.6                          0x00002aec83492460 __libc_start_main +
    245

    8    tmpddcuzy0o                        0x0000563d25b8e389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_chars\
    \ = Array(reversed_string.characters)\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    var prefix_length = 0\n    var prefix_index\
    \ = 0\n    var suffix_length = 0\n    var suffix_index = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac = 0\n    var\
    \ ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n   \
    \ var ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n\
    \    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n    var ar =\
    \ 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var av = 0\n    var aw\
    \ = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba = 0\n    var\
    \ bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n   \
    \ var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n\
    \    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo = 0\n    var bp\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjw22s9tc.swift:54:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpjw22s9tc.swift:54:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpjw22s9tc.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjw22s9tc.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjw22s9tc.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:77:9: error: type annotation\
    \ missing in pattern\n    var bp\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    let string_chars_reversed = string_chars.reversed()\n \
    \   var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    var i = 0\n    while i < string_length {\n        var j = 0\n        while\
    \ i - j >= 0 && i + j < string_length && string_chars[i - j] == string_chars[i\
    \ + j] {\n            j += 1\n        }\n        if j > longest_palindrome_length\
    \ {\n            longest_palindrome_length = j\n            longest_palindrome_index\
    \ = i\n        }\n        i += 1\n    }\n    var result = string\n    var k =\
    \ 0\n    while k < string_length - longest_palindrome_length {\n        result.append(string_chars_reversed[k])\n\
    \        k += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpc9tag1h8.swift:27:45: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[String.Element]>.Index' (aka\
    \ 'ReversedCollection<Array<Character>>.Index')\n        result.append(string_chars_reversed[k])\n\
    \                                            ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    var i = 0\n    while i < string_length {\n   \
    \     if is_palindrome(string_array, start: i - palindrome_length - 1, end: i)\
    \ {\n            palindrome_length += 2\n            palindrome_index = i\n  \
    \      } else if is_palindrome(string_array, start: i - palindrome_length, end:\
    \ i) {\n            palindrome_length += 1\n            palindrome_index = i\n\
    \        }\n        if palindrome_length > longest_palindrome_length {\n     \
    \       longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = palindrome_index\n        }\n        i += 1\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp1heg9ohb.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp1heg9ohb.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1heg9ohb.swift:15:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: i - palindrome_length\
    \ - 1, end: i) {\n           ^~~~~~~~~~~~~\n/tmp/tmp1heg9ohb.swift:18:19: error:\
    \ cannot find 'is_palindrome' in scope\n        } else if is_palindrome(string_array,\
    \ start: i - palindrome_length, end: i) {\n                  ^~~~~~~~~~~~~\n/tmp/tmp1heg9ohb.swift:28:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp1heg9ohb.swift:28:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n                                        \
    \ ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reverse()\n    let concatenated\
    \ = string + reversed\n    let longest_palindrome_suffix = longest_palindrome_suffix_of(concatenated)\n\
    \    let prefix = string.substringToIndex(string.endIndex.advancedBy(-longest_palindrome_suffix.characters.count))\n\
    \    let reversed_prefix = prefix.reverse()\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbm1cmu0u.swift:7:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmpbm1cmu0u.swift:9:37: error: cannot find 'longest_palindrome_suffix_of'\
    \ in scope\n    let longest_palindrome_suffix = longest_palindrome_suffix_of(concatenated)\n\
    \                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbm1cmu0u.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.endIndex.advancedBy(-longest_palindrome_suffix.characters.count))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpbm1cmu0u.swift:10:58: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.endIndex.advancedBy(-longest_palindrome_suffix.characters.count))\n\
    \                                         ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ prefix_length = 0\n    var suffix_start = 0\n    var prefix_start = 0\n    var\
    \ suffix_end = 0\n    var prefix_end = 0\n    var is_palindrome = false\n    var\
    \ palindrome_length = 0\n    var palindrome_start = 0\n    var palindrome_end\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n\
    \    var ac = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag =\
    \ 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al\
    \ = 0\n    var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var\
    \ aq = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n   \
    \ var av = 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n\
    \    var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be =\
    \ 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj\
    \ = 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var\
    \ bo = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpv_78d7n4.swift:55:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpv_78d7n4.swift:55:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpv_78d7n4.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpv_78d7n4.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpv_78d7n4.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpv_78d7n4.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpv_78d7n4.swift:9:9: warning: initialization of variable 'suffix_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var suffix_length = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpv_78d7n4.swift:10:9:\
    \ warning: initialization of variable 'prefix_length' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var prefix_length = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpv_78d7n4.swift:11:9: warning: initialization\
    \ of variable 'suffix_start' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var suffix_start = 0\n    ~~~~^~~~~~~~~~~~\n    _\n\
    /tmp/tmpv_78d7n4.swift:12:9: warning: initialization of variable 'prefix_start'\
    \ was never us"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let z_array = z_algorithm(combined)\n\
    \    let z_array_reversed = z_array.reverse()\n    let z_array_reversed_without_first\
    \ = Array(z_array_reversed[1..<z_array_reversed.count])\n    let z_array_without_last\
    \ = Array(z_array[0..<z_array.count-1])\n    let z_array_without_last_and_first\
    \ = zip(z_array_without_last, z_array_reversed_without_first)\n    let max_z =\
    \ z_array_without_last_and_first.maxElement { $0.0 < $1.0 }\n    let max_z_index\
    \ = z_array_without_last_and_first.indexOf { $0 == max_z }\n    let prefix = String(string.characters.prefix(max_z_index!))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return prefix\
    \ + string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmplqx_1r9h.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmplqx_1r9h.swift:9:19: error:\
    \ cannot find 'z_algorithm' in scope\n    let z_array = z_algorithm(combined)\n\
    \                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reverse()\n    let concatenated\
    \ = string + \"#\" + reversed\n    let z_array = z_algorithm(string: concatenated)\n\
    \    let z_array_count = z_array.count\n    let z_array_last = z_array[z_array_count\
    \ - 1]\n    let z_array_second_last = z_array[z_array_count - 2]\n    let z_array_third_last\
    \ = z_array[z_array_count - 3]\n    let z_array_fourth_last = z_array[z_array_count\
    \ - 4]\n    let z_array_fifth_last = z_array[z_array_count - 5]\n    let z_array_sixth_last\
    \ = z_array[z_array_count - 6]\n    let z_array_seventh_last = z_array[z_array_count\
    \ - 7]\n    let z_array_eighth_last = z_array[z_array_count - 8]\n    let z_array_ninth_last\
    \ = z_array[z_array_count - 9]\n    let z_array_tenth_last = z_array[z_array_count\
    \ - 10]\n    let z_array_eleventh_last = z_array[z_array_count - 11]\n    let\
    \ z_array_twelfth_last = z_array[z_array_count - 12]\n    let z_array_thirteenth_last\
    \ = z_array[z_array_count - 13]\n    let z_array_fourteenth_last = z_array[z_array_count\
    \ - 14]\n    let z_array_fifteenth_last = z_array[z_array_count - 15]\n    let\
    \ z_array_sixteenth_last = z_array[z_array_count - 16]\n    let z_array_seventeenth_last\
    \ = z_array[z_array_count - 17]\n    let z_array_eighteenth_last = z_array[z_array_count\
    \ - 18]\n    let z_array_nineteenth_last = z_array[z_array_count - 19]\n    let\
    \ z_array_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpaq74xwqu.swift:7:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmpaq74xwqu.swift:9:19: error: cannot find 'z_algorithm' in scope\n    let\
    \ z_array = z_algorithm(string: concatenated)\n                  ^~~~~~~~~~~\n\
    /tmp/tmpaq74xwqu.swift:30:9: error: type annotation missing in pattern\n    let\
    \ z_array_\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return reversed + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpghk_0ol3.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpghk_0ol3.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var palindrome_suffix = [Character]()\n\
    \    var palindrome_prefix = [Character]()\n    var palindrome_suffix_length =\
    \ 0\n    var palindrome_prefix_length = 0\n    var palindrome_suffix_start = 0\n\
    \    var palindrome_prefix_start = 0\n    var palindrome_suffix_end = 0\n    var\
    \ palindrome_prefix_end = 0\n    var palindrome_suffix_is_palindrome = false\n\
    \    var palindrome_prefix_is_palindrome = false\n    var palindrome_suffix_is_longest\
    \ = false\n    var palindrome_prefix_is_longest = false\n    var palindrome_suffix_is_longer\
    \ = false\n    var palindrome_prefix_is_longer = false\n    var palindrome_suffix_is_shorter\
    \ = false\n    var palindrome_prefix_is_shorter = false\n    var palindrome_suffix_is_longer_than_prefix\
    \ = false\n    var palindrome_prefix_is_longer_than_suffix = false\n    var palindrome_suffix_is_shorter_than_prefix\
    \ = false\n    var palindrome_prefix_is_shorter_than_suffix = false\n    var palindrome_suffix_is_equal_to_prefix\
    \ = false\n    var palindrome_prefix_is_equal_to_suffix = false\n    var palindrome_suffix_is_longer_than_half\
    \ = false\n    var palindrome_prefix_is_longer_than_half = false\n    var palindrome_suffix_is_shorter_than_half\
    \ = false\n    var palindrome_prefix_is_shorter_than_half = false\n    var palindrome_suffix_is_equal_to_half\
    \ = false\n    var palindrome_prefix_is_equal_to_half = false\n    var palindrome_suffix_is_longer_than_one\
    \ = false\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp5b72vp7w.swift:38:8: error: expected pattern\n    var\n       ^\n\
    /tmp/tmp5b72vp7w.swift:7:32: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_length = string.characters.count\n                \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5b72vp7w.swift:8:42: error: 'characters' is unavailable: Please use\
    \ String directly\n    let string_characters = Array(string.characters)\n    \
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5b72vp7w.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp5b72vp7w.swift:8:9: warning: initialization of immutable value\
    \ 'string_characters' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    let string_characters = Array(string.characters)\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp5b72vp7w.swift:9:9: warning: initialization of variable 'palindrome_suffix'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_suffix = [Character]()\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp5b72vp7w.swift:10:9: warning: initialization of variable 'palindrome_prefix'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_prefix = [Character]()\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp5b72vp7w.swift:11:9: warning: initialization of variable 'palindrome_suffix_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_suffix_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp5b72vp7w.swift:12:9: warning: initialization of variable 'palindrome_prefix_length'\
    \ was never used; consider replacing with assignment to '_' or r"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let z_array = z_function(concatenated)\n\
    \    let z_array_reversed = z_array.reverse()\n    let z_array_reversed_without_first\
    \ = Array(z_array_reversed.dropFirst())\n    let z_array_without_last = Array(z_array.dropLast())\n\
    \    let max_z = zip(z_array_without_last, z_array_reversed_without_first).map(max).maxElement()!\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_z))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5pq2ojtt.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp5pq2ojtt.swift:9:19: error:\
    \ cannot find 'z_function' in scope\n    let z_array = z_function(concatenated)\n\
    \                  ^~~~~~~~~~\n/tmp/tmp5pq2ojtt.swift:13:79: error: cannot convert\
    \ value of type '(_, _) -> _' to expected argument type '(Zip2Sequence<_, _>.Element)\
    \ throws -> _'\n    let max_z = zip(z_array_without_last, z_array_reversed_without_first).map(max).maxElement()!\n\
    \                                                                            \
    \  ^\n/tmp/tmp5pq2ojtt.swift:13:84: error: value of type '[T]' has no member 'maxElement'\n\
    \    let max_z = zip(z_array_without_last, z_array_reversed_without_first).map(max).maxElement()!\n\
    \                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp5pq2ojtt.swift:14:25: error: value of type 'String' has\
    \ no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_z))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp5pq2ojtt.swift:14:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_z))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed_string = String(string.characters.reverse())\n\
    \    let string_length = string.characters.count\n    let reversed_string_length\
    \ = reversed_string.characters.count\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    var table = Array(count: reversed_string_length,\
    \ repeatedValue: Array(count: string_length, repeatedValue: 0))\n    for i in\
    \ 0..<reversed_string_length {\n        for j in 0..<string_length {\n       \
    \     if reversed_string[i] == string[j] {\n                if i == 0 || j ==\
    \ 0 {\n                    table[i][j] = 1\n                } else {\n       \
    \             table[i][j] = table[i - 1][j - 1] + 1\n                }\n     \
    \           if table[i][j] > longest_palindrome_length {\n                   \
    \ longest_palindrome_length = table[i][j]\n                    longest_palindrome_index\
    \ = i\n                }\n            }\n        }\n    }\n    let prefix = reversed_string.substringToIndex(reversed_string.startIndex.advancedBy(reversed_string_length\
    \ - longest_palindrome_index - 1))\n    return string + prefix\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp88o2sf40.swift:7:52: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed_string = String(string.characters.reverse())\n \
    \                                ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp88o2sf40.swift:8:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp88o2sf40.swift:12:69: error: extra argument\
    \ 'repeatedValue' in call\n    var table = Array(count: reversed_string_length,\
    \ repeatedValue: Array(count: string_length, repeatedValue: 0))\n            \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp88o2sf40.swift:12:112: error: extra argument 'repeatedValue' in call\n\
    \    var table = Array(count: reversed_string_length, repeatedValue: Array(count:\
    \ string_length, repeatedValue: 0))\n                                        \
    \                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmp88o2sf40.swift:12:75:\
    \ error: missing argument for parameter 'repeating' in call\n    var table = Array(count:\
    \ reversed_string_length, repeatedValue: Array(count: string_length, repeatedValue:\
    \ 0))\n                                                                      \
    \    ^\n                                                                     \
    \     repeating: <#_#>, \nSwift.Array:4:23: note: 'init(repeating:count:)' declared\
    \ here\n    @inlinable public init(repeating repeatedValue: Element, count: Int)\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.last!))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpab3h5_fz.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpab3h5_fz.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpab3h5_fz.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(lps.last!))\n       \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpab3h5_fz.swift:10:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.last!))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb4b27fj1.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpb4b27fj1.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    var i = 0\n    while i < string_length {\n   \
    \     // Check for palindrome of odd length\n        palindrome_length = 0\n \
    \       palindrome_index = i\n        while i - palindrome_length >= 0 && i +\
    \ palindrome_length < string_length {\n            if string_chars[i - palindrome_length]\
    \ != string_chars[i + palindrome_length] {\n                break\n          \
    \  }\n            palindrome_length += 1\n        }\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_index = palindrome_index\n        }\n        //\
    \ Check for palindrome of even length\n        palindrome_length = 0\n       \
    \ palindrome_index = i\n        while i - palindrome_length >= 0 && i + palindrome_length\
    \ + 1 < string_length {\n            if string_chars[i - palindrome_length] !=\
    \ string_chars[i + palindrome_length + 1] {\n                break\n         \
    \   }\n            palindrome_length += 1\n        }\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_index = palindrome_index\n        }\n        i\
    \ += 1\n    }\n    let prefix_start = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_index\n    let prefix = String(string_chars[prefix_start...prefix_end])\n\
    \    let reversed_prefix = String(prefix.characters.reversed())\n    return prefix\
    \ + string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpek091j0u.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpek091j0u.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpek091j0u.swift:46:41: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_prefix = String(prefix.characters.reversed())\n\
    \                                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_chars = Array(reversed_string.characters)\n    \n   \
    \ var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n  \
    \  \n    // Find the longest palindrome suffix.\n    for i in 0..<string_length\
    \ {\n        let prefix_length = string_length - i\n        let prefix = String(string_chars[i..<string_length])\n\
    \        let suffix = String(reversed_string_chars[0..<prefix_length])\n     \
    \   if prefix == suffix {\n            longest_palindrome_length = prefix_length\n\
    \            longest_palindrome_index = i\n            break\n        }\n    }\n\
    \    \n    // Append the reverse of the prefix before the palindrome suffix.\n\
    \    let prefix_length = string_length - longest_palindrome_length\n    let prefix\
    \ = String(string_chars[0..<prefix_length])\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \    let result = prefix + reversed_prefix + string\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp56_o4f08.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp56_o4f08.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp56_o4f08.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp56_o4f08.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp56_o4f08.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp56_o4f08.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp56_o4f08.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp56_o4f08.swift:30:52: error: value of type\
    \ 'String' has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string = string.characters.map { String($0) }\n\
    \    let reversed = string.reverse()\n    let string_length = string.count\n \
    \   let reversed_length = reversed.count\n    var prefix_length = 0\n    var suffix_length\
    \ = 0\n    var prefix_index = 0\n    var suffix_index = 0\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var table = Array(count: reversed_length,\
    \ repeatedValue: Array(count: string_length, repeatedValue: 0))\n    for i in\
    \ 0..<reversed_length {\n        for j in 0..<string_length {\n            if\
    \ reversed[i] == string[j] {\n                if i == 0 || j == 0 {\n        \
    \            table[i][j] = 1\n                } else {\n                    table[i][j]\
    \ = table[i - 1][j - 1] + 1\n                }\n                if table[i][j]\
    \ > longest_palindrome_length {\n                    longest_palindrome_length\
    \ = table[i][j]\n                    longest_palindrome_index = j\n          \
    \      }\n            }\n        }\n    }\n    prefix_length = string_length -\
    \ longest_palindrome_length\n    suffix_length = longest_palindrome_length\n \
    \   prefix_index = 0\n    suffix_index = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    return string[prefix_index..<prefix_index + prefix_length].reverse().joinWithSeparator(\"\
    \") + string.joinWithSeparator(\"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnk7wjeka.swift:7:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters.map { String($0) }\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpnk7wjeka.swift:8:27: error: cannot use mutating member\
    \ on immutable value: 'string' is a 'let' constant\n    let reversed = string.reverse()\n\
    \                   ~~~~~~ ^\n/tmp/tmpnk7wjeka.swift:7:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let string = string.characters.map { String($0)\
    \ }\n    ^~~\n    var\n/tmp/tmpnk7wjeka.swift:17:62: error: extra argument 'repeatedValue'\
    \ in call\n    var table = Array(count: reversed_length, repeatedValue: Array(count:\
    \ string_length, repeatedValue: 0))\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpnk7wjeka.swift:17:105: error: extra argument 'repeatedValue' in call\n\
    \    var table = Array(count: reversed_length, repeatedValue: Array(count: string_length,\
    \ repeatedValue: 0))\n                                                       \
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmpnk7wjeka.swift:17:68:\
    \ error: missing argument for parameter 'repeating' in call\n    var table = Array(count:\
    \ reversed_length, repeatedValue: Array(count: string_length, repeatedValue: 0))\n\
    \                                                                   ^\n      \
    \                                                             repeating: <#_#>,\
    \ \nSwift.Array:4:23: note: 'init(repeating:count:)' declared here\n    @inlinable\
    \ public init(repeating repeatedValue: Element, count: Int)\n                \
    \      ^\n/tmp/tmpnk7wjeka.swift:37:105: error: value of type '[String]' has no\
    \ member 'joinWithSeparator'\n    return string[prefix_index..<prefix_index +\
    \ prefix_length].reverse().joinWithSeparator(\"\") + string.joinWithSeparator(\"\
    \")\n                                                                        \
    \                         ~~~"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.last!))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpruqq2sk5.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpruqq2sk5.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_chars\
    \ = Array(reversed_string.characters)\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_start = 0\n    var longest_palindrome_end = 0\n  \
    \  var longest_palindrome_end_reversed = 0\n    var longest_palindrome_start_reversed\
    \ = 0\n    var longest_palindrome_length_reversed = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o\
    \ = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t =\
    \ 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n\
    \    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n\
    \    var ae = 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n    var ai =\
    \ 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n    var an\
    \ = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var\
    \ as = 0\n    var at = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n   \
    \ var ax = 0\n    var ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n\
    \    var bc = 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n    var bg =\
    \ 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n    var\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmplcd8o6dk.swift:54:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmplcd8o6dk.swift:54:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmplcd8o6dk.swift:73:8: error: expected pattern\n    var\n\
    \       ^\n/tmp/tmplcd8o6dk.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmplcd8o6dk.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmplcd8o6dk.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmplcd8o6dk.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmplcd8o6dk.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmplcd8o6dk.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmplcd8o6dk.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_chars\
    \ = Array(reversed_string.characters)\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    var z_function = [Int](count: reversed_string_length,\
    \ repeatedValue: 0)\n    z_function[0] = reversed_string_length\n    var left\
    \ = 0\n    var right = 0\n    for i in 1..<reversed_string_length {\n        if\
    \ i <= right {\n            z_function[i] = min(right - i + 1, z_function[i -\
    \ left])\n        }\n        while i + z_function[i] < reversed_string_length\
    \ && reversed_string_chars[z_function[i]] == reversed_string_chars[i + z_function[i]]\
    \ {\n            z_function[i] += 1\n        }\n        if i + z_function[i] -\
    \ 1 > right {\n            left = i\n            right = i + z_function[i] - 1\n\
    \        }\n        if z_function[i] == i {\n            longest_palindrome_length\
    \ = z_function[i]\n            longest_palindrome_index = i\n        }\n    }\n\
    \    let string_prefix = String(string_chars[0..<string_length - longest_palindrome_length])\n\
    \    let string_prefix_reversed = String(string_prefix.characters.reverse())\n\
    \    return string + string_prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpe3d3tkns.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpe3d3tkns.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpe3d3tkns.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpe3d3tkns.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpe3d3tkns.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpe3d3tkns.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpe3d3tkns.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpe3d3tkns.swift:14:74: error: extra argument\
    \ 'repeatedValue' in call\n    var z_function = [Int](count: reversed_string_length,\
    \ repeatedValue: 0)\n                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpe3d3tkns.swift:35:66: error: value of type 'String' has no member 'reverse'\n\
    \    let string_prefix_reversed = String(string_prefix.characters.reverse())\n\
    \                                        ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var current_palindrome_length\
    \ = 0\n    var current_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        current_palindrome_length = 0\n        current_palindrome_index =\
    \ i\n        while i < string_length && string_characters[i] == string_characters[string_length\
    \ - 1 - i] {\n            current_palindrome_length += 1\n            i += 1\n\
    \        }\n        if current_palindrome_length > longest_palindrome_length {\n\
    \            longest_palindrome_length = current_palindrome_length\n         \
    \   longest_palindrome_index = current_palindrome_index\n        }\n        i\
    \ += 1\n    }\n    var result = string\n    for i in 0..<string_length - longest_palindrome_length\
    \ {\n        result.append(string_characters[string_length - 1 - i])\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmptmdlrg0o.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmptmdlrg0o.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmptmdlrg0o.swift:10:9: warning: variable\
    \ 'longest_palindrome_index' was written to, but never read\n    var longest_palindrome_index\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var dp_table = Array(repeating:\
    \ Array(repeating: false, count: string_length), count: string_length)\n    for\
    \ i in 0..<string_length {\n        dp_table[i][i] = true\n        longest_palindrome_length\
    \ = 1\n        longest_palindrome_index = i\n    }\n    for i in 0..<string_length\
    \ - 1 {\n        if string_array[i] == string_array[i + 1] {\n            dp_table[i][i\
    \ + 1] = true\n            longest_palindrome_length = 2\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    for length in 3...string_length {\n        for i\
    \ in 0..<string_length - length + 1 {\n            let j = i + length - 1\n  \
    \          if string_array[i] == string_array[j] && dp_table[i + 1][j - 1] {\n\
    \                dp_table[i][j] = true\n                longest_palindrome_length\
    \ = length\n                longest_palindrome_index = i\n            }\n    \
    \    }\n    }\n    let prefix = string_array[0..<longest_palindrome_index].reversed()\n\
    \    let suffix = string_array[longest_palindrome_index + longest_palindrome_length..<string_length]\n\
    \    return String(prefix) + String(suffix) + String(string_array[longest_palindrome_index..<longest_palindrome_index\
    \ + longest_palindrome_length])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpoaxanl81.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpoaxanl81.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_lengths = [Int](count:\
    \ string_length, repeatedValue: 0)\n    for index in 0..<string_length {\n   \
    \     var palindrome_length = 1\n        if index > 0 && index < string_length\
    \ - 1 {\n            palindrome_length = min(palindrome_lengths[index - 1], string_length\
    \ - index - 1)\n        }\n        while palindrome_length <= index && palindrome_length\
    \ <= string_length - index - 1 && string_array[index - palindrome_length] == string_array[index\
    \ + palindrome_length] {\n            palindrome_lengths[index] = palindrome_length\n\
    \            palindrome_length += 1\n        }\n        if palindrome_length >\
    \ longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_index = index\n        }\n    }\n    let prefix_start\
    \ = longest_palindrome_index - longest_palindrome_length + 1\n    let prefix_end\
    \ = longest_palindrome_index + longest_palindrome_length\n    let prefix = string.substringWithRange(Range<String.Index>(start:\
    \ string.startIndex.advancedBy(prefix_start), end: string.startIndex.advancedBy(prefix_end)))\n\
    \    let prefix_reversed = String(prefix.characters.reverse())\n    let suffix\
    \ = string.substringFromIndex(string.startIndex.advancedBy(prefix_end))\n    return\
    \ prefix_reversed + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpvdizy2fx.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvdizy2fx.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvdizy2fx.swift:11:30: error: no exact matches in call\
    \ to initializer \n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmpvdizy2fx.swift:11:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmpvdizy2fx.swift:11:30: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var palindrome_lengths\
    \ = [Int](count: string_length, repeatedValue: 0)\n                          \
    \   ^\n/tmp/tmpvdizy2fx.swift:28:25: error: value of type 'String' has no member\
    \ 'substringWithRange'\n    let prefix = string.substringWithRange(Range<String.Index>(start:\
    \ string.startIndex.advancedBy(prefix_start), end: string.startIndex.advancedBy(prefix_end)))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvdizy2fx.swift:28:44: error:\
    \ referencing initializer 'init(_:)' on 'Range' requires that 'String.Index' conform\
    \ to 'Strideable'\n    let prefix = string.substringWithRange(Range<String.Index>(start:\
    \ string.startIndex.advancedBy(prefix_start), end: string.startIndex.advancedBy(prefix_end)))\n\
    \                                           ^\nSwift.Range:1:11: note: where 'Bound'\
    \ = 'String.Index'\nextension Range where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n/tmp/tmpvdizy2fx.s"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string = string.lowercased()\n    let reversed\
    \ = String(string.reversed())\n    let suffix = reversed.commonPrefix(with: string)\n\
    \    let prefix = String(string.dropLast(suffix.count))\n    return string + String(prefix.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpk7gei7e2.swift:9:27: error: value of type 'String' has no member\
    \ 'commonPrefix'\n    let suffix = reversed.commonPrefix(with: string)\n     \
    \            ~~~~~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var\
    \ l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q\
    \ = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v =\
    \ 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var aa =\
    \ 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae = 0\n    var af\
    \ = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n    var\
    \ ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var ao = 0\n   \
    \ var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n\
    \    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n    var ay =\
    \ 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd\
    \ = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n    var\
    \ bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n   \
    \ var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n\
    \    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n    var bw =\
    \ 0\n    var bx = 0\n    var by = 0\n    var bz\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbg44oyyh.swift:49:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpbg44oyyh.swift:49:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpbg44oyyh.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbg44oyyh.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbg44oyyh.swift:82:9: error: type annotation missing\
    \ in pattern\n    var bz\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var palindrome_length = 0\n   \
    \ var palindrome_start = 0\n    var palindrome_end = 0\n    var palindrome_length_max\
    \ = 0\n    var palindrome_start_max = 0\n    var palindrome_end_max = 0\n    for\
    \ i in 0..<string_length {\n        palindrome_length = 0\n        palindrome_start\
    \ = i\n        palindrome_end = i\n        while palindrome_start >= 0 && palindrome_end\
    \ < string_length {\n            if string_chars[palindrome_start] == string_chars[palindrome_end]\
    \ {\n                palindrome_length = palindrome_end - palindrome_start + 1\n\
    \                if palindrome_length > palindrome_length_max {\n            \
    \        palindrome_length_max = palindrome_length\n                    palindrome_start_max\
    \ = palindrome_start\n                    palindrome_end_max = palindrome_end\n\
    \                }\n            } else {\n                break\n            }\n\
    \            palindrome_start -= 1\n            palindrome_end += 1\n        }\n\
    \        palindrome_length = 0\n        palindrome_start = i\n        palindrome_end\
    \ = i + 1\n        while palindrome_start >= 0 && palindrome_end < string_length\
    \ {\n            if string_chars[palindrome_start] == string_chars[palindrome_end]\
    \ {\n                palindrome_length = palindrome_end - palindrome_start + 1\n\
    \                if palindrome_length > palindrome_length_max {\n            \
    \        palindrome_length_max = palindrome_length\n                    palindrome_start_max\
    \ = palindrome_start\n                    palindrome_end_max = palindrome_end\n\
    \                }\n            } else {\n                break\n            }\n\
    \            palindrome_start -= 1\n            palindrome_end += 1\n        }\n\
    \    }\n    var result = \"\"\n    for i in 0..<pal\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8v2svbfj.swift:52:21: error: expected '{' to start the body of\
    \ for-each loop\n    for i in 0..<pal\n                    ^\n/tmp/tmp8v2svbfj.swift:7:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8v2svbfj.swift:8:37: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8v2svbfj.swift:52:18: error: cannot find 'pal' in scope\n\
    \    for i in 0..<pal\n                 ^~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    var longest_palindrome_length = 0\n    var longest_palindrome_start = 0\n\
    \    for i in 0..<string_length {\n        var j = 0\n        while i - j >= 0\
    \ && i + j < string_length && string_array[i - j] == reversed_string_array[i +\
    \ j] {\n            j += 1\n        }\n        if j > longest_palindrome_length\
    \ {\n            longest_palindrome_length = j\n            longest_palindrome_start\
    \ = i - j + 1\n        }\n    }\n    \n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    var\
    \ result = string\n    for i in 0..<string_length - longest_palindrome_length\
    \ {\n        result.append(reversed_string_array[i])\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpf44ykcgl.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpf44ykcgl.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpf44ykcgl.swift:9:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpf44ykcgl.swift:13:9: warning: variable\
    \ 'longest_palindrome_start' was written to, but never read\n    var longest_palindrome_start\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.characters.reverse()\n    let\
    \ reversed_string = String(reversed)\n    let string_length = string.characters.count\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let string_suffix\
    \ = string.substringFromIndex(string.startIndex.advancedBy(string_length / 2))\n\
    \    let reversed_string_prefix = reversed_string.substringToIndex(reversed_string.startIndex.advancedBy(reversed_string_length\
    \ / 2))\n    let reversed_string_prefix_length = reversed_string_prefix.characters.count\n\
    \    let reversed_string_prefix_suffix = reversed_string_prefix.substringFromIndex(reversed_string_prefix.startIndex.advancedBy(reversed_string_prefix_length\
    \ / 2))\n    let reversed_string_prefix_suffix_length = reversed_string_prefix_suffix.characters.count\n\
    \    let reversed_string_prefix_suffix_prefix = reversed_string_prefix.substringToIndex(reversed_string_prefix.startIndex.advancedBy(reversed_string_prefix_length\
    \ / 2))\n    let reversed_string_prefix_suffix_prefix_length = reversed_string_prefix_suffix_prefix.characters.count\n\
    \    let string_suffix_length = string_suffix.characters.count\n    let string_suffix_prefix\
    \ = string_suffix.substringToIndex(string_suffix.startIndex.advancedBy(string_suffix_length\
    \ / 2))\n    let string_suffix_prefix_length = string_suffix_prefix.characters.count\n\
    \    let string_suffix_prefix_suffix = string_suffix.substringFromIndex(string_suffix.startIndex.advancedBy(string_suffix_length\
    \ / 2))\n    let string_suffix_prefix_suffix_length = string_suffix_prefix_suffix.characters.count\n\
    \    let string_suffix_prefix_suffix_prefix = string_suffix.substringToIndex(string_suffix.startIndex.advancedBy(string_suffix_length\
    \ / 2))\n    let\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp4cuqaxre.swift:24:8: error: expected pattern\n    let\n       ^\n\
    /tmp/tmp4cuqaxre.swift:7:38: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed = string.characters.reverse()\n                   ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmp4cuqaxre.swift:9:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp4cuqaxre.swift:11:32: error: value of type 'String' has\
    \ no member 'substringFromIndex'\n    let string_suffix = string.substringFromIndex(string.startIndex.advancedBy(string_length\
    \ / 2))\n                        ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp4cuqaxre.swift:11:69:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let string_suffix\
    \ = string.substringFromIndex(string.startIndex.advancedBy(string_length / 2))\n\
    \                                                  ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_suffix\
    \ = string + \"#\" + reversed_string\n    let string_suffix_length = string_suffix.characters.count\n\
    \    var longest_palindrome_suffix = [Int](count: string_suffix_length, repeatedValue:\
    \ 0)\n    var current_longest_palindrome_suffix_length = 0\n    for i in 1..<string_suffix_length\
    \ {\n        if string_suffix[string_suffix.startIndex.advancedBy(i)] == string_suffix[string_suffix.startIndex.advancedBy(current_longest_palindrome_suffix_length)]\
    \ {\n            current_longest_palindrome_suffix_length += 1\n            longest_palindrome_suffix[i]\
    \ = current_longest_palindrome_suffix_length\n        } else {\n            if\
    \ current_longest_palindrome_suffix_length != 0 {\n                current_longest_palindrome_suffix_length\
    \ = longest_palindrome_suffix[current_longest_palindrome_suffix_length - 1]\n\
    \                i -= 1\n            }\n        }\n    }\n    let prefix_length\
    \ = string_length - longest_palindrome_suffix[string_suffix_length - 1]\n    let\
    \ prefix = string[string.startIndex..<string.startIndex.advancedBy(prefix_length)]\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpafcy6rq1.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpafcy6rq1.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpafcy6rq1.swift:11:87:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_palindrome_suffix\
    \ = [Int](count: string_suffix_length, repeatedValue: 0)\n                   \
    \                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmpafcy6rq1.swift:25:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string[string.startIndex..<string.startIndex.advancedBy(prefix_length)]\n\
    \                                            ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + reversed_string\n    let string_with_reversed_prefix_length = string_with_reversed_prefix.characters.count\n\
    \    let z_function = z_function_of_string(string_with_reversed_prefix)\n    let\
    \ z_function_length = z_function.count\n    var longest_palindrome_suffix_length\
    \ = 0\n    for i in 0..<z_function_length {\n        if z_function[i] == string_length\
    \ {\n            longest_palindrome_suffix_length = string_length - i\n      \
    \      break\n        }\n    }\n    let prefix_length = string_length - longest_palindrome_suffix_length\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp77ipb_38.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp77ipb_38.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp77ipb_38.swift:11:22:\
    \ error: cannot find 'z_function_of_string' in scope\n    let z_function = z_function_of_string(string_with_reversed_prefix)\n\
    \                     ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp77ipb_38.swift:21:25: error:\
    \ value of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp77ipb_38.swift:21:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed_string = String(string.characters.reverse())\n\
    \    let combined_string = string + \"#\" + reversed_string\n    let z_function\
    \ = z_algorithm(string: combined_string)\n    let z_function_length = z_function.count\n\
    \    let z_function_last_element = z_function[z_function_length - 1]\n    let\
    \ prefix_length = string.characters.count - z_function_last_element\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n   \
    \ let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpf8zc_lvt.swift:7:52: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed_string = String(string.characters.reverse())\n \
    \                                ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpf8zc_lvt.swift:9:22:\
    \ error: cannot find 'z_algorithm' in scope\n    let z_function = z_algorithm(string:\
    \ combined_string)\n                     ^~~~~~~~~~~\n/tmp/tmpf8zc_lvt.swift:13:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n   \
    \              ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpf8zc_lvt.swift:13:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        // Check for palindromes of odd length.\n        var j = 0\n        while\
    \ i - j >= 0 && i + j < string_length && string_chars[i - j] == string_chars[i\
    \ + j] {\n            j += 1\n        }\n        if j > longest_palindrome_length\
    \ {\n            longest_palindrome_length = j\n            longest_palindrome_start\
    \ = i - j + 1\n        }\n        // Check for palindromes of even length.\n \
    \       j = 0\n        while i - j >= 0 && i + j + 1 < string_length && string_chars[i\
    \ - j] == string_chars[i + j + 1] {\n            j += 1\n        }\n        if\
    \ j > longest_palindrome_length {\n            longest_palindrome_length = j\n\
    \            longest_palindrome_start = i - j + 1\n        }\n    }\n    let prefix\
    \ = String(string_chars[0..<longest_palindrome_start])\n    let reversed_prefix\
    \ = String(prefix.characters.reverse())\n    return prefix + reversed_prefix +\
    \ String(string_chars[longest_palindrome_start + longest_palindrome_length..<string_length])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp4_9h24lq.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp4_9h24lq.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp4_9h24lq.swift:32:52: error: value of type 'String'\
    \ has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var current_palindrome_length =\
    \ 0\n    var current_palindrome_index = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae =\
    \ 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj\
    \ = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var\
    \ ao = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n   \
    \ var at = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n\
    \    var ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc =\
    \ 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh\
    \ = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var\
    \ bm = 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n   \
    \ var br = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n\
    \    var bw = 0\n    var bx = 0\n    var by = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp09dkc19x.swift:49:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmp09dkc19x.swift:49:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmp09dkc19x.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp09dkc19x.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp09dkc19x.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp09dkc19x.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmp09dkc19x.swift:9:9: warning: initialization of variable 'longest_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmp09dkc19x.swift:10:9: warning: initialization of variable 'longest_palindrome_index'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_index = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp09dkc19x.swift:11:9: warning: initialization of variable 'current_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var current_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    let reversed_string = String(string_chars.reversed())\n\
    \    let reversed_string_chars = Array(reversed_string)\n    let reversed_string_length\
    \ = reversed_string.count\n    var longest_prefix_length = 0\n    var longest_prefix_index\
    \ = 0\n    var longest_suffix_length = 0\n    var longest_suffix_index = 0\n \
    \   var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    var longest_palindrome_length_index = 0\n    var longest_palindrome_index_index\
    \ = 0\n    var longest_palindrome_length_index_index = 0\n    var longest_palindrome_index_index_index\
    \ = 0\n    var longest_palindrome_length_index_index_index = 0\n    var longest_palindrome_index_index_index_index\
    \ = 0\n    var longest_palindrome_length_index_index_index_index = 0\n    var\
    \ longest_palindrome_index_index_index_index_index = 0\n    var longest_palindrome_length_index_index_index_index_index\
    \ = 0\n    var longest_palindrome_index_index_index_index_index_index = 0\n  \
    \  var longest_palindrome_length_index_index_index_index_index_index = 0\n   \
    \ var longest_palindrome_index_index_index_index_index_index_index = 0\n    var\
    \ longest_palindrome_length_index_index_index_index_index_index_index = 0\n  \
    \  var longest_palindrome_index_index_index_index_index_index_index_index = 0\n\
    \    var longest_palindrome_length_index_index_index_index_index_index_index_index\
    \ = 0\n    var longest_palindrome_index_index_index_index_index_index_index_index_index\
    \ = 0\n    var longest_palindrome_length_index_index_index_index_index_index_index_index_index\
    \ = 0\n    var longest_palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp12ih6hco.swift:35:9: error: type annotation missing in pattern\n\
    \    var longest_palindrome\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_characters\
    \ = Array(string)\n    let reversed_string = String(string_characters.reversed())\n\
    \    let reversed_string_length = reversed_string.count\n    let reversed_string_characters\
    \ = Array(reversed_string)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    var longest_palindrome_end = 0\n    var longest_palindrome_reversed_start\
    \ = 0\n    var longest_palindrome_reversed_end = 0\n    var longest_palindrome_reversed_length\
    \ = 0\n    var longest_palindrome_reversed_start_index = 0\n    var longest_palindrome_reversed_end_index\
    \ = 0\n    var longest_palindrome_reversed_length_index = 0\n    var longest_palindrome_reversed_start_char\
    \ = \"\"\n    var longest_palindrome_reversed_end_char = \"\"\n    var longest_palindrome_reversed_length_char\
    \ = \"\"\n    var longest_palindrome_reversed_start_char_index = 0\n    var longest_palindrome_reversed_end_char_index\
    \ = 0\n    var longest_palindrome_reversed_length_char_index = 0\n    var longest_palindrome_reversed_start_char_index_plus_one\
    \ = 0\n    var longest_palindrome_reversed_end_char_index_plus_one = 0\n    var\
    \ longest_palindrome_reversed_length_char_index_plus_one = 0\n    var longest_palindrome_reversed_start_char_index_plus_one_char\
    \ = \"\"\n    var longest_palindrome_reversed_end_char_index_plus_one_char = \"\
    \"\n    var longest_palindrome_reversed_length_char_index_plus_one_char = \"\"\
    \n    var longest_palindrome_reversed_start_char_index_plus_one_char_index = 0\n\
    \    var longest_palindrome_re\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp4x96ogx9.swift:34:9: error: type annotation missing in pattern\n\
    \    var longest_palindrome_re\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps.last!))\n    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9ylv10h7.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp9ylv10h7.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_lengths = [Int](count:\
    \ string_length, repeatedValue: 0)\n    for index in 0..<string_length {\n   \
    \     var palindrome_length = 0\n        if index > 0 && index < string_length\
    \ - 1 {\n            palindrome_length = min(palindrome_lengths[index - 1], string_length\
    \ - index - 1)\n        } else {\n            palindrome_length = string_length\
    \ - index - 1\n        }\n        while palindrome_length >= 0 && string_array[index\
    \ - palindrome_length] == string_array[index + palindrome_length] {\n        \
    \    palindrome_length -= 1\n        }\n        palindrome_lengths[index] = palindrome_length\
    \ + 1\n        if palindrome_lengths[index] > longest_palindrome_length {\n  \
    \          longest_palindrome_length = palindrome_lengths[index]\n           \
    \ longest_palindrome_index = index\n        }\n    }\n    let palindrome_prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n    let palindrome_suffix = String(palindrome_prefix.characters.reverse())\n\
    \    return string + palindrome_suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpm43wjlss.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpm43wjlss.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpm43wjlss.swift:11:30: error: no exact matches in call\
    \ to initializer \n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmpm43wjlss.swift:11:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmpm43wjlss.swift:11:30: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var palindrome_lengths\
    \ = [Int](count: string_length, repeatedValue: 0)\n                          \
    \   ^\n/tmp/tmpm43wjlss.swift:28:36: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    let palindrome_prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n                            ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpm43wjlss.swift:28:71: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let palindrome_prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n                                        \
    \            ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var palindrome_suffix = [Character]()\n\
    \    var palindrome_prefix = [Character]()\n    var palindrome_suffix_length =\
    \ 0\n    var palindrome_prefix_length = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae =\
    \ 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj\
    \ = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var\
    \ ao = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n   \
    \ var at = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n\
    \    var ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc =\
    \ 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh\
    \ = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var\
    \ bm = 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n   \
    \ var br = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n\
    \    var bw = 0\n    var bx = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpyci2cgo6.swift:49:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpyci2cgo6.swift:49:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpyci2cgo6.swift:81:8: error: expected pattern\n    var\n\
    \       ^\n/tmp/tmpyci2cgo6.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpyci2cgo6.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyci2cgo6.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpyci2cgo6.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpyci2cgo6.swift:9:9: warning: initialization of variable 'palindrome_suffix'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_suffix = [Character]()\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpyci2cgo6.swift:10:9: warning: initialization of variable 'palindrome_prefix'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_prefix = [Character]()\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpyci2cgo6.swift:11:9: warning: initialization of variable 'palindrome_suffix_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palind"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    var\
    \ index = 0\n    for i in 1..<string_with_reversed_prefix_length {\n        if\
    \ string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ == string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(index)]\
    \ {\n            index += 1\n            longest_prefix_suffix[i] = index\n  \
    \      } else {\n            if index != 0 {\n                index = longest_prefix_suffix[index\
    \ - 1]\n                i -= 1\n            }\n        }\n    }\n    return reversed_string.substringToIndex(reversed_string.startIndex.advancedBy(string_length\
    \ - longest_prefix_suffix[string_with_reversed_prefix_length - 1])) + string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2vlu3yta.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2vlu3yta.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp2vlu3yta.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reverse()\n    let concatenated\
    \ = string + \"#\" + reversed\n    let z_array = z_function(concatenated)\n  \
    \  let z_array_without_first_element = Array(z_array[1..<z_array.count])\n   \
    \ let max_index = maxElementIndex(z_array_without_first_element)\n    let prefix\
    \ = string[0..<(string.count - max_index - 1)]\n    let reversed_prefix = prefix.reverse()\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprlx83azo.swift:7:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmprlx83azo.swift:9:19: error: cannot find 'z_function' in scope\n    let\
    \ z_array = z_function(concatenated)\n                  ^~~~~~~~~~\n/tmp/tmprlx83azo.swift:11:21:\
    \ error: cannot find 'maxElementIndex' in scope\n    let max_index = maxElementIndex(z_array_without_first_element)\n\
    \                    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n \
    \   var palindrome_index = 0\n    var i = 0\n    var j = 0\n    while i < string_length\
    \ {\n        j = 0\n        while i - j >= 0 && i + j < string_length && string_characters[i\
    \ - j] == string_characters[i + j] {\n            palindrome_length = j * 2 +\
    \ 1\n            palindrome_index = i - j\n            j += 1\n        }\n   \
    \     if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_index = palindrome_index\n\
    \        }\n        j = 0\n        while i - j >= 0 && i + j + 1 < string_length\
    \ && string_characters[i - j] == string_characters[i + j + 1] {\n            palindrome_length\
    \ = j * 2 + 2\n            palindrome_index = i - j\n            j += 1\n    \
    \    }\n        if palindrome_length > longest_palindrome_length {\n         \
    \   longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = palindrome_index\n        }\n        i += 1\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpp3x9l3fm.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpp3x9l3fm.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpp3x9l3fm.swift:38:25: error: value of type\
    \ 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpp3x9l3fm.swift:38:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var is_palindrome = Array(count:\
    \ string_length, repeatedValue: Array(count: string_length, repeatedValue: false))\n\
    \    for i in 0..<string_length {\n        is_palindrome[i][i] = true\n      \
    \  if i < string_length - 1 && string_array[i] == string_array[i + 1] {\n    \
    \        is_palindrome[i][i + 1] = true\n            longest_palindrome_length\
    \ = 2\n            longest_palindrome_index = i\n        }\n    }\n    for i in\
    \ 2..<string_length {\n        for j in 0..<string_length - i {\n            if\
    \ string_array[j] == string_array[j + i] && is_palindrome[j + 1][j + i - 1] {\n\
    \                is_palindrome[j][j + i] = true\n                longest_palindrome_length\
    \ = i + 1\n                longest_palindrome_index = j\n            }\n     \
    \   }\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \    let prefix_reversed = String(prefix.characters.reverse())\n    return string\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp77wh3mh8.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp77wh3mh8.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp77wh3mh8.swift:11:25: error: no exact matches in call\
    \ to initializer \n    var is_palindrome = Array(count: string_length, repeatedValue:\
    \ Array(count: string_length, repeatedValue: false))\n                       \
    \ ^\n/tmp/tmp77wh3mh8.swift:11:25: note: candidate has partially matching parameter\
    \ list (repeating: _, count: Int)\n    var is_palindrome = Array(count: string_length,\
    \ repeatedValue: Array(count: string_length, repeatedValue: false))\n        \
    \                ^\n/tmp/tmp77wh3mh8.swift:11:25: note: candidate has partially\
    \ matching parameter list (repeating: _, count: Int)\n    var is_palindrome =\
    \ Array(count: string_length, repeatedValue: Array(count: string_length, repeatedValue:\
    \ false))\n                        ^\n/tmp/tmp77wh3mh8.swift:11:111: error: extra\
    \ argument 'repeatedValue' in call\n    var is_palindrome = Array(count: string_length,\
    \ repeatedValue: Array(count: string_length, repeatedValue: false))\n        \
    \                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmp77wh3mh8.swift:11:74: error: missing argument for parameter 'repeating'\
    \ in call\n    var is_palindrome = Array(count: string_length, repeatedValue:\
    \ Array(count: string_length, repeatedValue: false))\n                       \
    \                                                  ^\n                       \
    \                                                  repeating: <#_#>, \nSwift."
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var longest_palindrome_array =\
    \ [Character]()\n    var longest_palindrome_string = \"\"\n    var longest_palindrome_prefix\
    \ = \"\"\n    var longest_palindrome_prefix_array = [Character]()\n    var longest_palindrome_prefix_string\
    \ = \"\"\n    var longest_palindrome_prefix_reverse_string = \"\"\n    var longest_palindrome_prefix_reverse_array\
    \ = [Character]()\n    var longest_palindrome_prefix_reverse_string_array = [Character]()\n\
    \    var longest_palindrome_prefix_reverse_string_array_length = 0\n    var longest_palindrome_prefix_reverse_string_array_index\
    \ = 0\n    var longest_palindrome_prefix_reverse_string_array_index_end = 0\n\
    \    var longest_palindrome_prefix_reverse_string_array_index_start = 0\n    var\
    \ longest_palindrome_prefix_reverse_string_array_index_start_end = 0\n    var\
    \ longest_palindrome_prefix_reverse_string_array_index_start_end_length = 0\n\
    \    var longest_palindrome_prefix_reverse_string_array_index_start_end_length_index\
    \ = 0\n    var longest_palindrome_prefix_reverse_string_array_index_start_end_length_index_end\
    \ = 0\n    var longest_palindrome_prefix_reverse_string_array_index_start_end_length_index_end_length\
    \ = 0\n    var longest_palindrome_prefix_reverse_string_array_index_start_end_length_index_end_length_index\
    \ = 0\n    var longest_palindrome_prefix_reverse_string_array_index_start_end_length_index_end_length_index_end\
    \ = 0\n    var longest_palindrome_prefix_reverse_string_array_index_start_end_length_index_end_length_index_end_length\
    \ = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpht_2w94d.swift:31:8: error: expected pattern\n    var\n       ^\n\
    /tmp/tmpht_2w94d.swift:7:32: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_length = string.characters.count\n                \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpht_2w94d.swift:8:37: error: 'characters' is unavailable: Please use\
    \ String directly\n    let string_array = Array(string.characters)\n         \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpht_2w94d.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpht_2w94d.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpht_2w94d.swift:9:9: warning: initialization of variable 'longest_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmpht_2w94d.swift:10:9: warning: initialization of variable 'longest_palindrome_index'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_index = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpht_2w94d.swift:11:9: warning: initialization of variable 'longest_palindrome_array'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_array = [Character]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpht_2w94d.swift:12:9: warning: initialization of variable 'longest_palindrome_string'\
    \ was never used; consider replacing with assignment to"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed_string = String(string.characters.reverse())\n\
    \    let combined_string = string + \"#\" + reversed_string\n    let lps = longest_prefix_suffix(combined_string)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return prefix\
    \ + string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmph6o_ou7i.swift:7:52: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed_string = String(string.characters.reverse())\n \
    \                                ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmph6o_ou7i.swift:9:15:\
    \ error: cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined_string)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    for i in 0..<string_length {\n        // Check\
    \ for odd palindromes.\n        palindrome_length = 0\n        palindrome_index\
    \ = i\n        while palindrome_index >= 0 && palindrome_index < string_length\
    \ {\n            if string_array[palindrome_index] == string_array[i] {\n    \
    \            palindrome_length += 1\n                palindrome_index -= 1\n \
    \           } else {\n                break\n            }\n        }\n      \
    \  if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_index = i\n        }\n \
    \       // Check for even palindromes.\n        palindrome_length = 0\n      \
    \  palindrome_index = i\n        while palindrome_index >= 0 && palindrome_index\
    \ < string_length {\n            if string_array[palindrome_index] == string_array[i\
    \ + 1] {\n                palindrome_length += 1\n                palindrome_index\
    \ -= 1\n            } else {\n                break\n            }\n        }\n\
    \        if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_index = i\n        }\n \
    \   }\n    let prefix_length = string_length - longest_palindrome_length\n   \
    \ let prefix_start = string.startIndex\n    let prefix_end = string.index(prefix_start,\
    \ offsetBy: prefix_length)\n    let prefix = string.substring(to: prefix_end)\n\
    \    let reversed_prefix = String(prefix.characters.reversed())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp85y56bvm.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp85y56bvm.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp85y56bvm.swift:48:25: error: value of type 'String'\
    \ has no member 'substring'\n    let prefix = string.substring(to: prefix_end)\n\
    \                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    var longest_palindrome_end = 0\n    for i in 0..<string_length {\n\
    \        var j = 0\n        while i - j >= 0 && i + j < string_length && string_chars[i\
    \ - j] == string_chars[i + j] {\n            j += 1\n        }\n        if j >\
    \ longest_palindrome_length {\n            longest_palindrome_length = j\n   \
    \         longest_palindrome_start = i - j + 1\n            longest_palindrome_end\
    \ = i + j - 1\n        }\n    }\n    var result = \"\"\n    for i in 0..<longest_palindrome_start\
    \ {\n        result.append(string_chars[i])\n    }\n    for i in (longest_palindrome_end\
    \ + 1..<string_length).reversed() {\n        result.append(string_chars[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace04df2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace04ae9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace04ae9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace04ae913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace04ae8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpybllzjof                        0x00005571dd59e65e <unavailable> + 9822

    6    tmpybllzjof                        0x00005571dd59d945 <unavailable> + 6469

    7    libc.so.6                          0x00002ace04fde460 __libc_start_main +
    245

    8    tmpybllzjof                        0x00005571dd59d649 <unavailable> + 5705

    '
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \    \n    var longest_palindrome_length = 0\n    var longest_palindrome_end_index\
    \ = 0\n    \n    // Find the longest palindrome suffix.\n    for i in 0..<string_length\
    \ {\n        let reversed_string_index = string_length - 1 - i\n        if string_array[i]\
    \ == reversed_string_array[reversed_string_index] {\n            if i + 1 > longest_palindrome_length\
    \ {\n                longest_palindrome_length = i + 1\n                longest_palindrome_end_index\
    \ = i\n            }\n        } else {\n            break\n        }\n    }\n\
    \    \n    // Append the reverse of the prefix to the end of the string.\n   \
    \ var result = string\n    for i in 0..<string_length - longest_palindrome_length\
    \ {\n        result.append(reversed_string_array[i])\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpr8omkamt.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpr8omkamt.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpr8omkamt.swift:9:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpr8omkamt.swift:12:9: warning: variable\
    \ 'longest_palindrome_end_index' was written to, but never read\n    var longest_palindrome_end_index\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_end = 0\n    var longest_palindrome_begin = 0\n\
    \    var longest_palindrome_end_reverse = 0\n    var longest_palindrome_begin_reverse\
    \ = 0\n    var longest_palindrome_length_reverse = 0\n    var longest_palindrome_end_reverse_reverse\
    \ = 0\n    var longest_palindrome_begin_reverse_reverse = 0\n    var longest_palindrome_length_reverse_reverse\
    \ = 0\n    var longest_palindrome_end_reverse_reverse_reverse = 0\n    var longest_palindrome_begin_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_length_reverse_reverse_reverse = 0\n    var\
    \ longest_palindrome_end_reverse_reverse_reverse_reverse = 0\n    var longest_palindrome_begin_reverse_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_length_reverse_reverse_reverse_reverse = 0\n\
    \    var longest_palindrome_end_reverse_reverse_reverse_reverse_reverse = 0\n\
    \    var longest_palindrome_begin_reverse_reverse_reverse_reverse_reverse = 0\n\
    \    var longest_palindrome_length_reverse_reverse_reverse_reverse_reverse = 0\n\
    \    var longest_palindrome_end_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_begin_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_length_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_end_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_begin_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_length_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = 0\n    var longest_palindrome_end_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmph_4rplxq.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmph_4rplxq.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph_4rplxq.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmph_4rplxq.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmph_4rplxq.swift:9:9: warning: initialization of variable 'longest_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmph_4rplxq.swift:10:9: warning: initialization of variable 'longest_palindrome_end'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_end = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmph_4rplxq.swift:11:9:\
    \ warning: initialization of variable 'longest_palindrome_begin' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var longest_palindrome_begin\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmph_4rplxq.swift:12:9: warning:\
    \ initialization of variable 'longest_palindrome_end_reverse' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var longest_palindrome_end_reverse\
    \ = 0\n    ~~~~^~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    var\
    \ longest_prefix_suffix_length = 0\n    var longest_prefix_suffix_index = 0\n\
    \    for i in 1..<string_with_reversed_prefix_length {\n        if string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ == string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(longest_prefix_suffix_length)]\
    \ {\n            longest_prefix_suffix_length += 1\n            longest_prefix_suffix[i]\
    \ = longest_prefix_suffix_length\n        } else {\n            if longest_prefix_suffix_length\
    \ > 0 {\n                longest_prefix_suffix_index = i - 1\n               \
    \ longest_prefix_suffix_length = longest_prefix_suffix[longest_prefix_suffix_index]\n\
    \            }\n        }\n    }\n    return reversed_string.substringToIndex(reversed_string.startIndex.advancedBy(string_length\
    \ - longest_prefix_suffix[string_with_reversed_prefix_length - 1])) + string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxg2p_n96.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpxg2p_n96.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpxg2p_n96.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps))\n    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnnuxukvg.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpnnuxukvg.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var\
    \ m = 0\n    var n = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac\
    \ = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var\
    \ ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n   \
    \ var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n\
    \    var ar = 0\n    var as_ = 0\n    var at = 0\n    var au = 0\n    var av =\
    \ 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba\
    \ = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var\
    \ bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n   \
    \ var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo = 0\n\
    \    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n    var bt =\
    \ 0\n    var bu = 0\n    var bv = 0\n    var bw = 0\n    var bx = 0\n    var by\
    \ = 0\n    var bz = 0\n    var ca = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjkmj7zo6.swift:82:8: error: expected pattern\n    var\n       ^\n\
    /tmp/tmpjkmj7zo6.swift:7:32: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_length = string.characters.count\n                \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjkmj7zo6.swift:8:37: error: 'characters' is unavailable: Please use\
    \ String directly\n    let string_array = Array(string.characters)\n         \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjkmj7zo6.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpjkmj7zo6.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpjkmj7zo6.swift:9:9: warning: initialization of variable 'longest_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmpjkmj7zo6.swift:10:9: warning: initialization of variable 'longest_palindrome_index'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_index = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpjkmj7zo6.swift:11:9: warning: initialization of variable 'palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpjkmj7zo6.swift:12:9:\
    \ warning: initialization of variable 'palindrome_index' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var palindrome_ind"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed_string = String(string.characters.reverse())\n\
    \    let combined_string = string + \"#\" + reversed_string\n    let lps = longest_prefix_suffix(combined_string)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.last!))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp46boaco6.swift:7:52: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed_string = String(string.characters.reverse())\n \
    \                                ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp46boaco6.swift:9:15:\
    \ error: cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined_string)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps_h8owoz.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmps_h8owoz.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = i\n        var k = i\n        while k < string_length - 1\
    \ && string_characters[k + 1] == string_characters[k] {\n            k += 1\n\
    \        }\n        i = k + 1\n        while k < string_length - 1 && j > 0 &&\
    \ string_characters[k + 1] == string_characters[j - 1] {\n            k += 1\n\
    \            j -= 1\n        }\n        let current_palindrome_length = k - j\
    \ + 1\n        if current_palindrome_length > longest_palindrome_length {\n  \
    \          longest_palindrome_length = current_palindrome_length\n           \
    \ longest_palindrome_index = j\n        }\n    }\n    let prefix = String(string_characters[0..<longest_palindrome_index])\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpopk_kxo1.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpopk_kxo1.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpopk_kxo1.swift:30:52: error: value of type\
    \ 'String' has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ suffix_start = 0\n    var suffix_end = 0\n    var prefix_start = 0\n    var\
    \ prefix_end = 0\n    var prefix_length = 0\n    var palindrome_length = 0\n \
    \   var palindrome_start = 0\n    var palindrome_end = 0\n    var palindrome_length_max\
    \ = 0\n    var palindrome_start_max = 0\n    var palindrome_end_max = 0\n    var\
    \ palindrome_length_max_prev = 0\n    var palindrome_start_max_prev = 0\n    var\
    \ palindrome_end_max_prev = 0\n    var palindrome_length_max_prev_prev = 0\n \
    \   var palindrome_start_max_prev_prev = 0\n    var palindrome_end_max_prev_prev\
    \ = 0\n    var palindrome_length_max_prev_prev_prev = 0\n    var palindrome_start_max_prev_prev_prev\
    \ = 0\n    var palindrome_end_max_prev_prev_prev = 0\n    var palindrome_length_max_prev_prev_prev_prev\
    \ = 0\n    var palindrome_start_max_prev_prev_prev_prev = 0\n    var palindrome_end_max_prev_prev_prev_prev\
    \ = 0\n    var palindrome_length_max_prev_prev_prev_prev_prev = 0\n    var palindrome_start_max_prev_prev_prev_prev_prev\
    \ = 0\n    var palindrome_end_max_prev_prev_prev_prev_prev = 0\n    var palindrome_length_max_prev_prev_prev_prev_prev_prev\
    \ = 0\n    var palindrome_start_max_prev_prev_prev_prev_prev_prev = 0\n    var\
    \ palindrome_end_max_prev_prev_prev_prev_prev_prev = 0\n    var palindrome_length_max_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp7bayojnz.swift:40:8: error: expected pattern\n    var\n       ^\n\
    /tmp/tmp7bayojnz.swift:7:32: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_length = string.characters.count\n                \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7bayojnz.swift:8:37: error: 'characters' is unavailable: Please use\
    \ String directly\n    let string_array = Array(string.characters)\n         \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp7bayojnz.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp7bayojnz.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmp7bayojnz.swift:9:9: warning: initialization of variable 'suffix_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var suffix_length = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp7bayojnz.swift:10:9:\
    \ warning: initialization of variable 'suffix_start' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var suffix_start = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp7bayojnz.swift:11:9: warning: initialization\
    \ of variable 'suffix_end' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var suffix_end = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp7bayojnz.swift:12:9:\
    \ warning: initialization of variable 'prefix_start' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var prefix_start = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp7bayojnz.swift:13:9: warning: initialization\
    \ of variable 'p"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    var longest_palindrome_end =\
    \ 0\n    for i in 0..<string_length {\n        var j = 0\n        while i - j\
    \ >= 0 && i + j < string_length && string_characters[i - j] == string_characters[i\
    \ + j] {\n            j += 1\n        }\n        if j > longest_palindrome_length\
    \ {\n            longest_palindrome_length = j\n            longest_palindrome_start\
    \ = i - j + 1\n            longest_palindrome_end = i + j - 1\n        }\n   \
    \     j = 0\n        while i - j >= 0 && i + j + 1 < string_length && string_characters[i\
    \ - j] == string_characters[i + j + 1] {\n            j += 1\n        }\n    \
    \    if j > longest_palindrome_length {\n            longest_palindrome_length\
    \ = j\n            longest_palindrome_start = i - j + 1\n            longest_palindrome_end\
    \ = i + j\n        }\n    }\n    let prefix = String(string_characters[0..<longest_palindrome_start])\n\
    \    let suffix = String(string_characters[longest_palindrome_end + 1..<string_length])\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return reversed_prefix\
    \ + string + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpdiyw9sxo.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpdiyw9sxo.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpdiyw9sxo.swift:34:52: error: value of type\
    \ 'String' has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    for\
    \ i in 1..<string_with_reversed_prefix_length {\n        var j = longest_prefix_suffix[i\
    \ - 1]\n        while j > 0 && string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ != string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(j)]\
    \ {\n            j = longest_prefix_suffix[j - 1]\n        }\n        if string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ == string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(j)]\
    \ {\n            j += 1\n        }\n        longest_prefix_suffix[i] = j\n   \
    \ }\n    return reversed_string.substringToIndex(reversed_string.startIndex.advancedBy(string_length\
    \ - longest_prefix_suffix[string_with_reversed_prefix_length - 1])) + string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpkonnsyvl.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpkonnsyvl.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpkonnsyvl.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var palindrome_suffix_length =\
    \ 0\n    var palindrome_suffix_start = 0\n    for i in 0..<string_length {\n \
    \       let j = string_length - 1 - i\n        if string_array[i] == string_array[j]\
    \ {\n            palindrome_suffix_length += 1\n            palindrome_suffix_start\
    \ = i\n        } else {\n            break\n        }\n    }\n    let palindrome_prefix_length\
    \ = string_length - palindrome_suffix_length\n    let palindrome_prefix_start\
    \ = palindrome_suffix_start - palindrome_prefix_length + 1\n    let palindrome_prefix\
    \ = String(string_array[palindrome_prefix_start..<palindrome_suffix_start + 1])\n\
    \    let palindrome_prefix_reversed = String(palindrome_prefix.characters.reverse())\n\
    \    return string + palindrome_prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpa3npbqp4.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpa3npbqp4.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpa3npbqp4.swift:23:74: error: value of type 'String'\
    \ has no member 'reverse'\n    let palindrome_prefix_reversed = String(palindrome_prefix.characters.reverse())\n\
    \                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = string.characters.reverse()\n    let reversed_string_array\
    \ = Array(reversed_string)\n    var longest_palindrome_length = 0\n    var longest_palindrome_index\
    \ = 0\n    var i = 0\n    while i < string_length {\n        var j = 0\n     \
    \   while i - j >= 0 && i + j < string_length && string[i - j] == reversed_string_array[i\
    \ + j] {\n            if 2 * j + 1 > longest_palindrome_length {\n           \
    \     longest_palindrome_length = 2 * j + 1\n                longest_palindrome_index\
    \ = i - j\n            }\n            j += 1\n        }\n        j = 0\n     \
    \   while i - j >= 0 && i + j + 1 < string_length && string[i - j] == reversed_string_array[i\
    \ + j + 1] {\n            if 2 * j + 2 > longest_palindrome_length {\n       \
    \         longest_palindrome_length = 2 * j + 2\n                longest_palindrome_index\
    \ = i - j\n            }\n            j += 1\n        }\n        i += 1\n    }\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \    let reversed_prefix = prefix.characters.reverse()\n    return string + String(reversed_prefix)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp_d5an_bc.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp_d5an_bc.swift:8:45: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = string.characters.reverse()\n\
    \                          ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp_d5an_bc.swift:32:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp_d5an_bc.swift:32:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpk9zy2tuv.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpk9zy2tuv.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk9zy2tuv.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n       \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpk9zy2tuv.swift:10:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_length = 0\n    for\
    \ i in 0..<string_length {\n        if is_palindrome(string: string, start: i,\
    \ end: string_length - 1) {\n            suffix_length = string_length - i\n \
    \           break\n        }\n    }\n    var prefix_length = string_length - suffix_length\n\
    \    var result = string\n    for i in 0..<prefix_length {\n        result.append(string_array[prefix_length\
    \ - i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpldxsnw5j.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpldxsnw5j.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpldxsnw5j.swift:11:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string: string, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps.last!))\n    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9ylv10h7.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp9ylv10h7.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.last!))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpruqq2sk5.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpruqq2sk5.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var palindrome_suffix = String(string_array[0])\n\
    \    var palindrome_prefix = String(string_array[0])\n    for i in 1..<string_length\
    \ {\n        palindrome_suffix = String(string_array[i]) + palindrome_suffix\n\
    \        palindrome_prefix = palindrome_prefix + String(string_array[i])\n   \
    \     if palindrome_suffix == palindrome_prefix {\n            return string +\
    \ String(palindrome_prefix.characters.reversed())\n        }\n    }\n    return\
    \ string + String(palindrome_prefix.characters.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8agzlotf.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8agzlotf.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8agzlotf.swift:15:54: error: 'characters' is unavailable:\
    \ Please use String directly\n            return string + String(palindrome_prefix.characters.reversed())\n\
    \                                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8agzlotf.swift:18:46: error: 'characters'\
    \ is unavailable: Please use String directly\n    return string + String(palindrome_prefix.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    if\
    \ string_length <= 1 {\n        return string\n    }\n    let string_characters\
    \ = Array(string.characters)\n    let string_characters_reversed = Array(string.characters.reversed())\n\
    \    var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    var i = 0\n    while i < string_length {\n        var j = 0\n        while\
    \ i - j >= 0 && i + j < string_length && string_characters[i - j] == string_characters[i\
    \ + j] {\n            j += 1\n        }\n        if j > longest_palindrome_length\
    \ {\n            longest_palindrome_length = j\n            longest_palindrome_index\
    \ = i\n        }\n        i += 1\n    }\n    var result = string\n    let prefix_length\
    \ = longest_palindrome_index - longest_palindrome_length + 1\n    let prefix_start\
    \ = string.index(string.startIndex, offsetBy: prefix_length)\n    let prefix =\
    \ string.substring(to: prefix_start)\n    result.append(contentsOf: prefix.characters.reversed())\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpt1tkv0z7.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpt1tkv0z7.swift:11:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpt1tkv0z7.swift:12:51: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_characters_reversed\
    \ = Array(string.characters.reversed())\n                                    \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpt1tkv0z7.swift:30:25: error: value of type 'String' has no member\
    \ 'substring'\n    let prefix = string.substring(to: prefix_start)\n         \
    \        ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_suffix\
    \ = string + \"#\" + reversed_string\n    var longest_palindrome_suffix = [Int](count:\
    \ string_suffix.characters.count, repeatedValue: 0)\n    var current_longest_palindrome_suffix_length\
    \ = 0\n    for i in 1..<string_suffix.characters.count {\n        while current_longest_palindrome_suffix_length\
    \ > 0 && string_suffix[string_suffix.startIndex.advancedBy(current_longest_palindrome_suffix_length)]\
    \ != string_suffix[string_suffix.startIndex.advancedBy(i)] {\n            current_longest_palindrome_suffix_length\
    \ = longest_palindrome_suffix[current_longest_palindrome_suffix_length - 1]\n\
    \        }\n        if string_suffix[string_suffix.startIndex.advancedBy(current_longest_palindrome_suffix_length)]\
    \ == string_suffix[string_suffix.startIndex.advancedBy(i)] {\n            current_longest_palindrome_suffix_length\
    \ += 1\n        }\n        longest_palindrome_suffix[i] = current_longest_palindrome_suffix_length\n\
    \    }\n    let palindrome_suffix_length = longest_palindrome_suffix[string_suffix.characters.count\
    \ - 1]\n    let palindrome_prefix_length = string_length - palindrome_suffix_length\n\
    \    let palindrome_prefix = String(string.characters.prefix(palindrome_prefix_length))\n\
    \    let palindrome_suffix = String(palindrome_prefix.characters.reverse())\n\
    \    return string + palindrome_suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpj1r_fank.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpj1r_fank.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpj1r_fank.swift:10:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_palindrome_suffix\
    \ = [Int](count: string_suffix.characters.count, repeatedValue: 0)\n         \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_chars\
    \ = Array(reversed_string.characters)\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = 0\n        while j < reversed_string_length {\n         \
    \   var k = 0\n            while k < string_length - i && k < reversed_string_length\
    \ - j && string_chars[i + k] == reversed_string_chars[j + k] {\n             \
    \   k += 1\n            }\n            if k > longest_palindrome_length {\n  \
    \              longest_palindrome_length = k\n                longest_palindrome_index\
    \ = i\n            }\n            j += 1\n        }\n        i += 1\n    }\n \
    \   let prefix = String(string_chars[0..<longest_palindrome_index])\n    let reversed_prefix\
    \ = String(prefix.characters.reverse())\n    return prefix + reversed_prefix +\
    \ string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpgww4agwq.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgww4agwq.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgww4agwq.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpgww4agwq.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpgww4agwq.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpgww4agwq.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpgww4agwq.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpgww4agwq.swift:31:52: error: value of type\
    \ 'String' has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reverse_string = String(string.characters.reverse())\n    let string_suffix\
    \ = string + \"#\" + reverse_string\n    let string_suffix_length = string_suffix.characters.count\n\
    \    var longest_prefix_suffix = [Int](count: string_suffix_length, repeatedValue:\
    \ 0)\n    var longest_prefix_suffix_length = 0\n    for i in 1..<string_suffix_length\
    \ {\n        var j = longest_prefix_suffix[i - 1]\n        while j > 0 && string_suffix[string_suffix.startIndex.advancedBy(i)]\
    \ != string_suffix[string_suffix.startIndex.advancedBy(j)] {\n            j =\
    \ longest_prefix_suffix[j - 1]\n        }\n        if string_suffix[string_suffix.startIndex.advancedBy(i)]\
    \ == string_suffix[string_suffix.startIndex.advancedBy(j)] {\n            j +=\
    \ 1\n        }\n        longest_prefix_suffix[i] = j\n        if j > longest_prefix_suffix_length\
    \ {\n            longest_prefix_suffix_length = j\n        }\n    }\n    let prefix_length\
    \ = string_length - longest_prefix_suffix_length\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \    let reverse_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reverse_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpz4m0woct.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpz4m0woct.swift:8:51: error: value of type 'String' has\
    \ no member 'reverse'\n    let reverse_string = String(string.characters.reverse())\n\
    \                                ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpz4m0woct.swift:11:83:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_suffix_length, repeatedValue: 0)\n                   \
    \                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmpz4m0woct.swift:27:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n   \
    \              ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpz4m0woct.swift:27:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_array\
    \ = Array(string)\n    let reversed_string_array = string_array.reversed()\n \
    \   var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    for i in 0..<string_length {\n        let suffix_length = string_length -\
    \ i\n        let suffix_array = Array(string_array[i..<string_length])\n     \
    \   let reversed_suffix_array = Array(reversed_string_array[0..<suffix_length])\n\
    \        if suffix_array == reversed_suffix_array {\n            longest_palindrome_length\
    \ = suffix_length\n            longest_palindrome_index = i\n            break\n\
    \        }\n    }\n    let prefix_array = Array(string_array[0..<longest_palindrome_index])\n\
    \    let reversed_prefix_array = prefix_array.reversed()\n    let result_array\
    \ = reversed_prefix_array + string_array\n    return String(result_array)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6ee8bic8.swift:15:64: error: subscript 'subscript(_:)' requires\
    \ the types 'ReversedCollection<[String.Element]>.Index' (aka 'ReversedCollection<Array<Character>>.Index')\
    \ and 'Int' be equivalent\n        let reversed_suffix_array = Array(reversed_string_array[0..<suffix_length])\n\
    \                                                               ^\nSwift.Collection:2:23:\
    \ note: where 'Self.Index' = 'ReversedCollection<[String.Element]>.Index' (aka\
    \ 'ReversedCollection<Array<Character>>.Index'), 'R.Bound' = 'Int'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpk9zy2tuv.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpk9zy2tuv.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk9zy2tuv.swift:10:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n       \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpk9zy2tuv.swift:10:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var i = 0\n    var j = string_length\
    \ - 1\n    while i < j {\n        if string_characters[i] != string_characters[j]\
    \ {\n            break\n        }\n        i += 1\n        j -= 1\n    }\n   \
    \ if i >= j {\n        return string\n    }\n    let prefix = string.substring(to:\
    \ string.index(string.startIndex, offsetBy: i))\n    let suffix = string.substring(from:\
    \ string.index(string.startIndex, offsetBy: i))\n    return prefix + String(suffix.characters.reversed())\
    \ + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmppu286f9g.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmppu286f9g.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmppu286f9g.swift:21:25: error: value of type\
    \ 'String' has no member 'substring'\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: i))\n                 ~~~~~~ ^~~~~~~~~\n/tmp/tmppu286f9g.swift:22:25:\
    \ error: value of type 'String' has no member 'substring'\n    let suffix = string.substring(from:\
    \ string.index(string.startIndex, offsetBy: i))\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    let string_chars_reversed = string_chars.reversed()\n \
    \   var longest_palindrome_length = 0\n    var longest_palindrome_start = 0\n\
    \    for i in 0..<string_length {\n        let suffix_length = string_length -\
    \ i\n        let suffix_start = i\n        let suffix_end = suffix_start + suffix_length\n\
    \        let suffix = string_chars[suffix_start..<suffix_end]\n        let suffix_reversed\
    \ = suffix.reversed()\n        if suffix == suffix_reversed {\n            longest_palindrome_length\
    \ = suffix_length\n            longest_palindrome_start = suffix_start\n     \
    \   }\n    }\n    let prefix_length = string_length - longest_palindrome_length\n\
    \    let prefix_start = 0\n    let prefix_end = prefix_start + prefix_length\n\
    \    let prefix = string_chars[prefix_start..<prefix_end]\n    let prefix_reversed\
    \ = prefix.reversed()\n    let palindrome = string + String(prefix_reversed)\n\
    \    return palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpg1iupcvo.swift:18:22: error: cannot convert value of type 'ReversedCollection<ArraySlice<String.Element>>'\
    \ (aka 'ReversedCollection<ArraySlice<Character>>') to expected argument type\
    \ 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>')\n        if suffix\
    \ == suffix_reversed {\n                     ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_lengths = [Int](count:\
    \ string_length, repeatedValue: 0)\n    for i in 0..<string_length {\n       \
    \ var palindrome_length = 0\n        if i > 0 && i < string_length - 1 {\n   \
    \         palindrome_length = min(palindrome_lengths[i - longest_palindrome_index],\
    \ longest_palindrome_index - i + longest_palindrome_length)\n        }\n     \
    \   while i - palindrome_length >= 0 && i + palindrome_length < string_length\
    \ && string_array[i - palindrome_length] == string_array[i + palindrome_length]\
    \ {\n            palindrome_length += 1\n        }\n        palindrome_lengths[i]\
    \ = palindrome_length\n        if i + palindrome_length - 1 > longest_palindrome_index\
    \ + longest_palindrome_length - 1 {\n            longest_palindrome_index = i\n\
    \            longest_palindrome_length = palindrome_length\n        }\n    }\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3l5g5ow1.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp3l5g5ow1.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3l5g5ow1.swift:11:30: error: no exact matches in call\
    \ to initializer \n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmp3l5g5ow1.swift:11:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmp3l5g5ow1.swift:11:30: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var palindrome_lengths\
    \ = [Int](count: string_length, repeatedValue: 0)\n                          \
    \   ^\n/tmp/tmp3l5g5ow1.swift:26:25: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp3l5g5ow1.swift:26:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ - longest_palindrome_length + 1))\n                                        \
    \ ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let prefix_start_index = longest_palindrome_index\
    \ - longest_palindrome_length + 1\n    let prefix_end_index = longest_palindrome_index\n\
    \    let prefix = string_characters[prefix_start_index...prefix_end_index]\n \
    \   let reversed_prefix = prefix.reverse()\n    let result = string + String(reversed_prefix)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpqtxf270t.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqtxf270t.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpqtxf270t.swift:12:33: error: cannot find\
    \ 'longest_palindrome_length_at_index' in scope\n        let palindrome_length\
    \ = longest_palindrome_length_at_index(string_characters, index: i)\n        \
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqtxf270t.swift:21:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let reversed_prefix = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmpqtxf270t.swift:20:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_characters[prefix_start_index...prefix_end_index]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_palindromic_substring(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.characters.count))\n\
    \    let result = prefix + string\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvn0q1wt_.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpvn0q1wt_.swift:9:15: error:\
    \ cannot find 'longest_palindromic_substring' in scope\n    let lps = longest_palindromic_substring(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb4b27fj1.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpb4b27fj1.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var\
    \ l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q\
    \ = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v =\
    \ 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var aa =\
    \ 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae = 0\n    var af\
    \ = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n    var\
    \ ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var ao = 0\n   \
    \ var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n\
    \    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n    var ay =\
    \ 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd\
    \ = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n    var\
    \ bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n   \
    \ var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n\
    \    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n    var bw =\
    \ 0\n    var bx = 0\n    var by = 0\n    var bz\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbg44oyyh.swift:49:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpbg44oyyh.swift:49:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpbg44oyyh.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbg44oyyh.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbg44oyyh.swift:82:9: error: type annotation missing\
    \ in pattern\n    var bz\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let z = z_function(combined)\n\
    \    let z_max = z.maxElement()!\n    let z_max_index = z.indexOf(z_max)!\n  \
    \  let prefix = String(string.characters.prefix(string.characters.count - z_max_index))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpo4qmbd4p.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpo4qmbd4p.swift:9:13: error:\
    \ cannot find 'z_function' in scope\n    let z = z_function(combined)\n      \
    \      ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string = string.characters.map { String($0) }\n\
    \    let reversed = string.reverse()\n    let combined = string + [\"|\"] + reversed\n\
    \    let suffix_array = suffix_array_of(combined)\n    let lcp_array = lcp_array_of(combined,\
    \ suffix_array: suffix_array)\n    let lcp_array_reversed = lcp_array.reverse()\n\
    \    let lcp_array_reversed_with_index = zip(lcp_array_reversed, 0..<lcp_array_reversed.count)\n\
    \    let lcp_array_reversed_with_index_filtered = lcp_array_reversed_with_index.filter\
    \ { $0.0 > 0 }\n    let lcp_array_reversed_with_index_filtered_sorted = lcp_array_reversed_with_index_filtered.sort\
    \ { $0.0 > $1.0 }\n    let lcp_array_reversed_with_index_filtered_sorted_first\
    \ = lcp_array_reversed_with_index_filtered_sorted.first\n    let lcp_array_reversed_with_index_filtered_sorted_first_index\
    \ = lcp_array_reversed_with_index_filtered_sorted_first?.1\n    let lcp_array_reversed_with_index_filtered_sorted_first_index_mapped\
    \ = lcp_array_reversed_with_index_filtered_sorted_first_index.map { $0 + 1 }\n\
    \    let lcp_array_reversed_with_index_filtered_sorted_first_index_mapped_filtered\
    \ = lcp_array_reversed_with_index_filtered_sorted_first_index_mapped.filter {\
    \ $0 < string.count }\n    let lcp_array_reversed_with_index_filtered_sorted_first_index_mapped_filtered_first\
    \ = lcp_array_reversed_with_index_filtered_sorted_first_index_mapped_filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpllr0upq4.swift:7:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters.map { String($0) }\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpllr0upq4.swift:8:27: error: cannot use mutating member\
    \ on immutable value: 'string' is a 'let' constant\n    let reversed = string.reverse()\n\
    \                   ~~~~~~ ^\n/tmp/tmpllr0upq4.swift:7:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let string = string.characters.map { String($0)\
    \ }\n    ^~~\n    var\n/tmp/tmpllr0upq4.swift:10:24: error: cannot find 'suffix_array_of'\
    \ in scope\n    let suffix_array = suffix_array_of(combined)\n               \
    \        ^~~~~~~~~~~~~~~\n/tmp/tmpllr0upq4.swift:11:21: error: cannot find 'lcp_array_of'\
    \ in scope\n    let lcp_array = lcp_array_of(combined, suffix_array: suffix_array)\n\
    \                    ^~~~~~~~~~~~\n/tmp/tmpllr0upq4.swift:17:122: error: type\
    \ of expression is ambiguous without more context\n    let lcp_array_reversed_with_index_filtered_sorted_first_index\
    \ = lcp_array_reversed_with_index_filtered_sorted_first?.1\n                 \
    \                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpe8u03yv9.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpe8u03yv9.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe8u03yv9.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpe8u03yv9.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ suffix_start = 0\n    var prefix_start = 0\n    var prefix_length = 0\n    var\
    \ palindrome_length = 0\n    var palindrome_start = 0\n    var palindrome_end\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n\
    \    var ac = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag =\
    \ 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al\
    \ = 0\n    var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var\
    \ aq = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n   \
    \ var av = 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n\
    \    var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be =\
    \ 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj\
    \ = 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var\
    \ bo = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n   \
    \ var bt = 0\n    var bu = 0\n    var bv = 0\n    var bw = 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpajxup6yp.swift:52:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpajxup6yp.swift:52:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpajxup6yp.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpajxup6yp.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpajxup6yp.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpajxup6yp.swift:8:9: warning: initialization of immutable value\
    \ 'string_array' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_array = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpajxup6yp.swift:9:9: warning: initialization of variable 'suffix_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var suffix_length = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpajxup6yp.swift:10:9:\
    \ warning: initialization of variable 'suffix_start' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var suffix_start = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpajxup6yp.swift:11:9: warning: initialization\
    \ of variable 'prefix_start' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var prefix_start = 0\n    ~~~~^~~~~~~~~~~~\n    _\n\
    /tmp/tmpajxup6yp.swift:12:9: warning: initialization of variable 'prefix_length'\
    \ was never used"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    let length = string.characters.count\n\
    \    let reversed = string.characters.reverse()\n    let reversed_string = String(reversed)\n\
    \    let suffix = reversed_string.commonSuffixWithString(string, options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \    let prefix = string.substringToIndex(string.endIndex.advancedBy(-suffix.characters.count))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    string.appendContentsOf(reversed_prefix)\n\
    \    return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpvgdh5llh.swift:8:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpvgdh5llh.swift:9:38: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed = string.characters.reverse()\n                   ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpvgdh5llh.swift:11:74: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n    let suffix = reversed_string.commonSuffixWithString(string, options:\
    \ NSStringCompareOptions.CaseInsensitiveSearch)\n                            \
    \                                             ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvgdh5llh.swift:12:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.endIndex.advancedBy(-suffix.characters.count))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpvgdh5llh.swift:12:58: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.endIndex.advancedBy(-suffix.characters.count))\n\
    \                                         ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvgdh5llh.swift:14:12:\
    \ error: value of type 'String' has no member 'appendContentsOf'\n    string.appendContentsOf(reversed_prefix)\n\
    \    ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var current_palindrome_length =\
    \ 0\n    var current_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        if string_array[i] == string_array[string_length - 1 - i] {\n   \
    \         current_palindrome_length += 1\n            current_palindrome_index\
    \ = i\n        } else {\n            if current_palindrome_length > longest_palindrome_length\
    \ {\n                longest_palindrome_length = current_palindrome_length\n \
    \               longest_palindrome_index = current_palindrome_index\n        \
    \    }\n            current_palindrome_length = 0\n            current_palindrome_index\
    \ = 0\n        }\n        i += 1\n    }\n    if current_palindrome_length > longest_palindrome_length\
    \ {\n        longest_palindrome_length = current_palindrome_length\n        longest_palindrome_index\
    \ = current_palindrome_index\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + 1))\n    let reversed_prefix = String(prefix.characters.reverse())\n    return\
    \ string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpecyelus7.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpecyelus7.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpecyelus7.swift:32:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + 1))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpecyelus7.swift:32:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + 1))\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ suffix_array = [Character]()\n    var prefix_array = [Character]()\n    for\
    \ i in 0..<string_length {\n        suffix_array.append(string_array[string_length\
    \ - 1 - i])\n        if is_palindrome(suffix_array) {\n            suffix_length\
    \ = i + 1\n            break\n        }\n    }\n    for i in 0..<string_length\
    \ - suffix_length {\n        prefix_array.append(string_array[i])\n    }\n   \
    \ return string + String(suffix_array.reverse())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpt9g7ldbh.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpt9g7ldbh.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpt9g7ldbh.swift:14:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(suffix_array) {\n           ^~~~~~~~~~~~~\n\
    /tmp/tmpt9g7ldbh.swift:22:21: error: no exact matches in call to initializer \n\
    \    return string + String(suffix_array.reverse())\n                    ^\nSwift.String:4:23:\
    \ note: candidate requires that '()' conform to 'LosslessStringConvertible' (requirement\
    \ specified as 'T' : 'LosslessStringConvertible')\n    @inlinable public init<T>(_\
    \ value: T) where T : LosslessStringConvertible\n                      ^\nSwift.String:2:12:\
    \ note: candidate requires that '()' conform to 'BinaryInteger' (requirement specified\
    \ as 'T' : 'BinaryInteger')\n    public init<T>(_ value: T, radix: Int = 10, uppercase:\
    \ Bool = false) where T : BinaryInteger\n           ^\nSwift.String:2:12: note:\
    \ incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n \
    \   public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n\
    \    public init<Subject>(reflecting subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var longest_palindrome_length_array\
    \ = [Int](count: string_length, repeatedValue: 0)\n    for i in 0..<string_length\
    \ {\n        var j = 0\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        longest_palindrome_length_array[i]\
    \ = j\n        if j > longest_palindrome_length {\n            longest_palindrome_length\
    \ = j\n            longest_palindrome_index = i\n        }\n    }\n    var result\
    \ = string\n    for i in 0..<longest_palindrome_index - longest_palindrome_length\
    \ + 1 {\n        result.append(string_array[i])\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp256oh6hv.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp256oh6hv.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp256oh6hv.swift:11:43: error: no exact matches in call\
    \ to initializer \n    var longest_palindrome_length_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n                                          ^\n/tmp/tmp256oh6hv.swift:11:43:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var longest_palindrome_length_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n                                          ^\n/tmp/tmp256oh6hv.swift:11:43:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var longest_palindrome_length_array = [Int](count: string_length,\
    \ repeatedValue: 0)\n                                          ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_lengths = [Int](count:\
    \ string_length, repeatedValue: 0)\n    for index in 0..<string_length {\n   \
    \     let reversed_index = string_length - index - 1\n        if string_array[index]\
    \ == string_array[reversed_index] {\n            if index == 0 || reversed_index\
    \ == string_length - 1 {\n                palindrome_lengths[index] = 1\n    \
    \        } else {\n                palindrome_lengths[index] = palindrome_lengths[index\
    \ - 1] + 2\n            }\n            if palindrome_lengths[index] > longest_palindrome_length\
    \ {\n                longest_palindrome_length = palindrome_lengths[index]\n \
    \               longest_palindrome_index = index\n            }\n        }\n \
    \   }\n    let prefix_length = string_length - longest_palindrome_length\n   \
    \ let prefix = string_array[0..<prefix_length]\n    let reversed_prefix = prefix.reverse()\n\
    \    let reversed_prefix_string = String(reversed_prefix)\n    return string +\
    \ reversed_prefix_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp253_l6_m.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp253_l6_m.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp253_l6_m.swift:11:30: error: no exact matches in call\
    \ to initializer \n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmp253_l6_m.swift:11:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmp253_l6_m.swift:11:30: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var palindrome_lengths\
    \ = [Int](count: string_length, repeatedValue: 0)\n                          \
    \   ^\n/tmp/tmp253_l6_m.swift:28:34: error: cannot use mutating member on immutable\
    \ value: 'prefix' is a 'let' constant\n    let reversed_prefix = prefix.reverse()\n\
    \                          ~~~~~~ ^\n/tmp/tmp253_l6_m.swift:27:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let prefix = string_array[0..<prefix_length]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpe8u03yv9.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpe8u03yv9.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe8u03yv9.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpe8u03yv9.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let reversed_string = String(string_chars.reverse())\n\
    \    let reversed_string_length = reversed_string.characters.count\n    let reversed_string_chars\
    \ = Array(reversed_string.characters)\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    var prefix_length = 0\n    var prefix_index\
    \ = 0\n    var suffix_length = 0\n    var suffix_index = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac = 0\n    var\
    \ ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n   \
    \ var ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n\
    \    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n    var ar =\
    \ 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var av = 0\n    var aw\
    \ = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba = 0\n    var\
    \ bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n   \
    \ var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n\
    \    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo = 0\n    var bp\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjw22s9tc.swift:54:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpjw22s9tc.swift:54:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpjw22s9tc.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjw22s9tc.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjw22s9tc.swift:9:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:9:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmpjw22s9tc.swift:77:9: error: type annotation\
    \ missing in pattern\n    var bp\n        ^\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let reversed_string_length\
    \ = reversed_string.characters.count\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    var prefix_length = 0\n    var prefix_index\
    \ = 0\n    var suffix_length = 0\n    var suffix_index = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac = 0\n    var\
    \ ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n   \
    \ var ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n\
    \    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n    var ar =\
    \ 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var av = 0\n    var aw\
    \ = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba = 0\n    var\
    \ bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n   \
    \ var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n\
    \    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo = 0\n    var bp =\
    \ 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n    var bt = 0\n    var bu\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpy390rv20.swift:52:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpy390rv20.swift:52:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpy390rv20.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpy390rv20.swift:8:52: error: value of type 'String'\
    \ has no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var palindrome_lengths = [Int](count:\
    \ string_length, repeatedValue: 0)\n    for index in 0..<string_length {\n   \
    \     var palindrome_length = 0\n        if index > longest_palindrome_length\
    \ && string_characters[index - longest_palindrome_length - 1] == string_characters[index]\
    \ {\n            palindrome_length = longest_palindrome_length + 2\n        }\
    \ else {\n            palindrome_length = palindrome_lengths[longest_palindrome_index]\n\
    \        }\n        while index + palindrome_length < string_length && index >=\
    \ palindrome_length && string_characters[index + palindrome_length] == string_characters[index\
    \ - palindrome_length] {\n            palindrome_length += 1\n        }\n    \
    \    palindrome_lengths[index] = palindrome_length\n        if index + palindrome_length\
    \ - 1 > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_index = index\n        }\n    }\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string_length - longest_palindrome_length))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpkidwm6w3.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpkidwm6w3.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpkidwm6w3.swift:11:30: error: no exact matches\
    \ in call to initializer \n    var palindrome_lengths = [Int](count: string_length,\
    \ repeatedValue: 0)\n                             ^\n/tmp/tmpkidwm6w3.swift:11:30:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmpkidwm6w3.swift:11:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmpkidwm6w3.swift:28:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - longest_palindrome_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpkidwm6w3.swift:28:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string_length - longest_palindrome_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let z_array = z_algorithm(string:\
    \ combined)\n    let z_max = z_array.maxElement()!\n    let z_max_index = z_array.indexOf(z_max)!\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(z_max_index))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpiywuis94.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpiywuis94.swift:9:19: error:\
    \ cannot find 'z_algorithm' in scope\n    let z_array = z_algorithm(string: combined)\n\
    \                  ^~~~~~~~~~~\n/tmp/tmpiywuis94.swift:12:25: error: value of\
    \ type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(z_max_index))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpiywuis94.swift:12:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(z_max_index))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps_h8owoz.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmps_h8owoz.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var i = 0\n    var j = string_length\
    \ - 1\n    while i < j {\n        if string_characters[i] != string_characters[j]\
    \ {\n            break\n        }\n        i += 1\n        j -= 1\n    }\n   \
    \ if i >= j {\n        return string\n    }\n    let prefix = string.substring(to:\
    \ string.index(string.startIndex, offsetBy: i))\n    let reversed_prefix = String(prefix.characters.reversed())\n\
    \    return reversed_prefix + make_palindrome(string: string.substring(from: string.index(string.startIndex,\
    \ offsetBy: i)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp42bpf3gz.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp42bpf3gz.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp42bpf3gz.swift:21:25: error: value of type\
    \ 'String' has no member 'substring'\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: i))\n                 ~~~~~~ ^~~~~~~~~\n/tmp/tmp42bpf3gz.swift:23:61:\
    \ error: value of type 'String' has no member 'substring'\n    return reversed_prefix\
    \ + make_palindrome(string: string.substring(from: string.index(string.startIndex,\
    \ offsetBy: i)))\n                                                     ~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    let string_characters_reversed\
    \ = Array(string.characters.reversed())\n    \n    // Find the longest postfix\
    \ of supplied string that is a palindrome.\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        var j = 0\n        while i - j >= 0 && i + j < string_length && string_characters[i\
    \ - j] == string_characters[i + j] {\n            j += 1\n        }\n        if\
    \ j > longest_palindrome_length {\n            longest_palindrome_length = j\n\
    \            longest_palindrome_start = i - j + 1\n        }\n    }\n    \n  \
    \  // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    var result = string\n    for i in 0..<string_length\
    \ - longest_palindrome_length {\n        result.append(string_characters_reversed[i])\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps8a656z4.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmps8a656z4.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmps8a656z4.swift:9:51: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_characters_reversed\
    \ = Array(string.characters.reversed())\n                                    \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmps8a656z4.swift:13:9: warning: variable 'longest_palindrome_start'\
    \ was written to, but never read\n    var longest_palindrome_start = 0\n     \
    \   ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = 0\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        if j *\
    \ 2 - 1 > longest_palindrome_length {\n            longest_palindrome_length =\
    \ j * 2 - 1\n            longest_palindrome_index = i\n        }\n        j =\
    \ 0\n        while i - j >= 0 && i + j + 1 < string_length && string_array[i -\
    \ j] == string_array[i + j + 1] {\n            j += 1\n        }\n        if j\
    \ * 2 > longest_palindrome_length {\n            longest_palindrome_length = j\
    \ * 2\n            longest_palindrome_index = i\n        }\n        i += 1\n \
    \   }\n    let prefix_length = string_length - longest_palindrome_length\n   \
    \ let prefix_start = string.index(string.startIndex, offsetBy: prefix_length)\n\
    \    let prefix = string.substring(to: prefix_start)\n    let reversed_prefix\
    \ = String(prefix.characters.reversed())\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5f1xjlef.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5f1xjlef.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5f1xjlef.swift:33:25: error: value of type 'String'\
    \ has no member 'substring'\n    let prefix = string.substring(to: prefix_start)\n\
    \                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    if\
    \ string_length == 0 {\n        return \"\"\n    }\n    if string_length == 1\
    \ {\n        return string\n    }\n    let string_array = Array(string.characters)\n\
    \    let reversed_string_array = Array(string.characters.reversed())\n    var\
    \ longest_palindrome_length = 0\n    var longest_palindrome_start = 0\n    for\
    \ i in 0..<string_length {\n        var j = 0\n        while i - j >= 0 && i +\
    \ j < string_length && string_array[i - j] == reversed_string_array[i + j] {\n\
    \            j += 1\n        }\n        if j > longest_palindrome_length {\n \
    \           longest_palindrome_length = j\n            longest_palindrome_start\
    \ = i - j + 1\n        }\n    }\n    var result = string\n    for i in 0..<string_length\
    \ - longest_palindrome_length {\n        result.append(string_array[string_length\
    \ - 1 - i])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp4rqiha5j.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp4rqiha5j.swift:14:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp4rqiha5j.swift:15:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp4rqiha5j.swift:17:9: warning: variable\
    \ 'longest_palindrome_start' was written to, but never read\n    var longest_palindrome_start\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_suffix\
    \ = string + \"#\" + reversed_string\n    let string_suffix_length = string_suffix.characters.count\n\
    \    var longest_palindrome_suffix = [Int](count: string_suffix_length, repeatedValue:\
    \ 0)\n    var current_longest_palindrome_suffix_length = 0\n    for i in 1..<string_suffix_length\
    \ {\n        if string_suffix[string_suffix.startIndex.advancedBy(i)] == string_suffix[string_suffix.startIndex.advancedBy(current_longest_palindrome_suffix_length)]\
    \ {\n            current_longest_palindrome_suffix_length += 1\n            longest_palindrome_suffix[i]\
    \ = current_longest_palindrome_suffix_length\n        } else {\n            if\
    \ current_longest_palindrome_suffix_length != 0 {\n                current_longest_palindrome_suffix_length\
    \ = longest_palindrome_suffix[current_longest_palindrome_suffix_length - 1]\n\
    \                i -= 1\n            }\n        }\n    }\n    let palindrome_suffix_length\
    \ = longest_palindrome_suffix[string_suffix_length - 1]\n    let palindrome_prefix_length\
    \ = string_length - palindrome_suffix_length\n    let palindrome_prefix = String(string.characters.prefix(palindrome_prefix_length))\n\
    \    let palindrome_prefix_reversed = String(palindrome_prefix.characters.reverse())\n\
    \    return string + palindrome_prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9517t9hw.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9517t9hw.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp9517t9hw.swift:11:87:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_palindrome_suffix\
    \ = [Int](count: string_suffix_length, repeatedValue: 0)\n                   \
    \                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var string_reversed = string_chars.reverse()\n\
    \    var i = 0\n    while i < string_length {\n        if string_chars[i] == string_reversed[i]\
    \ {\n            i += 1\n        } else {\n            break\n        }\n    }\n\
    \    var prefix = string_chars[0..<i]\n    return string + String(prefix.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2gdenkzm.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2gdenkzm.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2gdenkzm.swift:9:40: error: cannot use mutating member\
    \ on immutable value: 'string_chars' is a 'let' constant\n    var string_reversed\
    \ = string_chars.reverse()\n                          ~~~~~~~~~~~~ ^\n/tmp/tmp2gdenkzm.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let string_chars = Array(string.characters)\n\
    \    ^~~\n    var\n/tmp/tmp2gdenkzm.swift:19:21: error: no exact matches in call\
    \ to initializer \n    return string + String(prefix.reverse())\n            \
    \        ^\nSwift.String:4:23: note: candidate requires that '()' conform to 'LosslessStringConvertible'\
    \ (requirement specified as 'T' : 'LosslessStringConvertible')\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\nSwift.String:2:12: note: candidate requires that '()' conform to\
    \ 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    public\
    \ init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger\n\
    \           ^\nSwift.String:2:12: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(describing:)')\n    public init<Subject>(describing instance:\
    \ Subject)\n           ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps.last!))\n    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9sk7n0p9.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp9sk7n0p9.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_palindromic_substring(string:\
    \ combined)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps.characters.count))\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjahqq3px.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpjahqq3px.swift:9:15: error:\
    \ cannot find 'longest_palindromic_substring' in scope\n    let lps = longest_palindromic_substring(string:\
    \ combined)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let s = string.characters.map { String($0) }\n    let\
    \ n = s.count\n    let t = s + [\"#\"] + s.reverse()\n    var z = [Int](count:\
    \ 2 * n + 1, repeatedValue: 0)\n    var l = 0, r = 0\n    for i in 1..<2 * n +\
    \ 1 {\n        if i <= r {\n            z[i] = min(r - i + 1, z[i - l])\n    \
    \    }\n        while i + z[i] < 2 * n + 1 && t[i + z[i]] == t[z[i]] {\n     \
    \       z[i]++\n        }\n        if i + z[i] - 1 > r {\n            l = i\n\
    \            r = i + z[i] - 1\n        }\n    }\n    var prefix = \"\"\n    for\
    \ i in n + 1..<2 * n + 1 {\n        if z[i] == i - n {\n            prefix = s[0..<n\
    \ - (i - n)].reverse().joinWithSeparator(\"\")\n            break\n        }\n\
    \    }\n    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqm8t4w0_.swift:7:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let s = string.characters.map { String($0) }\n    \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqm8t4w0_.swift:9:23: error: binary operator '+' cannot be applied\
    \ to operands of type '[String]' and '()'\n    let t = s + [\"#\"] + s.reverse()\n\
    \            ~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmpqm8t4w0_.swift:10:13: error: no\
    \ exact matches in call to initializer \n    var z = [Int](count: 2 * n + 1, repeatedValue:\
    \ 0)\n            ^\n/tmp/tmpqm8t4w0_.swift:10:13: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var z = [Int](count:\
    \ 2 * n + 1, repeatedValue: 0)\n            ^\n/tmp/tmpqm8t4w0_.swift:10:13: note:\
    \ candidate has partially matching parameter list (repeating: Int, count: Int)\n\
    \    var z = [Int](count: 2 * n + 1, repeatedValue: 0)\n            ^\n/tmp/tmpqm8t4w0_.swift:17:17:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  z[i]++\n                ^~\n/tmp/tmpqm8t4w0_.swift:27:51: error: value of tuple\
    \ type '()' has no member 'joinWithSeparator'\n            prefix = s[0..<n -\
    \ (i - n)].reverse().joinWithSeparator(\"\")\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(concatenated)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpj5x345hq.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpj5x345hq.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(concatenated)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    var palindrome_suffix_start = 0\n    var palindrome_suffix_end = 0\n\
    \    var palindrome_prefix_start = 0\n    var palindrome_prefix_end = 0\n    var\
    \ palindrome_prefix_length = 0\n    var palindrome_length = 0\n    var palindrome_start\
    \ = 0\n    var palindrome_end = 0\n    var palindrome_center = 0\n    var palindrome_center_left\
    \ = 0\n    var palindrome_center_right = 0\n    var palindrome_center_left_length\
    \ = 0\n    var palindrome_center_right_length = 0\n    var palindrome_center_length\
    \ = 0\n    var palindrome_center_start = 0\n    var palindrome_center_end = 0\n\
    \    var palindrome_center_left_start = 0\n    var palindrome_center_left_end\
    \ = 0\n    var palindrome_center_right_start = 0\n    var palindrome_center_right_end\
    \ = 0\n    var palindrome_center_left_center = 0\n    var palindrome_center_right_center\
    \ = 0\n    var palindrome_center_left_center_length = 0\n    var palindrome_center_right_center_length\
    \ = 0\n    var palindrome_center_left_center_start = 0\n    var palindrome_center_left_center_end\
    \ = 0\n    var palindrome_center_right_center_start = 0\n    var palindrome_center_right_center_end\
    \ = 0\n    var palindrome_center_left_center_left = 0\n    var palindrome_center_left_center_right\
    \ = 0\n    var palindrome_center_right_center_left = 0\n    var palindrome_center_right_center_right\
    \ = 0\n    var palindrome_center_left_center_left_length = 0\n    var palindrome_center_left_center_right_length\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn4y42r0.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpmn4y42r0.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpmn4y42r0.swift:7:9: warning: initialization\
    \ of immutable value 'string_length' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let string_length = string.characters.count\n   \
    \ ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpmn4y42r0.swift:8:9: warning: initialization\
    \ of immutable value 'string_characters' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    let string_characters = Array(string.characters)\n\
    \    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmn4y42r0.swift:9:9: warning: initialization\
    \ of variable 'palindrome_suffix_length' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var palindrome_suffix_length = 0\n   \
    \ ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmn4y42r0.swift:10:9: warning: initialization\
    \ of variable 'palindrome_suffix_start' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var palindrome_suffix_start = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpmn4y42r0.swift:11:9: warning: initialization of variable 'palindrome_suffix_end'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_suffix_end = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmn4y42r0.swift:12:9:\
    \ warning: initialization of variable 'palindrome_prefix_start' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var palindrome_prefix_start\
    \ = 0\n    ~~~~^~~~~~~~~~"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = 0\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        if j >\
    \ longest_palindrome_length {\n            longest_palindrome_length = j\n   \
    \         longest_palindrome_index = i\n        }\n        i += 1\n    }\n   \
    \ var prefix = \"\"\n    for i in 0..<string_length - longest_palindrome_length\
    \ {\n        prefix.append(string_array[i])\n    }\n    var reversed_prefix =\
    \ String(prefix.characters.reversed())\n    return prefix + string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpu2tm1ols.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpu2tm1ols.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpu2tm1ols.swift:27:41: error: 'characters' is unavailable:\
    \ Please use String directly\n    var reversed_prefix = String(prefix.characters.reversed())\n\
    \                                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpu2tm1ols.swift:10:9: warning: variable\
    \ 'longest_palindrome_index' was written to, but never read\n    var longest_palindrome_index\
    \ = 0\n        ^\n/tmp/tmpu2tm1ols.swift:27:9: warning: variable 'reversed_prefix'\
    \ was never mutated; consider changing to 'let' constant\n    var reversed_prefix\
    \ = String(prefix.characters.reversed())\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb4b27fj1.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpb4b27fj1.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpb4b27fj1.swift:10:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    for\
    \ i in 1..<string_with_reversed_prefix_length {\n        var j = longest_prefix_suffix[i\
    \ - 1]\n        while j > 0 && string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ != string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(j)]\
    \ {\n            j = longest_prefix_suffix[j - 1]\n        }\n        if string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ == string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(j)]\
    \ {\n            j += 1\n        }\n        longest_prefix_suffix[i] = j\n   \
    \ }\n    let palindrome_suffix_length = string_length - longest_prefix_suffix[string_with_reversed_prefix_length\
    \ - 1]\n    let palindrome_prefix = String(string.characters.prefix(palindrome_suffix_length).reverse())\n\
    \    return string + palindrome_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp_dt1vljx.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp_dt1vljx.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp_dt1vljx.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmp_dt1vljx.swift:23:87: error: reference to member 'reverse' cannot be resolved\
    \ without a contextual type\n    let palindrome_prefix = String(string.characters.prefix(palindrome_suffix_length).reverse())\n\
    \                                                                            \
    \          ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    let string_chars_reversed = Array(string.characters.reversed())\n\
    \    \n    // Find the longest postfix that is a palindrome.\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_end = 0\n    for i in 0..<string_length {\n\
    \        let j = string_length - 1 - i\n        if string_chars[i] == string_chars_reversed[j]\
    \ {\n            if i == j {\n                longest_palindrome_length = 1\n\
    \                longest_palindrome_end = i\n            } else if i + 1 == j\
    \ {\n                longest_palindrome_length = 2\n                longest_palindrome_end\
    \ = i\n            } else {\n                longest_palindrome_length = 2 + longest_palindrome_length\n\
    \                longest_palindrome_end = i\n            }\n        } else {\n\
    \            break\n        }\n    }\n    \n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    var\
    \ result = string\n    for i in 0..<string_length - longest_palindrome_end - longest_palindrome_length\
    \ {\n        result.append(string_chars_reversed[i])\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpi8p0wyes.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpi8p0wyes.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpi8p0wyes.swift:9:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars_reversed = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reverse()\n    let combined =\
    \ string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n \
    \   let prefix = string.substringToIndex(string.endIndex.advancedBy(-lps))\n \
    \   return prefix.reverse() + string\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7w3yg5cg.swift:7:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmp7w3yg5cg.swift:9:15: error: cannot find 'longest_prefix_suffix' in scope\n\
    \    let lps = longest_prefix_suffix(combined)\n              ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7w3yg5cg.swift:10:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.endIndex.advancedBy(-lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp7w3yg5cg.swift:10:58: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.endIndex.advancedBy(-lps))\n\
    \                                         ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var palindrome_length = 0\n   \
    \ var palindrome_start = 0\n    var palindrome_end = 0\n    var palindrome_length_max\
    \ = 0\n    var palindrome_start_max = 0\n    var palindrome_end_max = 0\n    for\
    \ i in 0..<string_length {\n        palindrome_length = 0\n        palindrome_start\
    \ = i\n        palindrome_end = i\n        while palindrome_start >= 0 && palindrome_end\
    \ < string_length {\n            if string_chars[palindrome_start] == string_chars[palindrome_end]\
    \ {\n                palindrome_length = palindrome_end - palindrome_start + 1\n\
    \                if palindrome_length > palindrome_length_max {\n            \
    \        palindrome_length_max = palindrome_length\n                    palindrome_start_max\
    \ = palindrome_start\n                    palindrome_end_max = palindrome_end\n\
    \                }\n            } else {\n                break\n            }\n\
    \            palindrome_start -= 1\n            palindrome_end += 1\n        }\n\
    \        palindrome_length = 0\n        palindrome_start = i\n        palindrome_end\
    \ = i + 1\n        while palindrome_start >= 0 && palindrome_end < string_length\
    \ {\n            if string_chars[palindrome_start] == string_chars[palindrome_end]\
    \ {\n                palindrome_length = palindrome_end - palindrome_start + 1\n\
    \                if palindrome_length > palindrome_length_max {\n            \
    \        palindrome_length_max = palindrome_length\n                    palindrome_start_max\
    \ = palindrome_start\n                    palindrome_end_max = palindrome_end\n\
    \                }\n            } else {\n                break\n            }\n\
    \            palindrome_start -= 1\n            palindrome_end += 1\n        }\n\
    \    }\n    let palindrome_prefix = String(string_chars\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvymng64z.swift:52:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpvymng64z.swift:51:35: note: to match this opening '('\n    let palindrome_prefix\
    \ = String(string_chars\n                                  ^\n/tmp/tmpvymng64z.swift:7:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvymng64z.swift:8:37: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvymng64z.swift:13:9: warning: variable 'palindrome_start_max'\
    \ was written to, but never read\n    var palindrome_start_max = 0\n        ^\n\
    /tmp/tmpvymng64z.swift:14:9: warning: variable 'palindrome_end_max' was written\
    \ to, but never read\n    var palindrome_end_max = 0\n        ^\n/tmp/tmpvymng64z.swift:51:9:\
    \ warning: initialization of immutable value 'palindrome_prefix' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    let palindrome_prefix\
    \ = String(string_chars\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var current_palindrome_length =\
    \ 0\n    var current_palindrome_index = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var aa = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae =\
    \ 0\n    var af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj\
    \ = 0\n    var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var\
    \ ao = 0\n    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n   \
    \ var at = 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n\
    \    var ay = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc =\
    \ 0\n    var bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh\
    \ = 0\n    var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var\
    \ bm = 0\n    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n   \
    \ var br = 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n\
    \    var bw = 0\n    var bx = 0\n    var by = 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpkp1m1jtp.swift:49:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpkp1m1jtp.swift:49:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpkp1m1jtp.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkp1m1jtp.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkp1m1jtp.swift:7:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpkp1m1jtp.swift:8:9: warning: initialization of immutable value\
    \ 'string_chars' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_chars = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpkp1m1jtp.swift:9:9: warning: initialization of variable 'longest_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmpkp1m1jtp.swift:10:9: warning: initialization of variable 'longest_palindrome_index'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_index = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpkp1m1jtp.swift:11:9: warning: initialization of variable 'current_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var current_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014367
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var is_palindrome = Array(count:\
    \ string_length, repeatedValue: false)\n    for i in 0..<string_length {\n   \
    \     for j in 0..<2 {\n            var left = i\n            var right = i +\
    \ j\n            while left >= 0 && right < string_length && string_characters[left]\
    \ == string_characters[right] {\n                is_palindrome[left] = true\n\
    \                if right - left + 1 > longest_palindrome_length {\n         \
    \           longest_palindrome_length = right - left + 1\n                   \
    \ longest_palindrome_index = left\n                }\n                left -=\
    \ 1\n                right += 1\n            }\n        }\n    }\n    var result\
    \ = string\n    for i in 0..<string_length {\n        if !is_palindrome[i] {\n\
    \            result = \"\\(string_characters[i])\\(result)\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpm8_14bw4.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpm8_14bw4.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpm8_14bw4.swift:11:25: error: no exact matches\
    \ in call to initializer \n    var is_palindrome = Array(count: string_length,\
    \ repeatedValue: false)\n                        ^\n/tmp/tmpm8_14bw4.swift:11:25:\
    \ note: candidate has partially matching parameter list (repeating: _, count:\
    \ Int)\n    var is_palindrome = Array(count: string_length, repeatedValue: false)\n\
    \                        ^\n/tmp/tmpm8_14bw4.swift:11:25: note: candidate has\
    \ partially matching parameter list (repeating: _, count: Int)\n    var is_palindrome\
    \ = Array(count: string_length, repeatedValue: false)\n                      \
    \  ^\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string = string.lowercased()\n    let string_length\
    \ = string.count\n    let string_chars = Array(string)\n    let string_chars_reversed\
    \ = string_chars.reversed()\n    \n    // Find the longest postfix of supplied\
    \ string that is a palindrome.\n    var longest_palindrome_length = 0\n    var\
    \ longest_palindrome_start = 0\n    for i in 0..<string_length {\n        let\
    \ j = string_length - i - 1\n        if string_chars[i] == string_chars_reversed[j]\
    \ {\n            longest_palindrome_length += 1\n            longest_palindrome_start\
    \ = i\n        } else {\n            break\n        }\n    }\n    \n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    let prefix_start = longest_palindrome_start + 1\n    let prefix_end\
    \ = string_length\n    let prefix = string[prefix_start..<prefix_end]\n    let\
    \ prefix_reversed = String(prefix.reversed())\n    return string + prefix_reversed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6nz6x5yh.swift:17:53: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[String.Element]>.Index' (aka\
    \ 'ReversedCollection<Array<Character>>.Index')\n        if string_chars[i] ==\
    \ string_chars_reversed[j] {\n                                               \
    \     ^\n/tmp/tmp6nz6x5yh.swift:28:18: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \    let prefix = string[prefix_start..<prefix_end]\n                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reverse()\n    let concatenated\
    \ = string + reversed\n    let suffix_length = find_longest_palindromic_suffix(concatenated)\n\
    \    let prefix = reversed.substringToIndex(advance(reversed.startIndex, reversed.characters.count\
    \ - suffix_length))\n    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpiffrploj.swift:7:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmpiffrploj.swift:9:25: error: cannot find 'find_longest_palindromic_suffix'\
    \ in scope\n    let suffix_length = find_longest_palindromic_suffix(concatenated)\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiffrploj.swift:10:44:\
    \ error: cannot find 'advance' in scope\n    let prefix = reversed.substringToIndex(advance(reversed.startIndex,\
    \ reversed.characters.count - suffix_length))\n                              \
    \             ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    var\
    \ i = 1\n    while i < string_with_reversed_prefix_length {\n        var j = longest_prefix_suffix[i\
    \ - 1]\n        while j > 0 && string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ != string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(j)]\
    \ {\n            j = longest_prefix_suffix[j - 1]\n        }\n        if string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(i)]\
    \ == string_with_reversed_prefix[string_with_reversed_prefix.startIndex.advancedBy(j)]\
    \ {\n            j += 1\n        }\n        longest_prefix_suffix[i] = j\n   \
    \     i += 1\n    }\n    let longest_palindromic_suffix_length = longest_prefix_suffix[string_with_reversed_prefix_length\
    \ - 1]\n    let prefix_to_append = reversed_string[reversed_string.startIndex..<reversed_string.startIndex.advancedBy(string_length\
    \ - longest_palindromic_suffix_length)]\n    return string + prefix_to_append\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5_vsm6a3.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5_vsm6a3.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp5_vsm6a3.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n   \
    \ var palindrome_index = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var\
    \ l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q\
    \ = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v =\
    \ 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var aa =\
    \ 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae = 0\n    var af\
    \ = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n    var\
    \ ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var ao = 0\n   \
    \ var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n\
    \    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n    var ay =\
    \ 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd\
    \ = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n    var\
    \ bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n   \
    \ var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n\
    \    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n    var bw =\
    \ 0\n    var bx = 0\n    var by = 0\n    var b\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpl2fvv3l7.swift:49:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpl2fvv3l7.swift:49:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpl2fvv3l7.swift:7:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpl2fvv3l7.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpl2fvv3l7.swift:82:9: error: type annotation missing\
    \ in pattern\n    var b\n        ^\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let string_length = string.characters.count\n    let reversed_length = reversed.characters.count\n\
    \    var lps = [Int](count: reversed_length, repeatedValue: 0)\n    var i = 1\n\
    \    var j = 0\n    while i < reversed_length {\n        if reversed[reversed.startIndex.advancedBy(i)]\
    \ == reversed[reversed.startIndex.advancedBy(j)] {\n            lps[i] = j + 1\n\
    \            i += 1\n            j += 1\n        } else {\n            if j !=\
    \ 0 {\n                j = lps[j - 1]\n            } else {\n                lps[i]\
    \ = 0\n                i += 1\n            }\n        }\n    }\n    let prefix_length\
    \ = string_length - lps[reversed_length - 1]\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpt79_urx5.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpt79_urx5.swift:8:32: error:\
    \ 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpt79_urx5.swift:10:60: error: extra argument\
    \ 'repeatedValue' in call\n    var lps = [Int](count: reversed_length, repeatedValue:\
    \ 0)\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmpt79_urx5.swift:28:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n   \
    \              ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpt79_urx5.swift:28:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps_h8owoz.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmps_h8owoz.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.count\n    let string_chars\
    \ = Array(string)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = min(i,\
    \ string_length - i - 1)\n        var palindrome_start = i - palindrome_length\n\
    \        var palindrome_end = i + palindrome_length\n        while palindrome_start\
    \ >= 0 && palindrome_end < string_length && string_chars[palindrome_start] ==\
    \ string_chars[palindrome_end] {\n            palindrome_start -= 1\n        \
    \    palindrome_end += 1\n        }\n        palindrome_start += 1\n        palindrome_end\
    \ -= 1\n        if palindrome_end - palindrome_start > longest_palindrome_length\
    \ {\n            longest_palindrome_length = palindrome_end - palindrome_start\n\
    \            longest_palindrome_start = palindrome_start\n        }\n    }\n \
    \   let prefix = String(string_chars[0..<longest_palindrome_start])\n    let prefix_reversed\
    \ = String(prefix.reversed())\n    return prefix_reversed + string\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: Exception
  stderr: 'tmpt98w35v5/tmpt98w35v5.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4ef921c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4ef618b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4ef618988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4ef6177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt98w35v5                        0x000055adf3f10c82 <unavailable> + 7298

    5    libc.so.6                          0x00002ac4efb0d460 __libc_start_main +
    245

    6    tmpt98w35v5                        0x000055adf3f106b9 <unavailable> + 5817

    '
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n \
    \   var palindrome_index = 0\n    var i = 0\n    var j = 0\n    while i < string_length\
    \ {\n        j = 0\n        while i - j >= 0 && i + j < string_length && string_characters[i\
    \ - j] == string_characters[i + j] {\n            j += 1\n        }\n        palindrome_length\
    \ = 2 * j - 1\n        palindrome_index = i - j + 1\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_index = palindrome_index\n        }\n        i\
    \ += 1\n        j = 0\n        while i - j - 1 >= 0 && i + j < string_length &&\
    \ string_characters[i - j - 1] == string_characters[i + j] {\n            j +=\
    \ 1\n        }\n        palindrome_length = 2 * j\n        palindrome_index =\
    \ i - j\n        if palindrome_length > longest_palindrome_length {\n        \
    \    longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = palindrome_index\n        }\n    }\n    let prefix = String(string_characters[0..<longest_palindrome_index])\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp4se4u807.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp4se4u807.swift:8:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp4se4u807.swift:39:52: error: value of type\
    \ 'String' has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_chars = Array(string.characters)\n    var suffix_length = 0\n    for\
    \ i in 0..<string_length {\n        if is_palindrome(string_chars, start: i, end:\
    \ string_length - 1) {\n            suffix_length = string_length - i\n      \
    \      break\n        }\n    }\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - suffix_length))\n    prefix = String(prefix.characters.reverse())\n    return\
    \ string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpdb2d83t5.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpdb2d83t5.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdb2d83t5.swift:11:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpdb2d83t5.swift:16:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - suffix_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpdb2d83t5.swift:16:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    var prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string_length - suffix_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reverse()\n    let concatenated\
    \ = string + \"#\" + reversed\n    let z = z_function(concatenated)\n    let z_max\
    \ = z.maxElement()!\n    let z_max_index = z.indexOf(z_max)!\n    let prefix =\
    \ string[string.startIndex..<string.startIndex.advancedBy(z_max_index)]\n    let\
    \ suffix = prefix.reverse()\n    return string + suffix\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpj8138ows.swift:7:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmpj8138ows.swift:9:13: error: cannot find 'z_function' in scope\n    let\
    \ z = z_function(concatenated)\n            ^~~~~~~~~~\n/tmp/tmpj8138ows.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string[string.startIndex..<string.startIndex.advancedBy(z_max_index)]\n  \
    \                                          ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \    \n    var longest_palindrome_length = 0\n    var longest_palindrome_index\
    \ = 0\n    \n    // Find the longest palindrome suffix.\n    for i in 0..<string_length\
    \ {\n        var j = 0\n        while j < string_length - i && string_array[i\
    \ + j] == reversed_string_array[j] {\n            j += 1\n        }\n        if\
    \ j > longest_palindrome_length {\n            longest_palindrome_length = j\n\
    \            longest_palindrome_index = i\n        }\n    }\n    \n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    var result = string\n    for i in 0..<string_length - longest_palindrome_index\
    \ {\n        result.append(string_array[string_length - i - 1])\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpz6wnc49t.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpz6wnc49t.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpz6wnc49t.swift:9:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    for i in 0..<string_length {\n        var j = 0\n        while j < string_length\
    \ - i && j < string_length - longest_palindrome_length {\n            if string_array[i\
    \ + j] != reversed_string_array[j] {\n                break\n            }\n \
    \           j += 1\n        }\n        if j > longest_palindrome_length {\n  \
    \          longest_palindrome_length = j\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    \n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    var result\
    \ = string\n    for i in 0..<string_length - longest_palindrome_length {\n   \
    \     result.append(string_array[string_length - 1 - i])\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpgf8s0qqq.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgf8s0qqq.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgf8s0qqq.swift:9:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpgf8s0qqq.swift:13:9: warning: variable\
    \ 'longest_palindrome_index' was written to, but never read\n    var longest_palindrome_index\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let s = string.characters.map { String($0) }\n    let\
    \ n = s.count\n    let reversed = s.reversed()\n    var lps = Array(repeating:\
    \ 0, count: n)\n    var i = 1\n    var len = 0\n    while i < n {\n        if\
    \ s[i] == s[len] {\n            len += 1\n            lps[i] = len\n         \
    \   i += 1\n        } else {\n            if len != 0 {\n                len =\
    \ lps[len - 1]\n            } else {\n                lps[i] = 0\n           \
    \     i += 1\n            }\n        }\n    }\n    let prefix = reversed[0..<(n\
    \ - lps[n - 1])]\n    return string + prefix.joined()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpz4g4jggy.swift:7:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let s = string.characters.map { String($0) }\n    \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz4g4jggy.swift:27:26: error: subscript 'subscript(_:)' requires the\
    \ types 'ReversedCollection<[String]>.Index' and 'Int' be equivalent\n    let\
    \ prefix = reversed[0..<(n - lps[n - 1])]\n                         ^\nSwift.Collection:2:23:\
    \ note: where 'Self.Index' = 'ReversedCollection<[String]>.Index', 'R.Bound' =\
    \ 'Int'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R\
    \ : RangeExpression, Self.Index == R.Bound { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    var longest_prefix_suffix = [Int](count:\
    \ string_with_reversed_prefix.characters.count, repeatedValue: 0)\n    var longest_prefix_suffix_length\
    \ = 0\n    for i in 1..<string_with_reversed_prefix.characters.count {\n     \
    \   var j = longest_prefix_suffix[i - 1]\n        while j > 0 && string_with_reversed_prefix[i]\
    \ != string_with_reversed_prefix[j] {\n            j = longest_prefix_suffix[j\
    \ - 1]\n        }\n        if string_with_reversed_prefix[i] == string_with_reversed_prefix[j]\
    \ {\n            j += 1\n        }\n        longest_prefix_suffix[i] = j\n   \
    \     if j > longest_prefix_suffix_length {\n            longest_prefix_suffix_length\
    \ = j\n        }\n    }\n    let prefix_length = string_length - longest_prefix_suffix_length\n\
    \    let prefix = reversed_string.substringToIndex(reversed_string.startIndex.advancedBy(prefix_length))\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5qniwug.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpw5qniwug.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpw5qniwug.swift:10:107:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix.characters.count, repeatedValue:\
    \ 0)\n                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var suffix_length = 0\n    var\
    \ suffix_array = [Character]()\n    var prefix_array = [Character]()\n    var\
    \ palindrome_array = [Character]()\n    \n    // Find the longest palindromic\
    \ suffix\n    for i in 0..<string_length {\n        suffix_array.append(string_array[string_length\
    \ - 1 - i])\n        if is_palindrome(string: String(suffix_array)) {\n      \
    \      suffix_length = i + 1\n            break\n        }\n    }\n    \n    //\
    \ Append the reverse of the prefix to the end of the string\n    for i in 0..<string_length\
    \ - suffix_length {\n        prefix_array.append(string_array[i])\n    }\n   \
    \ palindrome_array = string_array + prefix_array.reversed()\n    \n    return\
    \ String(palindrome_array)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpfecgq1__.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpfecgq1__.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfecgq1__.swift:17:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string: String(suffix_array)) {\n       \
    \    ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ reversed_string = String(string.characters.reverse())\n    let string_with_reversed_prefix\
    \ = string + \"#\" + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    var\
    \ longest_prefix_suffix_length = 0\n    for i in 1..<string_with_reversed_prefix_length\
    \ {\n        var j = longest_prefix_suffix[i - 1]\n        while j > 0 && string_with_reversed_prefix[i]\
    \ != string_with_reversed_prefix[j] {\n            j = longest_prefix_suffix[j\
    \ - 1]\n        }\n        if string_with_reversed_prefix[i] == string_with_reversed_prefix[j]\
    \ {\n            j += 1\n        }\n        longest_prefix_suffix[i] = j\n   \
    \     if j == string_length {\n            longest_prefix_suffix_length = j\n\
    \        }\n    }\n    let palindrome_suffix = string[string_length - longest_prefix_suffix_length..<string_length]\n\
    \    let palindrome_prefix = String(palindrome_suffix.characters.reverse())\n\
    \    return palindrome_prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqqf2tm7_.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqqf2tm7_.swift:8:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpqqf2tm7_.swift:11:97:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_prefix_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpqqf2tm7_.swift:26:29: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n    let palindrome_suffix\
    \ = string[string_length - longest_prefix_suffix_length..<string_length]\n   \
    \                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpqqf2tm7_.swift:27:65: error: value\
    \ of type 'String' has no member 'reverse'\n    let palindrome_prefix = String(palindrome_suffix.characters.reverse())\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.last!))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpruqq2sk5.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpruqq2sk5.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let s = string.characters.map { String($0) }\n    let\
    \ n = s.count\n    let s_rev = s.reverse()\n    \n    var z = [Int](count: 2 *\
    \ n + 1, repeatedValue: 0)\n    var l = 0\n    var r = 0\n    \n    for i in 1..<2\
    \ * n {\n        if i > r {\n            l = i\n            r = i\n        } else\
    \ {\n            let i_mirror = l + (r - i)\n            let diff = r - i\n  \
    \          if z[i_mirror] < diff {\n                z[i] = z[i_mirror]\n     \
    \           continue\n            } else if z[i_mirror] == diff && r + 1 == n\
    \ {\n                z[i] = z[i_mirror]\n                continue\n          \
    \  } else {\n                l = i\n            }\n            r = max(r, i)\n\
    \        }\n        while l - 1 >= 0 && r + 1 < n && s[l - 1] == s_rev[r + 1]\
    \ {\n            l -= 1\n            r += 1\n        }\n        z[i] = r - l +\
    \ 1\n    }\n    \n    var result = \"\"\n    for i in 0..<n {\n        result\
    \ += s[i]\n    }\n    for i in n..<2 * n {\n        if z[i] == i + 1 {\n     \
    \       for j in 0..<n - (i + 1) / 2 {\n                result += s_rev[j]\n \
    \           }\n            break\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmplxdghtfy.swift:7:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let s = string.characters.map { String($0) }\n    \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplxdghtfy.swift:9:19: error: cannot use mutating member on immutable\
    \ value: 's' is a 'let' constant\n    let s_rev = s.reverse()\n              \
    \  ~ ^\n/tmp/tmplxdghtfy.swift:7:5: note: change 'let' to 'var' to make it mutable\n\
    \    let s = string.characters.map { String($0) }\n    ^~~\n    var\n/tmp/tmplxdghtfy.swift:11:13:\
    \ error: no exact matches in call to initializer \n    var z = [Int](count: 2\
    \ * n + 1, repeatedValue: 0)\n            ^\n/tmp/tmplxdghtfy.swift:11:13: note:\
    \ candidate has partially matching parameter list (repeating: Int, count: Int)\n\
    \    var z = [Int](count: 2 * n + 1, repeatedValue: 0)\n            ^\n/tmp/tmplxdghtfy.swift:11:13:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var z = [Int](count: 2 * n + 1, repeatedValue: 0)\n            ^\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let longest_common_suffix = longest_common_substring(string, reversed)\n\
    \    let prefix = String(string.characters.dropLast(longest_common_suffix.characters.count))\n\
    \    return prefix + reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp7_ksxrc3.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp7_ksxrc3.swift:8:33: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_suffix\
    \ = longest_common_substring(string, reversed)\n                             \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.characters.count\n    let\
    \ string_array = Array(string.characters)\n    var longest_palindrome_length =\
    \ 0\n    var longest_palindrome_end = 0\n    var longest_palindrome_start = 0\n\
    \    var palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n\
    \    for i in 0..<string_length {\n        let mirror = 2 * longest_palindrome_end\
    \ - i\n        if i < longest_palindrome_end {\n            palindrome_lengths[i]\
    \ = min(longest_palindrome_end - i, palindrome_lengths[mirror])\n        }\n \
    \       let left = i - (1 + palindrome_lengths[i])\n        let right = i + (1\
    \ + palindrome_lengths[i])\n        while left >= 0 && right < string_length &&\
    \ string_array[left] == string_array[right] {\n            palindrome_lengths[i]\
    \ += 1\n            left -= 1\n            right += 1\n        }\n        if i\
    \ + palindrome_lengths[i] > longest_palindrome_end {\n            longest_palindrome_end\
    \ = i + palindrome_lengths[i]\n            longest_palindrome_start = i\n    \
    \    }\n        if palindrome_lengths[i] > longest_palindrome_length {\n     \
    \       longest_palindrome_length = palindrome_lengths[i]\n        }\n    }\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start\
    \ - longest_palindrome_length))\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \    return reversed_prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp18ae68wx.swift:7:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp18ae68wx.swift:8:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp18ae68wx.swift:12:30: error: no exact matches in call\
    \ to initializer \n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmp18ae68wx.swift:12:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmp18ae68wx.swift:12:30: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var palindrome_lengths\
    \ = [Int](count: string_length, repeatedValue: 0)\n                          \
    \   ^\n/tmp/tmp18ae68wx.swift:33:25: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start\
    \ - longest_palindrome_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp18ae68wx.swift:33:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start\
    \ - longest_palindrome_length))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let s = string.characters.map { String($0) }\n    let\
    \ n = s.count\n    var i = 0\n    var j = n - 1\n    while i < j {\n        if\
    \ s[i] != s[j] {\n            break\n        }\n        i += 1\n        j -= 1\n\
    \    }\n    if i >= j {\n        return string\n    }\n    let suffix = Array(s[i...j])\n\
    \    let suffix_palindrome = longest_palindrome(suffix)\n    let prefix = Array(s[0..<i])\n\
    \    let prefix_reversed = prefix.reverse()\n    return prefix.joinWithSeparator(\"\
    \") + suffix_palindrome + prefix_reversed.joinWithSeparator(\"\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5d1ozdmm.swift:7:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let s = string.characters.map { String($0) }\n    \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5d1ozdmm.swift:22:29: error: cannot find 'longest_palindrome' in\
    \ scope\n    let suffix_palindrome = longest_palindrome(suffix)\n            \
    \                ^~~~~~~~~~~~~~~~~~\n/tmp/tmp5d1ozdmm.swift:24:34: error: cannot\
    \ use mutating member on immutable value: 'prefix' is a 'let' constant\n    let\
    \ prefix_reversed = prefix.reverse()\n                          ~~~~~~ ^\n/tmp/tmp5d1ozdmm.swift:23:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let prefix = Array(s[0..<i])\n\
    \    ^~~\n    var\n/tmp/tmp5d1ozdmm.swift:25:19: error: value of type '[String]'\
    \ has no member 'joinWithSeparator'\n    return prefix.joinWithSeparator(\"\"\
    ) + suffix_palindrome + prefix_reversed.joinWithSeparator(\"\")\n           ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014368
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps.last!))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpruqq2sk5.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpruqq2sk5.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - lps))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps_h8owoz.swift:7:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmps_h8owoz.swift:9:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014366
