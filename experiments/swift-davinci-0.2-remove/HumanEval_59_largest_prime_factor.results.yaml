language: swift
name: HumanEval_59_largest_prime_factor
results:
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n    var n\
    \ = n\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp07ajy0nj.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    var i = 3\n    while\
    \ i <= Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            n /= i\n \
    \           largest_prime = i\n        } else {\n            i += 2\n        }\n\
    \    }\n    if n > largest_prime {\n        largest_prime = n\n    }\n    return\
    \ largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp2o27oi6k.swift:10:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    var i = 3\n    while\
    \ i <= Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            n /= i\n \
    \           largest_prime = i\n        } else {\n            i += 2\n        }\n\
    \    }\n    if n > 2 {\n        largest_prime = n\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpb4qt3ku1.swift:10:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    var i = 3\n    while\
    \ i <= Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            n /= i\n \
    \           largest_prime = i\n        } else {\n            i += 2\n        }\n\
    \    }\n    if n > 2 {\n        largest_prime = n\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpb4qt3ku1.swift:10:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n \
    \   return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest_prime = i\n            while n % i == 0 {\n                n /= i\n\
    \            }\n        }\n        i += 1\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpfqtn93yd.swift:10:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= i\n                ~\
    \ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for i in 3.stride(through:\
    \ Int(sqrt(Double(n))), by: 2) {\n        while n % i == 0 {\n            n /=\
    \ i\n            largest_prime = i\n        }\n    }\n    if n > 2 {\n       \
    \ largest_prime = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpdalc3sl_.swift:9:36: error: cannot find 'sqrt' in scope\n    for\
    \ i in 3.stride(through: Int(sqrt(Double(n))), by: 2) {\n                    \
    \               ^~~~\n/tmp/tmpdalc3sl_.swift:9:16: error: value of type 'Int'\
    \ has no member 'stride'\n    for i in 3.stride(through: Int(sqrt(Double(n))),\
    \ by: 2) {\n             ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n    var largest\
    \ = 1\n    while i <= n {\n        if n % i == 0 {\n            largest = i\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpx35iatv4.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp07ajy0nj.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp07ajy0nj.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor * factor <= n {\n        if n % factor == 0 {\n      \
    \      n /= factor\n        } else {\n            factor += 1\n        }\n   \
    \ }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest_prime = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n    return\
    \ largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpdpmzy954.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest\
    \ = 1\n    while n % 2 == 0 {\n        largest = 2\n        n /= 2\n    }\n  \
    \  var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        if n % i == 0 {\n\
    \            largest = i\n            n /= i\n        } else {\n            i\
    \ += 2\n        }\n    }\n    if n > 2 {\n        largest = n\n    }\n    return\
    \ largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpulefnlmi.swift:11:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n    var largest_prime_factor\
    \ = 1\n    while i <= n {\n        if n % i == 0 {\n            largest_prime_factor\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp2sunefnn.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_prime_factor = i\n            n /= i\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpv0c9_mj1.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 0\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_prime = i\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_factor\
    \ = 1\n    var factor = 2\n    while factor <= n {\n        if n % factor == 0\
    \ {\n            largest_factor = factor\n            n /= factor\n        } else\
    \ {\n            factor += 1\n        }\n    }\n    return largest_factor\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor =\
    \ 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest_factor = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    if n > 1 {\n        largest_factor = n\n    }\n   \
    \ return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp144o8_i2.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    let primes = prime_sieve(n)\n\
    \    for p in primes.reverse() {\n        if n % p == 0 {\n            return\
    \ p\n        }\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmptxr0jr4d.swift:4:18: error: cannot find 'prime_sieve' in scope\n\
    \    let primes = prime_sieve(n)\n                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime_factor\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    var i = 3\n    while\
    \ i <= Int(sqrt(Double(n))) {\n        while n % i == 0 {\n            n /= i\n\
    \            largest_prime_factor = i\n        }\n        i += 2\n    }\n    if\
    \ n > 2 {\n        largest_prime_factor = n\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp12z69zhq.swift:10:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n    var largest\
    \ = 0\n    while i <= n {\n        if n % i == 0 {\n            largest = i\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpad4531vt.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n \
    \   return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 0\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmplb320qvp.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest_prime = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n    return\
    \ largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp8cjylta_.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest\
    \ = 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest = i\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    return max(largest, n)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor =\
    \ 1\n    var factor = 2\n    var n = n\n    while n > 1 {\n        while n % factor\
    \ == 0 {\n            largest_factor = factor\n            n /= factor\n     \
    \   }\n        factor += 1\n    }\n    return largest_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 1\n    while n % 2 == 0 {\n        largest_prime = 2\n        n /= 2\n   \
    \ }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        if n % i ==\
    \ 0 {\n            largest_prime = i\n            n /= i\n        } else {\n \
    \           i += 2\n        }\n    }\n    if n > 2 {\n        largest_prime =\
    \ n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmppkrybzbr.swift:11:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 0\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmplb320qvp.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_prime_factor = i\n            n /= i\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpv0c9_mj1.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest_prime = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n    return\
    \ largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpdpmzy954.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var factor = 2\n    while factor <= n {\n        if n % factor == 0 {\n\
    \            largest_prime = factor\n            n /= factor\n        } else {\n\
    \            factor += 1\n        }\n    }\n    return largest_prime\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpypye6vay.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor * factor <= n {\n        if n % factor == 0 {\n      \
    \      n /= factor\n        } else {\n            factor += 1\n        }\n   \
    \ }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i <= n {\n        if n % i == 0 {\n            n /= i\n     \
    \   } else {\n            i += 1\n        }\n    }\n    return i\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 2\n    while n > 1 {\n        if n % largest_prime == 0 {\n            n /=\
    \ largest_prime\n        } else {\n            largest_prime += 1\n        }\n\
    \    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_factor = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_factor = n\n    }\n\
    \    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_factor\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpp_w54b71.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor * factor <= n {\n        if n % factor == 0 {\n      \
    \      n /= factor\n        } else {\n            factor += 1\n        }\n   \
    \ }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_factor\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_factor = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n % factor != 0 {\n        factor += 1\n    }\n    n /= factor\n\
    \    while n % factor == 0 {\n        n /= factor\n    }\n    if n == 1 {\n  \
    \      return factor\n    }\n    return largest_prime_factor(n: n)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_factor\
    \ = 2\n    while n > 1 {\n        if n % largest_factor == 0 {\n            n\
    \ /= largest_factor\n        } else {\n            largest_factor += 1\n     \
    \   }\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest = 0\n  \
    \  var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp4hik5pgx.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor =\
    \ 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest_factor = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return max(largest_factor, n)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpo8w9112r.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest\
    \ = 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest = i\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    return max(largest, n)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i < n {\n        if n % i == 0 {\n            n /= i\n      \
    \  } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp07ajy0nj.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for i in stride(from:\
    \ 3, through: n, by: 2) {\n        while n % i == 0 {\n            n /= i\n  \
    \          largest_prime = i\n        }\n    }\n    return largest_prime\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_prime = i\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_factor\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpp_w54b71.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for i in stride(from:\
    \ 3, through: n, by: 2) {\n        while n % i == 0 {\n            n /= i\n  \
    \          largest = i\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var p\
    \ = 2\n    while n > 1 {\n        if n % p == 0 {\n            n /= p\n      \
    \  } else {\n            p += 1\n        }\n    }\n    return p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var p\
    \ = 2\n    while p * p <= n {\n        if n % p == 0 {\n            n /= p\n \
    \       } else {\n            p += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest = 0\n  \
    \  var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp4hik5pgx.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var f\
    \ = 2\n    while f * f <= n {\n        if n % f == 0 {\n            n /= f\n \
    \       } else {\n            f += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor * factor <= n {\n        if n % factor == 0 {\n      \
    \      n /= factor\n        } else {\n            factor += 1\n        }\n   \
    \ }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest\
    \ = 0\n    for i in 2..<n {\n        if n % i == 0 {\n            n /= i\n   \
    \         largest = i\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpmkkot7h5/tmpmkkot7h5.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b144ee6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b144eb66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b144eb66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b144eb657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmkkot7h5                        0x0000564a9121a3b0 <unavailable> + 5040

    5    libc.so.6                          0x00002b144f05b460 __libc_start_main +
    245

    6    tmpmkkot7h5                        0x0000564a91219fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor * factor <= n {\n        if n % factor == 0 {\n      \
    \      n /= factor\n        } else {\n            factor += 1\n        }\n   \
    \ }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n    var n\
    \ = n\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp07ajy0nj.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest = 0\n  \
    \  for i in 2...n {\n        if n % i == 0 {\n            largest = i\n      \
    \      n /= i\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3odcki4l.swift:8:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor =\
    \ 0\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_factor\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp089lg_w_.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var p = 2\n    var n\
    \ = n\n    while p * p <= n {\n        if n % p == 0 {\n            n /= p\n \
    \       } else {\n            p += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp07ajy0nj.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_factor\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_factor = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n    var n\
    \ = n\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest\
    \ = 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest = i\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    if n > 1 {\n        largest = n\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor * factor <= n {\n        if n % factor == 0 {\n      \
    \      n /= factor\n        } else {\n            factor += 1\n        }\n   \
    \ }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_factor = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_factor = n\n    }\n\
    \    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor * factor <= n {\n        if n % factor == 0 {\n      \
    \      n /= factor\n        } else {\n            factor += 1\n        }\n   \
    \ }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while factor <= n {\n        if n % factor == 0 {\n            n /=\
    \ factor\n        } else {\n            factor += 1\n        }\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 0\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_prime_factor = i\n            n /= i\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpj7g3_nia.swift:9:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var factor\
    \ = 2\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 0\n    var n = n\n    for i in 2...n {\n        if n % i == 0 {\n          \
    \  largest_prime = i\n            n /= i\n        }\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmp2hyznkbs/tmp2hyznkbs.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6bfa346c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6bfa03db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6bfa03d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6bfa03c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hyznkbs                        0x000055f0668bb3b0 <unavailable> + 5040

    5    libc.so.6                          0x00002b6bfa532460 __libc_start_main +
    245

    6    tmp2hyznkbs                        0x000055f0668bafe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime =\
    \ 2\n    var n = n\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for i in\
    \ 3.stride(through: Int(sqrt(Double(n))), by: 2) {\n        while n % i == 0 {\n\
    \            largest_prime = i\n            n /= i\n        }\n    }\n    if n\
    \ > 2 {\n        largest_prime = n\n    }\n    return largest_prime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpcnfzjje9.swift:9:36: error: cannot find 'sqrt' in scope\n    for\
    \ i in 3.stride(through: Int(sqrt(Double(n))), by: 2) {\n                    \
    \               ^~~~\n/tmp/tmpcnfzjje9.swift:9:16: error: value of type 'Int'\
    \ has no member 'stride'\n    for i in 3.stride(through: Int(sqrt(Double(n))),\
    \ by: 2) {\n             ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_factor\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_factor = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 2\n   \
    \ var n = n\n    while n % factor != 0 {\n        factor += 1\n    }\n    n /=\
    \ factor\n    while n % factor == 0 {\n        n /= factor\n    }\n    if n ==\
    \ 1 {\n        return factor\n    }\n    return largest_prime_factor(n: n)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n    var largest_prime\
    \ = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    var i = 3\n    while\
    \ i <= n {\n        if n % i == 0 {\n            n /= i\n            largest_prime\
    \ = i\n        } else {\n            i += 2\n        }\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014130
