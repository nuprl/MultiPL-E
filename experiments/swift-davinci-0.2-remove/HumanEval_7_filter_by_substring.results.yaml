language: swift
name: HumanEval_7_filter_by_substring
results:
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for s in strings {\n      \
    \  if s.contains(substring) {\n            filtered.append(s)\n        }\n   \
    \ }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.rangeOfString(substring) != nil {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1w6now5r.swift:6:19: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if string.rangeOfString(substring) != nil {\n     \
    \      ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (string) -> Bool in\n        return\
    \ string.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.rangeOfString(substring) != nil {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1w6now5r.swift:6:19: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if string.rangeOfString(substring) != nil {\n     \
    \      ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var result: [String] = []\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            result.append(string)\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (str: String) -> Bool in\n        return\
    \ str.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var result: [String] = []\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            result.append(string)\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for s in strings {\n        if\
    \ s.contains(substring) {\n            filtered.append(s)\n        }\n    }\n\
    \    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (s: String) -> Bool in\n        return\
    \ s.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for str in strings {\n      \
    \  if str.contains(substring) {\n            filtered.append(str)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for s in strings {\n        if\
    \ s.contains(substring) {\n            filtered.append(s)\n        }\n    }\n\
    \    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (string) -> Bool in\n        return\
    \ string.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (string) -> Bool in\n        return\
    \ string.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (str: String) -> Bool in\n        return\
    \ str.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for s in strings {\n        if\
    \ s.contains(substring) {\n            filtered.append(s)\n        }\n    }\n\
    \    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var result: [String] = []\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            result.append(string)\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered_strings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var result: [String] = []\n    for s in strings {\n        if\
    \ s.contains(substring) {\n            result.append(s)\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
