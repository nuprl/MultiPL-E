language: swift
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i == 0 {\n            continue\n        }\n        prod *=\
    \ i < 0 ? -1 : 1\n        sum += abs(i)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkr5jafs0/tmpkr5jafs0.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abec3236c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abec2f2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abec2f2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abec2f2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkr5jafs0                        0x0000556d109fb815 <unavailable> + 6165

    5    libc.so.6                          0x00002abec3422460 __libc_start_main +
    245

    6    tmpkr5jafs0                        0x0000556d109fb219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0\
    \ ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n    return magnitudes.reduce(1,\
    \ *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp38fd8g4s/tmp38fd8g4s.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37d7a71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37d7768b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37d7768988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37d77677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp38fd8g4s                        0x000055e85cdba639 <unavailable> + 5689

    5    libc.so.6                          0x00002b37d7c5d460 __libc_start_main +
    245

    6    tmp38fd8g4s                        0x000055e85cdba1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    for i in arr {\n        sum +=\
    \ abs(i) * (i < 0 ? -1 : 1)\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpizwv2zuq/tmpizwv2zuq.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1329bb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13298aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13298ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13298ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpizwv2zuq                        0x000056243af5c689 <unavailable> + 5769

    5    libc.so.6                          0x00002b1329da3460 __libc_start_main +
    245

    6    tmpizwv2zuq                        0x000056243af5c219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0\
    \ ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0\
    \ ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i >= 0 ? 1 : -1\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp8_cz51lr/tmp8_cz51lr.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1cecaac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1ce9a1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1ce9a1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1ce9a07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8_cz51lr                        0x000055f729a66815 <unavailable> + 6165

    5    libc.so.6                          0x00002ad1cee96460 __libc_start_main +
    245

    6    tmp8_cz51lr                        0x000055f729a66219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num > 0 {\n            prod *= 1\n        } else if num\
    \ < 0 {\n            prod *= -1\n        } else {\n            prod *= 0\n   \
    \     }\n        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num.signum()\n    }\n   \
    \ return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        }\n        sum +=\
    \ abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp7ttutmbp/tmp7ttutmbp.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae4a37d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae4a34cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae4a34cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4a34ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ttutmbp                        0x000055e830afa815 <unavailable> + 6165

    5    libc.so.6                          0x00002ae4a39c4460 __libc_start_main +
    245

    6    tmp7ttutmbp                        0x000055e830afa219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0\
    \ ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n    let sum = arr.reduce(0, {\
    \ $0 + abs($1) })\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : ($0 >\
    \ 0 ? 1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    let signs = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1\
    \ : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0\
    \ ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n    let sum = arr.reduce(0, +)\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpwyff5g18/tmpwyff5g18.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9048372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9048069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9048069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90480687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwyff5g18                        0x0000556bbf077559 <unavailable> + 5465

    5    libc.so.6                          0x00002b904855e460 __libc_start_main +
    245

    6    tmpwyff5g18                        0x0000556bbf0770e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i == 0 {\n            continue\n        }\n        prod *=\
    \ i < 0 ? -1 : 1\n        sum += abs(i)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkr5jafs0/tmpkr5jafs0.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abec3236c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abec2f2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abec2f2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abec2f2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkr5jafs0                        0x0000556d109fb815 <unavailable> + 6165

    5    libc.so.6                          0x00002abec3422460 __libc_start_main +
    245

    6    tmpkr5jafs0                        0x0000556d109fb219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 > 0 ? 1 : $0 < 0\
    \ ? -1 : 0 }\n    let prod = signs.reduce(1, *)\n    let sum = arr.reduce(0, +)\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiyeifh1q/tmpiyeifh1q.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c3d9fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c3d6f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c3d6f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c3d6f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiyeifh1q                        0x000055880f797559 <unavailable> + 5465

    5    libc.so.6                          0x00002b3c3dbea460 __libc_start_main +
    245

    6    tmpiyeifh1q                        0x000055880f7970e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num < 0 ? -1 : num > 0 ?\
    \ 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1\
    \ : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n        sum += abs(i)\n    }\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var product = 1\n    for\
    \ i in arr {\n        if i < 0 {\n            product *= -1\n        }\n     \
    \   sum += abs(i)\n    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1x41hmtu/tmp1x41hmtu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad17d38fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad17d086b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad17d086988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad17d0857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1x41hmtu                        0x000055b26b255815 <unavailable> + 6165

    5    libc.so.6                          0x00002ad17d57b460 __libc_start_main +
    245

    6    tmp1x41hmtu                        0x000055b26b255219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var product = 1\n    for\
    \ i in arr {\n        if i > 0 {\n            sum += i\n            product *=\
    \ 1\n        } else if i < 0 {\n            sum += abs(i)\n            product\
    \ *= -1\n        } else {\n            product *= 0\n        }\n    }\n    return\
    \ sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        if i != 0 {\n            prod *= i < 0\
    \ ? -1 : 1\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpwaa97l6y/tmpwaa97l6y.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aade46cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aade43c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aade43c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aade43c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwaa97l6y                        0x000055af70e56815 <unavailable> + 6165

    5    libc.so.6                          0x00002aade48b6460 __libc_start_main +
    245

    6    tmpwaa97l6y                        0x000055af70e56219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num < 0 {\n            prod *= -1\n        } else if num\
    \ > 0 {\n            prod *= 1\n        } else {\n            prod *= 0\n    \
    \    }\n        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0\
    \ ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for n in arr\
    \ {\n        sum += abs(n)\n        prod *= n < 0 ? -1 : n > 0 ? 1 : 0\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        if i > 0 {\n            sum += i\n            prod *= 1\n   \
    \     } else if i < 0 {\n            sum += -i\n            prod *= -1\n     \
    \   } else {\n            prod *= 0\n        }\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for num in arr\
    \ {\n        sum += abs(num)\n        prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    return arr.map({ abs($0) }).reduce(1, *) * arr.map({\
    \ $0 < 0 ? -1 : ($0 > 0 ? 1 : 0) }).reduce(1, *)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0j5ufc67/tmp0j5ufc67.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7e3eabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7e3ba2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7e3ba2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7e3ba17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0j5ufc67                        0x000055d167bc8649 <unavailable> + 5705

    5    libc.so.6                          0x00002af7e4097460 __libc_start_main +
    245

    6    tmp0j5ufc67                        0x000055d167bc81d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \      sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num == 0 {\n            continue\n        }\n        prod\
    \ *= num < 0 ? -1 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmptyo74rsh/tmptyo74rsh.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c80bbfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c808b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c808b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c808b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptyo74rsh                        0x000055b05ce83815 <unavailable> + 6165

    5    libc.so.6                          0x00002b0c80dab460 __libc_start_main +
    245

    6    tmptyo74rsh                        0x000055b05ce83219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    var sum = 0\n\
    \    var prod = 1\n    if arr.count == 0 {\n        return nil\n    }\n    for\
    \ i in arr {\n        if i > 0 {\n            sum += i\n            prod *= 1\n\
    \        } else if i < 0 {\n            sum += abs(i)\n            prod *= -1\n\
    \        } else {\n            prod *= 0\n        }\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        if i != 0 {\n            prod *= i / abs(i)\n\
    \        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpvyz9b7ve/tmpvyz9b7ve.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ad0cb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ad09adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ad09ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ad09ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvyz9b7ve                        0x0000557f562488a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b9ad0ea2460 __libc_start_main +
    245

    6    tmpvyz9b7ve                        0x0000557f562482a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num < 0 ? -1 : num > 0 ?\
    \ 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var product = 1\n    var sum = 0\n    for\
    \ i in arr {\n        if i > 0 {\n            product *= 1\n        } else if\
    \ i < 0 {\n            product *= -1\n        } else {\n            product *=\
    \ 0\n        }\n        sum += abs(i)\n    }\n    return sum * product\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0\
    \ ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudeSum = magnitudes.reduce(0, +)\n    return signProduct *\
    \ magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num > 0 {\n            prod *= 1\n        } else if num\
    \ < 0 {\n            prod *= -1\n        } else {\n            prod *= 0\n   \
    \     }\n        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \      sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        if i > 0 {\n            sum += i\n            prod *= 1\n   \
    \     } else if i < 0 {\n            sum += abs(i)\n            prod *= -1\n \
    \       } else {\n            prod *= 0\n        }\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : ($0 >\
    \ 0 ? 1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0,\
    \ +)\n    let prod = signs.reduce(1, *)\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 > 0 ? 1 : $0 < 0\
    \ ? -1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n        sum += abs(i)\n\
    \    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        if i != 0 {\n            sum += abs(i)\n            prod *= i\
    \ > 0 ? 1 : -1\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpzfr_alsc/tmpzfr_alsc.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2f0f75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2f0c6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2f0c6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2f0c6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzfr_alsc                        0x000055f4c8386815 <unavailable> + 6165

    5    libc.so.6                          0x00002ac2f1161460 __libc_start_main +
    245

    6    tmpzfr_alsc                        0x000055f4c8386219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0\
    \ ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1\
    \ : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n    let sum = arr.reduce(0,\
    \ { $0 + abs($1) })\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num < 0 ? -1 : (num == 0\
    \ ? 0 : 1)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : ($0 >\
    \ 0 ? 1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n    let product = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return product * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0\
    \ ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n    return magnitudes.reduce(1,\
    \ combine: *) * signs.reduce(1, combine: *)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1ft_d4o8.swift:13:29: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                            ^   ~~~~~~~~~\n                            \
    \    \n/tmp/tmp1ft_d4o8.swift:13:59: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                                                          ^   ~~~~~~~~~\n\
    \                                                              \n"
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1\
    \ : 0 }\n    let sum = arr.reduce(0) { $0 + abs($1) }\n    let prod = signs.reduce(1)\
    \ { $0 * $1 }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num > 0 {\n            prod *= 1\n        } else if num\
    \ < 0 {\n            prod *= -1\n        } else {\n            prod *= 0\n   \
    \     }\n        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n        sum += abs(i)\n\
    \    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n \
    \   for i in arr {\n        if i > 0 {\n            prod *= 1\n        } else\
    \ if i < 0 {\n            prod *= -1\n        } else {\n            prod *= 0\n\
    \        }\n        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num > 0 {\n            prod *= 1\n        } else if num\
    \ < 0 {\n            prod *= -1\n        } else {\n            prod *= 0\n   \
    \     }\n        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else {\n        return nil\n    }\n    var sign = 1\n    var sum = 0\n \
    \   for i in arr {\n        if i != 0 {\n            sum += abs(i)\n         \
    \   sign *= i < 0 ? -1 : 1\n        }\n    }\n    return sum * sign\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpu11wdp9q/tmpu11wdp9q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dc6da3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9dc6a9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9dc6a9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9dc6a997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu11wdp9q                        0x00005642a8daf815 <unavailable> + 6165

    5    libc.so.6                          0x00002b9dc6f8f460 __libc_start_main +
    245

    6    tmpu11wdp9q                        0x00005642a8daf219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        if i > 0 {\n            sum += i\n            prod *= 1\n   \
    \     } else if i < 0 {\n            sum += abs(i)\n            prod *= -1\n \
    \       } else {\n            prod *= 0\n        }\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let sign = arr.map { $0 < 0 ? -1 : $0 > 0\
    \ ? 1 : 0 }\n    let prod = sign.reduce(1, *)\n    let mag = arr.map { abs($0)\
    \ }\n    let sum = mag.reduce(0, +)\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1\
    \ : 0 }\n    let prod = signs.reduce(1, *)\n    let sum = arr.reduce(0, +)\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5oknlx7e/tmp5oknlx7e.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ec9d51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ec9a48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ec9a48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ec9a477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5oknlx7e                        0x000056259cc91559 <unavailable> + 5465

    5    libc.so.6                          0x00002b3ec9f3d460 __libc_start_main +
    245

    6    tmp5oknlx7e                        0x000056259cc910e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        if i != 0 {\n            prod *= i / abs(i)\n\
    \        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpvyz9b7ve/tmpvyz9b7ve.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ad0cb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ad09adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ad09ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ad09ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvyz9b7ve                        0x0000557f562488a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b9ad0ea2460 __libc_start_main +
    245

    6    tmpvyz9b7ve                        0x0000557f562482a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var product = 1\n    for\
    \ i in arr {\n        sum += abs(i)\n        product *= i < 0 ? -1 : i == 0 ?\
    \ 0 : 1\n    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        if i != 0 {\n            prod *= i > 0\
    \ ? 1 : -1\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpv0z7yz1r/tmpv0z7yz1r.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0e8296c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0e7f8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0e7f8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0e7f8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0z7yz1r                        0x000055e27b974815 <unavailable> + 6165

    5    libc.so.6                          0x00002ac0e8482460 __libc_start_main +
    245

    6    tmpv0z7yz1r                        0x000055e27b974219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0\
    \ ? 1 : -1 }\n    let mags = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = mags.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        if i != 0 {\n            prod *= i > 0\
    \ ? 1 : -1\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpv0z7yz1r/tmpv0z7yz1r.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0e8296c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0e7f8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0e7f8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0e7f8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0z7yz1r                        0x000055e27b974815 <unavailable> + 6165

    5    libc.so.6                          0x00002ac0e8482460 __libc_start_main +
    245

    6    tmpv0z7yz1r                        0x000055e27b974219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1\
    \ : -1 }\n    let magnitudes = arr.map { $0 == 0 ? 0 : abs($0) }\n    return signs.reduce(1,\
    \ *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var product = 1\n    for\
    \ i in arr {\n        sum += abs(i)\n        product *= i < 0 ? -1 : i == 0 ?\
    \ 0 : 1\n    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n \
    \           sum += i\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmptzny6p33/tmptzny6p33.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b8690fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b86606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b86606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b866057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptzny6p33                        0x0000556d453d9599 <unavailable> + 5529

    5    libc.so.6                          0x00002b4b86afb460 __libc_start_main +
    245

    6    tmptzny6p33                        0x0000556d453d9129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    for i in arr {\n        sum +=\
    \ abs(i) * (i == 0 ? 0 : i > 0 ? 1 : -1)\n    }\n    return sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkk19tlwl/tmpkk19tlwl.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9c95d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9c92d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9c92d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9c92cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkk19tlwl                        0x000055c029804689 <unavailable> + 5769

    5    libc.so.6                          0x00002ad9c97c5460 __libc_start_main +
    245

    6    tmpkk19tlwl                        0x000055c029804219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : (i < 0 ? -1 : 0)\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : ($0 >\
    \ 0 ? 1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0,\
    \ +)\n    let product = signs.reduce(1, *)\n    return sum * product\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        if i < 0 {\n            prod *= -1\n \
    \       } else if i > 0 {\n            prod *= 1\n        }\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpqincey48/tmpqincey48.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24cf38bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24cf082b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24cf082988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24cf0817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqincey48                        0x00005603ec24a815 <unavailable> + 6165

    5    libc.so.6                          0x00002b24cf577460 __libc_start_main +
    245

    6    tmpqincey48                        0x00005603ec24a219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i == 0 ? 1 : i / abs(i)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2grgpl0r/tmp2grgpl0r.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9387893c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b938758ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b938758a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93875897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2grgpl0r                        0x0000562b42bf08a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b9387a7f460 __libc_start_main +
    245

    6    tmp2grgpl0r                        0x0000562b42bf02a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num < 0 ? -1 : num > 0 ?\
    \ 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var product = 1\n    for\
    \ i in arr {\n        sum += abs(i)\n        product *= i < 0 ? -1 : i == 0 ?\
    \ 0 : 1\n    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0\
    \ ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0,\
    \ +)\n    let prod = signs.reduce(1, *)\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \      sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num > 0 {\n            prod *= 1\n        } else if num\
    \ < 0 {\n            prod *= -1\n        } else {\n            prod *= 0\n   \
    \     }\n        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        if i > 0 {\n            sum += i\n            prod *= 1\n   \
    \     } else if i < 0 {\n            sum += abs(i)\n            prod *= -1\n \
    \       } else {\n            prod *= 0\n        }\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i == 0 ? 1 : (i > 0 ? 1 : -1)\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0joce5bq/tmp0joce5bq.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c20f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c1deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c1dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c1ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0joce5bq                        0x000055ee37042815 <unavailable> + 6165

    5    libc.so.6                          0x00002ab1c22e3460 __libc_start_main +
    245

    6    tmp0joce5bq                        0x000055ee37042219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for num\
    \ in arr {\n        if num < 0 {\n            prod *= -1\n        } else if num\
    \ > 0 {\n            prod *= 1\n        } else {\n            prod *= 0\n    \
    \    }\n        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num < 0 ? -1 : num > 0 ?\
    \ 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for num in arr\
    \ {\n        sum += abs(num)\n        prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num > 0 ? 1 : num < 0 ? -1\
    \ : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \      sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            prod *= -1\n        } else if i > 0 {\n\
    \            prod *= 1\n        } else {\n            prod *= 0\n        }\n \
    \       sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i == 0 ? 1 : i < 0 ? -1 : 1\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp9ygrsnsv/tmp9ygrsnsv.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b64a4b8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64a4881b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b64a4881988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b64a48807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ygrsnsv                        0x0000555fcf1c0815 <unavailable> + 6165

    5    libc.so.6                          0x00002b64a4d76460 __libc_start_main +
    245

    6    tmp9ygrsnsv                        0x0000555fcf1c0219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var product = 1\n    for\
    \ num in arr {\n        sum += abs(num)\n        product *= num > 0 ? 1 : num\
    \ < 0 ? -1 : 0\n    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : (i < 0 ? -1 : 0)\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0.signum() }\n    let\
    \ magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0, +)\n  \
    \  let prod = signs.reduce(1, *)\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num < 0 ? -1 : num > 0 ?\
    \ 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 < 0 ? -1 : $0 > 0\
    \ ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = magnitudes.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var prod = 1\n    var sum = 0\n    for i in\
    \ arr {\n        if i == 0 {\n            prod *= 0\n        } else if i < 0 {\n\
    \            prod *= -1\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        if i == 0 {\n            continue\n        }\n        prod *= i <\
    \ 0 ? -1 : 1\n        sum += abs(i)\n    }\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppdqqwbqe/tmppdqqwbqe.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b447f1a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b447ee9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b447ee9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b447ee997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppdqqwbqe                        0x000055879c2b8815 <unavailable> + 6165

    5    libc.so.6                          0x00002b447f38f460 __libc_start_main +
    245

    6    tmppdqqwbqe                        0x000055879c2b8219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0\
    \ ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0,\
    \ +)\n    let prod = signs.reduce(1, *)\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    for i in arr {\n        sum +=\
    \ abs(i) * (i > 0 ? 1 : (i < 0 ? -1 : 0))\n    }\n    return sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpugxfbmp8/tmpugxfbmp8.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63d2792c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63d2489b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63d2489988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63d24887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpugxfbmp8                        0x00005567f02a5689 <unavailable> + 5769

    5    libc.so.6                          0x00002b63d297e460 __libc_start_main +
    245

    6    tmpugxfbmp8                        0x00005567f02a5219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979762
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num < 0 ? -1 : num > 0 ?\
    \ 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        if i != 0 {\n            sum += abs(i)\n            prod *= i\
    \ > 0 ? 1 : -1\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpzfr_alsc/tmpzfr_alsc.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2f0f75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2f0c6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2f0c6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2f0c6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzfr_alsc                        0x000055f4c8386815 <unavailable> + 6165

    5    libc.so.6                          0x00002ac2f1161460 __libc_start_main +
    245

    6    tmpzfr_alsc                        0x000055f4c8386219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for num\
    \ in arr {\n        sum += abs(num)\n        prod *= num > 0 ? 1 : num < 0 ? -1\
    \ : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for i in arr\
    \ {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    return arr.map { abs($0) }.reduce(1, *) * arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb3jkvc_i/tmpb3jkvc_i.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d72ac7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d727beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d727be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d727bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb3jkvc_i                        0x000055752e3dc649 <unavailable> + 5705

    5    libc.so.6                          0x00002b8d72cb3460 __libc_start_main +
    245

    6    tmpb3jkvc_i                        0x000055752e3dc1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979762
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i < 0 ? -1 : i > 0 ? 1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979760
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var result = 1\n    for i in arr {\n     \
    \   if i == 0 {\n            result = 0\n            break\n        }\n      \
    \  result *= i < 0 ? -1 : 1\n    }\n    return arr.reduce(0, { $0 + abs($1) })\
    \ * result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979762
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n \
    \   }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var prod = 1\n    for i in\
    \ arr {\n        sum += abs(i)\n        prod *= i == 0 ? 1 : i / abs(i)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpr785wffi/tmpr785wffi.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8a3c4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8a3945b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8a3945988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8a39447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr785wffi                        0x00005612b67238a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ad8a3e3a460 __libc_start_main +
    245

    6    tmpr785wffi                        0x00005612b67232a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979762
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var sum = 0\n    var prod = 1\n    for num in arr\
    \ {\n        sum += abs(num)\n        prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\nfunc prod_signs(arr: [Int]) -> Int? {\n    guard arr.count\
    \ > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1\n        } else if i < 0 {\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \      sum += abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979761
