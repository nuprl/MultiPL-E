language: swift
name: HumanEval_80_is_happy
results:
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    if s.count < 3 {\n        return false\n\
    \    }\n    for i in 0..<s.count-2 {\n        if s[i] == s[i+1] && s[i] == s[i+2]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpf3pjaq8m/tmpf3pjaq8m.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaaf9a2bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaaf9722b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaaf9722988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaaf97217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf3pjaq8m                        0x0000563f8f9d3831 <unavailable> + 6193

    5    libc.so.6                          0x00002aaaf9c17460 __libc_start_main +
    245

    6    tmpf3pjaq8m                        0x0000563f8f9d32d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmps33vrvtj/tmps33vrvtj.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b530f8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b530f5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b530f5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b530f5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps33vrvtj                        0x000055dbb8d2639b <unavailable> + 5019

    5    libc.so.6                          0x00002b530faa1460 __libc_start_main +
    245

    6    tmps33vrvtj                        0x000055dbb8d25ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var last3\
    \ = s.prefix(3)\n    for i in 3..<s.count {\n        let index = s.index(s.startIndex,\
    \ offsetBy: i)\n        if last3.contains(s[index]) {\n            return false\n\
    \        }\n        last3.removeFirst()\n        last3.append(s[index])\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpogb7w0sg/tmpogb7w0sg.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14cd444c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14cd13bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14cd13b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14cd13a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpogb7w0sg                        0x0000560203d55b9f <unavailable> + 7071

    5    libc.so.6                          0x00002b14cd630460 __libc_start_main +
    245

    6    tmpogb7w0sg                        0x0000560203d554d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    if s.count < 3 {\n        return\
    \ false\n    }\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let sub = s[start..<end]\n        if Set(sub).count != 3 {\n           \
    \ return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var previous\
    \ = s.prefix(3)\n    for i in 3..<s.count {\n        let index = s.index(s.startIndex,\
    \ offsetBy: i)\n        let current = s[index]\n        if previous.contains(current)\
    \ {\n            return false\n        }\n        previous.removeFirst()\n   \
    \     previous.append(current)\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpedz6boll/tmpedz6boll.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b825f41ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b825f115b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b825f115988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b825f1147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpedz6boll                        0x000055db22928b9f <unavailable> + 7071

    5    libc.so.6                          0x00002b825f60a460 __libc_start_main +
    245

    6    tmpedz6boll                        0x000055db229284d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var previous\
    \ = s.first!\n    var previousPrevious = s[s.index(after: s.startIndex)]\n   \
    \ for c in s.dropFirst(2) {\n        if c == previous || c == previousPrevious\
    \ {\n            return false\n        }\n        previousPrevious = previous\n\
    \        previous = c\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    let n = s.count\n    if n < 3 { return\
    \ false }\n    for i in 0..<n-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2]\
    \ || s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\n\
    assert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\n\
    assert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\n\
    assert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\n\
    assert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = s.startIndex\n\
    \    while i < s.index(s.endIndex, offsetBy: -2) {\n        if s[i] == s[s.index(i,\
    \ offsetBy: 1)] || s[i] == s[s.index(i, offsetBy: 2)] || s[s.index(i, offsetBy:\
    \ 1)] == s[s.index(i, offsetBy: 2)] {\n            return false\n        }\n \
    \       i = s.index(i, offsetBy: 1)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ != 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = 0\n   \
    \ while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub\
    \ = s[start..<end]\n        if Set(sub).count != 3 {\n            return false\n\
    \        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmps33vrvtj/tmps33vrvtj.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b530f8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b530f5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b530f5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b530f5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps33vrvtj                        0x000055dbb8d2639b <unavailable> + 5019

    5    libc.so.6                          0x00002b530faa1460 __libc_start_main +
    245

    6    tmps33vrvtj                        0x000055dbb8d25ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        for i in 0..<s.count\
    \ - 2 {\n            let start = s.index(s.startIndex, offsetBy: i)\n        \
    \    let end = s.index(s.startIndex, offsetBy: i + 3)\n            let range =\
    \ start..<end\n            let subString = s[range]\n            if Set(subString).count\
    \ == 3 {\n                result = true\n            } else {\n              \
    \  result = false\n                break\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let range = start..<end\n    \
    \    let substring = s[range]\n        if Set(substring).count != 3 {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = 0\n   \
    \ while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub\
    \ = s[start..<end]\n        if Set(sub).count != 3 {\n            return false\n\
    \        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().reduce(true) { (isHappy,\
    \ indexAndChar) in\n        let (index, char) = indexAndChar\n        return isHappy\
    \ && (index < 2 || char != s[s.index(s.startIndex, offsetBy: index - 2)])\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\n\
    assert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\n\
    assert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\n\
    assert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\n\
    assert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmptdf5bd2_/tmptdf5bd2_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4478697c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b447838eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b447838e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b447838d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptdf5bd2_                        0x0000558e77148831 <unavailable> + 6193

    5    libc.so.6                          0x00002b4478883460 __libc_start_main +
    245

    6    tmptdf5bd2_                        0x0000558e771482d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var isHappy = false\n    let s = Array(s)\n    if s.count >=\
    \ 3 {\n        for i in 0..<s.count-2 {\n            if s[i] != s[i+1] && s[i]\
    \ != s[i+2] && s[i+1] != s[i+2] {\n                isHappy = true\n          \
    \  } else {\n                isHappy = false\n                break\n        \
    \    }\n        }\n    }\n    return isHappy\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    if s.count < 3 {\n        return false\n\
    \    }\n    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] ==\
    \ s[i + 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = true\n    if s.count < 3 {\n        result = false\n\
    \    } else {\n        for i in 0...s.count - 3 {\n            let start = s.index(s.startIndex,\
    \ offsetBy: i)\n            let end = s.index(s.startIndex, offsetBy: i + 3)\n\
    \            let range = start..<end\n            let subString = s[range]\n \
    \           if Set(subString).count != 3 {\n                result = false\n \
    \               break\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count < 3 {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count != 3 {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    var happy = true\n    if s.count\
    \ < 3 {\n        happy = false\n    } else {\n        for i in 0..<s.count - 2\
    \ {\n            let start = s.index(s.startIndex, offsetBy: i)\n            let\
    \ end = s.index(s.startIndex, offsetBy: i + 3)\n            let range = start..<end\n\
    \            let sub = s[range]\n            if Set(sub).count != 3 {\n      \
    \          happy = false\n                break\n            }\n        }\n  \
    \  }\n    return happy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let s = Array(s)\n\
    \    for i in 0..<s.count-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2] ||\
    \ s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub\
    \ = s[start..<end]\n        if Set(sub).count < 3 {\n            return false\n\
    \        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmps33vrvtj/tmps33vrvtj.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b530f8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b530f5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b530f5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b530f5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps33vrvtj                        0x000055dbb8d2639b <unavailable> + 5019

    5    libc.so.6                          0x00002b530faa1460 __libc_start_main +
    245

    6    tmps33vrvtj                        0x000055dbb8d25ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        let sArray\
    \ = Array(s)\n        for i in 0..<sArray.count - 2 {\n            if sArray[i]\
    \ != sArray[i + 1] && sArray[i] != sArray[i + 2] && sArray[i + 1] != sArray[i\
    \ + 2] {\n                result = true\n            } else {\n              \
    \  result = false\n                break\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let chars = Array(s)\n    if chars.count < 3 {\n        return\
    \ false\n    }\n    for i in 0..<chars.count - 2 {\n        if chars[i] == chars[i\
    \ + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var previous\
    \ = s.prefix(3)\n    for i in 3..<s.count {\n        let index = s.index(s.startIndex,\
    \ offsetBy: i)\n        let current = s[index]\n        if previous.contains(current)\
    \ {\n            return false\n        }\n        previous.removeFirst()\n   \
    \     previous.append(current)\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpedz6boll/tmpedz6boll.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b825f41ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b825f115b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b825f115988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b825f1147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpedz6boll                        0x000055db22928b9f <unavailable> + 7071

    5    libc.so.6                          0x00002b825f60a460 __libc_start_main +
    245

    6    tmpedz6boll                        0x000055db229284d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let range = start..<end\n    \
    \    let sub = s[range]\n        let set = Set(sub)\n        if set.count == 1\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp8pbdpqbj/tmp8pbdpqbj.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af04e3b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af04e0aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af04e0ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af04e0ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8pbdpqbj                        0x0000557165a6e8e1 <unavailable> + 6369

    5    libc.so.6                          0x00002af04e5a3460 __libc_start_main +
    245

    6    tmp8pbdpqbj                        0x0000557165a6e389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    let s = Array(s)\n    if s.count >= 3\
    \ {\n        for i in 0..<s.count - 2 {\n            if s[i] != s[i + 1] && s[i]\
    \ != s[i + 2] && s[i + 1] != s[i + 2] {\n                result = true\n     \
    \       } else {\n                result = false\n                break\n    \
    \        }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count != 3 {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var prev = s.startIndex\n\
    \    var curr = s.index(after: prev)\n    var next = s.index(after: curr)\n  \
    \  while next < s.endIndex {\n        if s[prev] == s[curr] || s[curr] == s[next]\
    \ || s[prev] == s[next] {\n            return false\n        }\n        prev =\
    \ curr\n        curr = next\n        next = s.index(after: next)\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\n\
    assert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\n\
    assert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\n\
    assert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\n\
    assert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0...s.count\
    \ - 3 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0...s.count\
    \ - 3 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ < 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0...s.count\
    \ - 3 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var set =\
    \ Set<Character>()\n    for i in 0..<s.count {\n        let index = s.index(s.startIndex,\
    \ offsetBy: i)\n        set.insert(s[index])\n        if set.count == 3 {\n  \
    \          return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpzo8g3g6g/tmpzo8g3g6g.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b726f27ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b726ef75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b726ef75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b726ef747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzo8g3g6g                        0x00005587c6b2eba8 <unavailable> + 7080

    5    libc.so.6                          0x00002b726f46a460 __libc_start_main +
    245

    6    tmpzo8g3g6g                        0x00005587c6b2e369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    guard s.count >= 3 else { return false\
    \ }\n    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i\
    \ + 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { i, c in\n\
    \        i < s.count - 2 ? s[s.index(s.startIndex, offsetBy: i + 1)] != c && s[s.index(s.startIndex,\
    \ offsetBy: i + 2)] != c : true\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp2bvf3sp3/tmp2bvf3sp3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab8e9e86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab8e9b7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab8e9b7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8e9b7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2bvf3sp3                        0x000055e8b3d0f95f <unavailable> + 6495

    5    libc.so.6                          0x00002ab8ea072460 __libc_start_main +
    245

    6    tmp2bvf3sp3                        0x000055e8b3d0f299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let subString = s[range]\n        if Set(subString).count\
    \ != 3 {\n            return false\n        }\n        i += 1\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\n\
    assert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\n\
    assert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\n\
    assert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\n\
    assert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var index\
    \ = s.startIndex\n    while index < s.endIndex {\n        let start = s.index(index,\
    \ offsetBy: 0)\n        let end = s.index(index, offsetBy: 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n        index = s.index(index, offsetBy:\
    \ 3)\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'Swift/StringCharacterView.swift:153: Fatal error: String index is out of
    bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b2820884c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b282057b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b282057b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b282057b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b282057abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b28206aeb0d <unavailable> + 2693901

    6    tmpm9smacjg                        0x00005632253c8cb4 <unavailable> + 7348

    7    tmpm9smacjg                        0x00005632253c8786 <unavailable> + 6022

    8    libc.so.6                          0x00002b2820a70460 __libc_start_main +
    245

    9    tmpm9smacjg                        0x00005632253c8349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var result = true\n\
    \    for i in 0..<s.count-2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i+3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        let set = Set(sub)\n    \
    \    if set.count != 3 {\n            result = false\n            break\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2] ||\
    \ s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var chars = Array(s)\n\
    \    for i in 0..<chars.count - 2 {\n        if chars[i] == chars[i + 1] || chars[i]\
    \ == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = s.startIndex\n\
    \    while i < s.index(s.endIndex, offsetBy: -2) {\n        if s[i] == s[s.index(i,\
    \ offsetBy: 1)] || s[i] == s[s.index(i, offsetBy: 2)] || s[s.index(i, offsetBy:\
    \ 1)] == s[s.index(i, offsetBy: 2)] {\n            return false\n        }\n \
    \       i = s.index(i, offsetBy: 1)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = s.startIndex\n\
    \    while i < s.index(s.endIndex, offsetBy: -2) {\n        if s[i] == s[s.index(i,\
    \ offsetBy: 1)] || s[i] == s[s.index(i, offsetBy: 2)] || s[s.index(i, offsetBy:\
    \ 1)] == s[s.index(i, offsetBy: 2)] {\n            return false\n        }\n \
    \       i = s.index(i, offsetBy: 1)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var last = s.startIndex\n\
    \    var next = s.index(after: last)\n    var afterNext = s.index(after: next)\n\
    \    while afterNext < s.endIndex {\n        if s[last] == s[next] || s[last]\
    \ == s[afterNext] || s[next] == s[afterNext] {\n            return false\n   \
    \     }\n        last = next\n        next = afterNext\n        afterNext = s.index(after:\
    \ afterNext)\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var result = true\n\
    \    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        let set = Set(sub)\n    \
    \    if set.count != 3 {\n            result = false\n            break\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let range = start..<end\n    \
    \    let sub = s[range]\n        let set = Set(sub)\n        if set.count == 1\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp8pbdpqbj/tmp8pbdpqbj.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af04e3b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af04e0aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af04e0ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af04e0ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8pbdpqbj                        0x0000557165a6e8e1 <unavailable> + 6369

    5    libc.so.6                          0x00002af04e5a3460 __libc_start_main +
    245

    6    tmp8pbdpqbj                        0x0000557165a6e389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var s = s\n   \
    \ while s.count >= 3 {\n        let first = s.removeFirst()\n        let second\
    \ = s.removeFirst()\n        let third = s.removeFirst()\n        if first ==\
    \ second || second == third || first == third {\n            return false\n  \
    \      }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpa2yh4r4z/tmpa2yh4r4z.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b445c8d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445c5cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b445c5cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b445c5cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa2yh4r4z                        0x0000562d1245e8a8 <unavailable> + 6312

    5    libc.so.6                          0x00002b445cac2460 __libc_start_main +
    245

    6    tmpa2yh4r4z                        0x0000562d1245e069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmps33vrvtj/tmps33vrvtj.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b530f8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b530f5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b530f5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b530f5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps33vrvtj                        0x000055dbb8d2639b <unavailable> + 5019

    5    libc.so.6                          0x00002b530faa1460 __libc_start_main +
    245

    6    tmps33vrvtj                        0x000055dbb8d25ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    if s.count < 3 {\n        return false\n\
    \    }\n    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] ==\
    \ s[i + 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    if s.count < 3 { return false }\n    for\
    \ i in 0..<s.count-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1]\
    \ == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = false\n    if s.count >= 3 {\n        for i in 0..<s.count-2\
    \ {\n            let index1 = s.index(s.startIndex, offsetBy: i)\n           \
    \ let index2 = s.index(s.startIndex, offsetBy: i+1)\n            let index3 =\
    \ s.index(s.startIndex, offsetBy: i+2)\n            let char1 = s[index1]\n  \
    \          let char2 = s[index2]\n            let char3 = s[index3]\n        \
    \    if char1 != char2 && char2 != char3 && char1 != char3 {\n               \
    \ happy = true\n            } else {\n                happy = false\n        \
    \        break\n            }\n        }\n    }\n    return happy\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    if s.count < 3 {\n        return\
    \ false\n    }\n    for i in 0..<s.count - 2 {\n        let index1 = s.index(s.startIndex,\
    \ offsetBy: i)\n        let index2 = s.index(s.startIndex, offsetBy: i + 1)\n\
    \        let index3 = s.index(s.startIndex, offsetBy: i + 2)\n        if s[index1]\
    \ == s[index2] || s[index1] == s[index3] || s[index2] == s[index3] {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = s.startIndex\n\
    \    var j = s.index(i, offsetBy: 1)\n    var k = s.index(i, offsetBy: 2)\n  \
    \  while k < s.endIndex {\n        if s[i] == s[j] || s[i] == s[k] || s[j] ==\
    \ s[k] {\n            return false\n        }\n        i = s.index(after: i)\n\
    \        j = s.index(after: j)\n        k = s.index(after: k)\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\n\
    assert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\n\
    assert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\n\
    assert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\n\
    assert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let range = start..<end\n    \
    \    let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = true\n    var index = s.startIndex\n    while index\
    \ != s.endIndex {\n        let nextIndex = s.index(index, offsetBy: 3)\n     \
    \   if nextIndex <= s.endIndex {\n            let subString = s[index..<nextIndex]\n\
    \            if Set(subString).count != 3 {\n                happy = false\n \
    \               break\n            }\n        }\n        index = nextIndex\n \
    \   }\n    return happy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'Swift/StringCharacterView.swift:153: Fatal error: String index is out of
    bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ca8be5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ca88dc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3ca88dc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3ca88dc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3ca88dbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b3ca8a0fb0d <unavailable> + 2693901

    6    tmp34yvwuha                        0x000055c3015c9cab <unavailable> + 7339

    7    tmp34yvwuha                        0x000055c3015c9676 <unavailable> + 5750

    8    libc.so.6                          0x00002b3ca8dd1460 __libc_start_main +
    245

    9    tmp34yvwuha                        0x000055c3015c9379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    guard s.count >= 3 else { return false\
    \ }\n    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i\
    \ + 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ < 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = true\n    if s.count < 3 {\n        result = false\n\
    \    } else {\n        for i in 0..<s.count-2 {\n            let start = s.index(s.startIndex,\
    \ offsetBy: i)\n            let end = s.index(s.startIndex, offsetBy: i+3)\n \
    \           let range = start..<end\n            let subString = s[range]\n  \
    \          if Set(subString).count != 3 {\n                result = false\n  \
    \              break\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { (index, char)\
    \ in\n        guard index + 2 < s.count else { return true }\n        let next\
    \ = s.index(s.startIndex, offsetBy: index + 1)\n        let nextNext = s.index(s.startIndex,\
    \ offsetBy: index + 2)\n        return char != s[next] && char != s[nextNext]\
    \ && s[next] != s[nextNext]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count < 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count < 3 {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { (i, c) in\n\
    \        i < s.count - 2 ? c != s[s.index(s.startIndex, offsetBy: i + 1)] && c\
    \ != s[s.index(s.startIndex, offsetBy: i + 2)] : true\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpldtpk6ck/tmpldtpk6ck.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21df0a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21ded9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21ded9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21ded997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpldtpk6ck                        0x0000559f4f36295f <unavailable> + 6495

    5    libc.so.6                          0x00002b21df28f460 __libc_start_main +
    245

    6    tmpldtpk6ck                        0x0000559f4f362299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { (i, c) in\n\
    \        i < s.count - 2 && c != s[s.index(s.startIndex, offsetBy: i + 1)] &&\
    \ c != s[s.index(s.startIndex, offsetBy: i + 2)]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp9anrw6ca/tmp9anrw6ca.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ee565ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ee5355b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ee5355988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ee53547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9anrw6ca                        0x000055f45ca6074b <unavailable> + 5963

    5    libc.so.6                          0x00002b0ee584a460 __libc_start_main +
    245

    6    tmp9anrw6ca                        0x000055f45ca60299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = 0\n   \
    \ while i < s.count - 2 {\n        let index1 = s.index(s.startIndex, offsetBy:\
    \ i)\n        let index2 = s.index(s.startIndex, offsetBy: i + 1)\n        let\
    \ index3 = s.index(s.startIndex, offsetBy: i + 2)\n        let sub1 = s[index1]\n\
    \        let sub2 = s[index2]\n        let sub3 = s[index3]\n        if sub1 ==\
    \ sub2 || sub1 == sub3 || sub2 == sub3 {\n            return false\n        }\n\
    \        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count < 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let s = s.lowercased()\n\
    \    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let chars = Array(s)\n\
    \    for i in 0..<s.count-2 {\n        if chars[i] == chars[i+1] || chars[i] ==\
    \ chars[i+2] || chars[i+1] == chars[i+2] {\n            return false\n       \
    \ }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count < 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let a = Array(s)\n\
    \    for i in 0..<a.count - 2 {\n        if a[i] == a[i + 1] || a[i] == a[i +\
    \ 2] || a[i + 1] == a[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var chars = Array(s)\n\
    \    var i = 0\n    while i < chars.count - 2 {\n        if chars[i] == chars[i\
    \ + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n       \
    \     return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub\
    \ = s[start..<end]\n        if Set(sub).count < 3 {\n            return false\n\
    \        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var index\
    \ = s.startIndex\n    var previous = s[index]\n    index = s.index(after: index)\n\
    \    var current = s[index]\n    index = s.index(after: index)\n    var next =\
    \ s[index]\n    while index < s.endIndex {\n        if previous == current ||\
    \ current == next || previous == next {\n            return false\n        }\n\
    \        previous = current\n        current = next\n        index = s.index(after:\
    \ index)\n        next = s[index]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002ad566e22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad566b19561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad566b19286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad566b1913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad566b18bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ad566c4cec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002ad566c05660 String.subscript.getter
    + 34

    7    tmpt0yemdw4                        0x0000564fbd600d56 <unavailable> + 7510

    8    tmpt0yemdw4                        0x0000564fbd600596 <unavailable> + 5526

    9    libc.so.6                          0x00002ad56700e460 __libc_start_main +
    245

    10   tmpt0yemdw4                        0x0000564fbd600159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let s = Array(s)\n\
    \    for i in 0..<s.count-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2] ||\
    \ s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { (i, c) in\n\
    \        i < s.count - 2 ? c != s[s.index(s.startIndex, offsetBy: i + 1)] && c\
    \ != s[s.index(s.startIndex, offsetBy: i + 2)] : true\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpldtpk6ck/tmpldtpk6ck.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21df0a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21ded9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21ded9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21ded997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpldtpk6ck                        0x0000559f4f36295f <unavailable> + 6495

    5    libc.so.6                          0x00002b21df28f460 __libc_start_main +
    245

    6    tmpldtpk6ck                        0x0000559f4f362299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count != 3 {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = 0\n   \
    \ while i < s.count - 2 {\n        let index1 = s.index(s.startIndex, offsetBy:\
    \ i)\n        let index2 = s.index(s.startIndex, offsetBy: i + 1)\n        let\
    \ index3 = s.index(s.startIndex, offsetBy: i + 2)\n        let sub1 = s[index1]\n\
    \        let sub2 = s[index2]\n        let sub3 = s[index3]\n        if sub1 ==\
    \ sub2 || sub1 == sub3 || sub2 == sub3 {\n            return false\n        }\n\
    \        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = true\n    if s.count < 3 {\n        happy = false\n\
    \    } else {\n        for i in 0..<s.count-2 {\n            let start = s.index(s.startIndex,\
    \ offsetBy: i)\n            let end = s.index(s.startIndex, offsetBy: i+3)\n \
    \           let range = start..<end\n            let sub = s[range]\n        \
    \    if sub.count == 3 {\n                if sub.first == sub.last {\n       \
    \             happy = false\n                    break\n                }\n  \
    \          }\n        }\n    }\n    return happy\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpvu_xtbni/tmpvu_xtbni.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34e3bd5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34e38ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34e38cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34e38cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvu_xtbni                        0x000055e50ade2951 <unavailable> + 6481

    5    libc.so.6                          0x00002b34e3dc1460 __libc_start_main +
    245

    6    tmpvu_xtbni                        0x000055e50ade23f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = true\n    if s.count < 3 {\n        result = false\n\
    \    } else {\n        for i in 0..<s.count - 2 {\n            let start = s.index(s.startIndex,\
    \ offsetBy: i)\n            let end = s.index(s.startIndex, offsetBy: i + 3)\n\
    \            let range = start..<end\n            let subString = s[range]\n \
    \           if subString.count == Set(subString).count {\n                result\
    \ = true\n            } else {\n                result = false\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let index = s.index(s.startIndex, offsetBy: i)\n        let nextIndex\
    \ = s.index(s.startIndex, offsetBy: i+1)\n        let nextNextIndex = s.index(s.startIndex,\
    \ offsetBy: i+2)\n        if s[index] == s[nextIndex] || s[index] == s[nextNextIndex]\
    \ || s[nextIndex] == s[nextNextIndex] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub\
    \ = s[start..<end]\n        if Set(sub).count != 3 {\n            return false\n\
    \        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count < 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count < 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    if s.count < 3 { return false }\n    for\
    \ i in 0..<s.count-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1]\
    \ == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = 0\n   \
    \ while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let chars = Array(s)\n\
    \    for i in 0..<chars.count - 2 {\n        if chars[i] == chars[i + 1] || chars[i]\
    \ == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        for i in 0..<s.count\
    \ - 2 {\n            let start = s.index(s.startIndex, offsetBy: i)\n        \
    \    let end = s.index(s.startIndex, offsetBy: i + 3)\n            let range =\
    \ start..<end\n            let subString = s[range]\n            if Set(subString).count\
    \ == 3 {\n                result = true\n            } else {\n              \
    \  result = false\n                break\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmps33vrvtj/tmps33vrvtj.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b530f8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b530f5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b530f5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b530f5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps33vrvtj                        0x000055dbb8d2639b <unavailable> + 5019

    5    libc.so.6                          0x00002b530faa1460 __libc_start_main +
    245

    6    tmps33vrvtj                        0x000055dbb8d25ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = false\n    if s.count >= 3 {\n        for i in 0..<s.count\
    \ - 2 {\n            let start = s.index(s.startIndex, offsetBy: i)\n        \
    \    let end = s.index(s.startIndex, offsetBy: i + 3)\n            let range =\
    \ start..<end\n            let sub = s[range]\n            if Set(sub).count ==\
    \ 3 {\n                happy = true\n            } else {\n                happy\
    \ = false\n                break\n            }\n        }\n    }\n    return\
    \ happy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\n\
    assert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\n\
    assert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\n\
    assert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\n\
    assert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    if s.count < 3 {\n        return\
    \ false\n    }\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let sub = s[start..<end]\n        if Set(sub).count != 3 {\n           \
    \ return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ != 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let substring = s[start..<end]\n\
    \        let set = Set(substring)\n        if set.count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count != 3 {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        let s_array\
    \ = Array(s)\n        for i in 0..<s_array.count-2 {\n            if s_array[i]\
    \ != s_array[i+1] && s_array[i] != s_array[i+2] && s_array[i+1] != s_array[i+2]\
    \ {\n                result = true\n            } else {\n                result\
    \ = false\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") ==\
    \ false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") ==\
    \ true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") ==\
    \ true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = s.startIndex\n\
    \    while i < s.index(s.endIndex, offsetBy: -2) {\n        let s1 = s[i]\n  \
    \      let s2 = s[s.index(after: i)]\n        let s3 = s[s.index(i, offsetBy:\
    \ 2)]\n        if s1 == s2 || s1 == s3 || s2 == s3 {\n            return false\n\
    \        }\n        i = s.index(after: i)\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ == 1 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpoliubig9/tmpoliubig9.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1698420c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1698117b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1698117988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16981167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoliubig9                        0x000056161c60f8e1 <unavailable> + 6369

    5    libc.so.6                          0x00002b169860c460 __libc_start_main +
    245

    6    tmpoliubig9                        0x000056161c60f389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count != 3 {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmps33vrvtj/tmps33vrvtj.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b530f8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b530f5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b530f5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b530f5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps33vrvtj                        0x000055dbb8d2639b <unavailable> + 5019

    5    libc.so.6                          0x00002b530faa1460 __libc_start_main +
    245

    6    tmps33vrvtj                        0x000055dbb8d25ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    if s.count < 3 {\n        return false\n\
    \    }\n    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] ==\
    \ s[i + 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count < 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = false\n    if s.count >= 3 {\n        for i in 0...s.count\
    \ - 3 {\n            let index = s.index(s.startIndex, offsetBy: i)\n        \
    \    let index2 = s.index(s.startIndex, offsetBy: i + 1)\n            let index3\
    \ = s.index(s.startIndex, offsetBy: i + 2)\n            if s[index] != s[index2]\
    \ && s[index] != s[index3] && s[index2] != s[index3] {\n                happy\
    \ = true\n            } else {\n                happy = false\n              \
    \  break\n            }\n        }\n    }\n    return happy\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count < 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = true\n    let s = Array(s)\n    for i in 0..<s.count\
    \ - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i +\
    \ 2] {\n            result = false\n            break\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") ==\
    \ false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") ==\
    \ true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") ==\
    \ true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002aea8fea0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea8fb97561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aea8fb97286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aea8fb9713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aea8fb96bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph5q9atue                        0x0000558c3b8e3ca7 <unavailable> + 7335

    6    tmph5q9atue                        0x0000558c3b8e35d6 <unavailable> + 5590

    7    libc.so.6                          0x00002aea9008c460 __libc_start_main +
    245

    8    tmph5q9atue                        0x0000558c3b8e32d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        let set = Set(sub)\n        if set.count < 3 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { (i, c) in\n\
    \        i % 3 != 2 || c != s[s.index(s.startIndex, offsetBy: i - 2)]\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpc5np9yim/tmpc5np9yim.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66df5a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66df297b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66df297988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66df2967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc5np9yim                        0x000055c38fec9881 <unavailable> + 6273

    5    libc.so.6                          0x00002b66df78c460 __libc_start_main +
    245

    6    tmpc5np9yim                        0x000055c38fec9329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = Array(s)\n    guard s.count >= 3 else { return false\
    \ }\n    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i\
    \ + 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ != 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { (i, c) in\n\
    \        i < s.count - 2 ? s[s.index(s.startIndex, offsetBy: i + 1)] != c && s[s.index(s.startIndex,\
    \ offsetBy: i + 2)] != c : true\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpegjndbyq/tmpegjndbyq.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9934550c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9934247b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9934247988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99342467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegjndbyq                        0x000055ffe0f3b95f <unavailable> + 6495

    5    libc.so.6                          0x00002b993473c460 __libc_start_main +
    245

    6    tmpegjndbyq                        0x000055ffe0f3b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        let sArray\
    \ = Array(s)\n        for i in 0...sArray.count - 3 {\n            if sArray[i]\
    \ != sArray[i + 1] && sArray[i] != sArray[i + 2] && sArray[i + 1] != sArray[i\
    \ + 2] {\n                result = true\n            } else {\n              \
    \  result = false\n                break\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count < 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    if s.count < 3 {\n        return\
    \ false\n    }\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let range = start..<end\n        let sub = s[range]\n        if Set(sub).count\
    \ != 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let range = start..<end\n    \
    \    let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmps33vrvtj/tmps33vrvtj.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b530f8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b530f5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b530f5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b530f5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps33vrvtj                        0x000055dbb8d2639b <unavailable> + 5019

    5    libc.so.6                          0x00002b530faa1460 __libc_start_main +
    245

    6    tmps33vrvtj                        0x000055dbb8d25ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    if s.count < 3 {\n        return\
    \ false\n    }\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let range = start..<end\n        let sub = s[range]\n        if Set(sub).count\
    \ != 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        let set = Set(sub)\n        if set.count < 3 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    if s.count < 3 {\n        return\
    \ false\n    }\n    for i in 0..<s.count - 2 {\n        let index1 = s.index(s.startIndex,\
    \ offsetBy: i)\n        let index2 = s.index(s.startIndex, offsetBy: i + 1)\n\
    \        let index3 = s.index(s.startIndex, offsetBy: i + 2)\n        if s[index1]\
    \ == s[index2] || s[index1] == s[index3] || s[index2] == s[index3] {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        for i in 0...s.count\
    \ - 3 {\n            let start = s.index(s.startIndex, offsetBy: i)\n        \
    \    let end = s.index(s.startIndex, offsetBy: i + 3)\n            let range =\
    \ start..<end\n            let subString = s[range]\n            if Set(subString).count\
    \ == 3 {\n                result = true\n            } else {\n              \
    \  result = false\n                break\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = true\n    if s.count < 3 {\n        happy = false\n\
    \    } else {\n        for i in 0..<s.count-2 {\n            let start = s.index(s.startIndex,\
    \ offsetBy: i)\n            let end = s.index(s.startIndex, offsetBy: i+3)\n \
    \           let range = start..<end\n            let sub = s[range]\n        \
    \    if sub.contains(sub.first!) {\n                happy = false\n          \
    \      break\n            }\n        }\n    }\n    return happy\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp5msk9yqy/tmp5msk9yqy.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b32d40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b32a37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b32a37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b32a367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5msk9yqy                        0x0000558c7da1784b <unavailable> + 6219

    5    libc.so.6                          0x00002b6b32f2c460 __libc_start_main +
    245

    6    tmp5msk9yqy                        0x0000558c7da17399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        let set = Set(sub)\n        if set.count != 3 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        let set = Set(sub)\n        if set.count != 3 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub\
    \ = s[start..<end]\n        let set = Set(sub)\n        if set.count != 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = false\n    if s.count > 2 {\n        let chars =\
    \ Array(s)\n        for i in 0..<chars.count - 2 {\n            if chars[i] !=\
    \ chars[i + 1] && chars[i] != chars[i + 2] && chars[i + 1] != chars[i + 2] {\n\
    \                happy = true\n            } else {\n                happy = false\n\
    \                break\n            }\n        }\n    }\n    return happy\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var last =\
    \ s.first!\n    var last2 = s[s.index(after: s.startIndex)]\n    for c in s.dropFirst(2)\
    \ {\n        if last == last2 && last2 == c {\n            return false\n    \
    \    }\n        last = last2\n        last2 = c\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp30v3u37g/tmp30v3u37g.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b167c558c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b167c24fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b167c24f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b167c24e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp30v3u37g                        0x000055642ea37971 <unavailable> + 6513

    5    libc.so.6                          0x00002b167c744460 __libc_start_main +
    245

    6    tmp30v3u37g                        0x000055642ea37419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     if Set(sub).count != 3 {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count < 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2] ||\
    \ s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let index1 = s.index(s.startIndex, offsetBy: i)\n        let\
    \ index2 = s.index(s.startIndex, offsetBy: i + 1)\n        let index3 = s.index(s.startIndex,\
    \ offsetBy: i + 2)\n        if s[index1] == s[index2] || s[index1] == s[index3]\
    \ || s[index2] == s[index3] {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let subString = s[range]\n        if Set(subString).count != 3 {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = true\n    if s.count < 3 {\n        result = false\n\
    \    } else {\n        for i in 0..<s.count - 2 {\n            let start = s.index(s.startIndex,\
    \ offsetBy: i)\n            let end = s.index(s.startIndex, offsetBy: i + 3)\n\
    \            let range = start..<end\n            let subString = s[range]\n \
    \           if Set(subString).count != 3 {\n                result = false\n \
    \               break\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().allSatisfy { (i, c) in\n\
    \        i == 0 || s[s.index(s.startIndex, offsetBy: i - 1)] != c\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp1l50dlxk/tmp1l50dlxk.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e241bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e23eb4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5e23eb4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5e23eb37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1l50dlxk                        0x0000555ebc50fad8 <unavailable> + 6872

    5    libc.so.6                          0x00002b5e243a9460 __libc_start_main +
    245

    6    tmp1l50dlxk                        0x0000555ebc50f299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        for i in 0..<s.count\
    \ - 2 {\n            let index1 = s.index(s.startIndex, offsetBy: i)\n       \
    \     let index2 = s.index(s.startIndex, offsetBy: i + 1)\n            let index3\
    \ = s.index(s.startIndex, offsetBy: i + 2)\n            let char1 = s[index1]\n\
    \            let char2 = s[index2]\n            let char3 = s[index3]\n      \
    \      if char1 != char2 && char2 != char3 && char1 != char3 {\n             \
    \   result = true\n            } else {\n                result = false\n    \
    \            break\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let index1 = s.index(s.startIndex, offsetBy:\
    \ i)\n        let index2 = s.index(s.startIndex, offsetBy: i + 1)\n        let\
    \ index3 = s.index(s.startIndex, offsetBy: i + 2)\n        let char1 = s[index1]\n\
    \        let char2 = s[index2]\n        let char3 = s[index3]\n        if char1\
    \ == char2 || char1 == char3 || char2 == char3 {\n            return false\n \
    \       }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let sub = s[start..<end]\n   \
    \     let set = Set(sub)\n        if set.count != 3 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let substring = s[range]\n        if Set(substring).count != 3 {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0...s.count\
    \ - 3 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ != 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0...s.count\
    \ - 3 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count < 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let index1 = s.index(s.startIndex, offsetBy:\
    \ i)\n        let index2 = s.index(s.startIndex, offsetBy: i + 1)\n        let\
    \ index3 = s.index(s.startIndex, offsetBy: i + 2)\n        let char1 = s[index1]\n\
    \        let char2 = s[index2]\n        let char3 = s[index3]\n        if char1\
    \ == char2 || char1 == char3 || char2 == char3 {\n            return false\n \
    \       }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0...s.count\
    \ - 3 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = 0\n   \
    \ while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count < 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    return s.count >= 3 && s.enumerated().reduce(true) { (result,\
    \ element) in\n        return result && (element.offset < s.count - 2 ? s[s.index(s.startIndex,\
    \ offsetBy: element.offset + 1)] != s[s.index(s.startIndex, offsetBy: element.offset\
    \ + 2)] : true)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpxjwa8ma6/tmpxjwa8ma6.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff05d09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff05a00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff05a00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff059ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxjwa8ma6                        0x00005642e401ab18 <unavailable> + 6936

    5    libc.so.6                          0x00002aff05ef5460 __libc_start_main +
    245

    6    tmpxjwa8ma6                        0x00005642e401a2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var i = 0\n\
    \    while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count-2 {\n        if s[i] == s[i+1] || s[i] == s[i+2] ||\
    \ s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var happy = true\n\
    \    for i in 0...s.count - 3 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        let set = Set(sub)\n    \
    \    if set.count != 3 {\n            happy = false\n            break\n     \
    \   }\n    }\n    return happy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let range = start..<end\n    \
    \    let subString = s[range]\n        if Set(subString).count != 3 {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\")\
    \ == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0...s.count\
    \ - 3 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = s.startIndex\n\
    \    while i < s.index(s.endIndex, offsetBy: -2) {\n        if s[i] == s[s.index(i,\
    \ offsetBy: 1)] || s[i] == s[s.index(i, offsetBy: 2)] || s[s.index(i, offsetBy:\
    \ 1)] == s[s.index(i, offsetBy: 2)] {\n            return false\n        }\n \
    \       i = s.index(i, offsetBy: 1)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        let set = Set(sub)\n        if set.count != 3 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var i = 0\n   \
    \ while i < s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range\
    \ = start..<end\n        let sub = s[range]\n        if Set(sub).count != 3 {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var happy = true\n    if s.count < 3 {\n        happy = false\n\
    \    } else {\n        for i in 0..<s.count - 2 {\n            let start = s.index(s.startIndex,\
    \ offsetBy: i)\n            let end = s.index(s.startIndex, offsetBy: i + 3)\n\
    \            let sub = s[start..<end]\n            if Set(sub).count != 3 {\n\
    \                happy = false\n                break\n            }\n       \
    \ }\n    }\n    return happy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s:\
    \ \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"\
    abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"\
    adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"\
    iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ == 1 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpoliubig9/tmpoliubig9.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1698420c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1698117b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1698117988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16981167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoliubig9                        0x000056161c60f8e1 <unavailable> + 6369

    5    libc.so.6                          0x00002b169860c460 __libc_start_main +
    245

    6    tmpoliubig9                        0x000056161c60f389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        let set = Set(sub)\n        if set.count != 3 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    let s = Array(s)\n\
    \    for i in 0..<s.count - 2 {\n        if s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    var prev = s.first!\n\
    \    var prev2 = s[s.index(after: s.startIndex)]\n    for c in s.dropFirst(2)\
    \ {\n        if c == prev || c == prev2 {\n            return false\n        }\n\
    \        prev2 = prev\n        prev = c\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let index1 = s.index(s.startIndex, offsetBy: i)\n        let index2\
    \ = s.index(s.startIndex, offsetBy: i+1)\n        let index3 = s.index(s.startIndex,\
    \ offsetBy: i+2)\n        if s[index1] == s[index2] || s[index1] == s[index3]\
    \ || s[index2] == s[index3] {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let substring = s[range]\n        if Set(substring).count != 3 {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\"\
    ) == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\"\
    ) == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
    ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"\
    iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let range = start..<end\n\
    \        let sub = s[range]\n        let set = Set(sub)\n        if set.count\
    \ != 3 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013819
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    var result = false\n    if s.count >= 3 {\n        let sArray\
    \ = Array(s)\n        for i in 0..<sArray.count - 2 {\n            if sArray[i]\
    \ != sArray[i + 1] && sArray[i] != sArray[i + 2] && sArray[i + 1] != sArray[i\
    \ + 2] {\n                result = true\n            } else {\n              \
    \  result = false\n                break\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\"\
    ) == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\"\
    ) == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\"\
    ) == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\"\
    ) == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013820
- exit_code: 1
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    let s = s.lowercased()\n    let s = s.characters.map { String($0)\
    \ }\n    var i = 0\n    while i < s.count - 2 {\n        if s[i] == s[i + 1] ||\
    \ s[i] == s[i + 2] || s[i + 1] == s[i + 2] {\n            return false\n     \
    \   }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\n\
    assert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\n\
    assert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\n\
    assert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") ==\
    \ false)"
  status: SyntaxError
  stderr: "/tmp/tmpaxrloe4t.swift:8:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    let s = s.characters.map { String($0) }\n         \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpaxrloe4t.swift:8:9:\
    \ error: invalid redeclaration of 's'\n    let s = s.characters.map { String($0)\
    \ }\n        ^\n/tmp/tmpaxrloe4t.swift:7:9: note: 's' previously declared here\n\
    \    let s = s.lowercased()\n        ^\n/tmp/tmpaxrloe4t.swift:11:12: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expression into distinct sub-expressions\n        if s[i] == s[i + 1]\
    \ || s[i] == s[i + 2] || s[i + 1] == s[i + 2] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var prev =\
    \ s.first!\n    var prev2 = s[s.index(after: s.startIndex)]\n    for c in s.dropFirst(2)\
    \ {\n        if prev == prev2 && prev2 == c {\n            return false\n    \
    \    }\n        prev = prev2\n        prev2 = c\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmp319ocprq/tmp319ocprq.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b197662cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1976323b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1976323988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19763227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp319ocprq                        0x000055e9bd965971 <unavailable> + 6513

    5    libc.so.6                          0x00002b1976818460 __libc_start_main +
    245

    6    tmp319ocprq                        0x000055e9bd965419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660013821
- exit_code: -4
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var previous\
    \ = s.first!\n    var current = s[s.index(after: s.startIndex)]\n    var next\
    \ = s[s.index(s.startIndex, offsetBy: 2)]\n    for i in 3..<s.count {\n      \
    \  if previous == current && current == next {\n            return false\n   \
    \     }\n        previous = current\n        current = next\n        next = s[s.index(s.startIndex,\
    \ offsetBy: i)]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s:\
    \ \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s:\
    \ \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s:\
    \ \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"
  status: Exception
  stderr: 'tmpva_xhvlj/tmpva_xhvlj.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab277e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab277b95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab277b95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab277b947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpva_xhvlj                        0x0000562ccbd828c1 <unavailable> + 6337

    5    libc.so.6                          0x00002ab27808a460 __libc_start_main +
    245

    6    tmpva_xhvlj                        0x0000562ccbd82369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660013821
- exit_code: 0
  program: "\n/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\nfunc is_happy(s: String)\
    \ -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    var prev =\
    \ s.first!\n    var prevprev = s[s.index(s.startIndex, offsetBy: 1)]\n    for\
    \ i in 2..<s.count {\n        let curr = s[s.index(s.startIndex, offsetBy: i)]\n\
    \        if curr == prev || curr == prevprev {\n            return false\n   \
    \     }\n        prevprev = prev\n        prev = curr\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
    \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s:\
    \ \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s:\
    \ \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s:\
    \ \"iopaxioi\") == false)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013821
