language: swift
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let integer\
    \ = Int(rounded)\n    if number - Double(integer) == 0.5 {\n        return integer\
    \ + 1\n    }\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.6L1lVo/tmp2hrjnnor-1.o:tmp2hrjnnor-1.o:function $s11tmp2hrjnnor15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6L1lVo/tmp2hrjnnor-1.o:tmp2hrjnnor-1.o:function $s11tmp2hrjnnor15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6L1lVo/tmp2hrjnnor-1.o:tmp2hrjnnor-1.o:function $s11tmp2hrjnnor15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6L1lVo/tmp2hrjnnor-1.o:tmp2hrjnnor-1.o:function $s11tmp2hrjnnor15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6L1lVo/tmp2hrjnnor-1.o:tmp2hrjnnor-1.o:function $s11tmp2hrjnnor15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6L1lVo/tmp2hrjnnor-1.o:tmp2hrjnnor-1.o:function $s11tmp2hrjnnor15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6L1lVo/tmp2hrjnnor-1.o:tmp2hrjnnor-1.o:function $s11tmp2hrjnnor15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if rounded\
    \ - floor == ceil - rounded {\n        return Int(number > 0 ? ceil : floor)\n\
    \    }\n    return Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1z79k5ni.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let rounded_up\
    \ = rounded.rounded(.up)\n    let rounded_down = rounded.rounded(.down)\n    if\
    \ number - rounded_down < rounded_up - number {\n        return Int(rounded_down)\n\
    \    } else {\n        return Int(rounded_up)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.pbu3Up/tmpsf7lbc8g-1.o:tmpsf7lbc8g-1.o:function $s11tmpsf7lbc8g15closest_i'
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if number - floored < ceiled\
    \ - number {\n        return Int(floored)\n    } else {\n        return Int(ceiled)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpoiisiq8i.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpoiisiq8i.swift:14:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpoiisiq8i.swift:15:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return ceil\n    } else if number\
    \ - Double(floor) == -0.5 {\n        return floor\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6dgZap/tmplr91sq31-1.o:tmplr91sq31-1.o:function $s11tmplr91sq3115closest_i'
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let diffFloor = abs(doubleValue!\
    \ - floorValue)\n    let diffCeil = abs(doubleValue! - ceilValue)\n    if diffFloor\
    \ < diffCeil {\n        return Int(floorValue)\n    } else {\n        return Int(ceilValue)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpn86oej70.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpn86oej70.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    let diff1 =\
    \ abs(number - rounded)\n    let diff2 = abs(number - floor)\n    let diff3 =\
    \ abs(number - ceil)\n    if diff1 < diff2 && diff1 < diff3 {\n        return\
    \ Int(rounded)\n    } else if diff2 < diff1 && diff2 < diff3 {\n        return\
    \ Int(floor)\n    } else {\n        return Int(ceil)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hlg0Oo/tmp5ywl_983-1.o:tmp5ywl_983-1.o:function $s11tmp5ywl_98315closest_i'
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = 0\n    let number = Double(value)\n    if number != nil {\n  \
    \      let numberInt = Int(number!)\n        let numberDouble = Double(numberInt)\n\
    \        if number! - numberDouble > 0.5 {\n            result = numberInt + 1\n\
    \        } else if number! - numberDouble < 0.5 {\n            result = numberInt\n\
    \        } else {\n            if number! > 0 {\n                result = numberInt\
    \ + 1\n            } else {\n                result = numberInt - 1\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp8ci0u1x2/tmp8ci0u1x2.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aacb1f53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aacb1c4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aacb1c4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aacb1c497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ci0u1x2                        0x000055a0e8edd512 <unavailable> + 5394

    5    libc.so.6                          0x00002aacb213f460 __libc_start_main +
    245

    6    tmp8ci0u1x2                        0x000055a0e8edd049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded + 1)\n    } else if number - rounded\
    \ < -0.5 {\n        return Int(rounded - 1)\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7xcbvvb7.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        if floorValue > 0 {\n            return Int(ceilValue)\n\
    \        } else {\n            return Int(floorValue)\n        }\n    } else if\
    \ floorDiff < ceilDiff {\n        return Int(floorValue)\n    } else {\n     \
    \   return Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdvlswwe6.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpdvlswwe6.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let intValue = Int(value)\n    let decimal\
    \ = value - Double(intValue)\n    if decimal < 0.5 {\n        return intValue\n\
    \    } else {\n        return intValue + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpmrl2ypwt/tmpmrl2ypwt.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b84206c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b83efdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b83efd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b83efc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmrl2ypwt                        0x0000558267f2f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4b843f2460 __libc_start_main +
    245

    6    tmpmrl2ypwt                        0x0000558267f2f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 < diff2 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpg49x9q4c.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpg49x9q4c.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpg49x9q4c.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpg49x9q4c.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpukvnmzal/tmpukvnmzal.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b192e674c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b192e36bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b192e36b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b192e36a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpukvnmzal                        0x000055c9e200c512 <unavailable> + 5394

    5    libc.so.6                          0x00002b192e860460 __libc_start_main +
    245

    6    tmpukvnmzal                        0x000055c9e200c049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    if number - Double(int)\
    \ < 0.5 {\n        return int\n    } else {\n        return int + 1\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp1nnjhgbw/tmp1nnjhgbw.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b975c24dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b975bf44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b975bf44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b975bf437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1nnjhgbw                        0x0000563fb3a07512 <unavailable> + 5394

    5    libc.so.6                          0x00002b975c439460 __libc_start_main +
    245

    6    tmp1nnjhgbw                        0x0000563fb3a07049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        if doubleValue! > 0 {\n            return Int(ceilValue)\n\
    \        } else {\n            return Int(floorValue)\n        }\n    } else if\
    \ floorDiff < ceilDiff {\n        return Int(floorValue)\n    } else {\n     \
    \   return Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3ieb_li2.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp3ieb_li2.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    if\
    \ number - Double(rounded) == 0.5 {\n        return rounded + (rounded > 0 ? 1\
    \ : -1)\n    }\n    return rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.lkvSQp/tmp7q0hrcc5-1.o:tmp7q0hrcc5-1.o:function $s11tmp7q0hrcc515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.lkvSQp/tmp7q0hrcc5-1.o:tmp7q0hrcc5-1.o:function $s11tmp7q0hrcc515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.lkvSQp/tmp7q0hrcc5-1.o:tmp7q0hrcc5-1.o:function $s11tmp7q0hrcc515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.lkvSQp/tmp7q0hrcc5-1.o:tmp7q0hrcc5-1.o:function $s11tmp7q0hrcc515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.lkvSQp/tmp7q0hrcc5-1.o:tmp7q0hrcc5-1.o:function $s11tmp7q0hrcc515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.lkvSQp/tmp7q0hrcc5-1.o:tmp7q0hrcc5-1.o:function $s11tmp7q0hrcc515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.lkvSQp/tmp7q0hrcc5-1.o:tmp7q0hrcc5-1.o:function $s11tmp7q0hrcc515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    return number - Double(floor) < Double(ceil) - number\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpls1sjkhy.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpls1sjkhy.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpls1sjkhy.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpls1sjkhy.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ if doubleValue! - Double(intValue) >= 0.5 {\n        return intValue + 1\n \
    \   } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp7hc6av_f/tmp7hc6av_f.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9729f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9726f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9726f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9726ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7hc6av_f                        0x000055ae26171512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab972be5460 __libc_start_main +
    245

    6    tmp7hc6av_f                        0x000055ae26171049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ abs(number - rounded) == 0.5 {\n        if number > 0 {\n            return\
    \ ceil\n        } else {\n            return floor\n        }\n    } else {\n\
    \        return Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7aui4gv_.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(ceilValue)\n    }\n    return floorDiff <\
    \ ceilDiff ? Int(floorValue) : Int(ceilValue)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdcegq_pw.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpdcegq_pw.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if rounded - Double(floor)\
    \ == 0.5 {\n        return ceil\n    } else if rounded - Double(floor) == -0.5\
    \ {\n        return floor\n    } else {\n        return Int(rounded)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8vndvn8k.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmp8vndvn8k.swift:14:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmp8vndvn8k.swift:14:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmp8vndvn8k.swift:15:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmp8vndvn8k.swift:15:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number < 0 ?\
    \ floor : ceil\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2zzyuidv.swift:13:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzy"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.oW9W3F/tmpr1xq9tbx-1.o:tmpr1xq9tbx-1.o:function $s11tmpr1xq9tbx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.oW9W3F/tmpr1xq9tbx-1.o:tmpr1xq9tbx-1.o:function $s11tmpr1xq9tbx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.oW9W3F/tmpr1xq9tbx-1.o:tmpr1xq9tbx-1.o:function $s11tmpr1xq9tbx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.oW9W3F/tmpr1xq9tbx-1.o:tmpr1xq9tbx-1.o:function $s11tmpr1xq9tbx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.oW9W3F/tmpr1xq9tbx-1.o:tmpr1xq9tbx-1.o:function $s11tmpr1xq9tbx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.oW9W3F/tmpr1xq9tbx-1.o:tmpr1xq9tbx-1.o:function $s11tmpr1xq9tbx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.oW9W3F/tmpr1xq9tbx-1.o:tmpr1xq9tbx-1.o:function $s11tmpr1xq9tbx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if number - floored < ceiled\
    \ - number {\n        return Int(floored)\n    } else {\n        return Int(ceiled)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpoiisiq8i.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpoiisiq8i.swift:14:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpoiisiq8i.swift:15:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff_floor = abs(number - Double(floor))\n    let\
    \ diff_ceil = abs(number - Double(ceil))\n    if diff_floor < diff_ceil {\n  \
    \      return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpglqd3fld.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpglqd3fld.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpglqd3fld.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpglqd3fld.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8ewuuc98.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpfx3ranfe/tmpfx3ranfe.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b904ca96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b904c78db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b904c78d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b904c78c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfx3ranfe                        0x0000556dc8c32512 <unavailable> + 5394

    5    libc.so.6                          0x00002b904cc82460 __libc_start_main +
    245

    6    tmpfx3ranfe                        0x0000556dc8c32049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if number - floored < ceiled\
    \ - number {\n        return Int(floored)\n    } else {\n        return Int(ceiled)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpoiisiq8i.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpoiisiq8i.swift:14:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpoiisiq8i.swift:15:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimal\
    \ = number - Double(intNumber)\n    if decimal >= 0.5 {\n        return intNumber\
    \ + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyg4kfvz_/tmpyg4kfvz_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d53cabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d539a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d539a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d539a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyg4kfvz_                        0x000055558caf9512 <unavailable> + 5394

    5    libc.so.6                          0x00002b8d53e97460 __libc_start_main +
    245

    6    tmpyg4kfvz_                        0x000055558caf9049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let diff = num - Double(int)\n\
    \    if diff < 0.5 {\n        return int\n    } else {\n        return int + 1\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpjd7v15lj/tmpjd7v15lj.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8703becc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87038e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87038e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87038e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjd7v15lj                        0x000056440dec8512 <unavailable> + 5394

    5    libc.so.6                          0x00002b8703dd8460 __libc_start_main +
    245

    6    tmpjd7v15lj                        0x000056440dec8049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpoqa3ew19/tmpoqa3ew19.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c3628c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c331fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c331f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c331e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoqa3ew19                        0x0000558778921512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba5c3814460 __libc_start_main +
    245

    6    tmpoqa3ew19                        0x0000558778921049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpe0ua60ru/tmpe0ua60ru.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba11535bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba115052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba115052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1150517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe0ua60ru                        0x0000559ff9cbd512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba115547460 __libc_start_main +
    245

    6    tmpe0ua60ru                        0x0000559ff9cbd049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let diff\
    \ = number - rounded\n    if diff > 0 {\n        return Int(rounded + 1)\n   \
    \ } else if diff < 0 {\n        return Int(rounded - 1)\n    } else {\n      \
    \  return Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxeksaz80.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpe0ua60ru/tmpe0ua60ru.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba11535bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba115052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba115052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1150517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe0ua60ru                        0x0000559ff9cbd512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba115547460 __libc_start_main +
    245

    6    tmpe0ua60ru                        0x0000559ff9cbd049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if number -\
    \ floor < ceil - number {\n        return Int(floor)\n    } else {\n        return\
    \ Int(ceil)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1q_yrdz8.swift:13:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = number.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link\
    \ command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8ewuuc98.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpfx3ranfe/tmpfx3ranfe.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b904ca96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b904c78db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b904c78d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b904c78c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfx3ranfe                        0x0000556dc8c32512 <unavailable> + 5394

    5    libc.so.6                          0x00002b904cc82460 __libc_start_main +
    245

    6    tmpfx3ranfe                        0x0000556dc8c32049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) == 0.5 {\n        return\
    \ number > 0 ? ceil : floor\n    }\n    return number - Double(floor) > 0.5 ?\
    \ ceil : floor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmprnw68nib.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmprnw68nib.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmprnw68nib.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmprnw68nib.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let intValue = Int(value)\n    let decimal\
    \ = value - Double(intValue)\n    if decimal < 0.5 {\n        return intValue\n\
    \    } else {\n        return intValue + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpmrl2ypwt/tmpmrl2ypwt.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b84206c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b83efdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b83efd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b83efc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmrl2ypwt                        0x0000558267f2f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4b843f2460 __libc_start_main +
    245

    6    tmpmrl2ypwt                        0x0000558267f2f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpfx3ranfe/tmpfx3ranfe.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b904ca96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b904c78db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b904c78d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b904c78c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfx3ranfe                        0x0000556dc8c32512 <unavailable> + 5394

    5    libc.so.6                          0x00002b904cc82460 __libc_start_main +
    245

    6    tmpfx3ranfe                        0x0000556dc8c32049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ rounded - Double(floor) == 0.5 {\n        return floor\n    } else if rounded\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2kphtz0x.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ number - floor < ceil - number {\n        return floor\n    } else {\n     \
    \   return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpzl9ziz.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpmpzl9ziz.swift:16:30:\
    \ error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    if number - floor < ceil - number {\n                        ~~~~ ^ ~~~~~~\n\
    /tmp/tmpmpzl9ziz.swift:16:30: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (Double, Double), (Int, Int)\n    if number - floor\
    \ < ceil - number {\n                             ^\n/tmp/tmpmpzl9ziz.swift:16:15:\
    \ error: binary operator '-' cannot be applied to operands of type 'Double' and\
    \ 'Int'\n    if number - floor < ceil - number {\n       ~~~~~~ ^ ~~~~~\n/tmp/tmpmpzl9ziz.swift:16:15:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    if number - floor < ceil - number {\n    \
    \          ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimal\
    \ = number - Double(intNumber)\n    if decimal >= 0.5 {\n        return intNumber\
    \ + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyg4kfvz_/tmpyg4kfvz_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d53cabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d539a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d539a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d539a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyg4kfvz_                        0x000055558caf9512 <unavailable> + 5394

    5    libc.so.6                          0x00002b8d53e97460 __libc_start_main +
    245

    6    tmpyg4kfvz_                        0x000055558caf9049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    if number - Double(floor) == 0.5\
    \ {\n        return ceil\n    } else if number - Double(floor) == -0.5 {\n   \
    \     return floor\n    } else {\n        return Int(number.rounded(.toNearestOrEven))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.V17AsQ/tmpyhhjnup3-1.o:tmpyhhjnup3-1.o:function $s11tmpyhhjnup315closest_i'
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 == diff2 {\n        return number\
    \ > 0 ? ceil : floor\n    }\n    return diff1 < diff2 ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpr3cla0ed.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpr3cla0ed.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpr3cla0ed.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpr3cla0ed.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpfx3ranfe/tmpfx3ranfe.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b904ca96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b904c78db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b904c78d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b904c78c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfx3ranfe                        0x0000556dc8c32512 <unavailable> + 5394

    5    libc.so.6                          0x00002b904cc82460 __libc_start_main +
    245

    6    tmpfx3ranfe                        0x0000556dc8c32049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp41xvetk_.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let diff1 = abs(number - Double(floor))\n\
    \    let diff2 = abs(number - Double(ceil))\n    if diff1 == diff2 {\n       \
    \ return number > 0 ? ceil : floor\n    }\n    return diff1 < diff2 ? floor :\
    \ ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.to1YfQ/tmpjysnjvrx-1.o:tmpjysnjvrx-1.o:function $s11tmpjysnjvrx15closest_i'
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    if roundedValue > doubleValue {\n        return Int(roundedValue - 1)\n \
    \   }\n    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfxyf4fio.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpe0ua60ru/tmpe0ua60ru.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba11535bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba115052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba115052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1150517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe0ua60ru                        0x0000559ff9cbd512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba115547460 __libc_start_main +
    245

    6    tmpe0ua60ru                        0x0000559ff9cbd049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    if number - Double(int)\
    \ < 0.5 {\n        return int\n    } else {\n        return int + 1\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp1nnjhgbw/tmp1nnjhgbw.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b975c24dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b975bf44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b975bf44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b975bf437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1nnjhgbw                        0x0000563fb3a07512 <unavailable> + 5394

    5    libc.so.6                          0x00002b975c439460 __libc_start_main +
    245

    6    tmp1nnjhgbw                        0x0000563fb3a07049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let doubleIntValue = Double(intValue)\n    if doubleValue! - doubleIntValue\
    \ > 0.5 {\n        return intValue + 1\n    } else {\n        return intValue\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpw5wx7pro/tmpw5wx7pro.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ef621cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ef5f13b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ef5f13988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ef5f127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw5wx7pro                        0x000055ef798f246b <unavailable> + 5227

    5    libc.so.6                          0x00002b2ef6408460 __libc_start_main +
    245

    6    tmpw5wx7pro                        0x000055ef798f2049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let diffFloor = abs(doubleValue!\
    \ - floorValue)\n    let diffCeil = abs(doubleValue! - ceilValue)\n    if diffFloor\
    \ == diffCeil {\n        return Int(doubleValue! > 0 ? ceilValue : floorValue)\n\
    \    }\n    return Int(diffFloor < diffCeil ? floorValue : ceilValue)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmiy7sekj.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpmiy7sekj.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if doubleValue! - floorValue < ceilValue\
    \ - doubleValue! {\n        return Int(floorValue)\n    } else {\n        return\
    \ Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0v4kzh75.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp0v4kzh75.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphxmlpdk7/tmphxmlpdk7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1611cb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16119afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16119af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16119ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphxmlpdk7                        0x000055b00b01a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1611ea4460 __libc_start_main +
    245

    6    tmphxmlpdk7                        0x000055b00b01a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ (number - rounded) == 0 {\n        return Int(rounded)\n    } else if (number\
    \ - rounded) < 0 {\n        return floor\n    } else {\n        return ceil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp559mb5gz.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let diffRounded = abs(number - Double(rounded))\n    let diffCeiled = abs(number\
    \ - Double(ceiled))\n    let diffFloored = abs(number - Double(floored))\n   \
    \ if diffRounded <= diffCeiled && diffRounded <= diffFloored {\n        return\
    \ rounded\n    } else if diffCeiled <= diffRounded && diffCeiled <= diffFloored\
    \ {\n        return ceiled\n    } else {\n        return floored\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wMfZSX/tmpiwi3t3jy-1.o:tmpiwi3t3jy-1.o:function $s11tmpiwi3t3jy15closest_i'
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return number > 0 ? ceil : floor\n\
    \    }\n    return rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nNBm00/tmp15wptt0t-1.o:tmp15wptt0t-1.o:function $s11tmp15wptt0t15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let integer = Int(value)\n    let decimal =\
    \ value - Double(integer)\n    if decimal >= 0.5 {\n        return integer + 1\n\
    \    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp6ck2wghj/tmp6ck2wghj.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057f852c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057f549b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057f549988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057f5487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6ck2wghj                        0x0000561d55605512 <unavailable> + 5394

    5    libc.so.6                          0x00002b057fa3e460 __libc_start_main +
    245

    6    tmp6ck2wghj                        0x0000561d55605049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let doubleValue2 = Double(intValue)\n    let doubleValue3 = doubleValue! - doubleValue2\n\
    \    if doubleValue3 >= 0.5 {\n        return intValue + 1\n    } else {\n   \
    \     return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpugy3vc3y/tmpugy3vc3y.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed2c6eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed2c3e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed2c3e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed2c3e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpugy3vc3y                        0x000055e57175a512 <unavailable> + 5394

    5    libc.so.6                          0x00002aed2c8d6460 __libc_start_main +
    245

    6    tmpugy3vc3y                        0x000055e57175a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff_floor = abs(number - Double(floor))\n    let\
    \ diff_ceil = abs(number - Double(ceil))\n    if diff_floor < diff_ceil {\n  \
    \      return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpglqd3fld.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpglqd3fld.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpglqd3fld.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpglqd3fld.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    let decimal = number - rounded\n    if decimal < 0.5 {\n\
    \        return roundedInt\n    } else {\n        return roundedInt + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxqaaihfn.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(ceilValue)\n    }\n    if floorDiff < ceilDiff\
    \ {\n        return Int(floorValue)\n    }\n    return Int(ceilValue)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpn_w43qia.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpn_w43qia.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpoqa3ew19/tmpoqa3ew19.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c3628c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c331fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c331f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c331e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoqa3ew19                        0x0000558778921512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba5c3814460 __libc_start_main +
    245

    6    tmpoqa3ew19                        0x0000558778921049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    if number - Double(int)\
    \ < 0.5 {\n        return int\n    } else {\n        return int + 1\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp1nnjhgbw/tmp1nnjhgbw.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b975c24dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b975bf44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b975bf44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b975bf437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1nnjhgbw                        0x0000563fb3a07512 <unavailable> + 5394

    5    libc.so.6                          0x00002b975c439460 __libc_start_main +
    245

    6    tmp1nnjhgbw                        0x0000563fb3a07049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if rounded > number\
    \ {\n        return floor\n    } else if rounded < number {\n        return ceil\n\
    \    } else {\n        return Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9nkneq64.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmp9nkneq64.swift:14:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmp9nkneq64.swift:14:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmp9nkneq64.swift:15:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmp9nkneq64.swift:15:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpylymxa2q.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp41xvetk_.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ floor = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if rounded\
    \ == floor {\n        return ceil\n    } else if rounded == ceil {\n        return\
    \ floor\n    } else {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxs72_fy0.swift:13:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmpxs72_fy0.swift:14:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmpxs72_fy0.swift:14:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmpxs72_fy0.swift:15:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmpxs72_fy0.swift:15:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let doubleValue2 = Double(intValue)\n    let doubleValue3 = doubleValue! - doubleValue2\n\
    \    if doubleValue3 >= 0.5 {\n        return intValue + 1\n    } else {\n   \
    \     return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpugy3vc3y/tmpugy3vc3y.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed2c6eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed2c3e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed2c3e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed2c3e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpugy3vc3y                        0x000055e57175a512 <unavailable> + 5394

    5    libc.so.6                          0x00002aed2c8d6460 __libc_start_main +
    245

    6    tmpugy3vc3y                        0x000055e57175a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let ceiled\
    \ = number.rounded(.up)\n    let floored = number.rounded(.down)\n    let diffRounded\
    \ = abs(number - rounded)\n    let diffCeiled = abs(number - ceiled)\n    let\
    \ diffFloored = abs(number - floored)\n    if diffRounded == diffCeiled && diffRounded\
    \ == diffFloored {\n        return Int(rounded)\n    } else if diffRounded < diffCeiled\
    \ && diffRounded < diffFloored {\n        return Int(rounded)\n    } else if diffCeiled\
    \ < diffRounded && diffCeiled < diffFloored {\n        return Int(ceiled)\n  \
    \  } else {\n        return Int(floored)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TJNpN5/tmpb9ozw5y6-1.o:tmpb9ozw5y6-1.o:function $s11tmpb9ozw5y615closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphxmlpdk7/tmphxmlpdk7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1611cb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16119afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16119af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16119ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphxmlpdk7                        0x000055b00b01a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1611ea4460 __libc_start_main +
    245

    6    tmphxmlpdk7                        0x000055b00b01a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ < ceilDiff {\n        return Int(floorValue)\n    } else {\n        return Int(ceilValue)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8ayzj7rj.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp8ayzj7rj.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded + 1)\n    } else if number - rounded\
    \ < -0.5 {\n        return Int(rounded - 1)\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7xcbvvb7.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let intValue = Int(value)\n    let decimal\
    \ = value - Double(intValue)\n    if decimal == 0.5 {\n        return intValue\
    \ + 1\n    } else if decimal == -0.5 {\n        return intValue - 1\n    } else\
    \ {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let intRounded\
    \ = Int(rounded)\n    if rounded - Double(intRounded) >= 0.5 {\n        return\
    \ intRounded + 1\n    } else {\n        return intRounded\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpaxbujppi.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let double = Double(value)!\n    let int = Int(double)\n    let decimal = double\
    \ - Double(int)\n    if decimal >= 0.5 {\n        return int + 1\n    } else {\n\
    \        return int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpliodn8ki/tmpliodn8ki.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b18f4848c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b18f453fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b18f453f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b18f453e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpliodn8ki                        0x000055997313e512 <unavailable> + 5394

    5    libc.so.6                          0x00002b18f4a34460 __libc_start_main +
    245

    6    tmpliodn8ki                        0x000055997313e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 < diff2 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpg49x9q4c.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpg49x9q4c.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpg49x9q4c.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpg49x9q4c.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = doubleValue!.rounded()\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.1NBkca/tmpj82xjd9m-1.o:tmpj82xjd9m-1.o:function $s11tmpj82xjd9m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.1NBkca/tmpj82xjd9m-1.o:tmpj82xjd9m-1.o:function $s11tmpj82xjd9m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.1NBkca/tmpj82xjd9m-1.o:tmpj82xjd9m-1.o:function $s11tmpj82xjd9m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.1NBkca/tmpj82xjd9m-1.o:tmpj82xjd9m-1.o:function $s11tmpj82xjd9m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.1NBkca/tmpj82xjd9m-1.o:tmpj82xjd9m-1.o:function $s11tmpj82xjd9m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.1NBkca/tmpj82xjd9m-1.o:tmpj82xjd9m-1.o:function $s11tmpj82xjd9m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.1NBkca/tmpj82xjd9m-1.o:tmpj82xjd9m-1.o:function $s11tmpj82xjd9m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(number - Double(floor))\n\
    \    let ceilDiff = abs(number - Double(ceil))\n    return floorDiff > ceilDiff\
    \ ? ceil : floor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.v4dj99/tmpdc9c9s2o-1.o:tmpdc9c9s2o-1.o:function $s11tmpdc9c9s2o15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(floor(num))\n    let ceil = Int(ceil(num))\n\
    \    if num - Double(floor) < Double(ceil) - num {\n        return floor\n   \
    \ }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxrhnsdzp.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(num))\n                    ^\n/tmp/tmpxrhnsdzp.swift:13:9:\
    \ note: 'floor' declared here\n    let floor = Int(floor(num))\n        ^\n/tmp/tmpxrhnsdzp.swift:14:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(num))\n\
    \                   ^\n/tmp/tmpxrhnsdzp.swift:14:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(num))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let int\
    \ = Int(rounded)\n    if number - Double(int) == 0.5 {\n        return int + 1\n\
    \    }\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.OIJwQb/tmpnx8zsuvq-1.o:tmpnx8zsuvq-1.o:function $s11tmpnx8zsuvq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OIJwQb/tmpnx8zsuvq-1.o:tmpnx8zsuvq-1.o:function $s11tmpnx8zsuvq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OIJwQb/tmpnx8zsuvq-1.o:tmpnx8zsuvq-1.o:function $s11tmpnx8zsuvq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OIJwQb/tmpnx8zsuvq-1.o:tmpnx8zsuvq-1.o:function $s11tmpnx8zsuvq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OIJwQb/tmpnx8zsuvq-1.o:tmpnx8zsuvq-1.o:function $s11tmpnx8zsuvq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OIJwQb/tmpnx8zsuvq-1.o:tmpnx8zsuvq-1.o:function $s11tmpnx8zsuvq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OIJwQb/tmpnx8zsuvq-1.o:tmpnx8zsuvq-1.o:function $s11tmpnx8zsuvq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdj9lhbdy/tmpdj9lhbdy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6041de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6041adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6041adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6041ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdj9lhbdy                        0x00005617437c1512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6041fd0460 __libc_start_main +
    245

    6    tmpdj9lhbdy                        0x00005617437c1049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdj9lhbdy/tmpdj9lhbdy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6041de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6041adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6041adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6041ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdj9lhbdy                        0x00005617437c1512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6041fd0460 __libc_start_main +
    245

    6    tmpdj9lhbdy                        0x00005617437c1049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floor = Int(floor(doubleValue!))\n\
    \    let ceil = Int(ceil(doubleValue!))\n    let floorDiff = abs(doubleValue!\
    \ - Double(floor))\n    let ceilDiff = abs(doubleValue! - Double(ceil))\n    if\
    \ floorDiff < ceilDiff {\n        return floor\n    } else {\n        return ceil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_d3x6n8y.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(doubleValue!))\n                \
    \    ^\n/tmp/tmp_d3x6n8y.swift:13:9: note: 'floor' declared here\n    let floor\
    \ = Int(floor(doubleValue!))\n        ^\n/tmp/tmp_d3x6n8y.swift:14:20: error:\
    \ use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(doubleValue!))\n\
    \                   ^\n/tmp/tmp_d3x6n8y.swift:14:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(doubleValue!))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) == 0.5 {\n        return\
    \ number > 0 ? ceil : floor\n    }\n    return number - Double(floor) > 0.5 ?\
    \ ceil : floor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmprnw68nib.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmprnw68nib.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmprnw68nib.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmprnw68nib.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diffFloor = abs(number - Double(floor))\n    let\
    \ diffCeil = abs(number - Double(ceil))\n    if diffFloor < diffCeil {\n     \
    \   return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmponk_2lgf.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmponk_2lgf.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmponk_2lgf.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmponk_2lgf.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if doubleValue! - floorValue < ceilValue\
    \ - doubleValue! {\n        return Int(floorValue)\n    } else {\n        return\
    \ Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0v4kzh75.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp0v4kzh75.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpi2wjgg6q.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpukvnmzal/tmpukvnmzal.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b192e674c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b192e36bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b192e36b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b192e36a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpukvnmzal                        0x000055c9e200c512 <unavailable> + 5394

    5    libc.so.6                          0x00002b192e860460 __libc_start_main +
    245

    6    tmpukvnmzal                        0x000055c9e200c049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(ceilValue)\n    }\n    return Int(floorDiff\
    \ < ceilDiff ? floorValue : ceilValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpl0n47rzt.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpl0n47rzt.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(floor(num))\n    let ceil = Int(ceil(num))\n\
    \    if num - Double(floor) < Double(ceil) - num {\n        return floor\n   \
    \ }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxrhnsdzp.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(num))\n                    ^\n/tmp/tmpxrhnsdzp.swift:13:9:\
    \ note: 'floor' declared here\n    let floor = Int(floor(num))\n        ^\n/tmp/tmpxrhnsdzp.swift:14:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(num))\n\
    \                   ^\n/tmp/tmpxrhnsdzp.swift:14:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(num))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdj9lhbdy/tmpdj9lhbdy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6041de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6041adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6041adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6041ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdj9lhbdy                        0x00005617437c1512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6041fd0460 __libc_start_main +
    245

    6    tmpdj9lhbdy                        0x00005617437c1049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff_floor = abs(number - Double(floor))\n    let diff_ceil = abs(number\
    \ - Double(ceil))\n    if diff_floor > diff_ceil {\n        return ceil\n    }\
    \ else if diff_floor < diff_ceil {\n        return floor\n    } else {\n     \
    \   return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.vugpnm/tmp8dc92w0i-1.o:tmp8dc92w0i-1.o:function $s11tmp8dc92w0i15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(doubleValue! > 0 ? ceilValue : floorValue)\n\
    \    }\n    return Int(floorDiff < ceilDiff ? floorValue : ceilValue)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpivef4ued.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpivef4ued.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    let decimal = number\
    \ - Double(int)\n    if decimal > 0.5 {\n        return int + 1\n    } else if\
    \ decimal < -0.5 {\n        return int - 1\n    } else {\n        return int\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp0s7_o2ns/tmp0s7_o2ns.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f01b13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f0180ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f0180a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f018097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0s7_o2ns                        0x0000561f2166046b <unavailable> + 5227

    5    libc.so.6                          0x00002b1f01cff460 __libc_start_main +
    245

    6    tmp0s7_o2ns                        0x0000561f21660049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number < 0 ?\
    \ floor : ceil\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2zzyuidv.swift:13:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzyuidv-1.o:tmp2zzyuidv-1.o:function\
    \ $s11tmp2zzyuidv15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.krZu7F/tmp2zzy"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6b9e60b5/tmp6b9e60b5.swift:12: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b384ca55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b384c74c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b384c74c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b384c74c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b384c74bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp6b9e60b5                        0x000055ece94ad75a <unavailable> + 5978

    6    tmp6b9e60b5                        0x000055ece94ad3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b384cc41460 __libc_start_main +
    245

    8    tmp6b9e60b5                        0x000055ece94ad039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphxmlpdk7/tmphxmlpdk7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1611cb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16119afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16119af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16119ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphxmlpdk7                        0x000055b00b01a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1611ea4460 __libc_start_main +
    245

    6    tmphxmlpdk7                        0x000055b00b01a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 < diff2 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpg49x9q4c.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpg49x9q4c.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpg49x9q4c.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpg49x9q4c.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if doubleValue! - floorValue < ceilValue\
    \ - doubleValue! {\n        return Int(floorValue)\n    } else {\n        return\
    \ Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0v4kzh75.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp0v4kzh75.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff_floor = abs(number - Double(floor))\n    let\
    \ diff_ceil = abs(number - Double(ceil))\n    if diff_floor < diff_ceil {\n  \
    \      return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpglqd3fld.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpglqd3fld.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpglqd3fld.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpglqd3fld.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let doubleValue2 = Double(intValue)\n    if doubleValue2 == doubleValue {\n\
    \        return intValue\n    } else if doubleValue2 > doubleValue {\n       \
    \ return intValue - 1\n    } else {\n        return intValue + 1\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_csuum6z.swift:17:30: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    } else if doubleValue2 > doubleValue\
    \ {\n                             ^\n/tmp/tmp_csuum6z.swift:17:30: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ } else if doubleValue2 > doubleValue {\n                             ^\n   \
    \                                      ?? <#default value#>\n/tmp/tmp_csuum6z.swift:17:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    } else if doubleValue2 > doubleValue {\n                        \
    \     ^\n                                        !\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdj9lhbdy/tmpdj9lhbdy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6041de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6041adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6041adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6041ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdj9lhbdy                        0x00005617437c1512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6041fd0460 __libc_start_main +
    245

    6    tmpdj9lhbdy                        0x00005617437c1049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ rounded - Double(floor) == 0.5 {\n        return ceil\n    } else if rounded\
    \ - Double(floor) == -0.5 {\n        return floor\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpbq57yqyc.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floor = Int(floor(doubleValue!))\n\
    \    let ceil = Int(ceil(doubleValue!))\n    let floorDiff = abs(doubleValue!\
    \ - Double(floor))\n    let ceilDiff = abs(doubleValue! - Double(ceil))\n    if\
    \ floorDiff == ceilDiff {\n        return doubleValue! > 0 ? ceil : floor\n  \
    \  }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwa6oe873.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(doubleValue!))\n                \
    \    ^\n/tmp/tmpwa6oe873.swift:13:9: note: 'floor' declared here\n    let floor\
    \ = Int(floor(doubleValue!))\n        ^\n/tmp/tmpwa6oe873.swift:14:20: error:\
    \ use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(doubleValue!))\n\
    \                   ^\n/tmp/tmpwa6oe873.swift:14:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(doubleValue!))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    if number - Double(floor) == 0.5\
    \ {\n        return number > 0 ? ceil : floor\n    }\n    return number - Double(floor)\
    \ < 0.5 ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TdUhWk/tmp9sx8wk_1-1.o:tmp9sx8wk_1-1.o:function $s11tmp9sx8wk_115closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    let decimal = number\
    \ - Double(int)\n    if decimal >= 0.5 {\n        return int + 1\n    } else {\n\
    \        return int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpz7nhn_w7/tmpz7nhn_w7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89a9c47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89a993eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89a993e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89a993d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz7nhn_w7                        0x0000559e54d21512 <unavailable> + 5394

    5    libc.so.6                          0x00002b89a9e33460 __libc_start_main +
    245

    6    tmpz7nhn_w7                        0x0000559e54d21049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let roundedInt\
    \ = Int(rounded)\n    if rounded - Double(roundedInt) == 0.5 {\n        return\
    \ roundedInt + 1\n    }\n    return roundedInt\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.lfakFm/tmpmi_zb865-1.o:tmpmi_zb865-1.o:function $s11tmpmi_zb86515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.lfakFm/tmpmi_zb865-1.o:tmpmi_zb865-1.o:function $s11tmpmi_zb86515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.lfakFm/tmpmi_zb865-1.o:tmpmi_zb865-1.o:function $s11tmpmi_zb86515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.lfakFm/tmpmi_zb865-1.o:tmpmi_zb865-1.o:function $s11tmpmi_zb86515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.lfakFm/tmpmi_zb865-1.o:tmpmi_zb865-1.o:function $s11tmpmi_zb86515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.lfakFm/tmpmi_zb865-1.o:tmpmi_zb865-1.o:function $s11tmpmi_zb86515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.lfakFm/tmpmi_zb865-1.o:tmpmi_zb865-1.o:function $s11tmpmi_zb86515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if (doubleValue! - floorValue) <\
    \ (ceilValue - doubleValue!) {\n        return Int(floorValue)\n    } else {\n\
    \        return Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3ehm8d2r.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp3ehm8d2r.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return ceil\n    }\n\
    \    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmprztp9h2w.swift:13:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp9h2w-1.o:tmprztp9h2w-1.o:function\
    \ $s11tmprztp9h2w15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.csT8Ul/tmprztp"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal < 0.5 {\n    \
    \    return intValue\n    } else {\n        return intValue + 1\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmps8wa2be7/tmps8wa2be7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f7fc3bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f7f932b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f7f932988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f7f9317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps8wa2be7                        0x0000556e72e31512 <unavailable> + 5394

    5    libc.so.6                          0x00002b7f7fe27460 __libc_start_main +
    245

    6    tmps8wa2be7                        0x0000556e72e31049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let diff = num - Double(int)\n\
    \    if diff == 0.5 {\n        return int + 1\n    } else if diff == -0.5 {\n\
    \        return int - 1\n    } else {\n        return int\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphxmlpdk7/tmphxmlpdk7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1611cb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16119afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16119af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16119ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphxmlpdk7                        0x000055b00b01a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1611ea4460 __libc_start_main +
    245

    6    tmphxmlpdk7                        0x000055b00b01a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(floor(num))\n    let ceil = Int(ceil(num))\n\
    \    let diff = num - Double(floor)\n    if diff < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptvrjouv0.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(num))\n                    ^\n/tmp/tmptvrjouv0.swift:13:9:\
    \ note: 'floor' declared here\n    let floor = Int(floor(num))\n        ^\n/tmp/tmptvrjouv0.swift:14:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(num))\n\
    \                   ^\n/tmp/tmptvrjouv0.swift:14:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(num))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let ceilValue = ceil(doubleValue!)\n \
    \   let floorValue = floor(doubleValue!)\n    let ceilDiff = ceilValue - doubleValue!\n\
    \    let floorDiff = doubleValue! - floorValue\n    if ceilDiff == floorDiff {\n\
    \        if ceilValue > 0 {\n            return Int(ceilValue)\n        } else\
    \ {\n            return Int(floorValue)\n        }\n    } else if ceilDiff < floorDiff\
    \ {\n        return Int(ceilValue)\n    } else {\n        return Int(floorValue)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3j1sclua.swift:13:21: error: cannot find 'ceil' in scope\n    let\
    \ ceilValue = ceil(doubleValue!)\n                    ^~~~\n/tmp/tmp3j1sclua.swift:14:22:\
    \ error: cannot find 'floor' in scope\n    let floorValue = floor(doubleValue!)\n\
    \                     ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(floor - number)\n    let ceilingDiff = abs(ceiling -\
    \ number)\n    if floorDiff == ceilingDiff {\n        return rounded < 0 ? floor\
    \ : ceiling\n    }\n    return floorDiff < ceilingDiff ? floor : ceiling\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpey1rqoo4.swift:16:31: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    let floorDiff = abs(floor - number)\n\
    \                        ~~~~~ ^ ~~~~~~\n/tmp/tmpey1rqoo4.swift:16:31: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double),\
    \ (Int, Int)\n    let floorDiff = abs(floor - number)\n                      \
    \        ^\n/tmp/tmpey1rqoo4.swift:17:35: error: binary operator '-' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    let ceilingDiff = abs(ceiling\
    \ - number)\n                          ~~~~~~~ ^ ~~~~~~\n/tmp/tmpey1rqoo4.swift:17:35:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    let ceilingDiff = abs(ceiling - number)\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ < ceilDiff {\n        return Int(floorValue)\n    } else {\n        return Int(ceilValue)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8ayzj7rj.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp8ayzj7rj.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = floor(number)\n    let ceil = ceil(number)\n    if number - floor < ceil -\
    \ number {\n        return Int(floor)\n    } else {\n        return Int(ceil)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1le7nfri.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmp1le7nfri.swift:14:17:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ floor(number)\n                ^\n/tmp/tmp1le7nfri.swift:14:9: note: 'floor'\
    \ declared here\n    let floor = floor(number)\n        ^\n/tmp/tmp1le7nfri.swift:15:16:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = ceil(number)\n\
    \               ^\n/tmp/tmp1le7nfri.swift:15:9: note: 'ceil' declared here\n \
    \   let ceil = ceil(number)\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpoqa3ew19/tmpoqa3ew19.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c3628c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c331fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c331f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c331e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoqa3ew19                        0x0000558778921512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba5c3814460 __libc_start_main +
    245

    6    tmpoqa3ew19                        0x0000558778921049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let floorDiff = abs(number - Double(floor))\n    let\
    \ ceilDiff = abs(number - Double(ceil))\n    if floorDiff == ceilDiff {\n    \
    \    return number < 0 ? floor : ceil\n    }\n    return floorDiff < ceilDiff\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpw51j7pho.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpw51j7pho.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpw51j7pho.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpw51j7pho.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return rounded\n\
    \    } else if floorDiff < ceilingDiff {\n        return floor\n    } else {\n\
    \        return ceiling\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.N4GPgr/tmpj1fg3fwj-1.o:tmpj1fg3fwj-1.o:function $s11tmpj1fg3fwj15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let roundedInt\
    \ = Int(rounded)\n    let diff = number - rounded\n    if diff == 0 {\n      \
    \  return roundedInt\n    } else if diff > 0 {\n        return roundedInt + 1\n\
    \    } else {\n        return roundedInt - 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.UuMMer/tmph510irxv-1.o:tmph510irxv-1.o:function $s11tmph510irxv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.UuMMer/tmph510irxv-1.o:tmph510irxv-1.o:function $s11tmph510irxv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.UuMMer/tmph510irxv-1.o:tmph510irxv-1.o:function $s11tmph510irxv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.UuMMer/tmph510irxv-1.o:tmph510irxv-1.o:function $s11tmph510irxv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.UuMMer/tmph510irxv-1.o:tmph510irxv-1.o:function $s11tmph510irxv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.UuMMer/tmph510irxv-1.o:tmph510irxv-1.o:function $s11tmph510irxv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.UuMMer/tmph510irxv-1.o:tmph510irxv-1.o:function $s11tmph510irxv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(ceilValue)\n    }\n    return floorDiff <\
    \ ceilDiff ? Int(floorValue) : Int(ceilValue)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdcegq_pw.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpdcegq_pw.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if number -\
    \ floor < ceil - number {\n        return Int(floor)\n    } else {\n        return\
    \ Int(ceil)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1q_yrdz8.swift:13:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = number.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link\
    \ command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-1.o:tmp1q_yrdz8-1.o:function\
    \ $s11tmp1q_yrdz815closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.U02blF/tmp1q_yrdz8-"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphxmlpdk7/tmphxmlpdk7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1611cb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16119afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16119af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16119ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphxmlpdk7                        0x000055b00b01a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1611ea4460 __libc_start_main +
    245

    6    tmphxmlpdk7                        0x000055b00b01a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n \
    \   if number - Double(floor) < 0.5 {\n        return floor\n    } else if Double(ceiling)\
    \ - number < 0.5 {\n        return ceiling\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3drxdem4.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let rounded_int\
    \ = Int(rounded)\n    let rounded_double = Double(rounded_int)\n    if number\
    \ > rounded_double {\n        return rounded_int + 1\n    } else if number < rounded_double\
    \ {\n        return rounded_int - 1\n    } else {\n        return rounded_int\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.HmvzKw/tmp5kylnb9q-1.o:tmp5kylnb9q-1.o:function $s11tmp5kylnb9q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.HmvzKw/tmp5kylnb9q-1.o:tmp5kylnb9q-1.o:function $s11tmp5kylnb9q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.HmvzKw/tmp5kylnb9q-1.o:tmp5kylnb9q-1.o:function $s11tmp5kylnb9q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.HmvzKw/tmp5kylnb9q-1.o:tmp5kylnb9q-1.o:function $s11tmp5kylnb9q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.HmvzKw/tmp5kylnb9q-1.o:tmp5kylnb9q-1.o:function $s11tmp5kylnb9q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HmvzKw/tmp5kylnb9q-1.o:tmp5kylnb9q-1.o:function $s11tmp5kylnb9q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HmvzKw/tmp5kylnb9q-1.o:tmp5kylnb9q-1.o:function $s11tmp5kylnb9q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if abs(number - Double(rounded)) == 0.5 {\n        if number > 0 {\n    \
    \        return ceil\n        } else {\n            return floor\n        }\n\
    \    }\n    return rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jWC07v/tmpr5bb274w-1.o:tmpr5bb274w-1.o:function $s11tmpr5bb274w15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ > ceilDiff {\n        return Int(ceilValue)\n    } else {\n        return Int(floorValue)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmbc_9uhk.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpmbc_9uhk.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal < 0.5 {\n        return int\n    } else {\n        return int\
    \ + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp8tzqp4_u/tmp8tzqp4_u.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf7bf55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf7bc4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf7bc4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf7bc4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8tzqp4_u                        0x000055d548d5a512 <unavailable> + 5394

    5    libc.so.6                          0x00002abf7c141460 __libc_start_main +
    245

    6    tmp8tzqp4_u                        0x000055d548d5a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(ceilValue)\n    }\n    return floorDiff <\
    \ ceilDiff ? Int(floorValue) : Int(ceilValue)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdcegq_pw.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpdcegq_pw.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if doubleValue! - floorValue == ceilValue\
    \ - doubleValue! {\n        return Int(floorValue)\n    }\n    return Int(doubleValue!\
    \ - floorValue > ceilValue - doubleValue! ? ceilValue : floorValue)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxfcrjl1l.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpxfcrjl1l.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let diff\
    \ = abs(number - rounded)\n    if diff == 0.5 {\n        if number > 0 {\n   \
    \         return Int(rounded + 1)\n        } else {\n            return Int(rounded\
    \ - 1)\n        }\n    }\n    return Int(rounded)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz64y0tmw.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let rounded_diff = abs(rounded - number)\n    let ceiled_diff = abs(ceiled\
    \ - number)\n    let floored_diff = abs(floored - number)\n    if rounded_diff\
    \ == ceiled_diff {\n        return ceiled\n    } else if rounded_diff == floored_diff\
    \ {\n        return floored\n    } else if rounded_diff < ceiled_diff && rounded_diff\
    \ < floored_diff {\n        return rounded\n    } else if ceiled_diff < rounded_diff\
    \ && ceiled_diff < floored_diff {\n        return ceiled\n    } else {\n     \
    \   return floored\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfckftlcl.swift:16:36: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    let rounded_diff = abs(rounded -\
    \ number)\n                           ~~~~~~~ ^ ~~~~~~\n/tmp/tmpfckftlcl.swift:16:36:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    let rounded_diff = abs(rounded - number)\n\
    \                                   ^\n/tmp/tmpfckftlcl.swift:17:34: error: binary\
    \ operator '-' cannot be applied to operands of type 'Int' and 'Double'\n    let\
    \ ceiled_diff = abs(ceiled - number)\n                          ~~~~~~ ^ ~~~~~~\n\
    /tmp/tmpfckftlcl.swift:17:34: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (Double, Double), (Int, Int)\n    let ceiled_diff\
    \ = abs(ceiled - number)\n                                 ^\n/tmp/tmpfckftlcl.swift:18:36:\
    \ error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    let floored_diff = abs(floored - number)\n                           ~~~~~~~\
    \ ^ ~~~~~~\n/tmp/tmpfckftlcl.swift:18:36: note: overloads for '-' exist with these\
    \ partially matching parameter lists: (Double, Double), (Int, Int)\n    let floored_diff\
    \ = abs(floored - number)\n                                   ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded) + 1\n    } else if number - rounded\
    \ < -0.5 {\n        return Int(rounded) - 1\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.n1aGDG/tmpw52q4ch3-1.o:tmpw52q4ch3-1.o:function $s11tmpw52q4ch315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.n1aGDG/tmpw52q4ch3-1.o:tmpw52q4ch3-1.o:function $s11tmpw52q4ch315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.n1aGDG/tmpw52q4ch3-1.o:tmpw52q4ch3-1.o:function $s11tmpw52q4ch315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.n1aGDG/tmpw52q4ch3-1.o:tmpw52q4ch3-1.o:function $s11tmpw52q4ch315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.n1aGDG/tmpw52q4ch3-1.o:tmpw52q4ch3-1.o:function $s11tmpw52q4ch315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n1aGDG/tmpw52q4ch3-1.o:tmpw52q4ch3-1.o:function $s11tmpw52q4ch315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n1aGDG/tmpw52q4ch3-1.o:tmpw52q4ch3-1.o:function $s11tmpw52q4ch315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ floor = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if abs(number\
    \ - Double(rounded)) < abs(number - Double(floor)) {\n        return rounded\n\
    \    } else if abs(number - Double(rounded)) < abs(number - Double(ceil)) {\n\
    \        return rounded\n    } else if abs(number - Double(floor)) < abs(number\
    \ - Double(ceil)) {\n        return floor\n    } else {\n        return ceil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpya8tw7qk.swift:13:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmpya8tw7qk.swift:14:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmpya8tw7qk.swift:14:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmpya8tw7qk.swift:15:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmpya8tw7qk.swift:15:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(doubleValue! > 0 ? ceilValue : floorValue)\n\
    \    }\n    return Int(floorDiff < ceilDiff ? floorValue : ceilValue)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpivef4ued.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpivef4ued.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if (doubleValue! - floorValue) <\
    \ (ceilValue - doubleValue!) {\n        return Int(floorValue)\n    } else {\n\
    \        return Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3ehm8d2r.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp3ehm8d2r.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    if number > 0 {\n        return Int(number.rounded(.up))\n\
    \    } else {\n        return Int(number.rounded(.down))\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.dGxcZI/tmp02oo3piy-1.o:tmp02oo3piy-1.o:function $s11tmp02oo3piy15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    if number - Double(floor) < Double(ceil)\
    \ - number {\n        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.xe7r4H/tmp6cyu2ev0-1.o:tmp6cyu2ev0-1.o:function $s11tmp6cyu2ev015closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    let floorDiff = abs(doubleValue!\
    \ - floorValue)\n    let ceilDiff = abs(doubleValue! - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(ceilValue)\n    }\n    return Int(floorDiff\
    \ < ceilDiff ? floorValue : ceilValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpl0n47rzt.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmpl0n47rzt.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff = number - Double(floor)\n    if diff == 0.5\
    \ {\n        return floor < 0 ? floor - 1 : ceil\n    }\n    return diff < 0.5\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphlgoo7pt.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmphlgoo7pt.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmphlgoo7pt.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmphlgoo7pt.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if rounded - number ==\
    \ 0.5 {\n        return Int(ceiled)\n    } else if number - rounded == 0.5 {\n\
    \        return Int(floored)\n    } else {\n        return Int(rounded)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptxot_vu7.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmptxot_vu7.swift:14:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmptxot_vu7.swift:15:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if rounded - Double(floor)\
    \ == 0.5 {\n        return floor\n    } else if rounded - Double(ceil) == 0.5\
    \ {\n        return ceil\n    } else {\n        return Int(rounded)\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2j_vjohp.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmp2j_vjohp.swift:14:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmp2j_vjohp.swift:14:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmp2j_vjohp.swift:15:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmp2j_vjohp.swift:15:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if (doubleValue! - floorValue) <\
    \ (ceilValue - doubleValue!) {\n        return Int(floorValue)\n    } else {\n\
    \        return Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3ehm8d2r.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp3ehm8d2r.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let ceiled\
    \ = number.rounded(.up)\n    let floored = number.rounded(.down)\n    let diffRounded\
    \ = abs(number - rounded)\n    let diffCeiled = abs(number - ceiled)\n    let\
    \ diffFloored = abs(number - floored)\n    if diffRounded < diffCeiled && diffRounded\
    \ < diffFloored {\n        return Int(rounded)\n    } else if diffCeiled < diffFloored\
    \ {\n        return Int(ceiled)\n    } else {\n        return Int(floored)\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.c8HMgI/tmph5ar10hk-1.o:tmph5ar10hk-1.o:function $s11tmph5ar10hk15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(floor(num))\n    let ceil = Int(ceil(num))\n\
    \    if num - Double(floor) < Double(ceil) - num {\n        return floor\n   \
    \ }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxrhnsdzp.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(num))\n                    ^\n/tmp/tmpxrhnsdzp.swift:13:9:\
    \ note: 'floor' declared here\n    let floor = Int(floor(num))\n        ^\n/tmp/tmpxrhnsdzp.swift:14:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(num))\n\
    \                   ^\n/tmp/tmpxrhnsdzp.swift:14:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(num))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if number - floored > ceiled\
    \ - number {\n        return Int(ceiled)\n    } else if number - floored < ceiled\
    \ - number {\n        return Int(floored)\n    } else {\n        return Int(number\
    \ < 0 ? floored : ceiled)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxjs27_i2.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpxjs27_i2.swift:14:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpxjs27_i2.swift:15:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphxmlpdk7/tmphxmlpdk7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1611cb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16119afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16119af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16119ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphxmlpdk7                        0x000055b00b01a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1611ea4460 __libc_start_main +
    245

    6    tmphxmlpdk7                        0x000055b00b01a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp41xvetk_.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ abs(number - rounded) == 0.5 {\n        if number > 0 {\n            return\
    \ ceil\n        } else {\n            return floor\n        }\n    } else {\n\
    \        return Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7aui4gv_.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if (doubleValue! - floorValue) <\
    \ (ceilValue - doubleValue!) {\n        return Int(floorValue)\n    } else {\n\
    \        return Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3ehm8d2r.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp3ehm8d2r.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let ceiled\
    \ = number.rounded(.up)\n    let floored = number.rounded(.down)\n    let diffRounded\
    \ = abs(number - rounded)\n    let diffCeiled = abs(number - ceiled)\n    let\
    \ diffFloored = abs(number - floored)\n    if diffRounded <= diffCeiled && diffRounded\
    \ <= diffFloored {\n        return Int(rounded)\n    } else if diffCeiled <= diffRounded\
    \ && diffCeiled <= diffFloored {\n        return Int(ceiled)\n    } else {\n \
    \       return Int(floored)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.cCEuoN/tmpiiywt5_s-1.o:tmpiiywt5_s-1.o:function $s11tmpiiywt5_s15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphxmlpdk7/tmphxmlpdk7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1611cb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16119afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16119af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16119ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphxmlpdk7                        0x000055b00b01a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1611ea4460 __libc_start_main +
    245

    6    tmphxmlpdk7                        0x000055b00b01a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdj9lhbdy/tmpdj9lhbdy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6041de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6041adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6041adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6041ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdj9lhbdy                        0x00005617437c1512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6041fd0460 __libc_start_main +
    245

    6    tmpdj9lhbdy                        0x00005617437c1049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(number - Double(floor))\n\
    \    let ceilDiff = abs(number - Double(ceil))\n    return floorDiff < ceilDiff\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZpjXsN/tmpymmr9buw-1.o:tmpymmr9buw-1.o:function $s11tmpymmr9buw15closest_i'
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    if (number - Double(floor)) > (Double(ceiling) - number) {\n        return\
    \ ceiling\n    } else {\n        return floor\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp04du6xv9.swift:13:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.neT4oN/tmp04du6xv9-1.o:tmp04du6xv9-1.o:function\
    \ $s11tmp04du6xv915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.neT4oN/tmp04du"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp08_ze1ja.swift:13:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnc94mkrp/tmpnc94mkrp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa091d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa08ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa08ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa08ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc94mkrp                        0x0000564e7baee512 <unavailable> + 5394

    5    libc.so.6                          0x00002baa093c5460 __libc_start_main +
    245

    6    tmpnc94mkrp                        0x0000564e7baee049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmlrv6ue.swift:13:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpxmlrv6ue.swift:13:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpxmlrv6ue.swift:14:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpxmlrv6ue.swift:14:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014177
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WVYViN/tmpam85iqki-1.o:tmpam85iqki-1.o:function $s11tmpam85iqki15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = floor(number)\n    let ceil = ceil(number)\n    if rounded - floor == 0.5\
    \ {\n        return Int(ceil)\n    } else if rounded - ceil == 0.5 {\n       \
    \ return Int(floor)\n    } else {\n        return Int(rounded)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfesn11pl.swift:13:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpfesn11pl.swift:14:17:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ floor(number)\n                ^\n/tmp/tmpfesn11pl.swift:14:9: note: 'floor'\
    \ declared here\n    let floor = floor(number)\n        ^\n/tmp/tmpfesn11pl.swift:15:16:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = ceil(number)\n\
    \               ^\n/tmp/tmpfesn11pl.swift:15:9: note: 'ceil' declared here\n \
    \   let ceil = ceil(number)\n        ^\n/tmp/tmpfesn11pl.swift:16:27: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Duration'\n    if\
    \ rounded - floor == 0.5 {\n                          ^\n/tmp/tmpfesn11pl.swift:18:33:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Duration'\n\
    \    } else if rounded - ceil == 0.5 {\n                                ^\n"
  stdout: ''
  timestamp: 1660014178
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let floorValue = floor(doubleValue!)\n\
    \    let ceilValue = ceil(doubleValue!)\n    if (doubleValue! - floorValue) <\
    \ (ceilValue - doubleValue!) {\n        return Int(floorValue)\n    } else {\n\
    \        return Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3ehm8d2r.swift:13:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue!)\n                     ^~~~~\n/tmp/tmp3ehm8d2r.swift:14:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue!)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014178
