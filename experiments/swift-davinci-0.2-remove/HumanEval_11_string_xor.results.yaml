language: swift
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_bit = a[i]\n        let b_bit = b[i]\n   \
    \     result += String(a_bit ^ b_bit)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp09fsny6b.swift:7:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_bit\
    \ = a[i]\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp09fsny6b.swift:8:21: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_bit = b[i]\n                    ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp09fsny6b.swift:9:32: error:\
    \ binary operator '^' cannot be applied to two 'Character' operands\n        result\
    \ += String(a_bit ^ b_bit)\n                         ~~~~~ ^ ~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.index(a.startIndex,\
    \ offsetBy: i)]\n        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpgctoogx1.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuz56i07m.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuz56i07m.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuz56i07m.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int\
    \ = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n        result\
    \ += String(a_int ^ b_int)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuz56i07m.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuz56i07m.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuz56i07m.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(a_char == b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp449vj_we.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp449vj_we.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp449vj_we.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(a_char\
    \ == b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfhvbnrre.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfhvbnrre.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpfhvbnrre.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuz56i07m.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuz56i07m.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuz56i07m.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ (index, char) in a.enumerated() {\n        if char == b[b.index(b.startIndex,\
    \ offsetBy: index)] {\n            result += \"0\"\n        } else {\n       \
    \     result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(a_char == b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int\
    \ = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n        result\
    \ += String(a_int ^ b_int)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_bit = a[i]\n        let b_bit = b[i]\n   \
    \     result += String(a_bit ^ b_bit)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp09fsny6b.swift:7:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_bit\
    \ = a[i]\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp09fsny6b.swift:8:21: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_bit = b[i]\n                    ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp09fsny6b.swift:9:32: error:\
    \ binary operator '^' cannot be applied to two 'Character' operands\n        result\
    \ += String(a_bit ^ b_bit)\n                         ~~~~~ ^ ~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int\
    \ = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n        let\
    \ xor_int = a_int ^ b_int\n        result += String(xor_int)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.index(a.startIndex,\
    \ offsetBy: i)]\n        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n\
    \        if a_char == b_char {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpsb7gftp2.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var a = a\n    var b = b\n\
    \    var result = \"\"\n    while a.count > 0 || b.count > 0 {\n        let a_bit\
    \ = a.popLast() ?? \"0\"\n        let b_bit = b.popLast() ?? \"0\"\n        result\
    \ = String(Int(a_bit)! ^ Int(b_bit)!) + result\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ytgitop.swift:11:29: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        result = String(Int(a_bit)!\
    \ ^ Int(b_bit)!) + result\n                            ^\n/tmp/tmp8ytgitop.swift:11:43:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n        result = String(Int(a_bit)! ^ Int(b_bit)!) +\
    \ result\n                                          ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp449vj_we.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp449vj_we.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp449vj_we.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ (index, char) in a.enumerated() {\n        let a_bit = char == \"1\"\n     \
    \   let b_bit = b[b.index(b.startIndex, offsetBy: index)] == \"1\"\n        result\
    \ += (a_bit != b_bit) ? \"1\" : \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[i]\n        let b_char = b[i]\n \
    \       if a_char == b_char {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu87ck0li.swift:7:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_char\
    \ = a[i]\n                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu87ck0li.swift:8:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_char = b[i]\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ (i, j) in zip(a, b) {\n        result += String(Int(String(i))! ^ Int(String(j))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp449vj_we.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp449vj_we.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp449vj_we.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ (i, j) in zip(a, b) {\n        if i == j {\n            result.append(\"0\"\
    )\n        } else {\n            result.append(\"1\")\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for i\
    \ in 0..<a.count {\n        res += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcbmt0dx1.swift:7:34: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        res += String(Int(String(a[i]))!\
    \ ^ Int(String(b[i]))!)\n                                 ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcbmt0dx1.swift:7:55:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        res += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n\
    \                                                      ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result.append(a_char\
    \ == b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzvywerxz.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpzvywerxz.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpzvywerxz.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int\
    \ = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n        let\
    \ result_int = a_int ^ b_int\n        result += String(result_int)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ (i, j) in zip(a, b) {\n        result += String(i ^ j)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvthlb5x9.swift:7:28: error: binary operator '^' cannot be applied\
    \ to two 'String.Element' (aka 'Character') operands\n        result += String(i\
    \ ^ j)\n                         ~ ^ ~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let xor_result = a_int ^ b_int\n\
    \        result.append(String(xor_result))\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu84e64gt.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpu84e64gt.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpu84e64gt.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ (i, char) in a.enumerated() {\n        if char == b[b.index(b.startIndex, offsetBy:\
    \ i)] {\n            result += \"0\"\n        } else {\n            result +=\
    \ \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(a_char == b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes =\
    \ zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    let xor_string = xor_bytes.map {\
    \ String($0, radix: 2) }.joined()\n    return xor_string\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = [UInt8](a.utf8)\n\
    \    let b_bytes = [UInt8](b.utf8)\n    var result = \"\"\n    for i in 0..<a_bytes.count\
    \ {\n        result += String(a_bytes[i] ^ b_bytes[i])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let xored_bytes\
    \ = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return xored_bytes.map { String($0,\
    \ radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int\
    \ = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n        let\
    \ xor_result = a_int ^ b_int\n        result += String(xor_result)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp449vj_we.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp449vj_we.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp449vj_we.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_i = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_i = b[b.index(b.startIndex, offsetBy: i)]\n        if a_i == b_i\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[i]\n        let b_char = b[i]\n \
    \       if a_char == b_char {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu87ck0li.swift:7:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_char\
    \ = a[i]\n                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu87ck0li.swift:8:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_char = b[i]\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let xor_int = a_int ^ b_int\n\
    \        result += String(xor_int)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuu2s0psn.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuu2s0psn.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuu2s0psn.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.index(a.startIndex,\
    \ offsetBy: i)]\n        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n\
    \        if a_char == b_char {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpsb7gftp2.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int\
    \ = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n        let\
    \ xor_result = a_int ^ b_int\n        result += String(xor_result)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[i]\n        let b_char = b[i]\n \
    \       result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpazh7ikmz.swift:7:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_char\
    \ = a[i]\n                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpazh7ikmz.swift:8:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_char = b[i]\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.index(a.startIndex,\
    \ offsetBy: i)]\n        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n\
    \        if a_char == b_char {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpsb7gftp2.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let xored = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return xored.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ (i, j) in zip(a, b) {\n        result += String(i ^ j)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvthlb5x9.swift:7:28: error: binary operator '^' cannot be applied\
    \ to two 'String.Element' (aka 'Character') operands\n        result += String(i\
    \ ^ j)\n                         ~ ^ ~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bnvlaag.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bnvlaag.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp6bnvlaag.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[i]\n        let b_char = b[i]\n \
    \       let a_int = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n\
    \        let result_int = a_int ^ b_int\n        result += String(result_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp74ii_vdi.swift:7:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_char\
    \ = a[i]\n                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp74ii_vdi.swift:8:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_char = b[i]\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let c_bytes = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return String(bytes: c_bytes, encoding: .utf8)!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfywt24c9.swift:8:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: c_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpfywt24c9.swift:8:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ c_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpfywt24c9.swift:8:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpfywt24c9.swift:8:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpfywt24c9.swift:8:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        result += String(a[i] == b[i] ? \"0\" : \"1\")\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpl80zsuuv.swift:7:26: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        result +=\
    \ String(a[i] == b[i] ? \"0\" : \"1\")\n                         ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpl80zsuuv.swift:7:34:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        result += String(a[i] == b[i] ? \"0\" :\
    \ \"1\")\n                                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ Int($0) }\n    let b_bytes = b.utf8.map { Int($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int\
    \ = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n        let\
    \ xor_result = a_int ^ b_int\n        result += String(xor_result)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp449vj_we.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp449vj_we.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp449vj_we.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(a_char\
    \ == b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfhvbnrre.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfhvbnrre.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpfhvbnrre.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ Int($0) }\n    let b_bytes = b.utf8.map { Int($0) }\n    let xor_bytes = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return xor_bytes.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        result +=\
    \ String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuz56i07m.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuz56i07m.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuz56i07m.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuz56i07m.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuz56i07m.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuz56i07m.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[i]\n        let b_char = b[i]\n \
    \       if a_char == b_char {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu87ck0li.swift:7:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_char\
    \ = a[i]\n                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu87ck0li.swift:8:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_char = b[i]\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ $0 }\n    let b_bytes = b.utf8.map { $0 }\n    let result = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp449vj_we.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp449vj_we.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp449vj_we.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp449vj_we.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp449vj_we.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp449vj_we.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.characters.count {\n        let a_char = a[a.startIndex.advancedBy(i)]\n\
    \        let b_char = b[b.startIndex.advancedBy(i)]\n        if a_char == b_char\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuz56i07m.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuz56i07m.swift:7:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuz56i07m.swift:8:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmprm334exg.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmprm334exg.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978452
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    let a_bytes = a.utf8.map {\
    \ UInt8($0) }\n    let b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes,\
    \ b_bytes).map { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978452
