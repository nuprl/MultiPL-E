name: HumanEval_99_closest_integer
language: sh
prompt: "#!/bin/bash\n# Create a function that takes a value (string) representing\
  \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
  # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
  \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
  \ away from zero means that if the given number is equidistant\n# from two integers,\
  \ the one you should return is the one that is the\n# farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should\
  \ return -15.\n#\n# $1 is a string\nclosest_integer() {\n"
tests: "}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
  \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\"\
  \ ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
completions: ["    # your code here\n    echo $1 | awk '{printf(\"%d\\n\", $1)}'",
  "    # Write your code here\n    # To print results to the standard output you can\
    \ use echo\n    # Example: echo \"Hello world!\"\n    echo \"Hello world!\"",
  "  # Your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'", "    local num=$1\n\
    \    local int=$(printf \"%.0f\" $num)\n    local dec=$(printf \"%.1f\" $num)\n\
    \    if (( $(echo \"$dec - $int\" | bc -l) >= 0.5 )); then\n        (( int++ ))\n\
    \    fi\n    echo $int", "    # If the number is equidistant from two integers,\
    \ round it away from zero.\n    # Rounding away from zero means that if the given\
    \ number is equidistant\n    # from two integers, the one you should return is\
    \ the one that is the\n    # farthest from zero. For example closest_integer(\"\
    14.5\") should\n    # return 15 and closest_integer(\"-14.5\") should return -15.\n\
    \    #\n    # If the number is equidistant from two integers, round it away from\
    \ zero.\n    # Rounding away from zero means that if the given number is equidistant\n\
    \    # from two integers, the one you should return is the one that is the\n \
    \   # farthest from zero. For example closest_integer(\"14.5\") should\n    #\
    \ return 15 and closest_integer(\"-14.5\") should return -15.\n    #\n    # If\
    \ the number is equidistant from two integers, round it away from zero.\n    #\
    \ Rounding away from zero means that if the given number is equidistant\n    #\
    \ from two integers, the one you should return is the one that is the\n    # farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n    # return 15 and\
    \ closest_integer(\"-14.5\") should return -15.\n    #\n    # If the number is\
    \ equidistant from two integers, round it away from zero.\n    # Rounding away\
    \ from zero means that if the given number is equidistant\n    # from two integers,\
    \ the one you should return is the one that is the\n    # farthest from zero.\
    \ For example closest_integer(\"14.5\") should\n    # return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    #\n    # If the number is equidistant from two\
    \ integers, round it away from zero.\n    # Rounding away from zero means that\
    \ if the given number is equidistant\n    # from two integers, the one you should\
    \ return is the one that is the\n    # farthest from zero. For example closest_integer(\"\
    14.5\") should\n    # return 15 and closest_integer(\"-14.5\") should return -15.\n\
    \    #\n    # If the number is equidistant from two integers, round it away from\
    \ zero.\n   ", "    # Use bc to do floating point arithmetic.\n    # The scale=0\
    \ option sets the number of digits after the decimal\n    # point to 0, so that\
    \ bc will round the number to the nearest\n    # integer.\n    # The printf command\
    \ formats the number as a string.\n    printf \"%d\" $(echo \"scale=0; $1/1\"\
    \ | bc)", "  # Your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'", " \
    \ # Write your code here\n  # To print results to the standard output you can\
    \ use echo\n  # Example: echo \"Hello world!\"\n  echo \"Not implemented\"", " \
    \   # Your code here\n    echo $1 | awk '{printf(\"%d\\n\", $1)}'", "    # Write\
    \ your code here\n    # To print results to the standard output you can use echo\n\
    \    # Example: echo \"Hello world!\"\n    echo \"Hello world!\"", "  # Write\
    \ your code here\n  # To print results to the standard output you can use echo\n\
    \  # Example: echo \"Hello world!\"\n  echo \"Hello world!\"", "  # Write your\
    \ code here\n  # To print results to the standard output you can use echo\n  #\
    \ Example: echo \"Hello world!\"\n  echo \"Hello world!\"", "    # The following\
    \ is a one-liner, but it's easier to read if we break it\n    # down into several\
    \ lines.\n    #\n    # First, we use bc to convert the string to a number.\n \
    \   # Then, we use printf to convert the number to a string.\n    # Finally, we\
    \ use sed to remove the decimal point.\n    #\n    # The sed command is a bit\
    \ tricky. It uses a regular expression to\n    # match a decimal point, and then\
    \ replaces it with an empty string.\n    #\n    # The regular expression is:\n\
    \    #\n    # ^[0-9]*\\.\n    #\n    # The ^ means \"beginning of line\".\n  \
    \  # The [0-9]* means \"any number of digits\".\n    # The \\. means \"a decimal\
    \ point\".\n    #\n    # The ^[0-9]*\\. matches the beginning of the string, followed\
    \ by any\n    # number of digits, followed by a decimal point.\n    #\n    # The\
    \ replacement string is empty, so the decimal point is removed.\n    #\n    #\
    \ The -r flag to sed tells it to use extended regular expressions.\n    #\n  \
    \  # The -i flag to sed tells it to edit the file in place.\n    #\n    # The\
    \ -e flag to sed tells it to use the following string as the\n    # regular expression.\n\
    \    #\n    # The -e flag to sed tells it to use the following string as the\n\
    \    # replacement string.\n    #\n    # The -e flag to sed tells it to use the\
    \ following string as the\n    # replacement string.\n    #\n    # The -e flag\
    \ to sed tells it to use the following string as the\n    # replacement string.\n\
    \    #\n    # The -e flag to sed tells it to use the following string as the\n\
    \    # replacement string.\n    #\n    # The -e flag to sed tells it to use the\
    \ following string as the\n    # replacement string.\n    #\n    # The -e flag\
    \ to sed tells it to use the following string as the\n    # replacement string.\n\
    \    #\n    # The -e flag to sed tells it to use the following string as the\n\
    \    # replacement string.\n    #\n    # The -e flag to sed tells it", "    #\
    \ Write your code here\n    # To print results to the standard output you can\
    \ use echo\n    # Example: echo \"Hello world!\"\n    echo \"Hello world!\"",
  "    # Write your code here\n    echo $1 | awk '{print int($1+0.5)}'", "  # TODO:\
    \ Your code here\n  echo \"$1\"", "    local number=\"$1\"\n    local integer=$(printf\
    \ \"%.0f\" \"$number\")\n    local decimal=$(printf \"%.1f\" \"$number\")\n  \
    \  local diff=$(echo \"$decimal - $integer\" | bc)\n    if [[ \"$diff\" == \"\
    0.5\" ]]; then\n        if [[ \"$number\" -ge 0 ]]; then\n            echo \"\
    $((integer + 1))\"\n        else\n            echo \"$((integer - 1))\"\n    \
    \    fi\n    else\n        echo \"$integer\"\n    fi", "    # your code here\n\
    \    echo $1 | awk '{printf \"%d\\n\", $1}'", '  # Your code here', "    # your\
    \ code here\n    echo $1 | awk '{printf(\"%d\\n\", $1)}'"]
stop_tokens:
- "\n}"
