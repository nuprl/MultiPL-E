name: HumanEval_102_choose_num
language: rb
prompt: "# This function takes two positive numbers x and y and returns the\n# biggest\
  \ even integer number that is in the range [x, y] inclusive. If \n# there's no such\
  \ number, then the function should return -1.\n# For example:\n# >>> choose_num.call(12,\
  \ 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n\
  \    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n\
  \    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33,\
  \ 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28,\
  \ candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1,\
  \ candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\n\
  end\n"
completions: ["    x.to_i.upto(y).each do |i|\n        return i if i % 2 == 0\n  \
    \  end\n    return -1\nend", "  \n  if x > y then\n    puts \"Please enter a smaller\
    \ number\"\n    exit\n  elsif x < y then\n    puts \"Please enter a larger number\"\
    \n    exit\n  end", "    x.to_i < y.to_i ? x.to_i + y.to_i : y.to_i + x.to_i\n\
    end", "    if x > y\n        y, x = x, y\n    \n    sum = 0\n    \n    for i in\
    \ (1..y)\n        sum += i\n        \n    for i in (1..x)\n        if sum % 2\
    \ == 0\n            return i\n        \n    return -1\n</code>\n<|/ a dscore=0\
    \ tags=python |>\n<| c |>\nThis does not explain what it does, nor does it answer\
    \ the question. The question asks how to write a function that returns -1 when\
    \ given a negative number and an even number. Your function would return 1 when\
    \ given 1 and 2.\n<|/ c |>\n<| c |>\nIt doesn't answer the question. `choose_num.call(12,\
    \ 15)` returns 14.\n<|/ c |>\n<| c |>\nThis answer fails to explain why `choose_num.call(13,\
    \ 12)` returns -1.\n<|/ c |>\n<| c |>\nI didn't mean to ask OP to choose what\
    \ to do. He just want to know what is wrong with his code when he called choose_num.call(13,\
    \ 12).\n<|/ c |>\n<| c |>\nThat comment was meant to be directed to the person\
    \ who voted up the answer. Thank you for pointing this out.\n<|/ c |>\n<| a |>\n\
    <code>", "  if x < y then return -1\n  max_even = x + y # initialize max even\
    \ number\n  for i in [x, y..max_even] do # for each number\n    if i % 2 ==0 then\
    \ # if even\n      if i >max_even then max_even = i # if the number is bigger\
    \ than max\n    else # if odd\n      if i <= max_even then return i # if the number\
    \ is smaller than max\n  return max_even # return max\nend\n</code>\n<|/ a tags=ruby,range\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a dscore=1 |>\nThis code will return the maximum\
    \ of any two numbers from any range.\n<code>", "  puts \"#{x} < #{y} ? #{x} <\
    \ #{y} : #{y} < #{x} ? #{y} < #{x} : #{x} > #{y} ? #{x} > #{y} : #{y} > #{x} ?\
    \ #{y} > #{x} : #{x} == #{y} ? #{x} != #{y} : #{y} != #{x}\"\n  puts \">>\"\n\
    \  puts \"#{x} < #{y} ? #{x} < #{y} : #{y} < #{x} ? #{y} < #{x} : #{x} > #{y}\
    \ ? #{x} > #{y} : #{y} > #{x} ? #{y} > #{x} : #{x} == #{y} ? #{x} != #{y} : #{y}\
    \ != #{x}\"\n  puts \"<\"\n  puts \"#{x} < #{y} ? #{x} < #{y} : #{y} < #{x} ?\
    \ #{y} < #{x} : #{x} > #{y} ? #{x} > #{y} : #{y} > #{x} ? #{y} > #{x} : #{x} ==\
    \ #{y} ? #{x} != #{y} : #{y} != #{x}\"\n  puts \">\"\n  return 1 if x <= y &&\
    \ x > y\n  return -1 if y <= x && y < x\n  return 1 if x > y && x <= y\n  return\
    \ -1 if y > x && y <= x\n  puts \" ==\"\n  puts \"#{x} > #{y} ? #{x} > #{y} :\
    \ #{y} > #{x} ? #{y} > #{x} : #{x} < #{y} ? #{x} < #{y} : #{y} < #{x} ? #{y} <\
    \ #{x} : #{x} == #{y} ? #{x} != #{y} : #{y} != #{x}\"\n  puts \"<\"\n  puts \"\
    #{x} > #{y} ? #{x} > #{y} : #{y} > #{x} ? #{y} > #{x} : #{x} < #{y} ? #{x} < #{y}\
    \ : #{y} < #{x} ? #{y} < #{x} : #{x} == #{y} ? #{x} != #{y", "  ((x > y) ? x :\
    \ y)\nend", "  ((x >= 1) and\n   (x <= y) and\n   (x % 2 != 0 and x != 0 and y\
    \ % 2 != 0 and y != 0)) and\n   return x\n  else\n    return -1\n  end\nend",
  "  if x % 2 == 0 and y % 2 == 0\n    return ((x * y)**2 - x)/2.0\n  else\n    return\
    \ -1\n  end\nend\n</code>\n<|/ a tags=ruby,python,c |>\n<| c |>\nThis seems more\
    \ like a comment than an answer.\n<|/ c |>\n<| c |>\n: It doesn't exactly answer\
    \ the question, but it does a useful job of demonstrating the problem. +1\n<|/\
    \ c |>\n<| c |>\nYes, I agree that this is an improvement over my answer.  I added\
    \ an alternative that uses integer arithmetic, but it's harder to understand.\n\
    <|/ c |>\n<| a |>\n<code>", "  return if x >= y\n  num = x\n  while x % 2 == 0\
    \ && y % 2 == 0\n    x /= 2\n    y /= 2\n  y -= 1\n  while num % 2 == 0\n    num\
    \ /= 2\n  while x % 2 == 0 && num % 2 == 0\n    x /= 2\n    num /= 2\n  return\
    \ num if x == y else -1", "  begin\n    loop do\n      y = y.succ\n      break\
    \ if y > x\n      y -= 2\n    end\n    return y\n  rescue StopIteration\n    return\
    \ -1\n  end\nend\n</cell>\n<code language=julia-1.6>", "    if x > y\n       \
    \ x, y = y, x\n    return x - y + 1 if x % 2 == 0 and y % 2 == 0 else x + y -\
    \ 1", "  \n  return x if x > y ? x : y\nend", "    return Math.maximum(Math.maximum(x\
    \ - y, Math.abs(x - y)), x - y)\nend", "  if x >= y \n    puts -1\n  else\n  \
    \  puts (x..y).reduce(:max)\n  end\nend", "  if x >= y and x <= y+1\n    even\n\
    \  elsif x >= y and x % 2 == 0\n    y+1\n  elsif x <= y and y % 2 == 0\n    -1\n\
    \  elsif x <= y and y % 2 == 1\n    y+1\n  else\n    -1\n  end\nend\n</code>\n\
    This code is a combination of my answer to a previous question and my answer to\
    \ that previous question.\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nGood point. I've\
    \ added some comments to help explain the logic behind it.\n<|/ c |>\n<| c |>\n\
    Thanks this is really helpful. However this only solves the problem with two numbers.\
    \ What if they were more than 2 numbers like choose_num.call(3, 7, 11) and choose_num.call(10,\
    \ 2, 5) ? Would you be able to solve the problem this way and if so, how?\n<|/\
    \ c |>\n<| c |>\nI have edited my answer to include your new example data.\n<|/\
    \ c |>\n<| c |>\nThanks a lot for the help. Unfortunately this still doesn't solve\
    \ the problem when there are more than 2 numbers in range. For example, choose_num.call(7,\
    \ 2, 5, 10, 11) should return 11, but it returns 11. The reason is because when\
    \ it tries to find the first even number, it sees that the 11 is even, so it returns\
    \ 11. Thus the function returns 11, instead of 11 and 10.\n<|/ c |>\n<| c |>\n\
    Oh, now I see. I made a slight mistake in my answer. It should be `choose_num.call(7,\
    \ 2, 5, 10, 11)` instead of `choose_num.call(7, 2, 5, 10)`. The `11` should actually\
    \ be the *next* even number, so it should be `choose_num.call(7, 2, 5, 10)`.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  max_num = 0\n  if x >= y\n    x.upto(y)\
    \ { |n| max_num = n if n % 2 == 0 }\n  else\n    y.upto(x) { |n| max_num = n if\
    \ n % 2 == 0 }\n  end\n  max_num\nend", "  if x > y \n    x, y = y, x\n  x.upto(y)\
    \ do |i|\n    break if i % 2 == 0\n    break if i == y\n  end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nHere is a solution which works for ranges of arbitrary\
    \ size. \n<code>", "  num = nil\n  while x <= y\n    if x % 2 == 0\n      num\
    \ = x\n    end\n    x += 1\n  end\n  return num\nend", "  num = nil\n  if x >\
    \ y\n    num = x\n  else\n    num = y\n  end\n  \n  while num % 2 == 0\n    num\
    \ = num / 2\n  end\n  \n  while num % 2 == 0\n    num = num / 2\n  end\n  \n \
    \ if num == 0 || num == -1\n    return -1\n  else\n    return num\n  end\nend\n\
    </code>\nAnd here's my final solution:\n<code>", "  if x < y then return -1 end\n\
    \  \n  # Initialize z to the smallest even number that is in the range [x, y]\
    \ inclusive.\n  z = 1\n  until x > z do\n    z = z + 2\n    if x > z then break\
    \ end\n  end\n  \n  # We know that z is in the range [x, y] inclusive, so we'll\
    \ just \n  # keep dividing it by 2 and rounding down to the nearest integer.\n\
    \  until z == x do\n    z = z / 2\n  end\n  \n  until z == y do\n    z = z / 2\n\
    \  end\n  \n  return z\nend\n</cell>\n<code language=julia-1.0>\nchoose_num.call(10,\
    \ 3)\n</cell>\n<text>\nWrite a function that takes a positive integer number and\
    \ returns its square.", "  x = x.to_i\n  y = y.to_i\n  if x > y\n    return x\n\
    \  else\n    return y\n  end\nend", "  if x > y\n    x, y = y, x\n  \n  if x >\
    \ 0 && y > 0\n    if x % 2 == 0 && y % 2 == 0\n      return( (x * y) / 2); \n\
    \    elsif x % 2 != 0 || y % 2 != 0\n      return(-1);\n    else\n      choose_num.call(x,\
    \ y - 1);\n    end;\n  else\n    return(-1);\n  end;\nend;\n</code>\nThe recursive\
    \ calls are only executed if the current condition doesn't hold.\nThe code could\
    \ be made better by eliminating the if statement and using an if statement within\
    \ a loop, but this is probably an exercise so I won't do that.\n<|/ a tags=ruby,recursion\
    \ |>\n<| c |>\nThe recursion calls should be made inside the `if` statement. Otherwise,\
    \ if you try to call `choose_num` on the first `return`, it will immediately return\
    \ without continuing the recursive calls.\n<|/ c |>\n<| c |>\nIt will return if\
    \ `x > 0 && y > 0` holds true, but that will leave `x % 2 != 0 || y % 2 != 0`\
    \ true, so the `else` statement will never be reached. `choose_num` will only\
    \ return if both x and y are non-negative\n<|/ c |>\n<| c |>\nAh, I didn't catch\
    \ that when reading through the code. Yes, the recursion needs to be made inside\
    \ of the `if` statement, not at the top. Fixed.\n<|/ c |>\n<| c |>\nI changed\
    \ my answer, so you can use the function directly without `choose_num.call(x,y);`\
    \ which is not needed\n<|/ c |>\n<| c |>\nIt's an exercise to make it work as\
    \ a method instead of a function. Thanks though.\n<|/ c |>\n<| a tags=ruby,recursion\
    \ |>\n<code>", "  if x == y\n    return -1\n  else\n    max = -1\n    for n in\
    \ (x..y)\n      if n % 2 == 0\n        max = max == -1 ? n : max\n    end\n  \
    \  return max\n  end\nend", "  result = -1\n  (x - y).times do |i|\n    if i /\
    \ 2 != 0\n      result = i\n    end\n  end\n  result\nend", "  even = y % 2 ==\
    \ 0\n  if even\n    z = x + (y / 2)\n    return z if z * 2 > x else -1\n  end\n\
    \  return x if x > y else y\nend", "    return x if x % 2 == 0 and y % 2 == 0\
    \ else -1\nend", "  i = x\n  j = (x - 1)\n  while i <= y\n    i = i + 2\n    j\
    \ = (j - 1)\n    if i % 2 == 0 and j % 2 == 0\n      return i\n    end\n  end\n\
    \  -1\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI wonder why this was downvoted?\n\
    <|/ c |>\n<| c |>\n+1 because this answer is better than my answer.  But maybe\
    \ the OP doesn't know that he can do `x % 2 == 0` directly.  I'll leave it to\
    \ him.\n<|/ c |>\n<| c |>\nI added the explanation to the code snippet\n<|/ c\
    \ |>\n<| a tags=ruby,while-loop |>\nIn Ruby 2.2 and later, the best way to write\
    \ this would be:\n<code>", "  num = (x || y > 0) ? x : (y || x > 0) ? y : -1\n\
    \  i = 2\n  while i <= num\n    if num % i == 0\n      num = num / i\n    else\n\
    \      i += 1\n    end\n  end\n  num\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nThe example you gave will never return -1 (as in \"no such number\").\
    \ Also, `choose_num.call(12, 15)` returns `14` instead of `15`.\n<|/ c |>\n<|\
    \ c |>\nI used the function as it was shown in the problem and in the solution.\
    \ I had to change it a bit in order to make it more readable and shorter and I\
    \ wanted to show the idea by modifying the function itself.\n<|/ c |>\n<| c |>\n\
    Sorry, I misread your first sentence, now I see that that was incorrect. Still,\
    \ I feel that the original code can be simplified, see my answer.\n<|/ c |>\n\
    <| c |>\nI modified the solution a bit. I used the function as it was shown in\
    \ the problem and in the solution. I had to change it a bit in order to make it\
    \ more readable and shorter and I wanted to show the idea by modifying the function\
    \ itself.\n<|/ c |>\n<| c |>\nThank you for the edit. I'll definitely use it.\n\
    <|/ c |>\n<| a dscore=0 |>\nI assume you are allowed to modify choose_num.\nYour\
    \ problem can be solved with recursion.\n<code>", "  if x > y\n    x, y = y, x\n\
    \  elsif x > y \n    x = y + 1\n  else\n    return -1\n  end\n  \n  while x !=\
    \ y\n    if x % 2 == 0\n      y = y / 2\n    else\n      x = x\n    end\n  end\n\
    \  \n  return x\nend\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n<cell>\nchoose_num(13,\
    \ 12)\n</cell>\n<cell>\nchoose_num(9, 17)\n</cell>\n<text>\nThe Elvis operator",
  "\txrange, yrange = x, y\n\twhile xrange < yrange\n\t\tyrange = yrange + 1\n\t\t\
    xrange = (xrange + yrange) / 2\n\treturn xrange - 1\n\t", "  if x <= 0 || y <=\
    \ 0\n    return -1\n  num = 2\n  while true\n    if x % num == 0 && y % num ==\
    \ 0\n      return num\n    num += 2\n  end\nend", "  smallest = x\n  biggest =\
    \ y\n  loop do\n    break unless smallest.even?\n    smallest = smallest.next\
    \ # decrement the number by 1\n  end\n  loop do\n    break unless biggest.even?\n\
    \    biggest = biggest.next # increment the number by 1\n  end\n  return biggest\n\
    end", "  begin\n    begin\n      raise ArgumentError, \"Invalid parameters: \"\
    \ + x + \"-\" + y\n    rescue ArgumentError => e\n      raise ArgumentError, \"\
    Invalid parameters: \" + e.message\n    end\n    if y > x\n      return x\n  \
    \  else\n      return y\n    end\n  rescue ArgumentError => e\n    raise ArgumentError,\
    \ \"Invalid parameters: \" + e.message\n  end\nend", "  if x <= y then return\
    \ -1\n  z = x - (x % y)\n  while z <= y do\n    if z * z <= x then\n      return\
    \ z\n    end\n    z = z + 1\n  end\n  return -1\nend\n</code>\n<|/ a dscore=0\
    \ tags=python,algorithm |>\n<| c |>\nThis solution works only when the range is\
    \ [a, b].\n<|/ c |>\n<| c |>\nNot true, this solution will work for any range\
    \ for any two numbers, including negative numbers. Please test your code before\
    \ down-voting. Also, consider your algorithm for choosing the number in the range\
    \ [a, b] where a = b - 1.\n<|/ c |>\n<| c |>\nIt doesn't work when the range is\
    \ [a, b] if the range is [a, b] - [a, a] or [a, b] - [a, b]. See the example in\
    \ my answer.\n<|/ c |>\n<| c |>\nAh, you're right. I've added some conditional\
    \ checks to account for this scenario. Thanks for the comments!\n<|/ c |>\n<|\
    \ c |>\n`def choose_num(a, b):\n    return max([a, b] - ([a, b] - [a, b]) or [a,\
    \ b])` this fails for `choose_num.call(1, 3)` which returns `1`. and `choose_num.call(1,\
    \ 5)` which returns `2`\n<|/ c |>\n<| a tags=python,algorithm |>\n<code>", " \
    \ # Your code here\n  raise \"Function choose_num must take a positive number\
    \ and a positive number as arguments\" if x < 0 or y < 0\n  return nil unless\
    \ x && y\n  \n  a = b = 1\n  \n  while a < b\n    (a**2) + (a**3) = a\n    b +=\
    \ 1\n  end\n  \n  while a < b\n    b -= 1\n  end\n  \n  (a**2) + b\nend", "  m\
    \ = Math.max(x, y)\n  while x <= y\n    if x % 2 == 0 and y % 2 == 0\n      return\
    \ m\n    x += 1\n    y -= 1\n  end\n  -1\nend\n</cell>\n<cell>", "  p =  Math.ceil(x/y)\n\
    \  return p if p*p <= x and p*p <= y then return p else return -1\nend", "  \n\
    \  return (x..y-1).find { |z| z % 2 == 0 } if x < y\n  \n  y-1\nend", "\treturn\
    \ (x >= y if x >= y and x <= y else -1) if x >= y or x <= y else -1", "  return\
    \ ((x || 0) + (y || 0) - 1) \\\n    rescue ((x >= y) ? x : y) - 2\nend\n</code>\n\
    <|/ a |>\n<| c |>\n`choose_num(12, 12)` returns 14 not -1\n<|/ c |>\n<| c |>\n\
    , I was working on that too but did not have time to finish the job :)\n<|/ c\
    \ |>\n<| c |>\n, I'm sorry I didn't see your comment. I fixed my code so now it\
    \ should return `-1` as mentioned in the OP.\n<|/ c |>\n<| a |>\nI'm sure you\
    \ can optimize this a lot, but it seems like a nice clean solution, except for\
    \ the one case where you don't want the code to raise an exception for bad inputs.\
    \ So I added that as an explicit case:\n<code>", "  even = x.even? && y.even?\n\
    \  return even ? y : (even ? x : -1)\nend", "\tif x < y then\n\t\treturn -1\n\t\
    else\n\t\treturn\n\tend\nend", "  if x>=y and x<(y+1)\n    return x\n  else\n\
    \    return y\n  end\nend", "  i = x\n  j = y\n  while i < j\n    i += 1\n   \
    \ j = j - 1\n  end\n  return j if i <= j\n  j = x\n  i = y\n  while j < i\n  \
    \  j += 1\n    i = i - 1\n  end\n  return i if i <= j\n  return -1\nend", "  num\
    \ = nil\n  \n  if y > x\n    (x..y).each do |i|\n      if i.even?\n        num\
    \ = i\n        break\n      end\n    end\n  else\n    (x..y).each do |i|\n   \
    \   if i.odd?\n        num = i\n        break\n      end\n    end\n  end\n  \n\
    \  return num\nend\nputs choose_num(6, 8)", "\treturn  ((x > y or x < 0) or x\
    \ > x % 2) and\n\t\t((y > x or y < 0) or y > x % 2) and\n\t\t((x > 0 and y > 0\
    \ and x < y and y < x) or\n\t\t (x < 0 and y > 0 and x < y and y > x))\nend",
  "    unless [x, y].all?{ |i| i.is_a? Integer }\n        raise ArgumentError, \"\
    Both numbers should be integers. Given [#{x.inspect}, #{y.inspect}]\"\n    end",
  "  max = -1\n  while y > x do\n    x = x + 2\n    max = max(x) if x > max else max\n\
    \  end\n  return max\nend", "  if x > y\n    return choose_num(y, x)\n  elsif\
    \ x == y\n    return x\n  elsif x < y\n    return choose_num(x, y - 1)\n  else\n\
    \    return -1\n  end\nend", "  x.upto(y, 2) do |i|\n    return i if i.even?\n\
    \  end\n  -1\nend", "    num = -1\n    \n    if x >= y and x > x\n        num\
    \ = x\n    end\n    \n    if y >= x and y > y\n        num = y\n    end\n    \n\
    \    if num == -1\n        num = 0\n    end\n    \n    return num\nend", "  if\
    \ x > y\n    x, y = y, x\n  i = nil\n  while i < x do\n    i = i + 1\n    if i\
    \ % 2 != 0\n      break\n    end\n  end\n  while i < y do\n    i = i + 1\n   \
    \ if i % 2 != 0\n      break\n    end\n  end\n  return i\nend", "  if x > y\n\
    \    x, y = y, x\n  else\n    x, y = y, x\n  x = x.to_i\n  y = y.to_i\n  while\
    \ x > 0\n    if x % 2 == 0\n      return x if x > y || x > y\n      y = y\n  \
    \  else\n      x /= 2\n    end\n  end\n  return -1\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,algorithm\
    \ dscore=1 |>\n<| c |>\nHi, thank you for your response. I'm a student and I'm\
    \ trying to learn Ruby and I'm following a course in Udemy and I'm very confused\
    \ on how they got this solution. I'm also a bit confused as to how they got this\
    \ solution. If I was to write this in Ruby what would I do?\n<|/ c |>\n<| c |>\n\
    Hi, thank you for your response. I'm a student and I'm trying to learn Ruby and\
    \ I'm following a course in Udemy and I'm very confused on how they got this solution.\
    \ I'm also a bit confused as to how they got this solution. If I was to write\
    \ this in Ruby what would I do?\n<|/ c |>\n<| c |>\nThe point here is that in\
    \ Ruby, there's always an easier way to do things than brute-forcing the solution.\
    \ If you want to solve the problem in Ruby, I'd suggest that you research \"Ruby\
    \ algorithms\". For this problem, there's [this](http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html)\
    \ tutorial for modules and [this](http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html)\
    \ tutorial for classes. Then go through some code examples until you understand\
    \ how the solution works.\n<|/ c |>\n<| c |>\nHi, I'm a bit confused on how to\
    \ translate this into Ruby, I tried it using RubyMine, but I'm confused on how\
    \ I'm supposed to run it on Ruby because I'm very new to Ruby. Do you think you\
    \ could write it out in Ruby that way I could follow it? If so could you please\
    \ give me an example?\n<|/ c |>\n<| c |>\nI've added an answer with code examples.\
    \ Feel free to ask for clarifications.\n<|/ c |>\n<| a dscore=1 |>\nI wrote an\
    \ answer earlier that shows a good ruby way, but it's not a good ruby way.  It's\
    \ not very efficient.  You can do it in one pass through the array, it's O(N).\n\
    <code>", "  if x > y then \n    x, y = y, x\n  even = x.even?\n  x = x.to_i\n\
    \  y = y.to_i\n  if even\n    y -= 1 if y % 2 == 1 else y\n  elsif x == y\n  \
    \  return -1\n  else\n    y -= 1 if y % 2 == 1 else y\n    x -= 1 if x % 2 ==\
    \ 1 else x\n    return y if even or x >= y \n    x if even or x < y\n  end\nend",
  "  if x <0 || y <0\n    return -1\n  i = x\n  j = y\n  while i <= j\n    if i %\
    \ 2 == 0\n      i += 1\n    else\n      j -= 1\n  end\n  return i\nend", "  x_even?(x)\
    \ or x_odd?(x) or x_even?(y) or x_odd?(y)\n  y - (((x - y) / 2) + y)\nend", " \
    \ (x..y) === y ? (return y) : ((x..y) === x ? return x : -1)\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nJust for the record, the operator is actually `..`\n<|/ c |>\n\
    <| c |>\nGood point. I've updated my answer with that info.\n<|/ c |>\n<| c |>\n\
    It should be `..` not `...`. `...` is Ruby, not Erlang; `..` is in some languages\
    \ (e.g. Haskell) but not Erlang.\n<|/ c |>\n<| c |>\nThe return statement doesn't\
    \ work as expected with numbers. What if the first argument is 0? For example,\
    \ `choose_num.call(0)` will return 0, but `choose_num.call(12)` will return 12\n\
    <|/ c |>\n<| c |>\nThe first argument should not be 0.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=2 |>\nHere's a pretty concise way to do this in Ruby.  It works even\
    \ when one or both arguments are nil:\n<code>", "  if x > y\n    x, y = y, x\n\
    \    \n  biggest = 0\n  smallest = 0\n  \n  for i in 1...y\n    if i is even\n\
    \      smallest = i\n    else\n      biggest = i\n  end\n  \n  if biggest is 0\n\
    \    return -1\n  end\n  \n  for i in 1...x\n    if i is even\n      return biggest\
    \ if biggest < i\n    else\n      return smallest if smallest > i\n    end\n \
    \ end\n  \n  biggest\nend\n</cell>\n<text>\nYour task:\nWrite a function named\
    \ choose_num_2 that takes two positive numbers x and y and returns the biggest\
    \ even number that is in the range [x, y] inclusive. If there's no such number,\
    \ then the function should return -1.", "    i = x\n    j = y\n    while i <=\
    \ j\n        i += 2\n        j += 1\n        if i % 2 == 0 && (i+j) % 2 == 0\n\
    \            return i\n    return -1\nend", "  z = nil\n  (x - y).times do |i|\n\
    \    z = i if i % 2 == 0\n  end\n  z ? z : -1\nend", "  return -1 if x < 0 or\
    \ y < 0 || (y == 0 and x == 0)\n  if y != 0\n    return y if y % 2 == 0\n    choose_num(y\
    \ / 2, x)\n  else\n    return x if x % 2 == 0\n    choose_num(x / 2, y)\nend",
  "  if x > y\n    num = -1\n  else\n    num = x\n  \n  while x > y\n    if num >\
    \ y\n      x -= 2\n      num /= 2\n    else\n      y -= 1\n      num *= 3\n  \
    \  end\n  end\n  \n  num\nend", "  if x > y \n    puts \"The smaller number is\
    \ #{x}\"\n    return\n  end\n  if x > y\n    puts \"The bigger number is #{y}\"\
    \n    return\n  end\n  \n  num = x if x % 2 == 0 and y % 2 == 0\n  num = y if\
    \ x % 2 != 0 and y % 2 != 0\n  \n  return num\nend\n</code>\n<|/ a tags=ruby dscore=1\
    \ |>\n<| a dscore=1 |>\nRuby doesn't provide built-in functions to check whether\
    \ a number exists in a given range, or whether two ranges overlap, but we can\
    \ write our own by checking the two conditions:\n<code>", "  z = ((x-y)**0.5).ceil\n\
    \  z.to_i\nend\n</code>\nYou can even do the same thing without using the built-in\
    \ ceil and floor methods, which are usually pretty expensive operations. Since\
    \ we're dealing with integers, all we have to do is take the square root:\n<code>",
  "  (x<y) ? x.ceil : y.ceil\nend", "  a = nil\n  b.each do |i|\n    if (i.to_i >=\
    \ x.to_i) && (i.to_i <= y.to_i)\n      a = i.to_i\n      break\n    end\n  end\n\
    \  return a\nend", "  return max_int(x..y)\nend\n</cell>\n<code language=julia-0.5>\n\
    choose_num(12,15)\n</cell>\n<text>\nFunctions return values as their last line\n\
    A function can return a value like this:", "    a, b = x, y\n    while a < b\n\
    \        a, b = b, a + (b - a)/2\n        if b > x\n            return -1\n  \
    \  return b\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI love the way\
    \ you wrote the solution! I didn't know this was a common problem and couldn't\
    \ find anything. Thank you for your time and effort.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\nIn your first method, you were passing an array into the second\
    \ argument, which wouldn't work as it says. You can only call a method on an object\
    \ or variable (a variable is the most common way), which means that you cannot\
    \ pass in an array, only a variable. In the second method, you didn't use a variable\
    \ for the first argument, so it was unusable in that instance.\nYou can either\
    \ pass an array into the second argument, or use a variable for the first argument.\
    \ The code you have there will work in the second method.\n<code>", "  return\
    \ x if y > x\n  result = y\n  while x > y\n    x = x - 2\n    result = result\
    \ + 2\n  end\n  result\nend\n</code>\nIt would be interesting to see how this\
    \ compares to the standard math library functions we looked at in class last week:\n\
    <code>\nrequire 'mathn'", "  while x < y\n    x, y = y, x % y\n  x > y ? y : x\n\
    end\n</code>\nTo use choose_num function, just do this:\n<code>\nchoose_num(13,\
    \ 12)\n</code>\n<|/ a |>\n<| a tags=ruby dscore=0 |>\nA more concise way (without\
    \ recursion limit) :\n<code>", "  return -1 if x < y else (x if y == x else y)\
    \ if x % 2 == 0 else\n    ((x if y == x else y) + 1) if y % 2 == 0 else\n    ((x\
    \ if y == x else y) - 1) if x % 2 != 0 else\n    ((x if y == x else y) * 2) if\
    \ y % 2 != 0 else\n    ((x if y == x else y) / 2)\nend", "  return x.to_i if x.to_i\
    \ < (y.to_i + 1)\n  x.to_i - 1\nend", "  a = x\n  b = y\n  while b < a\n    b\
    \ = b % 2\n  end\n  while a <= b\n    if a % 2\n      a = a + 1\n    else\n  \
    \    a = 0\n    end\n  end\n  if b == a\n    a\n  else\n    -1\n  end\nend\n</cell>\n\
    <text>\nQ3. Create the following class, which will create and store a person's\
    \ name and age, as well as the person's birthday in three attributes: name, age,\
    \ and dob.", "  # Your code here!\n  return -1", "  x.to_i > y.to_i ? x = y :\
    \ y = x\n  x.to_i < y.to_i ? return -1 : (x = x.to_i, y = y.to_i)\n  \n  \n  x%2\
    \ == 0 ? x : x*2\n  \nend", "  # Your code here!\n  return -1", "  x = x.to_i\n\
    \  y = y.to_i\n  result = (x << 1) | x >> 31\n  while x > y\n    if result <=\
    \ y << 1\n      result += 1\n    x >>= 1\n  result -= y << 1\n  result |= y >>\
    \ 31\n  if result > 0\n    result\n  else\n    -1\nend", "  return x if x % 2\
    \ == 0 && (x != y) && y % 2 == 0 && (y != x) && (x <= y && x >= x && y >= x -\
    \ 1) else -1\nend", "  x = x - 1 if x < 0 else x\n  y = y - 1 if y < 0 else y\n\
    \  z = x + y\n  while z < 2 * z\n    z = z + y\n  while z > 2 * z\n    z = z -\
    \ y\n  return z\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYour code won't work\
    \ if `x == y`; you'll end up doing `z > 2 * z + y - 1` (if `x > y`), and that\
    \ doesn't change the value of `z`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I'm still struggling with that, but I'll try to fix it.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere are some general approaches to this. I assume that your question\
    \ is more about the algorithm than about the language or platform (as you seem\
    \ to have figured out with your recent question).", "  x = x.to_f\n  y = y.to_f\n\
    \  return y if x > y ? -1 : x if x > y ? y : x\nend", "  if x==y\n    return -1\n\
    \  else\n    div = x / y\n    modx = x % y\n    mody = y % y\n    div == 0 ? return\
    \ -1 : (modx == 0 ? return mody : choose_num(modx, mody))\n  end\nend", "  m =\
    \ x.max\n  m = x.min if x > m else m\n  m = y.max if y > m else m\n  m = y.min\
    \ if y > m else m\n  return m if m % 2 == 0 else -1\nend", "  result = nil\n \
    \ \n  if x <= y \n    puts \"The range is wrong\"\n  elsif x == y\n    if x <=\
    \ 10\n      result = 1\n    elsif x <= 20\n      result = 2\n    elsif x <= 30\n\
    \      result = 3\n    elsif x <= 40\n      result = 4\n    elsif x <= 50\n  \
    \    result = 5\n    elsif x <= 60\n      result = 6\n    elsif x <= 70\n    \
    \  result = 7\n    elsif x <= 80\n      result = 8\n    elsif x <= 90\n      result\
    \ = 9\n    elsif x <= 100\n      result = 10\n    elsif x <= 110\n      result\
    \ = 11\n    elsif x <= 120\n      result = 12\n    elsif x <= 130\n      result\
    \ = 13\n    elsif x <= 140\n      result = 14\n    elsif x <= 150\n      result\
    \ = 15\n    else\n      result = -1\n    end\n  else \n    if x <= 10\n      result\
    \ = 1\n    elsif x <= 20\n      result = 2\n    elsif x <= 30\n      result =\
    \ 3\n    elsif x <= 40\n      result = 4\n    elsif x <= 50\n      result = 5\n\
    \    elsif x <= 60\n      result = 6\n    elsif x <= 70\n      result = 7\n  \
    \  elsif x <= 80\n      result = 8\n    elsif x <= 90\n      result = 9\n    elsif\
    \ x <= 100\n      result = 10\n    elsif x <= 110\n      result = 11\n    elsif\
    \ x <= 120\n      result = 12\n    elsif x <= 130\n      result = 13\n    elsif\
    \ x <= 140\n      result = 14\n    elsif x <= 150\n      result = 15\n    else\n\
    \      result = -1\n    end\n  end\n  \n  return result\nend\n</code>\nThe error\
    \ I was getting with my original code was because I didn't have the if statement\
    \ inside of the else statement. Because of that, I had to nest them together,\
    \ which was fine for my first few tests, but then I realized I had to restart\
    \ the terminal or run the file multiple times after I changed the if statement\
    \ to else statement. I'm not sure why that is, but that's what was causing the\
    \ error. My question now is, is there a way I can make my code work without restarting\
    \ the terminal or running the file multiple times? Thanks.\n<|/ q |>\n<| c |>\n\
    It would help if your question was more specific about what you want.  You state\
    \ \"This program must ", "  return if y > x\n  \n  smallest = y\n  largest = x\n\
    \  \n  while smallest > 0 and largest < y\n    smallest = smallest - 2\n    largest\
    \ = largest + 2\n  end\n  \n  if largest < smallest\n    largest = y\n  end\n\
    \  \n  return\nend\n</cell>\n<text>\nThe choose_num function has a few properties.\
    \ First, it is easy to test. Second, it handles both positive and negative ranges.\
    \ Finally, it returns a number that is an even number if and only if that number\
    \ is in the range [x, y].", "  biggest = x if x > y || x == y then x else y\n\
    \  until biggest == x\n  return biggest\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,rubygems\
    \ dscore=1 |>\n<| c |>\nYou should explain what you are doing so OP can learn\
    \ from it rather than just copying and pasting code into their program.\n<|/ c\
    \ |>\n<| a dscore=0 tags=ruby,ruby-on-rails,rubygems |>\nJust to give a quick\
    \ answer to the question of choose_num.call in Ruby 2.3, it can be done in one\
    \ line (without an additional variable or argument):\n<code>", "  if x != y &&\
    \ x % 2 == 0 && y % 2 == 0\n    return ((x+y)/2).round\n  else\n    return -1\n\
    \  end\nend\n</code>\nI made two changes:\nFirst, I removed parenthesis from the\
    \ if condition, because you were not doing anything with that condition. Secondly,\
    \ I replaced round with round because round is a ruby method.\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYour code is still not correct. Try your example with `choose_num.call(12,\
    \ 15)`.\n<|/ c |>\n<| c |>\n: Thanks for pointing it out. I updated my answer\
    \ accordingly.\n<|/ c |>\n<| c |>\nThe parentheses are just unnecessary noise\
    \ and the fact that it doesn't return the actual number is also unnecessary noise\
    \ to begin with. The whole `choose_num` can be replaced by `return (x+y) / 2.0`.\n\
    <|/ c |>\n<| c |>\nYes and no. I wanted to keep the code as similar as possible\
    \ to the OP's code. In reality, `return (x+y) / 2.0` could return a float, whereas\
    \ `return ((x+y)/2).round` returns a number. Thus, the OP's code was correct in\
    \ returning the actual number.\n<|/ c |>\n<| c |>\nIn other words, `(x+y)/2` returns\
    \ a number and the `.round` method rounds the number to an integer, but `(x+y)\
    \ / 2` returns a float and `.round` rounds the number to a float, which is not\
    \ what you want. You don't want rounding to be applied to the number you want\
    \ to return.\n<|/ c |>\n<| a |>\nIn your code you are missing some things:", " \
    \ x = x.to_i\n  y = y.to_i\n  if x >= y\n    return x\n  else\n    return -1\n\
    \  end\nend", "\t\n\t# First case: If the upper bound is greater than the lower\
    \ bound, then\n\t# the only possible solution is that of the lower bound, which\
    \ is the\n\t# minimum\n\tif x <= y\n\t\treturn x\n\t\n\t# Second case: If the\
    \ upper bound is less than the lower bound, then we\n\t# need to check both lower\
    \ and upper bound because the bigger of\n\t# the two numbers must be equal to\
    \ or bigger than the lower bound\n\telsif y <= x\n\t\treturn choose_num(x, y -\
    \ 1)\n\t\n\t# Third case: If the upper bound is equal to the lower bound, then\
    \ we\n\t# need to check both upper and lower bound because the bigger of the two\n\
    \t# numbers must be equal to or bigger than the lower bound\n\telsif x == y\n\t\
    \treturn choose_num(x, y - 1)\n\t\n\t# Fourth case: We need to check only the\
    \ lower bound\n\telse\n\t\treturn choose_num(x - 1, y)\n\tend\nend", "  p =  0\n\
    \  q =  0\n  x -= 1\n  y -= 1\n  while x >= y\n    p += 1\n    x -= 2\n  while\
    \ y >= x\n    q += 1\n    y -= 2\n  p += 1\n  q += 1\n  if x == y\n    return\
    \ -1\n  if p < q\n    return p\n  return q\nend\n</code>\nAnd now you can simply\
    \ implement choose_num to test whether two integers are in range, by comparing\
    \ the return value of your method with the argument you pass to the method.\n\
    <code>", "  if x <= y\n    min = x\n    maxy = y\n  else\n    miny = y\n    maxx\
    \ = x\n  end\n  \n  until x > y do\n    min = (min < y) ? min : y\n    max = (max\
    \ > y) ? max : y\n    x = x + 2\n    y = y - 1\n  end\n  \n  until x < min do\n\
    \    min = (min < y) ? min : y\n    x = x + 2\n    y = y - 1\n  end\n  \n  until\
    \ y < max do\n    max = (max > y) ? max : y\n    min = (min < y) ? min : y\n \
    \   y = y - 1\n  end\n  \n  return min\nend", "  evens = (0..y).to_a\n  odd =\
    \ (1..x).to_a\n  evens.each do |even|\n    if odd.include?(even)\n      return\
    \ even\n    end\n  end\n  -1\nend", "  (x == nil and y == nil) or x > y ? x :\
    \ (y == nil and x > x) ? x : y\nend\n</code>\nNow you can do the following:\n\
    <code>", "  i = x\n  while i < y\n    if i % 2 == 0\n      i = i + 1\n    else\n\
    \      break\n    end\n  end\n  i\nend\n</cell>\n<text>\nExercise\nRun the function\
    \ with the arguments (5, 8) and then with the arguments (9, 12). Which one comes\
    \ first? Why?", "\tcase x<y\n\t\twhen true\n\t\t\tx\n\t\twhen false\n\t\t\ty\n\
    \t\telse\n\t\t\tx-y\n\tend\nend", "  if x < y then\n    x.upto(y) { |i| return\
    \ i if i % 2 == 0 }\n    return -1\n  end\n  x.upto(y) { |i| return i if i % 2\
    \ == 1 }\nend", "  x -= y\n  i = 1\n  while i <= x\n    if i % 2 == 0\n      return\
    \ i\n    i += 1\n  end\n  -1\nend", "    return 0 if x == y or x < y or x > y\
    \ else x + y if x > y and x % y == 0 \\\n                else choose_num(x, y\
    \ - 1)\nend", "  x_even = (x % 2) == 0\n  y_even = (y % 2) == 0\n  if x_even &&\
    \ y_even\n    return x if x > y ? x :y \n  else\n    return y if x > y ? y :x\n\
    \  end\nend\n</code>\n<|/ a tags=algorithm,ruby dscore=2 |>\n<| a tags=algorithm,ruby\
    \ dscore=2 |>\nTry this:\n<code>", "  if x == 0\n    return -1\n  elsif y == 0\n\
    \    return x\n  elsif (x | y) == 0\n    return choose_num(x - 1, y - 1)\n  elsif\
    \ x % 2 == 0\n    return choose_num(x - 1, y)\n  else\n    return choose_num(x,\
    \ y - 1)\nend", "    evens = []\n    odds = []\n    \n    # Iterate through all\
    \ the numbers in the range [x, y] inclusive\n    for i in (x..y)\n        if i.even?\
    \ # Checks if i is even\n            evens << i # Adds i to evens\n        else\
    \ # Checks if i is odd\n            odds << i # Adds i to odds\n    end\n    \n\
    \    # Since we're only looking for even numbers in the odd range,\n    # just\
    \ return the max of x or y (i.e. the even number).\n    return evens.max || evens.max\n\
    end", "  return nil if x < 0 || y < 0 || x >= y || y > x\n  \n  # We start by\
    \ checking x to see if it's evenly divisible by 2.\n  # If not, we move on to\
    \ y.\n  if x % 2 == 0\n    x = x / 2\n  else\n    x = y / 2\n  end\n  \n  # We\
    \ do the same thing to y.\n  if y % 2 == 0\n    y = y / 2\n  else\n    y = x /\
    \ 2\n  end\n  \n  # Now we check the value of x to see if it's evenly divisible\
    \ by 4.\n  if x % 4 == 0\n    x = x / 4\n  else\n    x = y / 4\n  end\n  \n  #\
    \ Now we check the value of y to see if it's evenly divisible by 8.\n  if y %\
    \ 8 == 0\n    y = y / 8\n  else\n    y = x / 8\n  end\n  \n  return x if x >=\
    \ y\n  return -1\nend", "    return x if x <= y && x % 2 == 0 && y % 2 == 0 else\
    \ -1\nend", "    p =  [x,y].min\n    q = [x,y].max\n    \n    while p * p <= q\
    \ * q\n        p += 1\n    \n    while q * q > p * p\n        q -= 1\n    \n \
    \   return p * q\nend", "  x = x - (x >= y)\n  y = y - (x <= y)\n  x = x if x<y\n\
    \  y = y if y<x \n  x = x if x>y \n  y = y if y>x\n  x = x if x+y>y\n  y = y if\
    \ y+x>x\n  return x if x>y else y\nend", "  if x < y then \n    puts \"The smallest\
    \ number is lower than the biggest.\"\n  elsif x == y then\n    puts \"You choose\
    \ the number #{x}\"\n  else\n    puts \"The biggest number is #{y}\"\n  end\n\
    end", "  # Write your solution here.\n  \n  return -1\n    \n</cell>\n<text>\n\
    Run the following cell to test your solution. Make sure you get '12' and '13'\
    \ as your output.", "\tsmallest = x\n\tlargest = x\n\t\n\tif y <= x\n\t\treturn\
    \ -1\n\t\t\n\tfor i in 1..y\n\t\tif smallest.zero? \n\t\t\tsmallest = 1\n\t\t\t\
    continue\n\t\telsif smallest.even? \n\t\t\tsmallest = 2\n\t\telsif smallest.odd?\n\
    \t\t\tsmallest = 3\n\t\telsif largest == x\n\t\t\tlargest = i\n\t\telse\n\t\t\t\
    largest = i\n\t\tend\n\tend\n\treturn smallest\nend", "  if x < 0 or y < 0\n \
    \   return -1\n  return biggest_even_number(x, y) if y > x else biggest_even_number(x,\
    \ y - 1)\nend\n</cell>\n<text>\nNow let's use our function with our previous functions.",
  "  puts \"The biggest even number between #{x} and #{y} is #{biggest_even(x, y)}\"\
    \nend", "  if x > y\n    x, y = y, x\n  result = -1\n  for i in (0...y)\n    next\
    \ if i % 2 == 0\n    begin\n      result = i\n    end until x > result\n  result\n\
    end", "  if x >= 0 and y >= 0 and x < y and x > y\n    x2 = x * x\n    y2 = y\
    \ * y\n    evens = (x2 - y2)/2\n    odds = (x2 + y2)/2\n    return evens if evens\
    \ % 2 == 0 else odds\n  else\n    return -1\nend", "  x += 1\n  y -= 1\n  \n \
    \ while x < y do\n    if (x % 2 == 0) and (y % 2 == 0) then\n      return x\n\
    \    end\n    x *= 2\n    y *= 2\n  end\n  \n  if x % 2 == 0 then\n    return\
    \ x\n  end\n  \n  -1\nend", "  if x <=> y == 0\n    return -1\n  else\n    if\
    \ x <=> y == -1\n      return -1\n    else\n      if x <=> y == 1\n        return\
    \ -1\n      else\n        x = x-(y+1)\n        y = y-(x+1)\n        choose_num(x,\
    \ y)\n      end\n    end\n  end\nend", "  return nil if x < 0 || x > y || y <\
    \ x\n  \n  even = 1\n  odd = 1\n  \n  while odd < x\n    even *= 2\n    odd *=\
    \ 2\n  end\n  \n  while even < y\n    odd /= 2\n    even *= 2\n  end\n  \n  return\
    \ even - 1 if even > y\nend", "    \n    if x > y\n        min, max = y, x\n \
    \   else\n        min, max = x, y ", "\tbiggest = nil\n\tfor i in [1..x]\n\t\t\
    if (i / 2) <= y\n\t\t\tif (biggest.nil?)\n\t\t\t\tbiggest = i\n\t\t\telsif (biggest\
    \ != i / 2)\n\t\t\t\tbiggest = nil\n\t\t\tend\n\t\tend\n\tend\n\treturn (biggest\
    \ == nil) ? -1 : biggest\nend", "\tsmallest = x\n\tlargest = y\n\twhile x < y\
    \ do\n\t\tsmallest = x\n\t\tx = x + 1\n\twhile y < smallest do\n\t\tlargest =\
    \ y\n\t\ty = y + 1\n\tif smallest * largest > x\n\t\tchoose_num.call(largest,\
    \ smallest)\n\telse\n\t\t-1\nend\n</code>\n<|/ a tags=ruby,loops dscore=1 |>\n\
    <| a dscore=1 |>\nYou can use while loop here. \n<code>", "  num = x\n  while\
    \ (x <= y)\n    if x % 2 == 0\n      x = x + 1\n    else\n      y = y - 1\n  end\n\
    \  num\nend", "  if x > y\n    x, y = y, x\n  lower = x + (y / 2)\n  upper = x\
    \ - y\n  while lower < upper\n    biggest = (lower + upper) / 2 # O(logn)\n  \
    \  if biggest % 2 == 0\n      return biggest\n    else \n      lower = biggest\
    \ + 1\n    \n  return -1\n</cell>\n<cell>\nchoose_num.call(12, 15)\n</cell>\n\
    <text>\nLet's look at what's happening in our functions. First, we can see that\
    \ choose_num iterates over all the numbers we provide, and checks if their number\
    \ is even or not. It then updates the bounds to check our numbers against them.\
    \ Then, when we've found the correct number, we return the value. It does this\
    \ in a while loop that increments by 2 until it finds the correct number. For\
    \ example, when the while loop is at number 6 (which means we're checking against\
    \ 11), it increments by 2 and checks to see if it goes under 11. If it does, then\
    \ it returns 11. If not, it keeps going and checks 6+2, 6+4, etc. until it finds\
    \ the correct number.", "  a1 = x/2\n  a2 = x-a1\n  b1 = y/2\n  b2 = y-b1\n  c\
    \ = (a1*b1 + a2*b2)/2\n  while c % 2 == 0 and a1 != a2 and b1 != b2 and a1 >=\
    \ 0 and b1 >= 0 and a2 <= x and b2 <= y\n    c = (a1*b1 + a2*b2)/2\n  while c\
    \ % 2 == 0 and a1 != a2 and b1 != b2 and a1 >= 0 and b1 >= 0 and a2 <= x and b2\
    \ <= y\n    return c\n  return -1", "  for i in x..y do\n    if i % 2 == 0\n \
    \     num = i\n      break\n    end\n  end", "  begin\n    # Write code here\n\
    \  rescue ArgumentError => err\n    puts \"Please input a valid input\"\n  end\n\
    end", "  z = nil\n  while true\n    z = x * y\n    if z > y\n      break\n   \
    \ end\n    if z % 2 == 0\n      return z\n    end\n    y += 1\n  end\n  -1\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=ruby,fizzbuzz |>\n<code>", "  if x != nil\
    \ and y != nil and x >= 0 and y > x\n    high = x\n    while x >= y and high >=\
    \ y\n      high = high - 1\n    end\n    low = y\n    while x <= high and low\
    \ <= high\n      low = low + 1\n    end\n    if high * low >= x\n      return\
    \ high * low\n    end\n    return nil\n  end\n  return -1\nend\n</code>\nThe recursive\
    \ case is the same as the iterative case.\n<|/ a |>\n<| c |>\nHe said \"without\
    \ using loop\"\n<|/ c |>\n<| c |>\n, I'm pretty sure that OP didn't mean without\
    \ loop, I just said loop is useless in this case (which I guess it is). But hey,\
    \ I thought that maybe he just mean \"without using a loop\".\n<|/ c |>\n<| c\
    \ |>\nI guess OP means without looping (the while loop). Am I right?\n<|/ c |>\n\
    <| c |>\nThat's right. I guess he means without using any looping constructs,\
    \ like `for`, `while`, `until`, etc. :)\n<|/ c |>\n<| c |>\nI don't believe that\
    \ your function works correctly for x = 5, y = 8.\n<|/ c |>\n<| a tags=ruby,arrays,multidimensional-array\
    \ |>\nYou can use recursion to do this:\n<code>", "  x = x.to_i\n  y = y.to_i\n\
    \  return x.succ if x > y && x.succ % 2 == 0 || (x.succ < y && x.succ % 2 != 0)\
    \ || x == y || choose_num.call(-y, x)\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis doesn't work. Try `choose_num.call(4,2)`.\n<|/ c |>\n<| c |>\nThis\
    \ works if `x > y`, otherwise it doesn't work. That's why the return value is\
    \ either `y` or `x`.\n<|/ c |>\n<| c |>\nYou forgot to handle if `x <=> y` returns\
    \ less than zero, which is what happens when `x > y`. Also if `x < y` but `x.succ\
    \ % 2 == 0`, `x` and `y` are not equal, so it returns `x.succ` instead. Also if\
    \ `x == y`, then `y` is returned.\n<|/ c |>\n<| c |>\nThanks for the heads up,\
    \ I fixed it.\n<|/ c |>\n<| a tags=ruby |>\nHere's a solution which uses recursion.\
    \  This is tail-recursive and thus more efficient than using an explicit loop:\n\
    <code>", "  return x if y <= x && x <= y || y <= x && x <= y || y <= x && x <=\
    \ y && x > y ? x : (y if y <= x && x <= y || y <= x && x <= y || y <= x && x <=\
    \ y && x > y ? y : -1)\nend", "  if x > y\n    return x if x.is_a? Integer else\
    \ y\n  else\n    return y if y.is_a? Integer else x\n  end\nend", "  if x <= y\
    \ then\n    if x < y then\n      if x % 2 == 0 then\n        return x / 2\n  \
    \    end\n    end\n  else\n    if y < x then\n      if y % 2 == 0 then\n     \
    \   return y / 2\n      end\n    end\n  end", "    biggest_num = y if x > y else\
    \ x if x < y else -1\n    return biggest_num if biggest_num % 2 == 0 else None\n\
    end", "    \n    \n    \n    \n    return -1\n    ", "  x *= 2\n  y = y / 2\n\
    \  while x != 0\n    if x % 2 == 0\n      if y % 2 == 0\n        x /= 2\n    \
    \    y /= 2\n      else\n        x /= 2\n      end\n    else\n      y /= 2\n \
    \   end\n  end\n  if x == 0\n    return y\n  else\n    return -1\n  end\nend\n\
    </code>\nHere's the same code using recursion:\n<code>", "  smallest = y\n  largest\
    \ = x\n  while smallest > largest\n    smallest = (smallest + largest) / 2\n \
    \   largest = smallest\n    if smallest == largest\n      break\n  end\n  while\
    \ largest < x\n    largest = (largest + x) / 2\n    smallest = largest\n    if\
    \ smallest == largest\n      break\n  end\n  while smallest < y\n    largest =\
    \ (largest - y) / 2\n    smallest = largest\n    if smallest == largest\n    \
    \  break\n  end\n  return smallest\nend", "  if x == nil or y == nil\n    return\
    \ -1\n  end\n  \n  if x > y\n    return choose_num(y, x)\n  end", "  i = 1\n \
    \ while i <= y\n    el = i\n    if el % 2 == 0\n      if x == el\n        return\
    \ el\n      else\n        i += 1\n      end\n    else\n      if x > el\n     \
    \   return x\n      else\n        i += 1\n      end\n    end\n  end", "  result\
    \ = -1\n  while result < x or result > y \n    result = (result + 2) % 6\n  end\n\
    \  puts result\nend", "  result = []\n  x = 3\n  while x <= y do\n    result.push\
    \ x\n    x = x * 2\n  end\n  result.push x\n  result.compact.last\nend", "  if\
    \ x > y\n  \tx = 0\n  elsif x < y\n  \ty = x\n  end", "  return if y <= x\n  \n\
    \  if x % 2 == 0 and y % 2 == 0\n    return if y > x\n  \n    \n  a = (x / 2)\n\
    \  b = (y / 2)\n  if a * b > x and a * b < y\n    return a * b\n  \n  c = ((2\
    \ * x) - 1) / 2\n  d = ((2 * y) - 1) / 2\n  if c * d > x and c * d < y\n    return\
    \ c * d\n  \n  e = (x / (2 * y))\n  f = ((y / x) + 1)\n  if e * f > x and e *\
    \ f < y\n    return e * f\n  \n  g = y / x\n  h = x / y\n  if g * h > x and g\
    \ * h < y\n    return g * h\n  \n  if g > h\n    return g\n  \n  if g < h\n  \
    \  return h\n  \n  if g == h\n    return g\n  \n  if g != h\n    return -1\nend\n\
    </cell>\n<text>\nNow let's check the performance of the new function:", "    return\
    \ 1 if x == y or x == x + y else x\nend", "  return\nend\n</code>\nAnd here is\
    \ what it looks like when we run it with the above two functions:\n<code>\nchoose_num(6,\
    \ 10)", "  even = nil\n  while true\n    even = x % 2 == 0\n    if even == true\
    \ && x < y\n      break\n    end\n    x = x + 1\n  end\n  return even == true\
    \ ? x : -1\nend", "  return nil if x > y\n  ((x - y) / 2..(x + y) / 2).find {|n|\
    \ n > 0 && n.even? }\nend", "  if x < y then\n    x, y = [y, x]\n  end", "  num\
    \ = (x + (y - x)) * (x / y)\n  if num < y\n    return -1\n  elsif num < x\n  \
    \  return num\n  elsif num == y\n    return num\n  end\n  choose_num(x, y)\nend",
  "  return ((x <= y) ? x : ((y > x) ? y : -1))\nend\n</cell>\n<code language=julia-1.0>\n\
    choose_num(12, 15)\n</cell>\n<text>\nA function in Julia can also return a tuple:",
  "  x = x.to_i\n  y = y.to_i\n  return nil unless x >= y && y > 0\n  \n  a = 1\n\
    \  b = y\n  while b > 0\n    (a, b) = (b, a * (a - b) / b)\n  end", "  return\
    \ x.divmod(y).map{|n, i| if n % 2 == 0 && i > x && i <= y; n if n % 2 == 0 &&\
    \ i > x && i <= y; nil }.compact.last\nend", "  return x if y >= x || y > x*x-1\n\
    \  y > x*x ? x*x : -1\nend", "  while y < x\n    if y % 2 == 0\n      x = x +\
    \ 1\n      y = y + 1\n    else\n      x = x + 1\n    end\n  end\n  return x\n\
    end", "  puts(\"Choose a number in the range #{x}, #{y} inclusive\")\n  puts(\"\
    Please enter a positive number\")\n  x = gets.chomp\n  y = gets.chomp\n  return\
    \ x if x < y || x == y && x > 1\n  return y\nend", "  if x > y\n    min, max =\
    \ y, x\n  else\n    min, max = x, y \n  end\n  while min <= max\n    mid = min\
    \ + (max - min) / 2 \n    if mid * mid == x\n      return mid\n    elsif mid *\
    \ mid == y\n      return mid\n    else \n      max = mid - 1\n    end\n  end\n\
    \  -1\nend", "  return y if (y <= x && x <= y && x % 2 == 0) else -1\nend\n</code>\n\
    This code uses the ternary operator if and else keywords. You can learn more about\
    \ them by reading the documentation here.\n<|/ a dscore=0 tags=ruby |>\n<| c |>\n\
    This is great for Python but I am writing this in ruby. Thanks though for trying\
    \ to help me out though. I'm new to programming so I'm a little lost.\n<|/ c |>\n\
    <| c |>\nNo problem! Sorry I didn't notice you were using Ruby. I have added some\
    \ code you can try.\n<|/ c |>\n<| c |>\nThank you! This really helped me understand\
    \ ternary operators better. I am now able to code this with no errors.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nHere's how I would write this:\n<code>", "  return -1\
    \ if x > y\n  num = nil\n  loop do\n    num = rand(x + rand(y - x))\n    break\
    \ if num.even?\n  end\n  num\nend", "  if x <= y && y > 0\n    x -= (y - x + 1)\n\
    \    x *= 10\n    x -= y - (x + 1)\n    y = (x + y) / 2\n  elsif x > y && y >\
    \ 0\n    y += (x - y + 1)\n    y *= 10\n    y -= x - (y + 1)\n    x = (y + x)\
    \ / 2\n  else\n    x = y = -1\n  end\n  return x\nend\n</code>\n<|/ a tags=ruby,math\
    \ |>\n<| a dscore=0 |>\nThe answer provided by was incorrect. I used this and\
    \ it worked perfectly:\n<code>", "  xx = x - 2\n  yy = y - 2\n  even = (xx % 2)\
    \ == 0\n  xx /= 2\n  yy /= 2\n  odd  = (yy % 2) == 0\n  yy /= 2\n  xx /= 2\n \
    \ \n  if even\n    (xx < yy || yy < xx) ? xx+1 : yy+1\n  else\n    (xx < yy ||\
    \ yy < xx) ? yy+1 : xx+1\n  end\nend", "  x = x.to_i\n  y = y.to_i\n  if x > y\n\
    \    y, x = x, y\n  end\n  \n  num = 0\n  while x < y\n    num = num + 2 * x\n\
    \    x = x + 1\n  end\n  return num\nend", "    biggest = y\n    smaller = x\n\
    \    \n    while smaller > biggest\n        biggest = biggest * 2\n        while\
    \ (biggest < smaller)\n            biggest = biggest + 1\n            if biggest\
    \ % 2 == 0:\n                break\n        smaller = smaller / 2\n    end\n \
    \   return biggest - 1\nend\n</cell>\n<cell>", "  ((x < y) == (not (x >= y)))?\
    \ x : (y+1)\nend", "  smallest = 1\n  largest = x\n  even = 0\n  while smallest\
    \ < largest\n    bigger = ((smallest + largest) / 2)\n    if bigger % 2 == 0\n\
    \      if bigger > y\n        smallest = bigger + 1\n      else\n        largest\
    \ = bigger - 1\n      end\n    else\n      if bigger < y\n        smallest = bigger\
    \ + 1\n      else\n        largest = bigger - 1\n      end\n    end\n    even\
    \ += 1 if bigger == even\n  end\n  return even == 0 ? -1 : (smallest - 1)\nend\n\
    </code>\nThe function returns a -1 when there are no even numbers in the range\
    \ [x, y].\nThe variable \"even\" is used to check whether an even number is in\
    \ the range.\nIt seems that you were trying to write a more concise function with\
    \ the same functionality, so I wrote that one instead.\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| c |>\nHow do you know if `smaller` is even or odd? That's a question\
    \ of whether `bigger` is even or odd, which is also a question of whether `smaller`\
    \ contains `bigger`. You can't know that without looking at the code. The OP should\
    \ do that before writing this answer and ask about it.\n<|/ c |>\n<| c |>\nI see\
    \ that you used an alternative way which is more concise. But I think OP is trying\
    \ to learn the way he solved the problem, so I decided to use my code. Since OP\
    \ did not specify what to do for the case where there's only one number in the\
    \ range, the function returns -1 in such cases. But I'll edit my answer with my\
    \ code if OP decides to modify it for one number in the range by myself.\n<|/\
    \ c |>\n<| c |>\nThank you so much. This is really helpful.\n<|/ c |>\n<| c |>\n\
    I updated my answer. Sorry if I missed your earlier comment. I think it's good\
    \ now.\n<|/ c |>\n<| a tags=ruby |>\nYour code does not behave like you want it\
    \ to. If you have a range [a, b] you need to decide whether a is smaller than\
    \ b or b is smaller than a. That is what the variables \"smaller\" and \"largest\"\
    \ do:\n<code>\nsmaller = b if b < a\nlargest = a\n</code>\nNow you can find the\
    \ smallest number in a range that is a multiple of b:\n<code>\nsmallest = (b *\
    \ a.floor) / 2\n</code>\nAnd now you can find out whether that number is even:\n\
    <code>\neven = ((b * a.floor).to_f % 2) == 0", "  if x > y\n    x, y = [y, x]\n\
    \  a = x % y\n  b = (x - a) / y\n  while (b > 0)\n    if (b % 2 == 0)\n      x\
    \ = a + 1\n      break\n    a = a + 1\n    b = (b - 1) / 2\n  else\n    x = a\
    \ + 1\n  end\n  x\nend\n</code>\nThis was the solution that I got from my friend:\n\
    <code>", "  if x <= y \n  then return y\n  else return x\nend\n</code>\n<|/ q\
    \ dscore=0 |>\n<| c |>\nYour problem is that the function choose_num is never\
    \ called. I don't know why it is never called, but there is an extra end  in your\
    \ function definition.\n<|/ c |>\n<| c |>\nIn addition, you are calling the function\
    \ but you do not specify an argument.\n<|/ c |>\n<| c |>\nPlease show how you\
    \ call the function and how you call this function\n<|/ c |>\n<| c |>\nI added\
    \ the function definition to my original post. Thank you! I didn't realize that\
    \ my function definition was the problem, but I fixed it and now it works. Thank\
    \ you!\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  return nil if x > y\n\
    \  \n  return y if x % y == 0\n  return y", "\tfor i in [x, y]\n\t\tbreak if i\
    \ >=0 && i <= 10\n\telse\n\t\treturn -1\n\treturn (i * i + i).ceil\nend", "  x\
    \ = x.to_i\n  y = y.to_i\n  return -1 if x <= y || y <= x\n  y = y - 1\n  until\
    \ x == y\n  x = x\n  y = y - 1\n  until x == y\n  x\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| c |>\nIt doesn't work. it gives me this error\n`ArgumentError:\
    \ wrong number of arguments (2 for 0)\n    from (irb):8:in `choose_num'\n    from\
    \ (irb):8\n    from /Users/kristinanthonybower/.rvm/rubies/ruby-2.5.3/bin/irb:11:in\
    \ `<main>'`\n<|/ c |>\n<| c |>\nIt works for me. I am running this on ruby 2.5.3\n\
    <|/ c |>\n<| c |>\nI have added a code example and output to the answer.\n<|/\
    \ c |>\n<| c |>\nThis is amazing, thank you. I still don't understand how the\
    \ code works, but this is a great example of how to implement the function. I\
    \ was trying to use loops and arrays but this works just as well. I think I understand\
    \ the code now but thank you for showing me this!\n<|/ c |>\n<| c |>\nThis code\
    \ is not the best. This code is in no way efficient.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI recommend you to write a new function, which checks if given range is\
    \ valid, e.g.:\n<code>", "    even = x/2\n    odd = x%2\n    if even == y and\
    \ odd != y\n        return even\n    elsif even == y and even != y\n        return\
    \ odd\n    elsif odd == y and even != y\n        return even\n    elsif odd ==\
    \ y and odd != y\n        return odd\n    return -1", "  while x <= y do\n   \
    \ num = x % 2\n    x = x + 1\n    y = y % 2\n  end\n  if x > y\n    return x \n\
    \  else\n    return y\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks\
    \ so much, I appreciate the explanation too! The code works but doesn't output\
    \ the correct result. For example, if I run it on the first set of test cases\
    \ it works fine but on the second set it doesn't output the correct answer or\
    \ give any error.\n<|/ c |>\n<| c |>\nI tested it on the provided link, and it\
    \ works fine. I will update the answer with a new solution.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThis is my solution:\n<code>", "  x = x.to_i\n  y = y.to_i\n  case x <=>\
    \ y\n  when 0\n    x\n  when 1\n    y\n  when -1\n  end\nend", "    return y if\
    \ y <= x || y <= x / 2 || y <= x * x / 2\n    return -1\nend", "    biggest =\
    \ y\n    while x < biggest\n        biggest = x\n        x = x + y\n    end\n\
    \    return biggest\nend\n</code>\n<|/ a dscore=3 tags=ruby,loops |>\n<| a dscore=3\
    \ tags=ruby,loops |>\nIn Ruby 1.9.2, you can just do this:\n<code>", "  x = x.to_i\
    \ if x.is_a? Integer\n  y = y.to_i if y.is_a? Integer\n  smallest_num = y\n  biggest_num\
    \ = x\n  loop = true\n  while loop\n    biggest_num = biggest_num + 1 \n    if\
    \ biggest_num >= y\n      loop = false\n    end\n  end\n  smallest_num = smallest_num\
    \ - 1\n  loop = true\n  while loop\n    smallest_num = smallest_num + 1 \n   \
    \ if smallest_num <= x\n      loop = false\n    end\n  end\n  if smallest_num\
    \ > biggest_num\n    smallest_num\n  else\n    biggest_num\n  end\nend", "  if\
    \ x..y == 0\n    return -1\n  m = x\n  n = y\n  while m != n\n    m += m\n   \
    \ n += n\n  end\n  return m\nend\n</code>\n<|/ a |>\n<| c |>\nI like this, except\
    \ that it is slower than the builtin `max_by` method (10ms vs 100ms in my test).\n\
    <|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", "  num = -1\n  \n  # We start\
    \ at y. If x is smaller than y, we'll get an infinite loop. \n  # So we check\
    \ if y is smaller before starting the loop.\n  until num >= x\n    \n    # If\
    \ the number is bigger than x, we check if it is divisible by x. \n    # If it\
    \ is, then we set num to that number and we're done.\n    until num % x == 0\n\
    \      \n      # If the number is smaller than x, and it is divisible by x, we\n\
    \      # set num to the previous number and set y to x + 1. \n      # We do this\
    \ so that we keep adding 2 to the number each time \n      # until it is divisible\
    \ by x, and finally return the last \n      # number that isn't divisible by x.\n\
    \      until num % x == 0 and num != 0\n        num = num + 2\n        y += 1\
    \ \n      end\n    end\n  end\nend\n</cell>\n<cell>\nchoose_num(10,25)\n</cell>\n\
    <text>\nExercise\nWrite a function that takes three numbers as input and returns\
    \ the sum of the squares of the first two numbers, if the first two numbers are\
    \ positive. If the first two numbers are negative, return -1. Use the choose_num\
    \ function you defined above for this. You don't need it to be super fast or efficient,\
    \ but it should work. Make sure you use return instead of puts.", "  while x <\
    \ y\n    x += (x + 1) // 2\n  end", "  num = -1\n  x = [1, 2, 3]\n  y = [4, 5,\
    \ 6]\n  \n  x.each do |i|\n    if i <= y && i <= x\n      num = i\n      break\n\
    \    end\n  end\n  \n  y\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\n\
    Thank you for the help! I appreciate it!\n<|/ c |>\n<| a dscore=1 tags=ruby |>\n\
    Here's my take on it:\n<code>", "  return nil if x < y or x > y\n  \n  return\
    \ x if x % 2 == 0\n  \n  y = y - 1\n  return choose_num(x, y) unless y > 0\n \
    \ \n  choose_num(x, y)\nend", "  x = x.to_i\n  y = y.to_i\n  \n  if((x > y) ==\
    \ true)\n    puts \"Invalid range\"\n    exit 1\n  elsif((x == 0) == true)\n \
    \   return y\n  elsif((y == 0) == true)\n    return x\n  elsif((x < 0) == true)\n\
    \    return choose_num(x + 1, y)\n  elsif((y < 0) == true)\n    return choose_num(x,\
    \ y - 1)\n  elsif((x == y) == true)\n    return x\n  else\n    return choose_num(x\
    \ - 1, y)\nend", "  return x + (y - x) / 2\nend", "    return ((x % 2 == 0 and\
    \ y % 2 == 0) or \n            (x % 2 == 1 and y % 2 == 1))\nend", "  case x <=>\
    \ y\n  when 0\n    -1\n  when 1\n    x\n  when -1\n    y\n  when -1\n    -1\n\
    \  when 1\n    y\n  else\n    x + (y - (x % y))\n  end\nend\n</code>\nThis approach\
    \ is more robust and more performant than the approach above, which could fail\
    \ to give the correct answer when x or y is negative.\n<|/ a tags=ruby |>\n<|\
    \ c |>\nI used this answer as a starting point for my project and I decided to\
    \ write a separate answer that shows the full source of this answer, and shows\
    \ a benchmark test to compare the approaches against each other here: http://stackoverflow.com/questions/40576568/how-to-find-a-number-that-is-greater-than-one-or-equal-to-the-other-number\n\
    <|/ c |>\n<| a dscore=3 |>\nThis is a solution using the binary search method\
    \ on Array. It uses a while loop which is less efficient than other approaches\
    \ posted so far but more readable.\n<code>", "  if x == 0 || y == 0\n    -1\n\
    \  else\n    (((x % 2 != 0) && (y % 2 == 0)) ? x - y : (x + y) % 2)\nend\n</code>\n\
    Then the function can be called with a single statement:\n<code>\nchoose_num.call\
    \ 12, 15\n</code>\nTo find out more about Ruby's syntax and some useful Ruby tricks,\
    \ try reading the Ruby Way book on Ruby or this Ruby tutorial. Also, Ruby has\
    \ some nice documentation on their website: http://www.ruby-lang.org\nHope this\
    \ helps!\n<|/ a dscore=2 tags=ruby,arrays |>\n<| c |>\nThis is just what I was\
    \ looking for. Thank you very much!\n<|/ c |>\n<| a tags=ruby,arrays dscore=1\
    \ |>\nHere is one way of doing it:\n<code>", "  if x && y\n    return if (x >\
    \ y)\n      x + (y - x)\n      -1\n  else\n    -1\nend", "  if x >  y \n    x\
    \ , y , num = x , y , x \n  else\n    x , y , num = y , x , y \n  end\n  num.upto(num.succ)\
    \ do |n|\n    if n % 2 == 0 \n      return n\n    end\n  end\n  return -1\nend",
  "    smallest_of_x = x if x < y else y\n    biggest_of_x = x if x > y else y\n \
    \   i = smallest_of_x + 1\n    while i < biggest_of_x\n        if i % 2\n    \
    \        return i\n        i += 1\n    return -1", "  range = get_range(x, y)\n\
    \  if range.empty?\n    -1\n  else\n    range.max.to_i\n  end\nend", "  a = b\
    \ = 0\n  while a < x and b < y:\n    if a % 2 == 0:\n      a += 1\n      continue\n\
    \    if b % 2 == 0:\n      b += 1\n      continue\n    if a > b:\n      a += 1\n\
    \    else:\n      b += 1\n  end\n  a\nend\n</code>\nHere we have two counters:\
    \ a and b. Initially a is 0, b is 0. The while loop iterates while a is less than\
    \ x, and b is less than y. So for the first iteration, a is 0 and b is 0 as well.\
    \ Then, a becomes 1 and b is 1. The condition a < x evaluates to true since a\
    \ is 1, b is 1. If we increment a, the condition is now a < 1. Now b becomes 2.\
    \ Since b is less than y, we increment it. Now, a is 2 and b is 2. Finally, a\
    \ is 3, b is 2. The condition is now a < 3, and b < 2. The condition is now b\
    \ < 3. The condition is now b < 3. The condition is now b < 3. The condition is\
    \ now a < 3, and b < 3. The condition is now a < 3. a is 3, and b is 3. The while\
    \ loop terminates. Now a is 3, and b is 3. Since a is less than x, we return a,\
    \ which is 3.\n<|/ a tags=ruby,algorithm |>\n<| c |>\nThat would be an O(n\xB2\
    ) solution. I guess it would be better as a O(n) solution if you do `if a > b`\
    \ in the loop.\n<|/ c |>\n<| c |>\nYes, you're right. I was thinking of a problem\
    \ where there are two numbers being compared, and `a` could be at most `y`, so\
    \ it's really O(n). I updated my answer. Thanks!\n<|/ c |>\n<| c |>\nThis is an\
    \ elegant solution, however I don't really understand how this algorithm works.\
    \ How would I implement this in Ruby? I'm a total beginner in Ruby, and I've been\
    \ trying to figure out how to solve this algorithm with arrays and loops for a\
    \ few hours.\n<|/ c |>\n<| a |>\nI guess you can do it in O(n) by doing the following\
    \ things.\nTake any two numbers, say x and y. To check if there is a number between\
    \ them, you simply have to", "  for i in [x, y]\n    return i.to_i if i.to_i >\
    \ i > -1 and i.to_i < x\n  end\n  -1\nend\n</cell>\n<code language=conda-root-py>\n\
    choose_num.call(8, 10)\n</cell>\n<text>\nLet's test your function in the next\
    \ cell:", "  x = [x | 0, y | 0]\n  x.reverse!\n  nums = Array.new", "  max = -1\n\
    \  min = x\n  until min > y\n    max = min if min > y else y\n    min = max if\
    \ max < x else x\n  end\n  max\nend\n</code>\n<|/ a dscore=3 tags=ruby,recursion\
    \ |>\n<| a dscore=2 |>\nI like how simple the answer is, but I came up with a\
    \ slightly more interesting solution. Here it is in Ruby\n<code>", '    return
    x if x > y ? x : y if y > x ? y : -1', "  if x > 0\n    x.upcase!\n  else\n  \
    \  x.downcase!\n  end\n  y = y.upcase if y > 0\n  while true\n    return -1 if\
    \ y == 0\n    return 1 if x == y\n    x.next!\n  end\nend\n</code>\n<|/ a tags=ruby,infinite-loop,recursion\
    \ dscore=2 |>\n<| c |>\nWhy are you modifying `x` and `y` after passing them into\
    \ this function?\n<|/ c |>\n<| c |>\nOops, forgot to remove that. I've updated\
    \ the answer to remove that line and explain the rest.\n<|/ c |>\n<| c |>\nThis\
    \ is really clever, but I wouldn't want to use it. It's not what I'd call readable,\
    \ and I'd like to see an explanation of what you've done.\n<|/ c |>\n<| c |>\n\
    , I've added an explanation of this code.\n<|/ c |>\n<| a tags=ruby,infinite-loop,recursion\
    \ |>\nThe way I do this is by first checking if I have an even number of inputs\
    \ and then check if I am on the boundary between even and odd. So I check if my\
    \ number is even. If I am, then my number is odd and I just need to recursively\
    \ call my method with the two numbers. If I don't, then my number is even and\
    \ I call my method with one number less.\nThe recursive method is called like\
    \ this: \n<code>\nodd_or_even(12, 15)\n</code>\nAnd here is my solution:\n<code>",
  "  x += 1\n  y += 1\n  while x <= y do\n    # Using Integer division to make sure\
    \ the divisor \n    # is always even\n    if x % 2 == 0\n      x /= 2\n    else\n\
    \      y = (y + 1) >> 1\n    end\n  end\n  return x\nend\n</cell>\n<code language=julia-1.0>\n\
    choose_num.call(12, 15)\n</cell>\n<code language=julia-1.0>\nchoose_num.call(15,\
    \ 12)\n</cell>\n<text>\nExercise 3\nWrite a function that takes a positive integer\
    \ $n$ and returns the factorial of $n$.", "  i = 1\n  while i < y do\n    i =\
    \ i * 2\n    if i % x == 0\n      return i\n  end\n  -1\nend\nchoose_num.call(10,\
    \ 20)\n</cell>\n<cell>", "  x = x.to_i\n  y = y.to_i\n  if x > y then\n    return\
    \ y\n  end\n  \n  # Find the highest even number that has two even numbers\n \
    \ # after it in the range [x, y] inclusive.\n  # The loop should go through this\
    \ numbers from \n  # [x, y-1] up to [x, y].\n  for i in x-1, y, x do\n    if i\
    \ % 2 == 0 then\n      if i != y and i % 2 == 0 then\n        return i\n     \
    \ end\n    end\n  end", "\tbiggest_num = biggest_even = x\n\t\n\twhile x <= y\n\
    \t\tif big_even_num?(x, biggest_even)\n\t\t\tbiggest_even = x\n\t\telse\n\t\t\t\
    biggest_even = biggest_num\n\t\tend\n\t\tx += 1\n\tend\n\tbiggest_even\nend",
  "  \n  # Write your code here.\n  n = nil\n  if x > 0\n    i = 2\n    while i <=\
    \ x\n      n = x * i\n      if n % 2 != 0\n        break \n      end\n      i\
    \ += 1\n    end\n  end\n  \n  if y > 0\n    m = nil\n    while m <= y\n      m\
    \ = y / x\n      if m % 2 != 0\n        break \n      end\n      y -= 1\n    end\n\
    \  end\n  return n if n != nil\n  return m if m != nil\n  return -1\nend", " \
    \ case x && y\n  when x < y then nil\n  when x == y then x\n  when x > y then\
    \ y\n  else -1\n  end\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nRuby\
    \ doesn't have a `case` statement. Your example is equivalent to `case x && y`\
    \ followed by `when x < y`.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nI know this\
    \ is an old thread, but I just want to share my take on this question to help\
    \ those searching for a solution.\nThe trick is to iterate through your array\
    \ of numbers and return the lowest number that doesn't exist in the range you're\
    \ looking for. \n<code>", "  x = x.to_i\n  y = y.to_i\n  i = if x > y\n      \
    \  x + 1\n      else\n        y + 1\n      end", "\tx = x.to_i\n\ty = y.to_i\n\
    \t\n\treturn -1  if x == y  or x == 0 or y ==0", "  if y > x\n    tmp = x\n  \
    \  x = y\n    y = tmp\n  end\n  while y >= 0 && y <= x\n    y >>= 1\n  end\n \
    \ y += 1\n  return y if y == x || y > x\n  y\nend\nputs choose_num.call(1, 2)"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
