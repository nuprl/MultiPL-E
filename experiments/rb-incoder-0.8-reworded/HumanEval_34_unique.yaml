name: HumanEval_34_unique
language: rb
prompt: "# Return sorted unique elements in an array\n# >>> unique.call([5, 3, 5,\
  \ 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n\
  \    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"
completions: ["  if l == nil\n    return nil\n  end\n  \n  last = nil\n  l.each {\
    \ |x| last != x ? last = x : (last.dup == x ? last = nil : last) }\n  last\nend",
  "  l = l.to_a\n  l = l.map(&:to_i)\n  Hash[l.uniq.sort_by(&:to_i)]\nend", "  l.uniq!\n\
    \  l\nend", "  l.sort!\n  l.reverse!\n  l.uniq!\n  l.reverse!\n  l\nend", "  #\
    \ use set to avoid duplicating elements\n  set = []\n  for x in l\n    set <<\
    \ x if !set.include?(x) end\n  end\n  return set\nend", "  l.uniq\nend", "  l\
    \ = l.to_a\n  l.uniq\nend", "  if l.length == 0\n    []\n  else\n    l.uniq.sort\n\
    \  end\nend\n</code>\n<|/ a tags=unique,ruby,sorting,arrays dscore=5 |>\n<| a\
    \ |>\nYou can use uniq and sort_by:\n<code>\na = [1,4,5,1,3,0,1,2,1,0,5,0,5,4,2,1,3]\n\
    a.uniq.sort_by{rand}\n</code>\n<|/ a tags=unique,ruby,sorting,arrays dscore=5\
    \ |>\n<| c |>\nThis is the best answer.  It does not sort by value at all.  It\
    \ returns an array with the unique values that you want.\n<|/ c |>\n<| c |>\n\
    I believe the question was asking for the unique values in *order* as they are\
    \ in the array. This is what OP needs.\n<|/ c |>\n<| c |>\n`uniq` and `sort_by`\
    \ together does the job.\n<|/ c |>\n<| c |>\nThis solution does not preserve order\
    \ when sorting.\n<|/ c |>\n<| a tags=unique,ruby,sorting,arrays dscore=5 |>\n\
    If you want to preserve order while removing duplicates, you can try this:\n<code>",
  "  l.uniq!\nend", "  l.uniq!\n  l\nend", "  l.compact.uniq\nend", "  seen = {}\n\
    \  ret = []\n  l.each{|i| seen[i] = true; ret.unshift(i)}\n  ret\nend", "    l.uniq!\n\
    end", "  l.sort\n  result = []\n  l.each do |i|\n    next if result.include?(i)\n\
    \    result << i\n  end\n  result\nend", "  l.sort\n  l.reverse!\n  l.reject!\
    \ { |e| l.count(e) > 1 }\n  l.uniq\nend", "  l.uniq.sort\nend", "  # Sort by length\n\
    \  l = l.sort { |a, b| a.length <=> b.length }\n  # Return first instance of each\
    \ unique element\n  l[0...-1].uniq\nend\n</code>\nAs you can see, this is much\
    \ easier to read than the answer provided by Matt B.\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks, I like your solution, much more elegant.\n<|/ c |>\n<| a dscore=0\
    \ |>\nIn case someone is looking for something similar in Ruby 1.9:\n<code>",
  "  l.uniq!\n  l\nend", "  l.uniq!\nend", "  s = l.clone\n  s.sort { |a,b| a <=>\
    \ b }\n  s.uniq\nend", "  l.uniq!\nend\naliased(:unique, :uniq)", "  return l[l.uniq!]\n\
    end", "  return l.uniq\nend", "  l.sort!\n  i = 1\n  while i <= l.length\n   \
    \ if l[i-1] != l[i]\n      break\n    i += 1\n  l[0..i-1]\nend", "  return l.uniq.sort\n\
    end", "  l.each_with_object({}) { |x,h| h[x] ||= x}.values.sort\nend", "  l.uniq!\n\
    \  l\nend", "    l.sort\n    l = l.uniq\nend", "  return l.uniq.sort\nend", " \
    \ l.uniq!\n  l\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\n`uniq` is\
    \ the best answer here.  However, `uniq!` will mutate the receiver.  A safer alternative\
    \ would be to use `Array#uniq`, which does not mutate the receiver.\n<|/ c |>\n\
    <| c |>\nIt will return the original array, and that may be the intent in some\
    \ cases.\n<|/ c |>\n<| c |>\nYes, but this answer doesn't do that either.  The\
    \ `!` means \"not unique\".\n<|/ c |>\n<| c |>\n`uniq!` is safer as it does not\
    \ mutate the receiver.\n<|/ c |>\n<| c |>\nIt's a nice solution, though you should\
    \ clarify that `#uniq!` modifies the receiver.  Also, you should probably add\
    \ a caveat that `#uniq` can mutate it by adding `!` to the end.  That's why I\
    \ deleted my answer, but I'll leave it here anyway.\n<|/ c |>\n<| a dscore=2 |>\n\
    How about something like\n<code>", "  l.uniq!\n  l\nend", "  l.uniq\nend", " \
    \ # Remove duplicates\n  l.reject { |e| l.index(e) == l.lastIndexOf(e) }\nend",
  '  l.sort!', "  l.sort\n  l.reject(&:==).uniq\nend\n</code>\n<|/ a |>\n<| c |>\n\
    `uniq` returns an Array though. `sort` returns an Array and `uniq` returns an\
    \ Array\n<|/ c |>\n<| a tags=ruby,arrays dscore=4 |>\nI find this to be the cleanest\
    \ way to deal with it\n<code>", "  return l.uniq\nend", "  l.uniq\nend", "   \
    \ seen = {}\n    i = 0\n    while i < l\n        j = i\n        while j < l\n\
    \            j += 1\n            if j not in seen or seen[j] == l[i]\n       \
    \         seen[j] = l[i]\n                i += 1\n            end\n        end\n\
    \    end\n    return seen.values_at(0, i)\nend", "  l.uniq!\nend", "  l.uniq!\n\
    \  l\nend", "  uniq, idx = [], []\n  l.each_with_index { |x,i| uniq.push(x) if\
    \ uniq.index(x) == i } unless l.nil?\n  uniq\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This was my first thought but your implementation returns `[3, 3, 5, 5]` instead\
    \ of `[0, 2, 3, 5, 9, 123]`\n<|/ c |>\n<| c |>\nNo, it only returns unique elements\
    \ not duplicates. So it returns `[5,5,3]` instead of `[0,5,3]`\n<|/ c |>\n<| a\
    \ |>\nTo return unique elements in an Array without using uniq or sort_by, I came\
    \ up with this:\n<code>", "  l.sort.uniq.join\nend", "  l = l.to_a\n  l.sort!\n\
    \  l[1..-1]\nend", "  l.uniq\nend\nend", "  l.sort &\n  (l.uniq)\nend", "  uniq\
    \ = Hash.new{|h,k| h[k] = true }\n  l.each {|x| uniq[x] = false }\n  uniq.keys.sort.each{|x|\
    \ uniq[x] = true }\nend", "  return l.uniq.sort\nend", "  seen = {}\n  l = l.sort.uniq\
    \ \nend", "  return l.uniq\nend", "  l.sort {|a,b| a.lt(b) ? -1 : a.eq(b) ? 0\
    \ : 1} \n  l.uniq!\nend\n</code>\n<|/ a |>\n<| c |>\nI like this solution, because\
    \ it works for arrays of anything with a #== method. An array of hashes can still\
    \ be sorted and then #uniq! will eliminate duplicate hashes. A common use case\
    \ is to sort an array of hashes by the date attribute of each.\n<|/ c |>\n<| a\
    \ dscore=1 tags=ruby,arrays |>\n<code>\na = Array.new(3, 0)\na[0] = 5\na[1] =\
    \ 3\na[2] = 3\na.sort!\na.shift\n</code>\n<|/ a |>\n<| a tags=ruby,arrays dscore=0\
    \ |>\n<code>", "    uniques = []\n    uniques2 = []\n    uniques3 = []\n    uniques4\
    \ = []\n    uniques5 = []\n    uniques6 = []\n    uniques7 = []\n    uniques8\
    \ = []\n    uniques9 = []\n    uniques10 = []\n    uniques11 = []\n    uniques12\
    \ = []\n    uniques13 = []\n    uniques14 = []\n    uniques15 = []\n    uniques16\
    \ = []\n    uniques17 = []\n    uniques18 = []\n    uniques19 = []\n    uniques20\
    \ = []\n    uniques21 = []\n    uniques22 = []\n    uniques23 = []\n    uniques24\
    \ = []\n    uniques25 = []\n    uniques26 = []\n    uniques27 = []\n    uniques28\
    \ = []\n    uniques29 = []\n    uniques30 = []\n    uniques31 = []\n    uniques32\
    \ = []\n    uniques33 = []\n    uniques34 = []\n    uniques35 = []\n    uniques36\
    \ = []\n    uniques37 = []\n    uniques38 = []\n    uniques39 = []\n    uniques40\
    \ = []\n    uniques41 = []\n    uniques42 = []\n    uniques43 = []\n    uniques44\
    \ = []\n    uniques45 = []\n    uniques46 = []\n    uniques47 = []\n    uniques48\
    \ = []\n    uniques49 = []\n    uniques50 = []\n    uniques51 = []\n    uniques52\
    \ = []\n    uniques53 = []\n    uniques54 = []\n    uniques55 = []\n    uniques56\
    \ = []\n    uniques57 = []\n    uniques58 = []\n    uniques59 = []\n    uniques60\
    \ = []\n    uniques61 = []\n    uniques62 = []\n    uniques63 = []\n    uniques64\
    \ = []\n    uniques65 = []\n    uniques66 = []\n    uniques67 = []\n    uniques68\
    \ = []\n    uniques69 = []\n    uniques70 = []\n    uniques71 = []\n    uniques72\
    \ = []\n    uniques73 = []\n    uniques74 = []\n    uniques75 = []\n    uniques76\
    \ = []\n    uniques77 = []\n    uniques78 = []\n    uniques79 = []\n    uniques80\
    \ = []\n    uniques81 = []\n    uniques82 = []\n    uniques83 = []", "  uniq.call(l).sort\
    \ rescue l\nend", "    l.uniq!\n    l\nend", "  seen = []\n  u = []\n  for x in\
    \ l\n    if !seen.include? x\n      seen << x\n    else\n      u << x\n    end\n\
    \  end\n  return u\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a tags=ruby\
    \ |>\n<code>", "  l.uniq!\n  l\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is an easy way to do this in Ruby:\n<code>", "  l.uniq\nend", "   \
    \ l.sort!\n    return l if l.uniq.empty? else l.uniq\nend", "  l.uniq!\n  l\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for pointing this out for Ruby\
    \ 1.8 and Ruby 2.1. I should have been more specific in the question.\n<|/ c |>\n\
    <| c |>\nThe question does say \"Ruby 1.9\". Also, this answer doesn't show how\
    \ to sort the unique elements.\n<|/ c |>\n<| c |>\nI did that to make sure people\
    \ are aware of the method and why it's not suitable for Ruby 1.9 or Ruby 2.0.\n\
    <|/ c |>\n<| c |>\nThis is not the answer to the question I asked.\n<|/ c |>\n\
    <| c |>\nThe question was how to remove duplicates. In addition to the other answers,\
    \ this answer doesn't even use Hash#uniq!, so the down-votes seem a bit harsh.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\na = [5,3,5,2,3,3,9,0,123]", "  seen = Set.new\
    \ # Set of seen elements\n  uniques = []\n  l.each do |e|\n    if !seen.include?(e)\n\
    \      uniques << e\n      seen << e\n    end\n  end\n  uniques\nend", "  l.uniq!\n\
    end", "  h = {}\n  l.map { |x| h[x] ||= []; h[x] << x }\n  h.map { |k, v| v |\
    \ v }.flatten\nend", "  l.sort { |a, b| b <=> a } \n  l.reject { |a| l.count(a)\
    \ == 1 }\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  return l.uniq\nend", " \
    \ l.uniq!\n  l\nend", "  # https://ruby-doc.org/stdlib-2.3.1/libdoc/set/rdoc/Set.html#method-i-uniq\n\
    \  # The method returns the unique elements in the set as an array.\n  # Returns\
    \ nil if the set is empty.\n  return l.uniq.sort if l.length\n  nil\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nNice solution, but for me the sorting was the real\
    \ reason. My array contained many strings with newlines in them, and sorting was\
    \ really slow. But `uniq` was a huge help.\n<|/ c |>\n<| a tags=arrays,ruby,duplicates,duplicates\
    \ |>\nI like to use this method, that also removes the duplicates and returns\
    \ the original array:\n<code>", "  l.sort!\n  l.reject!(&:blank?).uniq!\nend\n\
    </pre>\n<pre>", "  return l.sort.uniq\nend", "  u = []\n  for i in l\n    if !u.include?(i)\n\
    \      u << i\n    end\n  end\n  u\nend", "  return l.uniq unless l.empty?\n \
    \ l.sort\n  l.reverse\n  l\nend", "  # Return sorted unique elements in an array\n\
    \  v = l.sort.uniq { |x| x }\n  v.length < l.size ? v : nil\nend", "    l.uniq!\n\
    \    l\nend\n</code>\n<|/ a tags=ruby,arrays dscore=5 |>\n<| c |>\nThis does not\
    \ answer the question in any way. It doesn't even attempt to answer the question.\n\
    <|/ c |>\n<| c |>\nI realized that I could have just edited the answer and posted\
    \ a new version of it since you were already posting pretty much the same answer\
    \ as I have. My point is this answer is better than most of the other answers,\
    \ because it addresses the question explicitly, and the others do not.\n<|/ c\
    \ |>\n<| c |>\nThe answers below are much more complete.  You should consider\
    \ selecting whichever answer you think best answered the question as best and\
    \ accept it.\n<|/ c |>\n<| c |>\nWhile this may be a good answer to the question,\
    \ it's hard to understand why this answer was chosen as the answer to the question.\
    \ There are a lot of good answers below and no one explains why the original question\
    \ was asked. This is the answer that explains why the original question was asked.\n\
    <|/ c |>\n<| c |>\nI appreciate the sentiment and upvotes.  I guess my choice\
    \ of wording was unfortunate.  Hopefully this helps people coming from a search\
    \ engine.  I'm glad you find it helpful though.  I always strive to answer questions.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\nIn Ruby 1.9.2:\n<code>\na = [5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123]\na.uniq.sort", "  l.sort #sort before calling uniq!\n  l.reject\
    \ { |a| a.next == a } #reject duplicate elements\nend", "  # Use a hash table\
    \ for lookup\n  # >>> h = {}\n  # >>> unique.call(h, 5)\n  # 0\n  # >>> unique.call(h,\
    \ 5)\n  # 0\n  # >>> h[5]\n  # 0\n  # >>> unique.call(h, 5)\n  # 0\n  # >>> h[5]\n\
    \  # 0\n  # >>> unique.call(h, 2)\n  # 1\n  # >>> h[2]\n  # 1\n  # >>> unique.call(h,\
    \ 3)\n  # 1\n  # >>> h[3]\n  # 1\n  # >>> h[6]\n  # 1\n  # >>> unique.call(h,\
    \ 6)\n  # 1\n  # >>> unique.call(h, 7)\n  # 2\n  # >>> h[7]\n  # 2\n  # >>> h[8]\n\
    \  # 2\n  # >>> h[9]\n  # 3\n  # >>> h[10]\n  # 3\n  # >>> h[11]\n  # 3\n  # >>>\
    \ h[12]\n  # 3\n  # >>> h[13]\n  # 4\n  h = {}\n  for i in l do\n    h[i] = 0\n\
    \  end\n  l.each do |x|\n    h[x] = x\n  end\n  # Sort and return\n  keys = h.keys.sort\n\
    \  keys.each do |key|\n    break if h[key] == key\n    h[key] = key\n  end\n \
    \ return keys\nend", "  l.sort\n  r = []\n  i =0\n  while i < l.length\n    if\
    \ r[i] != l[i]\n      r.push l[i]\n      i += 1\n    end\n  end\n  r\nend", '  result
    = Set[]', "  return l.uniq\nend", "  return l.uniq\nend", "  l.sort.reduce([])\
    \ do |a, v| a << v if a.last != v then a << v else a end\nend\n</code>\nI haven't\
    \ tested this with huge lists, but it should be fine.\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI actually like this approach, it's elegant.\n<|/ c |>\n<| c |>\n\
    , It's probably the most elegant and most efficient solution, but I suspect that\
    \ someone (@bdonlan) will come along and suggest `uniq` since that method comes\
    \ from the standard library. Which one should I choose?\n<|/ c |>\n<| c |>\n-\
    \ I think `uniq` is the most elegant solution. Why do you think `uniq` is more\
    \ efficient? It has to do a little extra work to do the initial checks to see\
    \ if the value already exists -- and that may or may not be a lot more work than\
    \ a custom sort.\n<|/ c |>\n<| c |>\n`uniq` does a lot more. Check out the source\
    \ for it [here](https://github.com/ruby/ruby/blob/trunk/enumerable.c#L2907)\n\
    <|/ c |>\n<| c |>\nThat's really interesting. My test was done on a much shorter\
    \ array of 1,000,000 elements. I tested `uniq` and `sort` and both took about\
    \ the same amount of time.\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays |>\nHere\
    \ is a method using Ruby 2.5's Enumerable#group_by and a Ruby hash instead of\
    \ an Array. \n<code>\narr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8]", "  l.uniq\n\
    end", "  l.uniq\nend", "  return l.uniq.sort\nend", "  return l.uniq.sort\nend",
  "  l.sort!\n  l.reject!(&:==)\n  l\nend", "  return l.uniq.sort\nend", "  l.uniq\n\
    end", "  l.sort { |a, b| a <=> b }\n  l.uniq.sort\nend", "  l.sort { |a, b| a\
    \ <=> b }\n  l.reject { |a| a.eql?(a[1..-1]) }\nend", "  if l.size==0\n    []\n\
    \  else\n    Set[l.uniq.sort]\n  end\nend\n</code>\n<|/ a dscore=5 tags=sorting,set,ruby\
    \ |>\n<| c |>\n`Set` doesn't have a `sort` method.\n<|/ c |>\n<| c |>\nYes it\
    \ does, at least in Ruby 2.1.2p95 and Ruby 1.9.3p385 on MacOS X.\n<|/ c |>\n<|\
    \ c |>\nYes, it does in Ruby 1.9.3-p385 but not in Ruby 2.1.2p95\n<|/ c |>\n<|\
    \ c |>\nNot sure about Ruby 2.x but in Ruby 1.9.3 Set#to_a creates a new set and\
    \ then copies the contents into it.\n<|/ c |>\n<| c |>\nAm I the only person who\
    \ finds this to be the most performant solution? I haven't found any benchmarks.\n\
    <|/ c |>\n<| a dscore=5 |>\nSet#sort should work, e.g.:\n<code>\nrequire 'set'\n\
    Set.new([1,2,3,4]).sort", "    seen = Set.new\n    l.each_with_index do |e,i|\n\
    \        seen.add? e or l.delete_at i\n    end\n    seen\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks. This is quite a nice solution. I would prefer a solution\
    \ without the need to instantiate Set (like with the other solution), but it's\
    \ still a great solution.\n<|/ c |>\n<| c |>\nWhy don't you just instantiate Set\
    \ in the first place?\n<|/ c |>\n<| c |>\nI prefer to have my code as clean/concise\
    \ as possible, since it's part of a larger project. If I can avoid instantiating\
    \ Set it would be great :)\n<|/ c |>\n<| c |>\nA Set has a lot of uses in ruby,\
    \ but in this case there is no need to use Set in the first place. see my solution.\n\
    <|/ c |>\n<| c |>\nI don't see how this approach avoids the instantiation of the\
    \ Set class.  I don't see a way that avoids the instantiation of the `Set` class.\n\
    <|/ c |>\n<| a |>\nYou could do something like this with Ruby:\n<code>\narray\
    \ = [5, 3, 5, 2, 3, 3, 9, 0, 123]", "  seen = Set.new()\n  l.each { |x| seen <<\
    \ x }\n  seen\nend", "  l.uniq.sort\n  l\nend\n</code>\n<|/ a dscore=4 tags=ruby,arrays\
    \ |>\n<| c |>\nThis method is nice when you want to remove duplicates, but not\
    \ when you want it sorted - so you shouldn't use it.\n<|/ c |>\n<| c |>\nThis\
    \ can be fixed by calling sort in the method (as in the answer to this question).\
    \ However, for other situations, this solution seems preferable to one involving\
    \ custom methods (as in the accepted answer).\n<|/ c |>\n<| c |>\n: What do you\
    \ mean by \"custom methods\"? This solution is generic and can be used on any\
    \ array, including those without `uniq` method (but still sorted by default).\
    \ Or do you want something like `uniq` that returns sorted array?\n<|/ c |>\n\
    <| c |>\nThe solution in my answer uses `uniq`, so you can use it on arrays without\
    \ `uniq` method (but still sorted by default). Or do you want something like `uniq`\
    \ that returns sorted array?\n<|/ c |>\n<| c |>\nYes, that's what he means. But\
    \ it only applies to the situation where `uniq` is defined on `Array`, which is\
    \ not always the case. For example, I could define `uniq` on `Integer` without\
    \ `uniq` and it would not remove duplicates. It would only remove the duplicates\
    \ that are equal to each other. As far as I can tell, it would only work in this\
    \ situation as long as `l` is a `Array`, but not on `Integer`.\n<|/ c |>\n<| a\
    \ dscore=3 |>\nRuby 2.5 adds an Array#uniq method:", "  l.sort!\n  unique = l[0]\n\
    \  l.shift\n  l.each do |x|\n    if x != unique\n      unique = x;\n    end\n\
    \  end\n  unique\nend", "  l.uniq!\n  l\nend\nLiquid::Template.register_filter(:unique)",
  "  return unique.filter(unique.uniq, l)\nend", "  l.uniq!\n  l\nend\n</code>\n<|/\
    \ a tags=arrays,ruby,duplicates dscore=5 |>\n<| c |>\nNote that this solution\
    \ does not mutate the original array and instead returns an altered copy so calling\
    \ unique multiple times will yield different results\n<|/ c |>\n<| a dscore=5\
    \ |>\nAs the other answers have pointed out there are many ways to do this. I\
    \ prefer #uniq! because it is destructive:\n<code>\na = [1, 5, 3, 9, 5, 3, 2]\n\
    a.uniq! # a = [1, 5, 3, 9, 2, 3]\n</code>\n<|/ a tags=arrays,ruby,duplicates |>\n\
    <| c |>\nThis is definitely the most concise answer. Just want to point out that\
    \ the `!` after `uniq!` will mutate the original array rather than creating a\
    \ copy.\n<|/ c |>\n<| c |>\nNo, it will not. `uniq!` is the same as `uniq` and\
    \ mutates the original array.\n<|/ c |>\n<| c |>\nI think it depends on the version\
    \ of Ruby you're using. I'm using `2.4.1`, where `uniq!` does indeed mutate the\
    \ original array.\n<|/ c |>\n<| c |>\nI came here looking for a way to remove\
    \ duplicates without modifying the original array. `uniq!` works perfectly for\
    \ me, but as `uniq` does, it sorts the array. `uniq!` was the easiest to implement\
    \ in my case.\n<|/ c |>\n<| c |>\nThe way I implemented this was to make a copy\
    \ of original array. `dup` returns the copy and `uniq!` removes duplicate elements\
    \ from the copy.\n<|/ c |>\n<| a |>\n<code>\n> a = [1, 5, 3, 9, 5, 3, 2]\n=> [1,\
    \ 5, 3, 9, 5, 3, 2]\n> a.uniq\n=> [1, 5, 3, 9, 2, 3]\n> a.uniq!\n=> [1, 5, 3,\
    \ 9, 2, 3]\n> a\n=> [1, 5, 3, 9, 5, 3, 2]\n</code>\n<|/ a tags=arrays,ruby,duplicates\
    \ dscore=5 |>\n<| a tags=arrays,ruby,duplicates |>\n<code>\na.uniq.sort\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThe downside to this approach is that it doesn't remove\
    \ duplicates from the original array. As mentioned by another answerer, the OP\
    \ only wants the unique elements of the original array.\n<|/ c |>\n<| a |>\n<code>\n\
    a.uniq!\n</code>\nThis removes duplic", "  l.sort.uniq\nend", "  return l.uniq\n\
    end", '  return l.uniq!', "  l.uniq!\nend", "  seen = {}\n  r = []\n  l.each do\
    \ |x|\n    if seen[x] == nil\n      seen[x] = true\n      r << x\n    end\n  end\n\
    \  return r\nend", "  return Array.new(l.size) { |i| l.delete_at(l.index(i)) if\
    \ l.count(i) == 1 }\nend", "  l.uniq\nend", "  uniques = []\n  l.each do |i|\n\
    \    if uniques.include?(i)\n      next\n    else\n      uniques.push(i)\n   \
    \ end\n  end\n  return uniques\nend", "  l.uniq &\n  l.compact\nend", "  l.uniq.sort\n\
    end", "  seen = Set.new\n  l.inject([]) {|a,e| return a + e if seen.add(e); a\
    \ }\nend\n</pre>", "  l.uniq!\nend", "  # Return unique elements from an array\n\
    \  l.sort.uniq\nend", "  result = []\n  l.each do |e|\n    result << e unless\
    \ result.include?(e)\n  end\n  result\nend", "  result = []\n  seen = []\n  l.each\
    \ do |i|\n    if seen.index?(i)\n      next\n    end\n    seen << i\n    result\
    \ << i\n  end\n  result\nend", "    l.uniq!\n    l\nend", "  l.uniq!\n  l\nend",
  "  # Avoid mutations\n  l = l.dup\n  return l.sort.uniq.compact\nend", "  l.sort.uniq\n\
    end", "  s = Set.new()\n  l.each do |i|\n    s.add(i)\n  end\n  s.to_a\nend",
  "  l.uniq!\nend", "    l.sort!\n    l.uniq!\n    l\nend", "  l.uniq!\nend", "  seen\
    \ = Set.new\n  l.each do |elem|\n    seen.add!(elem)\n  end\n  seen\nend", " \
    \ l.uniq!\n  l\nend", "  a = (0..(l-1).to_a).to_a\n  a.uniq.compact!\n  a\nend",
  "  l.sort do |a,b|\n    a <=> b\n  end\n  l.reject!(&:==).uniq\nend", "  l.reduce\
    \ (Hash.new, :+)\nend", "  l.uniq.sort\nend", "  # Return unique elements from\
    \ given array\n  l = [] if l.nil? || l.empty?\n  l[0] = l[0] if l.size == 1\n\
    \  l << l[0] if l.size > 1\n  l.uniq\nend\n</code>\n<|/ a tags=arrays,ruby |>\n\
    <| c |>\nNice job but you should add some explanation to your answer :)\n<|/ c\
    \ |>\n<| c |>\nThe only problem with this is that it returns an array with two\
    \ elements instead of one (so `unique.call([5, 3, 2]) #=> [3, 2]`). That's a problem\
    \ for me because I need an array with just one element.\n<|/ c |>\n<| c |>\nThis\
    \ solution isn't really any better than using Hash::new and Array#first as suggested\
    \ in the other answers. It's still O(N^2) though.\n<|/ c |>\n<| a |>\nFor Ruby\
    \ versions before 2.3.0 you can use Enumerable#uniq:\n<code>\n[5, 3, 2].uniq",
  "  l.uniq!\n  l\nend\n</pre>\n            </div>\n          </div>\n        </div>\n\
    \      </div>", "  if l.is_a?(Array)\n    l.uniq\n  else\n    l\n  end\nend",
  "  l.each_with_index do |element, index|\n    yield(element, index) if yield(element)\n\
    \  end\nend", "  l.uniq.sort!\n  l\nend", "    l.sort!\n    return l\nend", " \
    \ return l.uniq\nend", "  l.sort!\n  unique_arr = []\n  unique_arr.push l[0] unless\
    \ l.include?(l[0])\n  l = l[1..-1]\n  while l.size > 0\n    el = l[0]\n    l.shift\n\
    \    unless l.include?(el)\n      unique_arr.push el\n    end\n  end\n  unique_arr\n\
    end", "  l.uniq.sort\nend", "  l.uniq { |x| x }\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=3 |>\n<| a |>\nAnother simple approach: \n<code>\n>> arr = [\"a\", \"\
    b\", \"c\", \"a\", \"c\", \"a\", \"b\", \"c\"]\n>> arr.uniq.sort\n=> [\"a\", \"\
    b\", \"c\", \"a\", \"c\", \"a\", \"b\", \"c\"]\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=3 |>\n<| a |>\n<code>", '  l.sort!', "  l.uniq!\n  l\nend", "  l.each\
    \ { |e| yield e if seen?(e) }\nend", "  l = l.sort\n  n = []\n  n.push l[0]\n\
    \  n.push l[1]\n  while l.length != 0\n    l.shift if l[0] != l[n.length]\n  \
    \  n.push l[0]\n  end\n  n\nend", "  # return uniques\n  result = Set.new()\n\
    \  l.each do |i|\n    if !result.include?(i)\n      result.add(i)\n    end\n \
    \ end\n  result\nend", "  l.to_enum(:uniq).to_a\nend", "  l.uniq.sort\nend", " \
    \ l.uniq!\n  l\nend", "  l.uniq\nend\nend", "  l.uniq\nend", "  l.uniq\nend\n\
    </code>\n<|/ a dscore=4 tags=arrays,ruby |>\n<| c |>\nNice answer but your example\
    \ doesn't seem to be working. [5,3,5,2,3,9,0,123].uniq returns [5,5,2,3,9,123].\
    \ How come you get [5,3,5,2,3,9,0,123]? [5,3,5,2,3,9,0,123].uniq.sort returns\
    \ [1,2,3,3,5,5,9,0,123]\n<|/ c |>\n<| c |>\nBecause my example doesn't handle\
    \ arrays of different types.\n<|/ c |>\n<| c |>\nYes but your answer didn't do\
    \ that. I didn't downvote you but your answer doesn't really answer the question\
    \ so you might want to update it. Also it's possible that your answer will get\
    \ downvoted so don't worry about it (I didn't downvote). Well I guess not having\
    \ downvoted is pretty harsh :)\n<|/ c |>\n<| c |>\nThe question was about Ruby\
    \ not Ruby on Rails. I think it's important to mention that it's Ruby's default\
    \ behaviour, not Rails.\n<|/ c |>\n<| c |>\nI agree with you but I don't want\
    \ to get downvoted so I think it's helpful to mention this when answering questions\
    \ like this.\n<|/ c |>\n<| a tags=arrays,ruby dscore=4 |>\nIt seems you want an\
    \ unique array of items in a given array.\n<code>\n[5, 3, 5, 2, 3, 3, 9, 0, 123].uniq",
  "  l.uniq!\n  l\nend", "  # @return [Array<Integer>] Unique elements in an array\n\
    \  seen = []\n  uniques = []", "  l.sort\n  uniques = []\n  l.each do |element|\n\
    \    if uniques.include?(element)\n      uniques.delete(element)\n    else\n \
    \     uniques.push(element)\n    end\n  end\n  uniques\nend\n</code>\n<|/ a dscore=2\
    \ tags=arrays,ruby,unique |>\n<| a dscore=1 |>\n<code>\narray.uniq.compact\n</code>\n\
    will do the trick. \nAnd if you're using Rails:\n<code>\narray.uniq.select(&:blank?)\n\
    </code>\n<|/ a tags=arrays,ruby,unique |>\n<| c |>\nThanks but it won't work if\
    \ the array contains only whitespace characters, it will return an array with\
    \ all the same elements. Also it won't return empty array if there are two empty\
    \ strings in the array.\n<|/ c |>\n<| c |>\nRight, because strings are objects\
    \ and aren't equal to anything. \nAlso, if you're using Rails, `array.uniq(&:blank?)`\
    \ will do the trick (though it will return an empty array when there are no non-blank\
    \ values in the array).\n<|/ c |>\n<| a tags=arrays,ruby,unique |>\n<code>\narr\
    \ = [1, 2, 3, 3, 4, 5, 2, 3]\narr.uniq", "  l.uniq\nend", "  l.uniq.sort!\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThe order of the resulting array\
    \ will be unpredictable if the original array contains duplicates.\n<|/ c |>\n\
    <| c |>\n: I agree, but the question did not specify how exactly the array should\
    \ be ordered. I just answered the question as I thought it would be most useful\
    \ for the OP.\n<|/ c |>\n<| c |>\n: I agree, but I was answering the original\
    \ question, and I don't think the OP wants duplicate elements removed, so I chose\
    \ to not remove duplicates -- but to order the array by the occurrence of the\
    \ elements.\n<|/ c |>\n<| c |>\nOh, I see the ordering requirement now. Thats\
    \ fair.\n<|/ c |>\n<| c |>\n: Yes, I noticed that as well :)\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  h = {}\n  l.uniq.each do |x|\n    h.merge!(Hash[x]) do |_, a|\n\
    \      a.map { |y| [y, x] }\n    end\n  end\n  h.values\nend", "  return l.to_a.uniq.sort.to_enum.to_a\n\
    end", "  l.uniq!\n  l\nend", "  seen = []\n  result = []\n  l.each do |x|\n  \
    \  if seen.include? x\n      next\n    else\n      seen << x\n      result <<\
    \ x\n    end\n  end\n  result\nend", "  a = l.reverse.sort.uniq.compact\n  a.shift\
    \ if a.first.nil?\n  a\nend", "  h = Hash.new\n  l.each { |x| h[x] ||= [] << x\
    \ }\n  h.values.map { |v| v.uniq.sort }.flatten.compact\nend", "  return l.sort().uniq.sort\n\
    end", "  seen = {}\n  result = []\n  l.each do |x|\n    if seen[x]\n      next\n\
    \    else\n      seen[x] = 1\n      result << x\n    end\n  end\n  result\nend",
  "  l.sort.uniq\n  l\nend", "  l.sort!\n  l.uniq!\nend", "  return l.sort!.uniq\n\
    end", "  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend", "  return uniq.call(l).sort\n\
    end", "  # Create a copy of l and return unique values\n  uniq.call(l)\nend\n\
    </cell>\n<code language=julia-1.5>", "  uniq = l.to_a\n  uniq.uniq!\n  uniq\n\
    end", "  return l.uniq.sort\nend", "  return l.uniq!\nend", "  l.sort\n  l = l.reject\
    \ { |e| l.count(e) > 1 }\n  l\nend", "  l.sort\n  uniqs = []\n  l.each_with_index\
    \ do |e, i|\n    (uniqs.include?(e) ? uniqs.delete(e) : uniqs << e)\n  end\n \
    \ uniqs\nend", "  return l.uniq\nend", "  l.sort.uniq\nend", "  l.sort!\n  l.uniq!\n\
    end", "  seen = {}\n  l.uniq(&:itself)\n  l.each do |obj|\n    if seen[obj] ==\
    \ :uniq\n      seen[obj] = nil\n    else\n      seen[obj] = :uniq\n    end\n \
    \ end\nend\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=arrays,ruby,unique |>\n\
    <code>", "  l.uniq!\nend", "  l.uniq\nend", "  seen = {}\n  result = []\n  result.concat(l)\n\
    \  l.each do |e|\n    if seen[e]\n      result.pop while seen[e] == e\n    else\
    \ seen[e] = true\n    end\n  end\n  return result\nend", "  l.uniq!\n  l\nend",
  "  l.uniq\nend", "  r = Set.new()\n  l.each do |x|\n    r << x unless r.include?(x)\n\
    \  end\n  r\nend", "  l = l.to_a\n  l.uniq\nend", "  l.uniq\nend", "  a = l.dup\n\
    \  a.sort!\n  a.uniq!\n  a\nend", "  return l.uniq\nend", "  l.uniq!\nend\n</code>\n\
    The first function returns a copy (to avoid mutating the original array).  The\
    \ second removes the duplicates.  It is implemented as a method on Array because\
    \ it is more efficient.  The third line removes the duplicates when it is invoked.\n\
    <|/ a dscore=3 |>\n<| c |>\nI used this and modified it slightly: `def unique_with_method(arr,\
    \ &blk)\n    arr = (arr || []).dup\n    blk.call(arr)\n    arr.uniq!\nend` then\
    \ `unique_with_method([5,5,5,5,5,5,5,2,2], :upcase)`\n<|/ c |>\n<| c |>\nI like\
    \ the simplicity of the block. Also, the default should be `||` and not `&&`,\
    \ as `dup` returns an empty array when passed an empty array. Also, this could\
    \ be a nice addition to `Array`.\n<|/ c |>\n<| a dscore=2 |>\nIf you're using\
    \ Rails, you can use ActiveSupport to achieve the result in a pretty simple manner.\n\
    <code>", "  unique.rb l, {}\nend", "  l.uniq\nend", "  # Remove duplicates\n \
    \ # >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  # [0, 2, 5, 9, 123]\n  # Remove\
    \ duplicates, but only adjacent to the previous element\n  # >>> unique([5, 3,\
    \ 5, 2, 3, 3, 9, 0, 123, 5])\n  # [0, 2, 3, 5, 9, 123]\n  # Only remove duplicates\
    \ that appear at least twice in one array\n  # >>> unique([5, 5, 5, 5])\n  # [5,\
    \ 5, 5]\n  # Only remove duplicates up to a specific value\n  # >>> unique([5,\
    \ 5, 5, 5], 5)\n  # [5, 5, 5]\n  l - l.uniq.sort\nend", "  return l.uniq\nend",
  "  l.sort\n  l[1..-1]\nend", "  return l.to_a.reduce(:&)\nend", "  l.sort do |a,\
    \ b|\n    a <=> b\n  end\n  l\nend", "  l.sort!\n  l.reverse!\n  l.uniq!\nend\n\
    </code>\n<|/ a dscore=4 tags=ruby |>\n<| c |>\nWhy use `sort!` instead of `sort`?\n\
    <|/ c |>\n<| c |>\nBecause that removes duplicates already found as soon as they're\
    \ found. So if you use `uniq!`, you'll get duplicates removed before they're actually\
    \ found anywhere.\n<|/ c |>\n<| c |>\nThanks, I always forget about that one!\
    \ `:P` I edited my answer to include this.\n<|/ c |>\n<| c |>\nThe `uniq!` method\
    \ doesn't work with negative numbers (unless you override the `<=>` method, which\
    \ will confuse people.\n<|/ c |>\n<| c |>\n`uniq!` removes all non-unique elements\
    \ from an array and returns an array with unique elements. So you get an array\
    \ with non-unique elements. `uniq` only removes duplicate elements from the array.\
    \ `uniq!` modifies the original array and returns nothing. `uniq!` will never\
    \ remove duplicate elements from an array with `-N` elements. If you have an array\
    \ with duplicate elements, use `uniq!` to find unique elements and then use something\
    \ like `uniq`. I recommend [this book](http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/1934356466)\
    \ if you want to understand how to use ruby and ruby idioms.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nJust for the record: there is an interesting solution with just one line,\
    \ but I agree with Mr. Sweet that this is quite unreadable:\n<code>\narray.uniq\
    \ { |elm| elm.to_s }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis does work for\
    \ negative numbers too. `array.uniq { |elm| elm.to_s(10) }`\n<|/ c |>\n<| c |>\n\
    It also fails when a float is present in an array.\n<|/ c |>\n<| c |>\nThanks,\
    \ I fixed my answer to use `to_s` instead of `to_i`.\n<|/ c |>\n<| c |>\nThe to_s\
    \ works with negative numbers. `array.uniq { |elm| elm.to_s(10) }`\n<|/ c |>\n\
    <| c |>\nBut it fails to handle floats, just as `to_i` does. So no, that's not\
    \ the right answer.\n<|/ c |>", "  a = []\n  a.concat(l)\n  a.uniq { |x| x }\n\
    end", "  l.uniq!\nend", "  l.uniq\nend", "  l.uniq\nend", "  l.sort\n  l.reverse!\n\
    \  l.remove_if{|x| l == x}\nend", "  l.sort!\n  l = l.reject(&:==l[0])\n  l\n\
    end", "  l.uniq!\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
