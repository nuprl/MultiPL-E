name: HumanEval_66_digitSum
language: rb
prompt: "# Task\n# Write a function that takes a string as input and returns the sum\
  \ of the upper characters only'\n# ASCII codes.\n# Examples:\n# >>> digitSum.call(\"\
  \")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n\
  # 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n\
  # 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n\
  \    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n\
  \    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"\
  abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131,\
  \ candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"\
  ))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327,\
  \ candidate.call(\"You arE Very Smart\"))\n  end\nend\n"
completions: ["    sum = 0\n    i = 0\n    while i < s.length\n        sum = sum +\
    \ s[i]\n        i = i + 1\n    return sum", "  # Your code here\n  s.each_byte\
    \ do |c|\n    if c < 48 || c > 57\n      puts 0\n    else\n      puts c.to_s +\
    \ s.count\n    end\n  end\nend", "  sum = 0\n  s.each_byte { |c| sum += c }\n\
    \  sum\nend", "  return s.upto('z').inject(0) { |s, c| s.succ * c + ord(c) }\n\
    end", "  return s.gsub(/\\d+/) { |digit| digit.to_s.upcase.to_i}\nend", "    sum\
    \ = 0\n    s.downcase!\n    digits = s.split(//)\n    digits.each { |i| sum +=\
    \ i.ord }\n    sum\nend\nputs digitSum.call(ARGV[0])\n</code>\n<|/ a dscore=2\
    \ tags=ruby,ruby-on-rails |>\n<| a dscore=1 |>\nIn case you need it more than\
    \ once, here's a one-liner:\n<code>\n\"abc123\".each_char.inject(:+).to_s\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nIt could be shortened even more to:\
    \ `\"abc123\".inject(:+).to_s`\n<|/ c |>\n<| c |>\nAh yes, that's a good one (for\
    \ those of us who prefer one-liners, like myself). :)\n<|/ c |>\n<| c |>\nOr even,\
    \ `\"abc123\".scan(/./).inject(:+).to_s`\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  s.chars.inject(0) {|sum, elem| sum + elem.ord }\nend", "  sum = 0\n  for i in\
    \ 0...s.length()-1\n    sum = sum + s(i)\n  end\n  return sum\nend", "  sum =\
    \ 0\n  s.each_char do |c| \n    if c.upcase >= 'A'\n      sum += c.ord - 65\n\
    \    else\n      sum += c.ord - 97\n    end\n  end\n  sum\nend", "    sum = 0\n\
    \    for c in s\n        if c.upcase? && !c.digit?\n            sum += c.value\n\
    \    end\n    sum\nend", "  sum = 0\n  s.each_byte { |b| sum += b }\n  return\
    \ sum\nend", "    total = 0\n    \n    digits.each do |x|\n        total += s.split(x).map(&:to_i).sum\n\
    \    end", "  return s.chars.reduce(:+)\nend", "    return s.ascii_uppercase.length\n\
    end", "  sum = 0\n  s.each_byte { |c| sum += c if c > 47 && c < 58 }\n  return\
    \ sum\nend\n</code>\nThe above function is fairly trivial, but I wanted to show\
    \ you the power of the Ruby enumerator and regular expressions.\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\nOne can use the Enumerator#scan method to get the sum\
    \ of the digits in a string. This is done by matching a regex on the string and\
    \ extracting the digits from the match results (and converting to an integer to\
    \ get the sum of the digits).\n<code>", "  s = s + \"\"\n  result = 0\n  s.chars.reverse_each\
    \ do |char|\n    result += (char =~ /[a-z]/i).to_i\n  end\n  return result\nend\n\
    digitSum.call(\"\")\ndigitSum.call(\"abAB\")\ndigitSum.call(\"abcCd\")\ndigitSum.call(\"\
    helloE\")\ndigitSum.call(\"woArBld\")\ndigitSum.call(\"aAaaaXa\")", "  s = 0\n\
    \  for i in s\n    s += i.upcase if i.upcase else i.downcase\n  s\nend\n</cell>\n\
    <code language=julia-0.4>\nfunction digitSum(s::String)\n  s = 0\n  for i in s\n\
    \    s += i.upcase if i.upcase else i.downcase\n  end\n  s\nend\n</cell>\n<code\
    \ language=julia-0.4>\ndigitSum(\"abcCd\")\n</cell>\n<code language=julia-0.4>\n\
    digitSum(\"helloE\")\n</cell>\n<code language=julia-0.4>\ndigitSum(\"woArBld\"\
    )\n</cell>\n<code language=julia-0.4>\ndigitSum(\"aAaaaXa\")\n</cell>\n<code language=julia-0.4>\n\
    digitSum(\"1!2$3&4\")\n</cell>\n<code language=julia-0.4>\ndigitSum(\"5$6%7^8\"\
    )\n</cell>\n<text>\nExercise 1\nWrite a function that takes a string and replaces\
    \ all letters with their uppercase counterparts.", "  sum = 0\n  s.each_char do\
    \ |c|\n    sum = sum + c.ord - 48\n  end\n  return sum\nend\n</code>\n<|/ a |>\n\
    <| c |>\nPlease explain the `return sum` part.\n<|/ c |>\n<| c |>\nThe 'return'\
    \ statement will return the value of the sum variable (which is an integer, in\
    \ this case) to the 'digitSum' function. In the case of the digitSum.call(\"aAaaaXa\"\
    ) function, the return value will be 153.\n<|/ c |>\n<| c |>\nHow would one return\
    \ the sum to the calling function?\n<|/ c |>\n<| c |>\nI edited my original answer\
    \ above to include a function that returns the sum to the calling function.\n\
    <|/ c |>\n<| c |>\nThis is an elegant solution. One question I have is why does\
    \ the return sum not work if you were to return something else other than sum?\
    \ For example if you were to return the string \"sum\" instead of this sum. Is\
    \ it not possible to return multiple things in Ruby?\n<|/ c |>\n<| a dscore=5\
    \ |>\nRuby 2.4 has added Enumerable#max_by so you can do this:\n<code>\n\"hello\
    \ there\".max_by(&:length) # => \"hello\"\n</code>\n<|/ a tags=ruby,sum |>\n<|\
    \ c |>\nNote that this also works on Ruby versions older than 2.4 where the `max_by`\
    \ method doesn't exist.\n<|/ c |>\n<| c |>\nRuby 2.5 introduced `Enumerable#max_by`\
    \ method. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,sum |>\nI know\
    \ it's an old question, but here is an interesting alternative:\n<code>", "  sum\
    \ = 0\n  s.each_byte {|c| sum += c if c >= 48 && c <= 57 }\n  return sum\nend",
  "    total = 0\n    i = 0\n    while i < s.length\n        if s.chars[i].upcase\
    \ == true\n            total = total + s.chars[i].to_i\n        i += 1\n    return\
    \ total", "  if s.empty?\n    0\n  else\n    s.chars.inject(0) do |sum, (char)|\n\
    \      sum + char.ord - '0'\n    end\n  end\nend", "  \n  sum = 0\n  \n  s.to_s.split(\"\
    \").each do |i|\n    sum = sum + i.upcase == i ? i.upcase.to_i : i.upcase.to_i\n\
    \  end", "  return s.to_s.reverse.scan(/[a-z]/).inject{ |sum, char| sum + char.ord\
    \ - 'a'.ord }\nend", "    sum = 0\n    str.split(s).each do |c|\n      sum +=\
    \ c.ord - 64\n    end\n    return sum\nend", "    sum = sum = 0\n    char = \"\
    \"\n    s.each_byte do |chr|\n        sum += chr.to_i\n        if sum >= 10\n\
    \            sum -= 10\n            char += chr\n        end\n    end\n    return\
    \ char.to_i\nend", "  return s.to_s.split(\"\").inject(:+)\nend", "    sum = 0\n\
    \    s.downcase!\n    s.each_char do |char|\n        if char >= \"0\" \n     \
    \       sum += char.ord\n        end\n    end\n    return sum\nend", "    total\
    \ = 0\n    digits = Array.new", "  s.chars.inject(0) do |total, c|\n    total\
    \ + c.ord - 65\n  end\nend", "  sum = 0\n  s.each_byte { |x| sum += x if x.to_i\
    \ > 64 && x.to_i < 91 }\n  return sum\nend", "  # Convert str to array (split\
    \ on space)\n  arr=s.chars.to_a\n  # Loop through array and sum the ASCII codes\n\
    \  sum=0\n  arr.each do |c|\n    sum+=c.to_i\n  end\n  sum\nend", "  s.each_char\
    \ do |char|\n    sum = 0\n    char.upto(127) do |c|\n      sum += c\n    end\n\
    \    return sum\n  end\nend", "    sum=0\n    chars=string.split(s)\n    chars.each\
    \ do |char|\n        sum+=char.upcase\n    end\n    return sum\nend", "    digitSum\
    \ = 0\n    i = 0\n    while i < s.length()\n        digitSum += s.codePointAt(i)\n\
    \        i += 1\n    end\n    return digitSum\nend", "  sum = 0\n  for i in 0...s.length\n\
    \    sum += s.codePointAt(i)\n  end\n  sum\nend", "  result = 0\n  for i in [s..s.length-1]\n\
    \    result += s.chars.map(&:ord).max\n  end\n  return result\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=ruby |>\nYou can use this to find the sum\
    \ of the digits of a number:\n<code>", "    sum = 0\n    i = 0\n    chars = s.split(\"\
    \")\n    while i < chars.length\n        if (chars[i].upcase != chars[i].downcase)\n\
    \            sum += chars[i].upcase - (chars[i].upcase - chars[i].downcase)\n\
    \        i += 1\n    return sum", "  return s.chars.map(&:ord).reduce(:+)\nend",
  "    sum = 0\n    i = 0\n    while i < s.length\n        if s[i] >= 'a' and s[i]\
    \ <= 'z'\n            sum += s[i]-'a'\n            i += 1\n        else\n    \
    \        i += 1\n    return sum", "    s.split(\"\").map { |c| c.ord }.inject\
    \ { |sum, el| sum + el }\nend", "  # TODO: Write code here\nend", "  sum = 0\n\
    \  s.each_char { |c| sum += (c >= '0' and c <= '9' ? c.ord - '0' : 0) }\n  return\
    \ sum\nend", "  return s.codepoints.inject(0) { |sum,e| sum + e.upcase }\nend",
  "    sum = 0\n    str.split(s).each do |character| sum += character.codepoint if\
    \ character == character && character.upcase == character end\n    sum\nend",
  "    return s.split('').inject(0) do |sum, ch|\n      sum += ch.upcase.ord if ch.upcase?\n\
    \      sum\n    end\nend", "  # your code here\n  s.each_char do |c|\n    puts\
    \ \"#{c.upcase}\" if c.upcase >= 65\n  end\nend", "  sum = 0\n  for i in 0...s.length\n\
    \    sum = sum + s.codePointAt(i).upcase - 'A'\n  end\n  return sum\nend", " \
    \ result = 0.chr\n  s.each_char do |char|\n    result << (char.ord - '0').abs\n\
    \  end\n  result\nend\nputs digitSum.call(\"hello world\")", "  return s.chars.inject(0)\
    \ {|sum, n| sum + n.to_i.digit }\nend", "    sum = 0\n    for character in s\n\
    \        if character >= '0' and character <= '9'\n            sum = sum + character.to_i\n\
    \    end\n    return sum\nend", "  sum = 0\n  s.each_char do |char|\n    sum =\
    \ sum + char.ord - 96\n  end\n  return sum\nend", "  sum=0\n  for i in s\n   \
    \ if i.is_a?(Fixnum)\n      sum+=i.abs\n    end\n  end\n  sum\nend\n</cell>\n\
    <code language=julia-0.4>\ndigitSum(\"\")\n</cell>\n<code language=julia-0.4>\n\
    digitSum(\"abAB\")\n</cell>\n<code language=julia-0.4>\ndigitSum(\"abcCd\")\n\
    </cell>\n<code language=julia-0.4>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-0.4>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-0.4>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nTask\nCreate a function that takes a string as input and returns\
    \ the sum of the digits only'\nASCII codes.\nExamples:\n>>> digitSum.call(\"\"\
    )\n0\n>>> digitSum.call(\"abAB\")\n10\n>>> digitSum.call(\"abcCd\")\n8\n>>> digitSum.call(\"\
    helloE\")\n5\n>>> digitSum.call(\"woArBld\")\n10\n>>> digitSum.call(\"aAaaaXa\"\
    )\n6\n</text>\n<code language=julia-0.4>\nfunction digitSum(s)\n  sum=0\n  for\
    \ i in s\n    if i.is_a?(Fixnum)\n      sum+=i.digits\n    end\n  end\n  sum\n\
    end\n</cell>\n<code language=julia-0.4>\ndigitSum(\"\")\n</cell>\n<code language=julia-0.4>\n\
    digitSum(\"abAB\")\n</cell>\n<code language=julia-0.4>\ndigitSum(\"abcCd\")\n\
    </cell>\n<code language=julia-0.4>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-0.4>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-0.4>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nTask\nCreate a function that takes a string as input and returns\
    \ the sum of the lower case characters only'\nASCII codes.\nExamples:\n>>> lowerSum.call(\"\
    \")\n0\n>>> lowerSum.call(\"abAB\")\n65\n>>> lowerSum.call(\"abcCd\")\n66\n>>>\
    \ lowerSum.call(\"helloE\")\n65\n>>> lowerSum.call(\"woArBld\")\n66\n>>> lowerSum.call(\"\
    aAaaaXa\")\n65\n</text>\n<code language=julia-0.4>\nfunction lowerSum(s)\n  sum=0\n\
    \  for i in s\n    if i.", "  digit = s.split(\"\").map(&:to_i).reduce(:+)\n \
    \ case digit \n  when 0..9\n    digit\n  when 10..48\n    digit + 10\n  when 49..57\n\
    \    digit + 1\n  when 65..90\n    digit - 10\n  else\n    raise \"Invalid input\"\
    \n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for that, I really like the\
    \ way you used Ruby's \"each_char\" method. I wasn't aware of that method. However\
    \ I just tried it out and it doesn't work. RubyMine says \"undefined method `each_char'\
    \ for \"abcCd\":String (NoMethodError)\" at the \"s.each_char\" line. What do\
    \ you think?\n<|/ c |>\n<| c |>\nOops, I meant `each_char`, not `each_chars`.\
    \  Fixed above.\n<|/ c |>\n<| c |>\nThe `to_i` conversion is not necessary on\
    \ `digit`. You could simply do `digit = s.each_char.reduce(:+).to_i`.\n<|/ c |>\n\
    <| c |>\n- Good catch, edited the answer to reflect that.  I've also added a refactoring\
    \ of the function so it's easier to read.\n<|/ c |>\n<| c |>\nAh! I didn't realize\
    \ I couldn't do things like that in Ruby. I just tried that and it works! Thank\
    \ you so much!\n<|/ c |>\n<| a tags=ascii,ruby,python,ruby-on-rails,string |>\n\
    <code>", "  # TODO: Write your code here.\n  i = 0\n  sum = 0\n  while i < s.length\n\
    \    char = s[i]\n    if char > 64 and char < 91 \n      sum += char - 64\n  \
    \  i += 1\n  return sum\nend", "  sum = 0\n  s.chars.each do |c|\n    sum += c.ord\
    \ if c.ord >= 64 && c.ord <= 91\n  end\n  sum\nend", "  # Your code here\n  return\
    \ 0\nend", "  str.to_chars.reduce(0) do |sum, char|\n    sum += char.ord - \"\
    0\".ord\n  end\nend\n</cell>\n<cell>\ndigitSum.call(\"helloE\")\n</cell>\n<text>\n\
    Part II: Write a function that takes a string as input and returns the number\
    \ of consecutive vowels (\"a\", \"e\", \"i\", \"o\", or \"u\") in the string.\n\
    ASCII codes are used.\nExamples:\n>>> vowelCount.call(\"\")\n0\n>>> vowelCount.call(\"\
    AaAa\")\n2\n>>> vowelCount.call(\"aAaa\")\n3\n>>> vowelCount.call(\"AaAaa\")\n\
    4\n>>> vowelCount.call(\"aaaa\")\n5\n>>> vowelCount.call(\"aaAa\")\n6\n>>> vowelCount.call(\"\
    AaAaa\")\n7\n>>> vowelCount.call(\"aaAa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n\
    7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"\
    AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\"\
    )\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>>\
    \ vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"\
    AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\"\
    )\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>>\
    \ vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"\
    AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\"\
    )\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>> vowelCount.call(\"AaAaa\")\n7\n>>>\
    \ vowelCount.call(\"AaAaa\")\n7\n>>> vowelCoun", "  s.scan(/./).map { |c| c.ord\
    \ - 'A'.ord }.reduce(:+)\nend", "  result = 0.upto(s.size-1, :downto).inject(0)\
    \ { |memo,i| memo + s.codepoints.at(i).ord - 42 }\n  result < 0 ? 0 : result\n\
    end", "  result = 0\n  s.each_byte do |c|\n    if c > 57 or c < 48\n      result\
    \ += c\n    end\n  end\n  result\nend", '  return s.gsub(/[a-z]/i) { |c| c.ord
    }.to_i', "    sum = 0\n    s.each_byte.map { |b| sum += b.to_i(16) }\n    sum\n\
    end", "  # Your code here\n  # Example\n  # return s.count('a') + s.count('A')\n\
    \  return", "  return s.digits.reduce(:+)\nend", "    sum = 0\n    \n    return\
    \ sum\n    \n</cell>\n<cell>", "  if s.size < 1 then return 0 end\n  local digitSum\
    \ = 0\n  for i = 1, #s do\n    if s[i] < 'a' or s[i] > 'z' then\n      digitSum\
    \ = digitSum + s[i]\n    end\n  end\n  return digitSum\nend", "\tsum = String.empty\n\
    \tletters = s.split('')\n\tletters.each do |l|\n\t\tif l.length == 1 && l[0].upcase\
    \ == 'A'\n\t\t\tsum += 65\n\t\telse\n\t\t\tsum += l[0].upcase.to_i\n\t\tend\n\t\
    end\n\tsum\nend", "  # TODO: implement the body of the function\n  return 0",
  "    sum = 0\n    s.upto(n){|c| sum += (c.ord + 96) if c}\n    sum\nend", "  sum\
    \ = 0\n  s.each_char {|c| sum += c if c.upcase == c.downcase }\n  return sum\n\
    end", "  return s.gsub(/\\A[a-z]|\\z|[\\-]\\Z/) {|s| s.upcase.size }\nend\n</code>\n\
    <|/ a tags=string,ruby dscore=0 |>\n<| c |>\nThanks for the suggestion but this\
    \ doesn't seem to work if you put in more than one digit. For example \"123X5\"\
    \ returns 155 instead of 125.\n<|/ c |>\n<| c |>\nAh sorry about that! I'll fix\
    \ it.\n<|/ c |>\n<| c |>\n, I've just edited my answer - I realized that I had\
    \ completely misread the problem and went with my previous solution :) I realized\
    \ later that I could have made the regex much simpler.\n<|/ c |>\n<| a tags=string,ruby\
    \ |>\nI went with this solution:\n<code>", "  sum = 0\n  for i in s\n    if i.downcase\
    \ == 'a'\n      sum += 65\n    elsif i.downcase == 'b'\n      sum += 66\n    elsif\
    \ i.downcase == 'c'\n      sum += 67\n    elsif i.downcase == 'd'\n      sum +=\
    \ 68\n    elsif i.downcase == 'e'\n      sum += 69\n    elsif i.downcase == 'f'\n\
    \      sum += 70\n    elsif i.downcase == 'g'\n      sum += 71\n    elsif i.downcase\
    \ == 'h'\n      sum += 72\n    elsif i.downcase == 'i'\n      sum += 73\n    elsif\
    \ i.downcase == 'j'\n      sum += 74\n    elsif i.downcase == 'k'\n      sum +=\
    \ 75\n    elsif i.downcase == 'l'\n      sum += 76\n    elsif i.downcase == 'm'\n\
    \      sum += 77\n    elsif i.downcase == 'n'\n      sum += 78\n    elsif i.downcase\
    \ == 'o'\n      sum += 79\n    elsif i.downcase == 'p'\n      sum += 80\n    elsif\
    \ i.downcase == 'q'\n      sum += 81\n    elsif i.downcase == 'r'\n      sum +=\
    \ 82\n    elsif i.downcase == 's'\n      sum += 83\n    elsif i.downcase == 't'\n\
    \      sum += 84\n    elsif i.downcase == 'u'\n      sum += 85\n    elsif i.downcase\
    \ == 'v'\n      sum += 86\n    elsif i.downcase == 'w'\n      sum += 87\n    elsif\
    \ i.downcase == 'x'\n      sum += 88\n    elsif i.downcase == 'y'\n      sum +=\
    \ 89\n    elsif i.downcase == 'z'\n      sum += 90\n    end\n  end\n  return sum\n\
    end", "  s.split('').inject(0) do |sum, n|\n    sum + n.upcase.ord - n.downcase.ord\n\
    \  end\nend", "  s.each do |l|\n    l.upto(\"A\") { |i| sum += i }\n  end\n  sum\n\
    end", "  sum = 0\n  s.each_char do |c|\n    sum = sum + c.ord - 'A'.ord\n  end\n\
    \  return sum\nend", "  s.chars.map{|c| c.ord - '0'}.inject(0, :+)\nend", "  \
    \  return s.upcase.length\nend", "  sum = 0\n  for i in 0...s.length\n    if i.to_s.length\
    \ < 1\n      sum += i.to_i\n    else\n      sum += i.to_i.ord.to_s.ord - (i.to_i.ord.to_s.ord\
    \ >= ord(\"A\") ? 96 : 64)\n  end\n  return sum\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThe question asks for the number of digits, not the sum.\n<|/ c\
    \ |>\n<| c |>\nThanks, I didn't notice that at first. Edited the answer accordingly.\n\
    <|/ c |>\n<| c |>\nThanks for this answer! I was searching for a way to get the\
    \ sum of a string without using regex. While I was searching, I found that Ruby\
    \ has the regex method `regex` which returns a MatchData object, which has a method\
    \ `to_a` which returns an array of strings of the regex matches. So you can also\
    \ do: `regex = /\\d/; digits.to_a.sum.match(regex).to_s.to_i`\n<|/ c |>\n<| a\
    \ |>\nHere's a solution using recursion. \n<code>", "  return sum((ord(char) -\
    \ 48) for char in s)\nend", "  result = \"\"\n  s.each_char do |char|\n    result\
    \ << char.to_i\n  end\n  result\nend", "  s = s.to_s\n  s.downcase!\n  s.chars.inject(0)\
    \ do |sum, el|\n    sum + el + (el > 'Z' ? el - 'A' : 0)\n  end\nend", "  sum\
    \ = 0\n  s.chars.each do |i|\n    sum += i.to_i if i.upcase != i\n  end\n  return\
    \ sum\nend", "  sum = 0\n  s.chars.each{|c| sum += c.upcase - 'a'}.to_i\n  sum\n\
    end", "  i = 0\n  total = 0\n  while i < s.length\n    total += get_digit(s[i],\
    \ i)\n    i += 1\n  end\n  total\nend", "  s.gsub(/[^[:digit:]]/).inject(0) {|sum,\
    \ n| sum + n.codepoint }\nend", "  # TODO: implement a solution here\n  0\nend\n\
    </cell>\n<code language=julia-1.0>\n@assert digitSum(\"\") == 0\n@assert digitSum(\"\
    abAB\") == 131\n@assert digitSum(\"abcCd\") == 67\n@assert digitSum(\"helloE\"\
    ) == 69\n@assert digitSum(\"woArBld\") == 131\n@assert digitSum(\"aAaaaXa\") ==\
    \ 153\n</cell>\n<code language=julia-1.0>", "  sum = 0\n  s.each_char { |c| sum\
    \ += c.upcase }\n  sum\nend\n</cell>\n<text>\nWe call our digit sum function with\
    \ our string and receive an integer.", "  \n  # Convert string to ASCII code\n\
    \  code = s.codepoints.to_a\n  \n  # Iterate through code\n  s.codepoints.each_with_index\
    \ do |c, i|\n    \n    # Sum the code values\n    sum = code + c.to_i\n    \n\
    \    # If the code value is greater than 127, add the value to the sum\n    if\
    \ sum > 127\n      sum += ((c - 64).to_i * 10)\n    end\n    \n    # Add the sum\
    \ to the sum\n    sum += i\n  end\n  \n  # Return the sum\n  sum\nend\n</cell>\n\
    <text>\n4.2 Write a function that takes a string as input and returns the sum\
    \ of the ASCII codes of the lower characters only", "  s = 0\n  s.chars.each do\
    \ |char|\n    s += char.ord - 96\n  end\n  s\nend\n</cell>\n<cell>\ndigitSum(\"\
    helloE\")\n</cell>\n<cell>", '  str_to_int = Hash.new', "    sum = 0\n    \n \
    \   for c in s\n        if c.upcase == true\n            sum += c.code\n    end\n\
    \    return sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi Sean,", "  if s.length\
    \ < 1\n    0\n  else\n    s[0] + digitSum[1..-1](s)\n  end\nend\ndigitSum.call(\"\
    \")\ndigitSum.call(\"abAB\")\ndigitSum.call(\"abcCd\")\ndigitSum.call(\"helloE\"\
    )\ndigitSum.call(\"woArBld\")\ndigitSum.call(\"aAaaaXa\")\ndigitSum.call(\"aAaXa\"\
    )\ndigitSum.call(\"aAaXaa\")\ndigitSum.call(\"aAaXaaX\")\ndigitSum.call(\"aAaXaaXa\"\
    )\ndigitSum.call(\"aAaXaaXaA\")\ndigitSum.call(\"aAaXaaXaAa\")\ndigitSum.call(\"\
    aAaXaaXaAaa\")\ndigitSum.call(\"aAaXaaXaAaaX\")\ndigitSum.call(\"aAaXaaXaAaaXa\"\
    )\ndigitSum.call(\"aAaXaaXaAaaXaa\")\ndigitSum.call(\"aAaXaaXaAaaXaaX\")\ndigitSum.call(\"\
    aAaXaaXaAaaXaaXa\")\ndigitSum.call(\"aAaXaaXaAaaXaaXaa\")\ndigitSum.call(\"aAaXaaXaAaaXaaXaaX\"\
    )\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXa\")\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXaa\"\
    )\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXaaX\")\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXaaXa\"\
    )\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXaaXaa\")\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXaaXaaX\"\
    )\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXaaXaaXa\")\ndigitSum.call(\"aAaXaaXaAaaXaaXaaXaaXaaXaa\"\
    )\ndigitSum.call(\"aAaXaaXaAaaXaaX", "  sum = 0\n  for c in s\n    if c.upcase\
    \ == \"A\"\n      sum += 26\n    else \n      sum += c.to_i\n  sum\nend", "  result\
    \ = \"\"\n  s.split(\"\").each do |char|\n    if char >= \"A\" and char <= \"\
    Z\"\n      result += (char.ord - \"A\" + 10)\n    end\n  end\n  return result.to_i\n\
    end\nprint digitSum.call(ARGV[0])", "  sum = 0\n  s.to_s.split(\"\").each do |char|\n\
    \    sum += (getAsciiCharValue(char) if char.upcase?)\n  end\n  return sum\nend",
  "  sum = 0\n  \n  s.each do |c|\n    sum = sum + c.ord if c =~ /[A-Z]/\n  end\n\
    \  \n  return sum\nend", "  # Your code here\n  s.split(//)\n  sum = 0\n  while\
    \ s.length != 0\n    # Your code here\n    next if s[0].isUpper\n    sum += s[0]\n\
    \    s.pop\n  end\n  return sum\nend", "  sum = 0\n  for i in 0...s.length-1\n\
    \    sum = sum + ord(s.char(i))-32\n  return sum\nend function", "  sum = 0\n\
    \  s.split('').each do |i|\n    sum += i.upcase\n  end\n  return sum\nend", " \
    \   count = 0\n    for letter in s\n        count += ord(letter) - 96\n    end\n\
    \    return count\nend\n</cell>\n<code language=julia-0.5>\ndigitSum(\"Hello World!\"\
    )\n</cell>\n<code language=julia-0.5>\ndigitSum(\"AaBcCdD\")\n</cell>\n<code language=julia-0.5>\n\
    digitSum(\"AaBcCdD\")\n</cell>\n<text>\nTask\nWrite a function that takes a string\
    \ as input and returns the sum of all characters that are divisible by 5's.",
  "  sum = 0\n  s.split('').each do |x|\n    sum += x.ord - 96\n  end\n  sum\nend",
  "  (0...s.length).reduce {|sum, idx| sum + s.codePointAt(idx)}.abs\nend", "  s.each_char.inject(0)\
    \ {|n,c| n+c.ord }\nend", "  return s.inject(0) do |sum, digit|\n    sum + digit.to_i\n\
    \  end\nend", "  sum = 0\n  s.each do |c|\n    sum = (sum.to_i + ord(c)) if c.upcase\
    \ == c\n  end\n  sum\nend", "    sum = 0\n    letters = s[:].split(\"\")\n   \
    \ letters.each do |letter|\n      if letter[0] >= 'A' and letter[0] <= 'Z'\n \
    \       sum += letter[0].ord\n      end\n    end\n    return sum\nend", "  # Your\
    \ code here\n  s.upcase!\n  sum=0\n  for i in 0...s.length-1\n    sum+=i.to_i\n\
    \  end\n  return sum\nend\nputs digitSum.call(\"\")\nputs digitSum.call(\"abAB\"\
    )\nputs digitSum.call(\"abcCd\")\nputs digitSum.call(\"helloE\")\nputs digitSum.call(\"\
    woArBld\")\nputs digitSum.call(\"aAaaaXa\")", "    sum = 0\n    chars = Array.new\n\
    \    s.chars.each do |c|\n      if c >= '0' && c <= '9'\n        sum += c.ord\
    \ - '0'\n      else\n        chars.push(c)\n      end\n    end\n    return sum\n\
    end\nputs digitSum(\"\")\nputs digitSum(\"abAB\")\nputs digitSum(\"abcCd\")\n\
    puts digitSum(\"helloE\")\nputs digitSum(\"woArBld\")\nputs digitSum(\"aAaaaXa\"\
    )", "  sum = 0\n  for i in [0..s.length]\n    sum += s[i]\n  end\n  return sum\n\
    end", "  sum = 0\n  s.split('').each do |char|\n    sum += char.ord - 'A'.ord\n\
    \  end\n  return sum\nend", "  # Your code here\n  sum = 0\n  for i in s:\n  \
    \  if i.upcase == 'A' or i.upcase == 'B' or i.upcase == 'C' or i.upcase == 'D'\
    \ or i.upcase == 'E':\n      sum += ord(i.upcase)\n  return sum", "  s.each_char\
    \ do |c|\n    return 0 unless c.upcase > '9'\n    digit = c - '0'\n    return\
    \ digit * 10 + digit\n  end\n  0\nend", "  sum = 0\n  s.each do |c|\n    sum +=\
    \ c.ord - 64 if c =~ /[A-Z]/\n  end\n  sum\nend\nputs digitSum(ARGV[0])\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWhile the other answers work, yours is the only one\
    \ I understand, which is why I upvoted it - it's far clearer than some of the\
    \ other answers, in my opinion.\n<|/ c |>\n<| c |>\nThanks for pointing that out.\
    \ I tried to improve my answer accordingly.\n<|/ c |>\n<| c |>\nI still think\
    \ you have the best answer, though, and it's a good demonstration that Ruby can\
    \ easily make these kinds of compact expressions.\n<|/ c |>\n<| a tags=regex,ruby\
    \ dscore=0 |>\nI guess this is what you are looking for:\n<code>", "  sum = 0\n\
    \  for i in 0..s.length\n    sum += if s.chars[i] == 'a' || s.chars[i] == 'A'\
    \ then '9' else s.chars[i]\n  sum\nend\n</cell>\n<text>\nExercise\nNow that you\
    \ have written a function that takes a string as input and returns its sum of\
    \ the numbers of the characters upper case letters you can test it as follows:",
  "  s.chars.map! { |c| c.ord - 'a'.ord }\n  s.to_s.length.digits.reduce(:+)\nend",
  "    sum = 0\n    digit = s.chars.to_a.map {|s| s.ord - 48 }\n    digit.each_with_index\
    \ {|c,i| sum += c*(i+1)}\n    return sum\nend", "  s.each_char do |c|\n    digits\
    \ = c.ord - '0'\n    sum += digits * 10\n  end\n  sum\nend", "  s.each_char{ |c|\
    \ return c.upcase }\n  0\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>\n\"\
    abc\".to_s.chars.map(&:upcase).sum\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c\
    \ |>\n\"abcd\".to_s.chars.map(&:upcase).sum", "    sum = 0\n    i = 0\n    while\
    \ i < s.length\n        sum += s.codePointAt(i)\n        if sum > 255\n      \
    \      sum += 32\n        i += 1\n    return sum\n</cell>\n<cell>", "    sum =\
    \ s[0]\n    s.scan(/./) do |char|\n        if char >= \"0\" && char <= \"9\"\n\
    \            sum += char.to_i\n        end\n    end\n    sum\nend\nputs digitSum.call(\"\
    abcCd\") # 67\nputs digitSum.call(\"helloE\") # 69\nputs digitSum.call(\"woArBld\"\
    ) # 131\nputs digitSum.call(\"aAaaaXa\") # 153", "\tsum = 0\n\ts.scan(/./) do\
    \ |char|\n\t\tsum += char.ord\n\tend\n\treturn sum\nend", "  sum = 0\n  (0..s.length).each\
    \ {\n    val c = s(it)\n    if (('A'..'Z').contains(c))\n      sum += (c - 'A'\
    \ + 10)\n  }\n  sum\nend", "    s = s.chars.map &:to_i\n    s = (0..s).sum\n \
    \   s.to_s\nend\n</cell>\n<text>\nTask\nImplement a Ruby version of the digitSum\
    \ function using recursion. How much faster? How much bigger? How much clearer\
    \ do you need?", "    sum = 0\n    i = 0\n    while i < s.length\n        sum\
    \ = sum + s[i][0].upcase + s[i][1].upcase + s[i][2].upcase + s[i][3].upcase +\
    \ s[i][4].upcase + s[i][5].upcase + s[i][6].upcase + s[i][7].upcase + s[i][8].upcase\
    \ + s[i][9].upcase + s[i][10].upcase + s[i][11].upcase + s[i][12].upcase + s[i][13].upcase\
    \ + s[i][14].upcase + s[i][15].upcase + s[i][16].upcase + s[i][17].upcase + s[i][18].upcase\
    \ + s[i][19].upcase + s[i][20].upcase + s[i][21].upcase + s[i][22].upcase + s[i][23].upcase\
    \ + s[i][24].upcase + s[i][25].upcase + s[i][26].upcase + s[i][27].upcase + s[i][28].upcase\
    \ + s[i][29].upcase + s[i][30].upcase + s[i][31].upcase + s[i][32].upcase + s[i][33].upcase\
    \ + s[i][34].upcase + s[i][35].upcase + s[i][36].upcase + s[i][37].upcase + s[i][38].upcase\
    \ + s[i][39].upcase + s[i][40].upcase + s[i][41].upcase + s[i][42].upcase + s[i][43].upcase\
    \ + s[i][44].upcase + s[i][45].upcase + s[i][46].upcase + s[i][47].upcase + s[i][48].upcase\
    \ + s[i][49].upcase + s[i][50].upcase + s[i][51].upcase + s[i][52].upcase + s[i][53].upcase\
    \ + s[i][54].upcase + s[i][55].upcase + s[i][56].upcase + s[i][57].upcase + s[i][58].upcase\
    \ + s[i][59].upcase + s[i][60].upcase + s[i][61].upcase + s[i][62].upcase + s[i][63].upcase\
    \ + s[i][64].upcase + s[i][65].upcase + s[i][66].upcase + s[i][67].upcase + s[i][68].upcase\
    \ + s[i][69].upcase + s[i][70].upcase + s[i][71].upcase + s[i][72].upcase + s[i][73].upcase\
    \ + s[i][74].upcase + s[i][75].upcase + s[i][76].upcase + s[i][77].upcase + s[i][78].upcase\
    \ + s[i][79].upcase + s[i][80].upcase + s[i][81].upcase + s[i][82].upcase + s[i][83",
  "  s.split('').inject(0) { |sum, item| sum += (item.ord - 'A'.ord) }\nend", "  return\
    \ s.chars.reduce(:+)\nend", "  return s.chars.reduce(:+)\nend", "    # your code\
    \ here\n    sum = 0\n    \n    for character in s\n        if character >= 'A'\
    \ and character <= 'Z'\n            sum += ord(character) - ord('A') + 1\n   \
    \ \n    return sum\n</cell>\n<cell>", "  s.downcase!\n  sum = 0\n  s.length.times\
    \ do |i|\n    sum += s.slice(i,i+1).upcase?.length ? s.slice(i,i+1).upcase.length\
    \ : 0\n  end\n  sum\nend", "  sum = 0\n  s.split(\"\").each do |c|\n    if c.ord\
    \ < 48 or c.ord > 57\n      next\n    end\n    sum = sum + c.ord\n  end\n  sum\n\
    end", "    # Your code goes here.\n    # Iterate through each letter in the string\
    \ and sum the ascii codes\n    # of its upper case letters.\n    s.each_char.inject(0)\
    \ { |sum, letter| sum + letter.ord if letter.upcase }\nend", "    sum = 0\n  \
    \  s.each_char do |char|\n        if char.upcase <= '9'\n            sum += char.upcase\n\
    \        else\n            break\n        end\n    end\n    sum\nend\n</cell>\n\
    <cell>", "  # TODO: Write your code here\n  return 0\nend", "  sum = 0\n  s.each_char\
    \ { |c| sum += c.ord - 'A'.ord}\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\n`each_char`\
    \ is in Rails, not Ruby 1.9\n<|/ c |>\n<| c |>\nThat is true, but if using rails\
    \ then `each_char` would be the answer.\n<|/ c |>\n<| c |>\n`each_char` would\
    \ work with the code I wrote, but in Ruby 1.9 and later, `each_char` won't work.\
    \  Using `each_with_index` is more idiomatic.\n<|/ c |>\n<| c |>\nI was going\
    \ to use `each_with_index`, but the problem was that `each_with_index` was returning\
    \ the elements in the array and the index, so I had to do some extra processing\
    \ on the elements.  I figured this was too easy an approach, so I went with the\
    \ simple `each_char`.\n<|/ c |>\n<| a tags=ruby dscore=2 |>\nHere's an example\
    \ of how you can implement it in Ruby 1.8.7:\n<code>", "  return s.to_s.split('').inject(:+)\n\
    end", "    total = 0\n    i = 0\n    while i < s.length\n        total += s.codePointAt(i).upcase\n\
    \        i += 1\n    return total\nend", "  s.chars.inject(0) { |sum,c| sum+c.ord\
    \ }\nend", "  s.chars.each.inject(0) do |sum,x|\n    sum + x.ord if x.upcase ==\
    \ x\n  end\nend", "  (0..s.size).inject {|sum, index| sum + s[index].ord + 48}\n\
    end", "  s.scan(/[a-z]/).map(&:ord).reduce(:+)\nend", "  total = 0\n  s.upcase.each_byte\
    \ { |char| total += char }\n  total\nend", "  return s.inject(0) {|sum, n| sum\
    \ + n.to_i.to_s(10)[0..1].length }\nend", "    sum = 0\n    chars = []\n    for\
    \ i in s\n        if i.upcase != 0\n            chars << i.upcase\n          \
    \  sum += i.upcase\n    return sum\nend", "    \n    # your code here\n    sum\
    \ = 0\n    for character in s \n        if character >= \"a\" and character <=\
    \ \"z\"\n            sum += ord(character) - ord(\"a\") + 1\n    end\n    return\
    \ sum\nend", "\tsum = 0\n\ts.each_char { |c| sum += c.upcase }\n\treturn sum\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI believe this should be `each_char.inject(:+)`\n\
    <|/ c |>\n<| c |>\nYes, `each_char` returns a `Enumerator` which has a `inject`\
    \ method. I think that's the correct way to do it (as opposed to using `inject`\
    \ directly on the string).\n<|/ c |>\n<| a tags=ruby,string,char,sum |>\n<code>",
  "    # Your code here\n    sum = [0] * 26\n    for i in s:\n        sum[ord(i) -\
    \ ord('a')] += 1 # ord('a') = 97\n    return sum(sum)", "  sum = 0\n  s.each_char\
    \ { |c| sum += c.ord - 'A'.ord }\n  sum\nend\n</cell>\n<cell>", "    s.to_s.split('').inject(0)\
    \ { |sum, n| sum + n.to_i.to_s[n.upcase ? 1 : -1].to_i }\nend", "  s.chars.reduce(0)\
    \ do |sum, n|\n    sum + n.ord.chr unless n.ord >= 48 && n.ord <= 57\n  end\n\
    end", "  sum = 0\n  s.chars.each do |c|\n    sum += (c.ord - 65)\n  end\n  sum\n\
    end\n</cell>\n<cell>", "  # Your code here\n  result = 0\n  s.each {|c| result\
    \ += c.to_i.chr}\n  result\nend", "  s.to_s.chars.inject {|sum, char| sum + char.ord\
    \ - \"A\".ord }\nend\n</cell>\n<cell>\ndigitSum(\"\")\n</cell>\n<cell>\ndigitSum(\"\
    abAB\")\n</cell>\n<cell>\ndigitSum(\"abcCd\")\n</cell>\n<cell>\ndigitSum(\"helloE\"\
    )\n</cell>\n<cell>\ndigitSum(\"woArBld\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nTask\nWrite a function that takes a string as input and returns\
    \ the sum of the characters that are equal to the character 'a'.\nExamples:\n\
    >>> charCount(\"aAbBcCdDa\")\n1\n>>> charCount(\"abBcCdda\")\n2\n>>> charCount(\"\
    abBccCdda\")\n2\n>>> charCount(\"aAbBcCdda\")\n1", "  result = 0\n  s.gsub!(/[^0-9]/,\
    \ \"\")\n  s.each_byte do |byte|\n    result += (byte - 48)\n  end\n  result\n\
    end", "    total = 0\n    s.each do |x|\n        if x.upcase >= 'A'\n        \
    \    total += (x-'A'+10)\n        end\n    end\n    return total\nend", "  # Write\
    \ your logic here\n  i = 0\n  sum = 0\n  while i < s.length\n    if s[i+1].to_i\
    \ > s[i].to_i\n      sum += s[i].to_i - s[i+1].to_i\n      i += 1\n    end\n \
    \ end\n  return sum\nend\ndigitSum(\"helloE\")", "  s.gsub!(/[^\\d]/,'')\n  s.to_i\n\
    end", "  str = ''\n  s.each_char { |c| str << c }\n  str.upcase!\n  str.length\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI love it! I like seeing how to solve\
    \ problems even with basic ruby knowledge and even better, seeing how to do things\
    \ differently and even better, seeing ways to solve problems with different tools\
    \ to aid my understanding. I guess I still have a long way to go but that gives\
    \ me something to chew on.\n<|/ c |>\n<| a |>\nHere's a solution using regular\
    \ expressions\n<code>", "  sum = 0\n  s.each_byte {|c| sum += c if c >= 48 &&\
    \ c <= 57}\n  return sum\nend", "    return s.gsub(/./) { |char| char.ord }.reduce(:+)\n\
    end", "  s.reverse!\n  sum = 0\n  s.each_byte do |char|\n    if char > 9\n   \
    \   sum += char - 48\n    else\n      sum += char\n    end\n  end\n  sum\nend",
  "  sum = s.split(//).inject(0) { |sum, char| sum + char.ord }\n  return sum\nend",
  "  sum = 0\n  for i in (s.upcase + s.downcase).to_a\n    sum += i.to_i\n  end\n\
    \  sum\nend", "    sum = 0\n    s.each_char do |x|\n        sum += x.ord + 48\
    \ if x.upcase? and x.ord >= 65 and x.ord <= 90\n    end\n    return sum\nend",
  "  # your code here\n  return 0\nend", "  return s.gsub(/[a-z]/).inject(0, :+).to_s\n\
    end", "  result = 0\n  s.each do |x|\n    if (x.ord >= 48).and.(x.ord <= 57)\n\
    \      result += x.ord\n    end\n  end\n  result\nend", "    sum = 0\n    l =\
    \ s.length\n    for i <- 0 until l\n        sum = sum + toUpper(s.charAt(i))\n\
    \    return sum\nend", "    sum = 0\n    s.split(\"\").each do |c|\n        sum\
    \ = sum + c.ord - \"0\" if c.ord >= \"0\" && c.ord <= \"9\"\n    end\n    return\
    \ sum\nend", "    sum = 0\n    for i in s\n        sum += i.to_i\n    end\n  \
    \  sum\nend\n</cell>\n<cell>", "  return s.chars.reduce(:+)\nend", "  s.each_char{\
    \ |c| return c if c >= '0' && c <= '9' }\n  s.count('a') + 1\nend", "  sum = 0\n\
    \  s.each_char do |c|\n    sum += (c.ord - 'A').to_i\n  end\n  sum\nend", "  \
    \  total = 0\n    s.chars.to_a.each do |e|\n        if e.ord > 64\n          \
    \  total += e.ord -64\n        end\n    end\n    total\nend", "  sum = 0\n  i\
    \ = 0\n  while i < s.length\n    sum = sum + ord(s[i]) - ord('A')\n    i += 1\n\
    \  sum\nend", "  (0..s.length).map { |i| s[i][0].ord - 'A'.ord }.inject(0, :+)\n\
    end", "  # TODO: write your code here\n  return 0\nend", "  return s.chars.inject(:+)\n\
    end\n</cell>\n<cell>\ndigitSum(\"tester\")\n</cell>\n<text>\nSolution 3", "  result\
    \ = s.dup\n  s.scan(/../){ |x| result += x.ord }\n  return result\nend", "  sum\
    \ = 0\n  s.chars.each do |c|\n    sum = sum + c.ord - 48\n  end\n  return sum\n\
    end", "  sum = 0\n  s.each do |c|\n    sum += c.ord - A\n  end\n  return sum\n\
    end", "  digitSum = 0\n  for i in 0..s.length\n    if s.charAt[i]>=65 and s.charAt[i]<=90\n\
    \      digitSum += (s.charAt[i])-65\n    else \n      return 0\n  return digitSum",
  "  return s.chars.inject(0) { |sum, (char)| sum + char.upcase.ord - char.downcase.ord\
    \ }\nend", "  sum = s.dup\n  s.gsub(/[a-z]/i) { sum.upto($&.to_i) }\n  sum.to_s\n\
    end\n</code>\n<|/ a tags=ruby,regex |>\n<| a dscore=0 |>\nI do not know Ruby,\
    \ but this looks good to me:\n<code>\nfunction digitSum(string)\n  var sum = 0;\n\
    \  for(var i = 0; i < string.length; i++) {\n    var char = string.substr(i, 1);\n\
    \    if(char.match(/\\d/))\n      sum += parseInt(char);\n  }\n  return sum;\n\
    }\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nWhy would you call it `function`\
    \ instead of `method`?\n<|/ c |>\n<| c |>\nBecause it is written in JavaScript.\
    \ You would call it a \"method\" in Ruby, but it has no direct equivalent.\n<|/\
    \ c |>\n<| a dscore=0 |>\nHere's an implementation using String#each_char:\n<code>",
  "    sum = 0\n    count = 0\n    \n    for i in s:\n        if i.isupper():\n  \
    \          count += 1\n            if count == 2:\n                sum += int(i)\n\
    \                count = 1\n        else:\n            count = 0\n    return sum\n\
    \            ", "  return s.downcase.gsub(/[[:digit:]]/).inject(0, :+)\nend",
  "    return s.to_i.inject(0) { |sum, n| sum + n }\nend", "    s = s.upcase\n   \
    \ sum = 0\n    s.each_char do |char|\n      sum += char.ord + 96\n    end\n  \
    \  return sum\nend", "  sum = 0\n  for i in s\n    if i.to_i.upcase > 9\n    \
    \  sum += i.to_i.upcase\n    end\n  end\n  return sum\nend", "    sum_ = 0\n \
    \   s.each_char.with_index do |char, index|\n        sum_ += char.ord if char\
    \ >= 'A' && char <= 'Z'\n    end\n    sum_\nend", "  return s.scan(/[a-z]/).inject(:+)\n\
    end", "  sum = 0\n  for i in (0...s.length)\n    # sum += (s.codeAt(i) - 'A').abs\n\
    \    sum += (s.codeAt(i) - '0').abs\n  return sum", "  s.scan(/./).inject do |sum,\
    \ chr|\n    sum + chr.ord if chr.ord >= 48 && chr.ord <= 57\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nNice use of inject. Although, it is not necessary to use inject\
    \ or scan here, since the OP's problem does not require the full range of ASCII\
    \ codes. You could also use [String#sum](http://ruby-doc.org/core-2.2.0/String.html#method-i-sum),\
    \ like `s.to_s.sum { |i| i.ord if i.ord >= 48 && i.ord <= 57 }`.\n<|/ c |>\n<|\
    \ a tags=ruby |>\nAs I mentioned in another answer, this is one way to do it with\
    \ Ruby's Kernel#Integer#chr:\n<code>\n\"helloE\".to_i(16).chr #=> \"e\"\n</code>\n\
    Another way to do it with Kernel#String#each_char:\n<code>\n\"helloE\".each_char.inject(0)\
    \ { |sum, chr| sum + chr.ord if chr.ord >= 48 && chr.ord <= 57 }\n  #=> 131 \n\
    </code>\nor\n<code>\n\"helloE\".to_i(16).each_char.inject(0) { |sum, chr| sum\
    \ + chr.ord if chr.ord >= 48 && chr.ord <= 57 }\n  #=> 131 \n</code>\nThe String\
    \ \"helloE\" is converted to an integer using to_i, passing an optional base to\
    \ use to convert the digits. In this case, I passed 16 (hexadecimal). \nThe return\
    \ value of to_i is an integer, and so each_char is called on that integer. \n\
    The Enumerable method inject is called on the resulting Enumerable of the call\
    \ to to_i. This produces an Enumerator that we can call Enumerator#next on to\
    \ get the next value of the enumerator. \nWhen the Enumerator is next called on\
    \ it, a block is passed to the block and its return value is returned by the next.\
    \ \nThe sum is incremented by sum + chr.ord if the character is between ASCII\
    \ code 48 and 57 (inclusive). \nThe block calculation is thus equivalent to:\n\
    <code>\n\"helloE\".to_i(16).each_char.inject(0) { |sum, chr| sum + chr.ord }\n\
    \  #=> 131 \n</code>\nAs noted in another answer, Enumerable#inject has been superseded\
    \ by Enumerator#reduce, so you could write that as:\n<code>\n\"helloE\".to_i(16).reduce(0)\
    \ { |sum, chr", "  return s.to_s.unpack(\"U*\").inject(:+).to_s\nend", "  s.scan(/./)\
    \ do |x|\n    x.ord - ('0'.ord) + ('9'.ord) - x.ord\n  end\nend", "  s.chars.inject\
    \ { |sum, (i, _)| sum + i.ord - '0' }\nend", "    sum = 0\n    for c in s\n  \
    \      if c.to_i >= 48 and c.to_i < 58\n            sum += c.to_i\n    return\
    \ sum\n</code>\n<|/ a tags=string,arrays,ruby |>\n<| a tags=string,arrays,ruby\
    \ |>\nIf you wish to do this by converting string to array, you can do it this\
    \ way:\n<code>\nstr = \"abcdefg\"\narr = [*str]\narr.select { |e| e.is_a? Integer\
    \ }\n</code>\nThis will return an array with integers and no other types. If you\
    \ want a string to be displayed as a string then you can convert it to string,\
    \ like this:\n<code>\nstr = \"abcdefg\"\narr = [*str]\narr.select { |e| e.is_a?\
    \ Integer }.map{ |e| e.to_s }\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,arrays,ruby\
    \ |>\n<code>\n def sum_up(str)\n str.chars.each.with_index.reduce(0) { |tot, i|\
    \ tot + i }\n end\n</code>\nI used Ruby 1.8.7\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ gives a `TypeError: can't convert String into Integer` on `\"aAaaaXa\"` since\
    \ `\"a\"` doesn't convert to `0` as you might expect.\n<|/ c |>\n<| c |>\nYou\
    \ missed the whole point of converting it to an array first.\n<|/ c |>\n<| c |>\n\
    : No, it doesn't \"give you a TypeError on `\"aAaaaXa\"`\". It gives an `ArgumentError:\
    \ wrong number of arguments (1 for 0) [arguments]` and a TypeError on `\"aAaaaXa\"\
    ` because `sum.call(\"aAaaaXa\")` gives an error because `\"a\"` doesn't convert\
    \ to `0` as you might expect.\n<|/ c |>\n<| c |>\n: Yes, it does give that error\
    \ on `\"aAaaaXa\"` because `\"a\"` doesn't convert to `0` as you might expect.\n\
    <|/ c |>\n<| c |>\n: Yes, it gives that error on `\"aAaaaXa\"` because `\"a\"\
    ` doesn't convert to `0` as you might expect.\n<|/ c |>\n<| a tags=string,arrays,ruby\
    \ |>\n<code>\n\"123\".chars.map { |c| c.to_i.to_s }.join('')\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,arrays,ruby |>\n<code>\n\"12334567\".", "  s.gsub(/[a-z]/){|i|\
    \ i.upcase + i.downcase}\nend", "  sum = 0\n  s.each do |c|\n    sum += c.upcase\
    \ unless c.is_ascii?\n  end\n  return sum\nend", "  sum = 0\n  s.each_byte { |c|\
    \ sum += c if c.upcase >= 'A' && c.upcase <= 'Z' }\n  sum\nend", "  s = 0\n  s.each_char\
    \ do |c|\n    s += (c.ord - '0') if c == '0' || c == '1'\n  end\n  s\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
