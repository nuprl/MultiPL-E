name: HumanEval_115_max_fill
language: rb
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n\
  # Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
  \ 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]],\
  \ 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length\
  \ <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <=\
  \ capacity <= 10\ndef max_fill(grid, capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["  fill = 0\n  while fill < capacity\n    fill = fill + 1 \n    \n \
    \   bucket_fill = fill\n    bucket_left = 0\n    bucket_right = len(grid[0]) -\
    \ 1\n    while bucket_fill != bucket_left\n      bucket_fill = bucket_fill - grid[bucket_left][bucket_right]\
    \ \n      bucket_right = bucket_right + 1\n    end", "    # Write your code here\n\
    \    total = 0\n    count = 0\n    for r in 0...grid[0].length\n        for c\
    \ in 0...grid[0].length\n            if grid[r][c] == 1\n                total\
    \ += 1\n                if total > capacity\n                    count += 1\n\
    \                total = 0\n            end\n        end\n    end\n    return\
    \ count\nend", "  n = grid.length\n  m = grid[0].length", "    # write your code\
    \ here\n    @cache.memoize\n    def helper(amount, buckets)\n        if amount\
    \ == 0\n            buckets.reduce(:+)\n        else\n            helper(amount\
    \ / grid.length, buckets) \\\n                + helper(amount - grid.length *\
    \ grid.first, buckets)\n        end\n    end\n    helper(capacity, Bucket.new(0))\n\
    end", "    length_of_grid = grid.length\n    \n    buckets = Array.new(capacity)\n\
    \    for i in 0..(length_of_grid - 1)\n        buckets[i] = 0\n    \n    length_of_grid\
    \ = length_of_grid - 1\n    buckets.each { |b| buckets[b] += 1 }\n    \n    length_of_grid\
    \ -= 1\n    \n    while length_of_grid > 0\n        for i in 0..(length_of_grid\
    \ - 1)\n            if buckets[i] < capacity\n                buckets[i] = buckets[i]\
    \ + capacity - buckets[i - 1]\n                length_of_grid -= 1\n         \
    \   end\n        end\n    end\n    \n    length_of_grid\nend\n</cell>\n<cell>\n\
    test_assert(max_fill([[1, 0, 0, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6)\ntest_assert(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) == 5)\ntest_assert(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5) == 0)\n</cell>\n<text>\n4.4 Dynamic Programming\nDP algorithm\
    \ is a way to solve the above problem without having to repeatedly recompute the\
    \ same thing. Let's solve the previous problem using a DP algorithm!", "    grid2\
    \ = Array.new(2)\n    Array.copy(grid, grid2)\n    grid2[0].fill(capacity)\n \
    \   grid2[1].fill(capacity)\n    grid2[2].fill(capacity)\n    grid2[3].fill(capacity)\n\
    \    grid2[4].fill(capacity)\n    grid2[5].fill(capacity)\n    grid2[6].fill(capacity)\n\
    \    grid2[7].fill(capacity)\n    grid2[8].fill(capacity)\n    grid2[9].fill(capacity)\n\
    \    grid2[10].fill(capacity)\n    grid2[11].fill(capacity)\n    grid2[12].fill(capacity)\n\
    \    grid2[13].fill(capacity)\n    grid2[14].fill(capacity)\n    grid2[15].fill(capacity)\n\
    \    grid2[16].fill(capacity)\n    grid2[17].fill(capacity)\n    grid2[18].fill(capacity)\n\
    \    grid2[19].fill(capacity)\n    grid2[20].fill(capacity)\n    grid2[21].fill(capacity)\n\
    \    grid2[22].fill(capacity)\n    grid2[23].fill(capacity)\n    grid2[24].fill(capacity)\n\
    \    grid2[25].fill(capacity)\n    grid2[26].fill(capacity)\n    grid2[27].fill(capacity)\n\
    \    grid2[28].fill(capacity)\n    grid2[29].fill(capacity)\n    grid2[30].fill(capacity)\n\
    \    grid2[31].fill(capacity)\n    grid2[32].fill(capacity)\n    grid2[33].fill(capacity)\n\
    \    grid2[34].fill(capacity)\n    grid2[35].fill(capacity)\n    grid2[36].fill(capacity)\n\
    \    grid2[37].fill(capacity)\n    grid2[38].fill(capacity)\n    grid2[39].fill(capacity)\n\
    \    grid2[40].fill(capacity)\n    grid2[41].fill(capacity)\n    grid2[42].fill(capacity)\n\
    \    grid2[43].fill(capacity)\n    grid2[44].fill(capacity)\n    grid2[45].fill(capacity)\n\
    \    grid2[46].fill(capacity)\n    grid2[47].fill(capacity)\n    grid2[48].fill(capacity)\n\
    \    grid2[49].fill(capacity)\n    ", "    # Write your code here.\n    buckets,\
    \ i, j, l = 0, 0, len(grid[0]), len(grid[0])\n    bucket_list = []\n    while\
    \ i < l:\n        if buckets[i] < capacity:\n            buckets[i] += 1\n   \
    \         bucket_list.append(i)\n        i += 1\n    while j < l:\n        if\
    \ buckets[j] < capacity:\n            buckets[j] += 1\n            bucket_list.append(j)\n\
    \        j += 1\n    count = 0\n    while i < len(grid) and j < len(grid):\n \
    \       if grid[i][j] == 1 and bucket_list.index(j) < bucket_list.index(i):\n\
    \            grid[i][j] = 0\n        else:\n            buckets[bucket_list.index(j)]\
    \ -= 1\n            buckets[bucket_list.index(i)] -= 1\n            count += 1\n\
    \        i += 1\n        j += 1\n    return count\n</cell>\n<text>\nProblem 13:\
    \ Maximum Area of Islands\nThe maze problem is a classic problem with many variations\
    \ and all have different ways to solve it.", "    # Fill each bucket in the grid\n\
    \    bucket_capacity = [0]\n    for bucket in grid\n        bucket_capacity.push(bucket.capacity)\n\
    \    \n    # Find the max capacity of the buckets\n    bucket_max_capacity = bucket_capacity.max",
  "  buckets = Array.new(grid[0].length, Array.new(grid[0].length, capacity))\n  grid[0].map.with_index\
    \ do |col, i|\n    buckets[i].map! do |row|\n      row.clear\n    end\n  end\n\
    \  grid[0].map.with_index do |col, i|\n    grid[0].length.times do |j|\n     \
    \ if grid[i][j] == 1\n        buckets[i][j] -= 1\n      end\n    end\n  end\n\
    \  buckets.each do |bucket|\n    bucket.each { |n| return n if n <= 0 }\n  end\n\
    \  0\nend", "  count = 0\n  grid.each do |row|\n    row[0].each do |cell|\n  \
    \    if(cell == 0)\n        count += row[1]\n      end\n    end\n  end\n  count\n\
    end\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a tags=algorithm,ruby |>\nHere\
    \ is an algorithm that solves your problem without recursion :\n<code>", "  return\
    \ nil if grid.length == 0\n  buckets = Array.new(capacity).fill(0).tap {|b| b.each_index\
    \ {|i| b[i] = 1}} \n  grid.each_index.with_index do |i, row|\n    buckets[grid[i][0]].tap\
    \ {|b| b[i] = 0}\n  end\n  buckets.length\nend", "    # Write your code here.\n\
    \    size = grid.length\n    buckets = Array.new(size)", "  n = grid.length\n\
    \  m = grid[0].length\n  num_fills = n * (n-1)\n  num_buckets = capacity\n  \n\
    \  buckets = Array.new(num_buckets)\n  \n  # Initialize all buckets to 0\n  (0...num_buckets).each\
    \ { |i| buckets[i] = 0 }\n  \n  # Fill buckets\n  (1...n).each do |i|\n    (1...m).each\
    \ do |j|\n      # For each well, check how many buckets are already full\n   \
    \   # and whether we can extract water from it.\n      if buckets[j] > 0 && grid[i][j]\
    \ == 1\n        buckets[j] -= 1 \n        num_fills -= 1 \n      else\n      \
    \  # There is no water to extract from j, so just put j's bucket to 0\n      \
    \  buckets[j] = 0\n      end\n    end\n  end\n  \n  num_fills\nend\n</cell>\n\
    <cell>", "    # Fill the empty location\n    empty = (nil, nil)\n    max_fill_val\
    \ = nil\n    max_fill_val = nil\n    max_fill_val = 0\n    grid.each do |row|\n\
    \        row.each do |item|\n            if item == 0\n                if empty[0]\
    \ != nil && empty[0] != nil\n                    empty[0] += 1\n             \
    \   end\n                if empty[1] != nil && empty[1] != nil\n             \
    \       empty[1] += 1\n                end\n            end\n        end\n   \
    \ end", "    # Your code here\n    n, m = len(grid), len(grid[0])\n    if capacity\
    \ == 0 or n < 1 or m <= 0 or capacity > 10 or n > 10^2 or m > 10^2:\n        return\
    \ 0\n    buckets = [[0] * capacity for _ in range(n)]\n    for well in range(n):\n\
    \        buckets[well][0] = grid[well][0];\n        buckets[well][1] = grid[well][1];\n\
    \    for i in range(1, m):\n        buckets[0][i] = grid[0][i];\n    for i in\
    \ range(1, n):\n        buckets[i][0] = grid[i][0];\n        for j in range(1,\
    \ m):\n            buckets[i][j] = max(buckets[i - 1][j], buckets[i][j - 1])\n\
    \    return sum([1 for bucket in buckets if bucket != 0])", "    # Write your\
    \ code here.\n    rows = grid.length\n    cols = grid[0].length\n    count = 0\n\
    \    max_count = 0\n    for i in range(rows)\n        if grid[i][cols-1] == 0\n\
    \            count += 1\n            if count > max_count\n                max_count\
    \ = count\n    count = 0\n    for i in range(rows)\n        if grid[i][0] == 0\n\
    \            count += 1\n            if count > max_count\n                max_count\
    \ = count\n    for i in range(rows)\n        for j in range(cols)\n          \
    \  if grid[i][j] == 1\n                count += 1\n                if count >\
    \ max_count\n                    max_count = count\n    return max_count\n   \
    \         \n            ", "    # Your code here\n    size = grid.length\n   \
    \ \n    count = 0\n    \n    buckets = Array.new(1, capacity)\n    \n    grid.each\
    \ do |row|\n      buckets[row[0]] = row[1]\n    end\n    \n    buckets.each do\
    \ |b|\n      count += 1 if b == 0\n    end\n    \n    count -= size if size !=\
    \ 0\n    \n    count\nend", "    \n    # Solution 1: Brute force\n    # Time complexity:\
    \ O(m*n), where m is the size of the grid and n is the number of rows\n    count\
    \ = 0\n    m = grid.length\n    n = grid[0].length\n    \n    # Find the last\
    \ row and last column\n    rows = m - 1\n    cols = n - 1\n    while rows >= 0\
    \ and cols >= 0\n        count = 0\n        while rows > 0 and cols > 0\n    \
    \        # Use bucket to extract water from each well\n            bucket = grid[rows][:cols]\n\
    \            grid[rows][:cols] = nil\n            # Count how many water is left\
    \ in the bucket\n            count = count + bucket_count(bucket)\n          \
    \  # Move to the next row\n            rows-=1\n            # Move to the next\
    \ column\n            cols-=1\n            # Move to the next row\n          \
    \  rows += bucket[0]\n            # Move to the next column\n            cols\
    \ += bucket[1]\n        \n        # Move to the next row if the current row has\
    \ enough water\n        if count >= capacity\n            count += 1\n       \
    \     rows -= 1\n        # Move to the next column if the current column has enough\
    \ water\n        if count >= capacity\n            count += 1\n            cols\
    \ -= 1\n        \n        # Move to the next row and column if all cells are empty\n\
    \        if count == 0\n            rows += 1\n            cols += 1\n       \
    \     count = 0\n        end \n    end\n    return count\nend", '    return 0',
  "    m, n = grid.length\n    i, j = 0, 0\n    while i < m and j < n\n        if\
    \ grid[i][j] == 1\n            i += 1 # move down\n        else if grid[i][j]\
    \ == 0\n            grid[i][j] = 1 # empty well\n            i += 1 # move down\n\
    \            j += 1 # move right\n        else # grid[i][j] can't be 0 or 1\n\
    \            i, j = i + 1, j + 1\n    return j - i + 1\nend", end, "    return\
    \ \nend\n</cell>\n<code language=julia-1.5>", "    m, n = grid.length\n    m,\
    \ n = n, m # swap dimensions\n    \n    sum = 0\n    \n    for i in 0...m-1\n\
    \        for j in 0...n-1\n            sum = sum + grid[i,j] * grid[i+1,j+1]\n\
    \            if sum > capacity\n                break\n            end\n     \
    \   end\n        sum = sum + grid[i,j] * grid[i,j+1]\n        sum %= capacity\n\
    \        sum += grid[i,j] * (capacity - sum)\n    end\n    return sum\nend", " \
    \   i = 0\n    count = 0\n    while i < grid.length\n        j = i\n        bucket\
    \ = grid[i][j]\n        i += 1\n        while i < grid.length\n            if\
    \ bucket != grid[i][j]\n                grid[j][i] = 0\n                j += 1\n\
    \                i += 1\n            else\n                i += 1\n          \
    \  end\n        end\n        count += 1\n    end\n    return count\nend", "  \
    \  # Fill the grid and return the number of ways you can do so\n    number_of_ways\
    \ = 0\n    while grid.length > 0\n        number_of_ways += 1\n        min_val,\
    \ max_val = find_min_max_in_grid(grid)\n        if max_val-min_val == capacity\
    \ or capacity == 0\n            break\n        grid.fill(capacity)\n    end\n\
    \    number_of_ways\nend", "    len = grid.length\n    h = grid.hash\n    ret\
    \ = 0\n    # sort grid first\n    grid = grid.sort_by {|i, j| [i, j]}\n    # fill\
    \ each well of the grid one by one \n    grid.each_cons(len) { |row, i|\n    \
    \    # if the well is empty, skip it \n        if row.length == 0\n          \
    \  next\n        end\n        # check if the row is full, if not skip the row\
    \ \n        if row.length >= capacity\n            ret += row.length\n       \
    \     next\n        end\n        # filling the bucket\n        row.each_with_index\
    \ { |value, j|\n            # if the bucket is full, skip the bucket \n      \
    \      if h[value] != nil && h[value].length >= capacity\n                ret\
    \ += h[value].length\n                next\n            end\n            # adding\
    \ the water to the bucket\n            h[value] ||= [] if h[value] == nil\n  \
    \          h[value] << row[j]\n        }\n    }\n    return ret\nend", "  return\
    \ count_fills(grid, capacity)\nend", "    buckets = Array.new(capacity)\n    grid.each_index\
    \ do |i|\n        grid.each_with_index do |row|\n            buckets[row] ||=\
    \ 0\n            if row[i] != 0\n                buckets[row] += 1 # Don't count\
    \ 0 as a unit\n            end\n        end\n    end\n    buckets.each_index do\
    \ |i|\n        if buckets[i] > 0\n            buckets[i-1] -= 1\n        end\n\
    \    end\n    buckets.length\nend", "    # Your code here\n    return 0\nend",
  "    # Write your code here\n    # O(n)\n    cnt = 0\n    i = 0\n    j = 0\n   \
    \ while i <  grid.length - 1\n        while j < grid[i].length\n            cnt\
    \ += grid[i][j]\n            j += 1\n        i += 1\n    i = j = 0\n    while\
    \ i < grid.length - 1\n        while j < grid[i].length\n            grid[i][j]\
    \ = 0\n            j += 1\n        i += 1\n    while i < grid.length - 1\n   \
    \     while j < grid[i].length\n            grid[i][j] = 1\n            j += 1\n\
    \        i += 1\n    while i < grid.length - 1\n        while j < grid[i].length\n\
    \            grid[i][j] = 0\n            j += 1\n        i += 1\n    return cnt",
  "    # write your code here\n    res = 0\n    cap = Array(capacity)\n    bucket\
    \ = Array(capacity)\n    for  i in 0..(grid.length-1)\n        for  j in 0..(grid[i].length-1)\n\
    \            if grid[i][j] == 1\n                cap[i] = cap[i] - 1\n       \
    \         bucket[i] = cap[i]\n            else\n                cap[i] = bucket[i]\n\
    \                if cap[i] > 0\n                    cap[i] = cap[i] - 1\n    \
    \                bucket[i] = cap[i]\n                end\n            end\n  \
    \      end\n    end\n    return res\nend\n</cell>\n<code language=julia-1.5>",
  "  result = 0\n  grid.each do |row|\n    row.each do |item|\n      result += (item\
    \ != 0) ? capacity : -1\n    end\n  end\n  result\nend\n</cell>\n<code language=julia-1.2>\n\
    max_fill([0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1])\n</cell>\n<text>\n\
    4. Permutations\nThe permutations are generated by selecting each element from\
    \ the set {1, 2, 3} and swapping it with each element in the set {2, 3, 1}.  You\
    \ can permute the elements of a set by swapping the first element with the second,\
    \ the second with the third, and so on, until you get to the end of the set.\n\
    For example, given the set {1, 2, 3}, a permutation {1, 3, 2} would produce the\
    \ set {2, 1, 3}.\nThe first element of the permutation can be swapped with the\
    \ last element of the permutation, and the second with the second to last, and\
    \ so on.\nFor example, given the set {1, 2, 3}, a permutation {1, 3, 2} would\
    \ produce the set {2, 3, 1}.\nA permutation of a set is a way to arrange its elements\
    \ so that they are in sorted order.\nGiven a permutation p of n elements of a\
    \ set A, a permutation P of m elements of a set B is:\nP = A[p[1], p[2], ...,\
    \ p[m]]", "    put = 0\n    min = capacity\n    \n    grid = deepcopy(grid)\n\
    \    while put < min\n        bucket = nil\n        max_value = -1\n        \n\
    \        for i in range(grid.length)\n            if grid[i][1] == 0 # 0 means\
    \ empty well\n                bucket = grid[i][0]\n                \n        \
    \        while bucket and bucket < capacity\n                    if bucket.lower.downer.value\
    \ > max_value\n                        max_value = bucket.lower.downer.value\n\
    \                    bucket = bucket.uper\n                \n                if\
    \ max_value == -1\n                    max_value = capacity\n                \n\
    \                grid[i][1] = max_value\n                \n                if\
    \ max_value < min\n                    min = max_value\n                put =\
    \ put + 1\n                \n            end\n        end\n    end\n    return\
    \ put\nend", "  return \nend", "  return if (grid.length == 0 || grid.first.length\
    \ == 0)\n  return if (capacity == 0)\n  max_fill_iter(0, grid.length, grid.first.length,\
    \ capacity)\nend", "    # Write your code here.\n  \n  \n  \n  \n  return result\n\
    \        \n        \n        \n        \n        \n        \n        ", "  grid.each_with_index\
    \ do |row,i|\n    row.each_with_index do |cell,j|\n      if cell == 1\n      \
    \  grid[i][j] = capacity - grid[i][j]\n      end\n    end\n  end\n  \n  count\
    \ = 0\n  grid.each_with_index do |row,i|\n    row.each_with_index do |cell,j|\n\
    \      count = count + 1 if cell == 0\n    end\n  end\n  \n  count\nend\n</cell>\n\
    <cell>", "    m, n = grid.length\n    buckets = Array.new(capacity, Array.new(capacity,\
    \ 0))\n    buckets.each do |b|\n        b.each do |b| # fill all buckets\n   \
    \         b.fill(0)\n        end\n    end\n    grid.each do |row|\n        row[1].each\
    \ do |w|\n            if buckets[w[0]][w[1]] == 0\n                buckets[w[0]][w[1]]\
    \ = w[2]\n            else\n                buckets[w[0]][w[1]] -= w[2]\n    \
    \        end\n        end\n    end\n    return buckets.reduce(:+)\nend\n</cell>\n\
    <code language=julia-1.3>\nmax_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
    \ [0, 1, 1, 1]], 2)\n</cell>\n<text>\n7. Parking Lot\nYou are given an array of\
    \ non-negative integers representing the parking lot's capacities.\nThe i-th element\
    \ represents the parking lot capacity of the i-th car in that parking lot.\nThe\
    \ goal is to find the minimum number of cars needed to park all the cars in the\
    \ parking lot.", "    # Fill wells by iterating over all empty wells \n    bucket_count\
    \ = {}\n    bucket_capacity = {}\n    \n    for i in 0..grid.length\n        bucket_count[i]\
    \ = 0\n    end\n    for j in 0..grid[0].length\n        bucket_capacity[j] = capacity\n\
    \    end\n    \n    for i in 0..grid.length\n        for j in 0..grid[0].length\n\
    \            if grid[i][j] == 0\n                \n                # Add current\
    \ bucket to bucket_count\n                bucket_count[grid[i][j]] += 1\n    \
    \            \n                # Calculate bucket_capacity with new bucket_count\n\
    \                bucket_capacity[grid[i][j]] -= 1\n                \n        \
    \        # Check if bucket_capacity is zero\n                if bucket_capacity[grid[i][j]]\
    \ < 0\n                    bucket_capacity[grid[i][j]] = 0\n                end\n\
    \            end\n        end\n    end\n    \n    # Return bucket_count\n    return\
    \ bucket_count\nend", "    length_buckets = Array.new(grid.length) { 0 }\n   \
    \ grid.length.times do |i|\n        grid.map! { |j| j == 0 ? capacity : length_buckets[i]\
    \ }\n    end\n    \n    grid.length.times do |i|\n        if grid[i].sum > 0\n\
    \            grid[i].times do |j|\n                if grid[i][j] == 1\n      \
    \              grid[i][j] = 0\n                    length_buckets[j] = length_buckets[j]\
    \ - 1\n                end\n            end\n        end\n    end\n    \n    length_buckets.reduce(0)\
    \ { |sum, val| sum + val }\nend", "  return solve_capacity(grid, capacity)\nend",
  "  m = []\n  l = nil\n  \n  m = Array.new(capacity, 0)\n  l = Array.new(capacity,\
    \ 0)\n  \n  n.times do |i|\n    m.each do |j| \n      if grid[i][j] == 1\n   \
    \     m[j] += 1\n        break\n      end\n    end\n  end\n  \n  m.each do |j|\n\
    \    if j > 0\n      l[j] = grid[j][0].to_i\n    end\n  end\n  \n  l.each do |j|\n\
    \    grid[j][0] += 1\n  end\n  \n  l.each do |j|\n    if l[j] == grid[j].length\n\
    \      m += l\n    end\n  end\n  \n  m.each do |l|\n    if m == l\n      return\
    \ m\n    end\n  end\n  \n  return 0\nend", "    count = 0\n    for row in (0...grid.length).to_a\n\
    \      empty = 0\n      row.each do |cell|\n        if cell.zero?\n          empty\
    \ += 1\n        end\n      end\n      count += empty / capacity\n    end\n   \
    \ count\nend", "  \n  row = 0\n  column = 0\n  rowMax = 0\n  columnMax = 0\n \
    \ \n  while column < grid.length\n    rowMax = 0\n    columnMax = 0\n    while\
    \ row < grid.length\n      if grid[row][column] == 1\n        if rowMax < capacity\n\
    \          rowMax += 1\n      \n        if columnMax < capacity\n          columnMax\
    \ += 1\n      \n      row += 1\n    end", "    buckets = Array.new(capacity, -1)\n\
    \    (rows, cols) = grid.size\n    (bucket_count, rows_count, cols_count) = grid.to_a\n\
    \    (bucket_count, rows_count, cols_count).each do |bucket, row, col|\n     \
    \   if bucket >= 0 && (row==rows_count-1) && (col==cols_count-1)\n           \
    \ buckets[bucket] += 1\n        else\n            buckets[bucket] = 0\n      \
    \  end\n    end\n    buckets.each do |bucket|\n        bucket_count = bucket\n\
    \        break\n    end\n    bucket_count.downto(bucket_count-1) do |bucket_count|\n\
    \        if bucket_count == 1\n            if capacity >= grid[bucket_count, 1]\n\
    \                grid[bucket_count, 1] = 0\n                capacity -= 1\n  \
    \          else\n                grid[bucket_count, 1] = 1\n                capacity\
    \ -= 1\n            end\n        else\n            if capacity >= grid[bucket_count,\
    \ 1]\n                grid[bucket_count, 1] = 0\n                capacity -= 1\n\
    \            else\n                grid[bucket_count, 1] = 1\n               \
    \ capacity -= 1\n            end\n        end\n    end\nend", "    length = grid[0].length\n\
    \    if length == 0\n        return 0\n    \n    current = length = grid[0].length\n\
    \    \n    left = 0\n    while length > 0\n        \n        grid[current][0]\
    \ = grid[left][0] = grid[left-1][0] = grid[left+1][0] = grid[current-1][0]\n \
    \       grid[current][1] = grid[left][1] = grid[left-1][1] = grid[left+1][1] =\
    \ grid[current-1][1]\n        \n        left += -1\n        current -= -1\n  \
    \      \n        length += 1\n    end\n    \n    current = length\n    left =\
    \ 0\n    while length > 0\n        \n        grid[current][0] = grid[left][0]\
    \ = grid[left-1][0] = grid[left+1][0] = grid[current-1][0]\n        grid[current][1]\
    \ = grid[left][1] = grid[left-1][1] = grid[left+1][1] = grid[current-1][1]\n \
    \       \n        left += -1\n        current -= -1\n        \n        length\
    \ += 1\n    end\n    \n    current = length\n    left = 0\n    while length >\
    \ 0\n        \n        grid[current][0] = grid[left][0] = grid[left-1][0] = grid[left+1][0]\
    \ = grid[current-1][0]\n        grid[current][1] = grid[left][1] = grid[left-1][1]\
    \ = grid[left+1][1] = grid[current-1][1]\n        \n        left += -1\n     \
    \   current -= -1\n        \n        length += 1\n    end\n    \n    current =\
    \ length\n    left = 0\n    while length > 0\n        \n        grid[current][0]\
    \ = grid[left][0] = grid[left-1][0] = grid[left+1][0] = grid[current-1][0]\n \
    \       grid[current][1] = grid[left][1] = grid[left-1][1] = grid[left+1][1] =\
    \ grid[current-1][1]\n        \n        left += -1\n        current -= -1\n  \
    \      \n        length += 1\n    end\n    \n    current = length\n    left =\
    \ 0\n    while length > 0\n        \n        grid[current][0] = grid[left][0]\
    \ = grid[left-1][0] = grid[left+1][0] = grid[current-1][0]\n        grid[current][1]\
    \ = grid[left][1] = grid[left-1][1] = grid[left+1][1] = grid[current-1][1]\n \
    \       \n        left += -1\n        current -= -1\n        \n        length\
    \ += 1\n    end\n    \n    current = length\n    left = 0\n    while length >\
    \ 0\n        \n        grid[current][0] = grid[left][0] = grid[left-1][0] = grid[left+1][0]\
    \ = grid[current-1][0]\n        grid", "    # Fill all the buckets with capacity\
    \ as 0 \n    bucket_map = Array(Int,10,10)\n    for row in grid\n        bucket_map[row[0]][row[1]]\
    \ = 0\n    # Fill in the bucket in every row\n    for row in grid\n        if\
    \ bucket_map[row[0]][row[1]] != 0\n            bucket_map[row[0]][row[1]] = capacity\n\
    \        else\n            bucket_map[row[0]][row[1]] = 0\n        \n    # Find\
    \ the max water in the buckets \n    count = 1\n    for bucket_row in bucket_map\n\
    \        bucket_max = bucket_row[bucket_row.length-1]\n        \n        # If\
    \ the bucket has a water with higher capacity\n        for bucket_item in bucket_item\n\
    \            # If the capacity is less than the bucket max water then increase\
    \ the count \n            if bucket_max < bucket_item\n                count +=\
    \ 1\n                bucket_max = bucket_item\n                \n    return count\n\
    end", "  return 1 if capacity == 0 or grid[0].length == 0 then 0 else if grid[0].length\
    \ >= grid[1].length then grid[0].length elsif grid[1].length >= grid[0].length\
    \ then grid[1].length else grid[1].length * grid[0].length\nend", "    # write\
    \ your code here\n    return 0\nend", "    # Write your code here.\n    return\
    \ nil\nend", "    # write your code here\n    return \n</cell>\n<text>\n6. Optimal\
    \ Substructure\nA substructure of a set is a group of elements that occur in different\
    \ positions of the set. For example, in the set {a, b, c}, substructure (a, c)\
    \ and substructure (b, a) are both substructures of the set.", "    m, n = grid.length,\
    \ grid[0].length\n    answer = 0\n    (m, n) = grid.length, grid[0].length\n \
    \   \n    bucket_capacity = Array.new(m,0)\n    \n    # Init the bucket capacities\n\
    \    bucket_capacity.each_index { |i| bucket_capacity[i] = capacity }\n    \n\
    \    # Initially fill the buckets\n    (1..m).each do |i|\n      bucket_capacity.each\
    \ { |c| bucket_capacity[i] -= c }\n    end\n    \n    # Fill the buckets\n   \
    \ grid.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n\
    \        bucket_capacity[j] -= value\n        \n        # If there's still space\
    \ left\n        if bucket_capacity[j] <= 0\n          bucket_capacity.swap(j,\
    \ bucket_capacity.length-1)\n          bucket_capacity[j] = capacity\n       \
    \   bucket_capacity.push(0)\n        end\n      end\n    end\n    \n    # Remove\
    \ the filler\n    bucket_capacity.each_index { |i| bucket_capacity[i] -= 1 }\n\
    \    \n    bucket_capacity.each_index { |i| answer += bucket_capacity[i] }\n \
    \   \n    return answer\n  end\nend", "  return \nend", "  count = 0\n  buckets\
    \ = Array.new(capacity)\n  grid.each do |row|\n    row.each_with_index do |value,\
    \ index|\n      count += 1 if buckets[index] >= capacity\n      buckets[index]\
    \ += 1 if value == 1\n    end\n  end\n  count\nend", "  grid.each do |row|\n \
    \   row.each do |cell|\n      cell[0] <= capacity ? cell[0] += 1 : cell[0] = 1\n\
    \    end\n  end\n  count = 0\n  grid.each do |row|\n    row.each do |cell|\n \
    \     cell[0] > capacity ? count += 1 : cell[0] = 0\n    end\n  end\n  count\n\
    end", "  # Write your code here.\n  raise NotImplementedError(\"You need to write\
    \ this function.\")", "    # Write your code here.\n    return max_fill_helper(grid,\
    \ 0, capacity)\nend", "    buckets = Array(capacity)\n    grid.each_with_index\
    \ do |row, i|\n        row.each_with_index do |column, i|\n            buckets[i]\
    \ = row\n        end\n    end\n    bucket_sum = 0\n    bucket_sums = buckets.zip(*buckets)\n\
    \    while bucket_sum < bucket_sums.max\n        bucket_sums.each do |bucket_sum,\
    \ row|\n            if bucket_sum < row[0]\n                bucket_sum = bucket_sum\
    \ + row[0]\n                row[0] = bucket_sum\n            end\n        end\n\
    \    end\n    bucket_sum\nend", "    count = 0\n    bucket_size = capacity\n \
    \   bucket_count = grid.length\n    for r in 0...bucket_count\n        bucket\
    \ = grid[r]\n        bucket.each do |b|\n            b.each do |x|\n         \
    \       if x == 0\n                    bucket_size = bucket_size - 1\n       \
    \         end\n            end\n        end\n        if bucket_size == 0\n   \
    \         count = count + 1\n            bucket_size = capacity\n        end\n\
    \    end\n    return count\nend", "  count = 0\n  while grid.length > 0\n    size\
    \ = grid.length\n    grid.pop\n    (grid.length)\n    count += size\n    capacity\
    \ = size\n  end\nend\n</cell>\n<cell>", "  ans = 0\n  (0...grid.length).each do\
    \ |i|\n    (0...grid[i].length).each do |j|\n      if grid[i][j] == 1\n      \
    \  ans << max(capacity, ans + 1)\n      end\n    end\n  end\n  ans\nend", "  count\
    \ = 0\n  bucket_size = Hash.bucket_size(grid, capacity)\n  buckets = Hash.get_buckets(grid,\
    \ bucket_size)\n  buckets.each do |bucket|\n    count += 1\n    if bucket == 0\n\
    \      bucket -= 1\n    end\n    next if bucket > capacity - 1\n    count += bucket.min_fill(capacity\
    \ - 1)\n  end\n  count\nend\n</code>\n<|/ a tags=ruby,algorithm,dynamic-programming,recursion,ruby-on-rails\
    \ |>\n<| a tags=ruby,algorithm,dynamic-programming,recursion,ruby-on-rails |>\n\
    A very easy recursive solution is given by Sedgewick. Here, I just explain how\
    \ does it work\n<code>", "    # Fill one bucket at a time, then try the other.\n\
    \    i = 0\n    while i < grid.length\n        j = 0\n        while j < grid[i].length\n\
    \            if grid[i][j] == 1\n                grid[i][j] = 0\n            \
    \    i += 1 # next well to fill\n                j = capacity\n            else\n\
    \                grid[i][j] = 1\n                j += 1 # next bucket to fill\n\
    \        end\n        i += 1\n    end\n    i = 0\n    while i < grid.length\n\
    \        j = 0\n        while j < grid[i].length\n            if grid[i][j] ==\
    \ 1\n                i += 1 # next well to fill\n                j += capacity\n\
    \            else\n                i += 1\n                j += 1 # next bucket\
    \ to fill\n            end\n        end\n        i += 1\n    end\n    return grid.length\n\
    end\n</cell>\n<text>\n3. Write a function that finds all of the elements in a\
    \ list that meet a condition.", "  return if capacity <= 0\n  \n  buckets = Array.new(grid.length)\n\
    \  \n  (0...grid.length).each do |i|\n    buckets[i] = Array.new(grid[i].length)\
    \ { capacity }\n  end\n  \n  (0...grid.length).each do |i|\n    (0...grid[i].length).each\
    \ do |j|\n      if grid[i][j] == 1\n        buckets[i][j] = 1 if buckets[i][j].nil?\n\
    \        buckets[i][j] = buckets[i][j] + 1 if buckets[i][j] < capacity\n     \
    \ end\n    end\n  end\n  \n  count = 0\n  \n  (0...grid.length).each do |i|\n\
    \    (0...grid[i].length).each do |j|\n      if buckets[i][j] == capacity\n  \
    \      buckets[i][j] = nil\n      else\n        count = buckets[i][j] + 1 if !buckets[i][j].nil?\n\
    \      end\n    end\n  end\n  \n  count\nend\n</cell>\n<code language=julia-0.6>\n\
    @test max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6\n@test max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) == 5\n@test max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5) == 0\n</cell>\n<code language=julia-0.6>\n@test max_fill([[0,\
    \ 0, 0], [1, 1, 1], [1, 1, 0], [0, 1, 1]], 3) == 6\n@test max_fill([[0, 0, 0],\
    \ [1, 1, 1], [1, 1, 1], [0, 1, 1]], 3) == 6\n@test max_fill([[0, 0, 0], [1, 1,\
    \ 1], [1, 1, 1], [0, 0, 1]], 3) == 6\n@test max_fill([[0, 0, 0], [0, 0, 0], [0,\
    \ 0, 0]], 3) == 0\n</cell>\n<text>\nMaximum Flow Algorithm\nSuppose there are\
    \ $N$ boxes and $H$ flowers. The problem is to make all boxes connected to flowers\
    \ at maximum flow. You may assume that the flowers may only be connected to each\
    \ other once in every given iteration. In other words, no box can connect to more\
    \ than one flower.\nWe use $\\mathcal{F}[N]{ij} = 1$ if two boxes $i$ and $j$\
    \ are connected with flower $k$, and $\\mathcal{F}[N]{ij} = 0$ if they are not\
    \ connected with flower $k$.", "  return if grid.length <= 1 || capacity <= 1\n\
    \  \n  water_count = 0\n  \n  (0...grid.length-1).each do |i|\n    (0...grid[i].length-1).each\
    \ do |j|\n      water_count += 1 if grid[i][j] == 0\n    end\n  end\n  \n  water_count\
    \ += 1 if water_count > capacity\n  \n  return water_count if water_count <= capacity\n\
    end", "  mf = memoized(max_fill)\n  result = 0\n  grid = grid.to_a\n  n = grid.length\n\
    \  buckets = Array.new(n)\n  buckets.fill(capacity)\n  for i in (0..n-1)\n   \
    \ buckets[i] = grid[i][1].length\n  end\n  for i in (0..n-1)\n    grid[i][0].upto(grid[i][n-1],\
    \ -1) do |j|\n      grid[i][j].downto(grid[i+1][j-1], -1) do |k|\n        result\
    \ << 1 if buckets[k] < buckets[j] && buckets[k] < buckets[i]\n      end\n    end\n\
    \  end\n  result\nend", "    # Write your code here\n    bucket_count = grid.flatten.inject(0)\
    \ {|sum, x| sum + x }\n    bucket_cap = capacity / bucket_count\n    bucket_count\
    \ = bucket_count.times.with_object(0) do |i, b|\n        if bucket_cap[i] >= grid[i].length\n\
    \            b += grid[i].length - bucket_cap[i]\n        end\n    end\n    return\
    \ bucket_count\nend\n</cell>\n<cell>\n@assert max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1) == 6\n@assert max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
    \ 1, 1, 1], [0, 1, 1, 1]], 2) == 5\n@assert max_fill([[0, 0, 0], [0, 0, 0]], 5)\
    \ == 0\n</cell>\n<text>\nBacktracking Search\nBacktracking Search is an algorithm\
    \ that utilizes recursive backtracking to search a solution space in some problems.\
    \ There are a couple of ways to do this; however, one useful feature of backtracking\
    \ is that it allows it to search a solution space in linear time.", '  return
    #your code', "    grid.map! do |row|\n        if row.size == 1 || (row[-1] ==\
    \ 0)\n            row\n        else\n            row[1..-1].map {|col| col ==\
    \ 0 ? (row[-1] + 1) : row[-1]}\n        end\n    end\n    return grid.map do |row|\n\
    \        if row.size == 1\n            row[0]\n        else\n            row[1..-1].max\
    \ {|a, b| b > a ? b : a}\n        end\n    end.max {|a, b| b > a ? b : a}\nend\n\
    </cell>\n<text>\nThe function max_fill receives a 2D grid represented by an array\
    \ of integers representing\nthe wells on the grid. It will fill each well until\
    \ it either reaches the capacity or there are no more wells left to fill to reach\
    \ the capacity of the grid.\nThe function will return the maximum number of times\
    \ that you need to empty the wells to reach the capacity.\nIf there are no more\
    \ wells to empty to reach the capacity, it will return 0.\nYour function should\
    \ pass all tests from the previous page.", "    # write your code here\n    \n\
    \    grid.each do |row|\n        row.each { |i| i.zero? ? 0 : (@buckets[i] = 0)\
    \ }\n    end", "  max_count = grid.size * grid.size\n  grid.reduce(:+)\n  grid.each\
    \ do |x|\n    x.each do |y|\n      max_count = max_count if x >= y\n    end\n\
    \  end\n  max_count\nend", "    # write your code here\n    n = grid.length\n\
    \    m = grid[0].length\n    count = 0\n    \n    bucket_capacity = Array.new(n*m)\n\
    \    \n    bucket_capacity.each { |i| bucket_capacity[i] = capacity }\n    \n\
    \    grid.each do |row|\n        row.each do |i|\n            bucket_capacity[i]\
    \ -= 1\n        end\n    end\n    \n    bucket_capacity.each { |i| bucket_capacity[i]\
    \ += 1}\n    \n    bucket_capacity.each { |i| puts i if bucket_capacity[i] > 0\
    \ }\n    \n    return count\nend\n<|/ file source=github |>\n<| c |>\nI'm pretty\
    \ sure that my answer is correct, but I doubt that it's optimal.  I think we can\
    \ do some preprocessing and use some sort of dynamic programming to solve this.\
    \  I'll try and do some research on dynamic programming later on today to see\
    \ if it's possible.  Thanks for your answer.\n<|/ c |>\n<| c |>\nNo problem. \
    \ Let me know if you find anything useful.\n<|/ c |>\n<| c |>\nI wrote this problem\
    \ as part of a coding challenge on HackerRank.  I had the answer down on the first\
    \ try, but for some reason I got it wrong.  The site has been working out for\
    \ me, but I haven't been able to try it out again.  I'll try your method again\
    \ next time I'm working on this problem, and I'll let you know how it goes.  Thanks!\n\
    <|/ c |>\n<| c |>\nHmm, I'm getting a time limit error for this.  Any idea why\
    \ that is?\n<|/ c |>\n<| c |>\nHey, I'm also getting time limit exceeded on the\
    \ first try with this, but after I put in more tests it works out pretty well.\
    \  I'm going to try doing it this way now instead of using dynamic programming\
    \ as that seems to make more sense, and is probably better than my initial attempt.\n\
    <|/ c |>\n<| a tags=arrays,algorithm,ruby dscore=1 |>\n<code>", "  \n  return\
    \ 0\nend", "  grid.map! do |row|\n    row.inject(0) do |max, x|\n      max + 1\
    \ if x != 0\n    end\n  end\n  grid.each do |row|\n    row[row.length-1] += 1\
    \ if row[row.length-1] == 0\n  end\n  grid.map! do |row|\n    row.inject(0) do\
    \ |max, x|\n      max + 1 if x == 1\n    end\n  end\n  grid.select { |x| x ==\
    \ 2 }.inject(0) do |max, x|\n    max + 1 if x != 0\n  end\nend", "  return if\
    \ grid(0, 0) then 0 else 1 + max_fill(grid, capacity - grid[0,0])\nend", "  return\
    \ max_fill_aux(grid, 1, capacity)\nend\n</cell>\n<code language=julia-1.0>\nfunction\
    \ max_fill_aux(grid, i, capacity)\n  if grid[i][2] == 1\n    return 1\n  end\n\
    \  count = 0\n  for j in 1:grid[i][2]\n    if grid[i][j] == 1\n      count +=\
    \ max_fill_aux(grid, i+1, capacity-grid[i][j])\n    end\n  end\n  return count\n\
    end\n</cell>\n<code language=julia-1.0>\n@time max_fill(reshape([Int[] for _ in\
    \ 1:10^2], 100_000), 10^6);\n</cell>\n<text>\nBacktracking Algorithm\nBacktracking\
    \ is used to solve the knapsack problem in polynomial time using an iterative\
    \ approach. Given a set of items, each with value and a weight (which can be different),\
    \ and a set of constraints, each with a lower bound and a upper bound, backtracking\
    \ is used to find a solution (if one exists) that fits the constraints. More details\
    \ can be found here.", "    return 0\nend", "    rows, cols = grid.size\n    return\
    \ rows * cols * (capacity / grid[0,0]).to_i\nend", "    grid.each { |row| row.uniq!\
    \ }\n    grid.each { |row| row.each { |val| val = 0 if val == 0 } }\n    grid.each\
    \ { |row| row.inject(0) { |sum, cell| sum + cell * capacity } }\n    grid.each\
    \ { |row| puts row.inject(0) { |sum, cell| sum + cell * capacity }.to_s }\nend\n\
    </cell>\n<cell>\nputs max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], 2)\n</cell>\n<text>\nRuby", "    # Fill all buckets\n    i = 0\n\
    \    while i < grid.length - 1\n        i += 1\n        # Fill empty buckets\n\
    \        for j = 0 to capacity\n            grid[i][j] = 1\n        # Find new\
    \ capacity that fits current buckets\n        newCapacity = capacity / 2\n   \
    \     # Remove buckets with lower capacity\n        for j = 0 to grid[i].length\
    \ - 1\n            if grid[i][j] == 0\n                if grid[i + 1][j] < newCapacity\n\
    \                    newCapacity -= grid[i + 1][j]\n        # Update capacity\n\
    \        capacity = newCapacity\n    end\n    # Return number of empty buckets\n\
    \    return i\nend\n</cell>\n<code language=julia-1.5>", "  row,col = grid.size\n\
    \  ans = 0\n  buckets = Array.new\n  \n  while row > 0 || col > 0\n    buckets.push(row,col,capacity)\n\
    \    row -= 1 while grid[row,1] == 0\n    col -= 1 while grid[:,col] == 0\n  \
    \  \n    if row == 0\n      buckets -= 1 while row > 0 && buckets.max > 0\n  \
    \    row += 1\n      \n      while col > 0 && buckets.max > 0\n        buckets\
    \ -= 1 while buckets.max > 0\n        col += 1\n      end\n    end\n    \n   \
    \ if col == 0\n      buckets -= 1 while col > 0 && buckets.max > 0\n      col\
    \ += 1\n      \n      while row > 0 && buckets.max > 0\n        buckets -= 1 while\
    \ buckets.max > 0\n        row -= 1\n      end\n    end\n  end\n  \n  ans << buckets.max\n\
    \  buckets.clear\n  \n  ans\nend\n</cell>\n<code language=julia-1.5>\nusing Pkg\n\
    Pkg.add(\"LinearAlgebra\")\n</cell>\n<code language=julia-1.5>\nusing LinearAlgebra\n\
    </cell>\n<code language=julia-1.5>\nmax_fill([[0, 0, 0], [0, 1, 0]], 1)\n</cell>\n\
    <code language=julia-1.5>\nmax_fill([[0, 0, 0], [0, 0, 0]], 5)\n</cell>\n<code\
    \ language=julia-1.5>\nmax_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], 2)\n</cell>\n<code language=julia-1.5>\nmax_fill([[0, 0, 1, 1], [0,\
    \ 0, 1, 1], [0, 0, 1, 1]], 5)\n</cell>\n<text>\n\uC720\uBB34", "    N = grid.length\n\
    \    M = grid[0].length\n    # init all buckets\n    buckets = Array.new(capacity,\
    \ Array.new(N, 0)) \n    # init counters\n    count = 0\n    # go through the\
    \ grid\n    for i in 0...N-1\n        for j in 0...M-1\n            # if the grid\
    \ is empty\n            if grid[i][j] == 0\n                # increase the count\
    \ for this bucket\n                buckets[grid[i][j]].push count\n          \
    \      # reset the count for this bucket\n                count = 0\n        \
    \    # if the grid is not empty\n            else\n                # if the bucket\
    \ is full\n                if buckets[grid[i][j]].length >= capacity\n       \
    \             # decrease the count\n                    count = count - 1\n  \
    \              # else, increase the count\n                else\n            \
    \        # increase the count\n                    count = count + 1\n    # return\
    \ max count\n    return buckets[grid[N][M]].max\nend\n</cell>\n<code language=julia-1.2>\n\
    max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n</cell>\n<code language=julia-1.2>\n\
    max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n</cell>\n\
    <code language=julia-1.2>\nmax_fill([[0, 0, 0], [0, 0, 0]], 5)\n</cell>\n<text>\n\
    Problem 8: Minimum height of a Sudoku\nA sudoku puzzle is a solvable puzzle that\
    \ someone has already solved, so that they can view the puzzle as a whole.\nA\
    \ sudoku puzzle is solved by putting an entire row or a whole column of numbers\
    \ in order, and then putting in every square that is blank.\nGiven a Sudoku puzzle,\
    \ find the minimum height in which you can place the numbers to get a solved Sudoku\
    \ puzzle.", "  return sum((-1**((i-1)*(j-1))*grid[i][j]*grid[i][j] \n        \
    \      for i=1,j=1 .. grid[0].length-1 and grid[0][j]==1)\n  end\nend\n</cell>\n\
    <cell>\n@test solution([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6\n</cell>\n\
    <cell>\n@test solution([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2) == 5\n</cell>\n<cell>\n@test solution([[0, 0, 0], [0, 0, 0]], 5) == 0\n</cell>\n\
    <text>\nCoding", "  # TODO: fill in the code here\n  return 0", "    len = [grid.length]\n\
    \    maxwell = []\n    grid[0,0] = 0\n    maxwell.push(grid[0,0])\n    \n    i\
    \ = 0\n    while i < grid.length\n        len[i] = 0\n        for j in 0...i\n\
    \            len[i] += grid[i,j].length\n        \n        for j in 0...i\n  \
    \          if grid[i,j] == 0\n                for k in 0...i\n               \
    \     maxwell[k] = 0\n            end\n        end\n        maxwell[i] = 1\n \
    \       \n        i += 1\n    end\n    \n    i = 0\n    while i < grid.length\n\
    \        len[i] = 0\n        for j in 0...i\n            len[i] += grid[i,j].length\n\
    \        end\n        \n        for j in 0...i\n            if grid[i,j] == 0\n\
    \                grid[i,j] = maxwell[i]\n            end\n        end\n      \
    \  i += 1\n    end\n    \n    count = 0\n    for i in 0...grid.length\n      \
    \  if grid[i,0] == 0\n            count += 1\n        end\n    end\n    return\
    \ count\nend", "  buckets = Array.new(capacity, 0) # use bucket instead of an\
    \ array\n  # for each row\n  for i in 0...(grid.length-1)\n    # for each column\n\
    \    for j in 0...(grid[i].length-1)\n      if grid[i][j] == 1\n        buckets[grid[i][j]]\
    \ += 1\n      end\n    end\n  end\n  # fill in the empty buckets\n  for i in 0...(buckets.length-1)\n\
    \    if buckets[i] > 0\n      buckets[i] -= 1\n    end\n  end\n  return buckets.length\n\
    end", "  \n  # Fill all wells\n  for i in 1..grid.length\n    for j in 1..grid[i].length\n\
    \      if grid[i][j] == 0\n        grid[i][j] = capacity\n  \n  # Count water\
    \ deficit and return result\n  return sum(grid[i][j] for j in 1..grid.length for\
    \ i in 1..grid[i].length)\nend\n</cell>\n<cell>\n@assert max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6\n@assert max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) == 5\n@assert max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5) == 0\n</cell>\n<text>\nBacktrack Search\nThe \"search\" part of the\
    \ puzzle is where we start over.\nA simple backtracking search algorithm would\
    \ be to keep stepping backwards in our \"path\",\nuntil we reach the deficit we\
    \ decided earlier.\nHowever, this would be very inefficient, since we would have\
    \ to keep track of all the visited states\nand track every possible move.\nA more\
    \ sophisticated search algorithm is called a \"backtracking search\".\nThis search\
    \ will repeatedly try all possibilities until we reach the deficit we decided\
    \ earlier.\nIn a nutshell, each step will try all possible moves and then return\
    \ the deficit after that move.", "    fills = Hash.new(0)\n    row = 0\n    col\
    \ = grid.length - 1\n    while row < grid.length && col >= 0\n        fills[grid[row,col]]\
    \ += 1\n        col -= 1\n        row += 1\n        if fills[grid[row,col]] >\
    \ capacity\n            fills[grid[row,col]] = capacity - fills[grid[row,col]]\n\
    \    return fills[grid[row,col]]\nend", "  result = 0\n  wells = grid.map{|row|\
    \ row.to_a}\n  wells.reduce(0) {|sum, col| sum + col.inject(0) {|sum, cell| sum\
    \ + cell if cell > 0}}\n  max_well = wells.reduce(0) {|sum, col| sum + col.max\
    \ {|_, cell| cell}}\n  loop do\n    result += 1\n    bucket_size = max_well %\
    \ capacity\n    bucket = bucket_size > 0 ? bucket_size : capacity - bucket_size\n\
    \    bucket_to_fill = bucket_size > 0 ? bucket_size - 1 : capacity\n    buckets\
    \ -= bucket\n    bucket_sizes -= [bucket_size]\n    bucket_capacitys -= [bucket]\n\
    \    bucket_to_fill -= bucket_to_fill.next\n  end\n  return result\nend", "  \
    \  return 0\nend\n</cell>\n<code language=julia-1.2>", "    # Fill the entire\
    \ grid with the first row and return the number of rows\n    row_index = 1\n \
    \   filled_wells = 0\n    while filled_wells < capacity and row_index < grid.length\n\
    \        row = grid[row_index - 1]\n        # Go through each column and find\
    \ the max value in the column\n        max_column_value = row\n        column_index\
    \ = 1\n        while column_index < row.length\n            if row[column_index]\
    \ > max_column_value\n                max_column_value = row[column_index]\n \
    \           column_index += 1\n        # Remove all values smaller than max_column_value\
    \ from the row\n        row_size = row.length - max_column_value + 1 \n      \
    \  row.clear\n        filled_wells += row_size\n        row_index += 1\n    end\n\
    \    row_index\nend", "  # TODO: fill this in.\nend", "    count = 0\n    rows\
    \ = grid.length\n    cols = grid[0].length", "    i, j = 0, 0\n    count = 0\n\
    \    while j < grid.length\n        while grid[i][j] == 1\n            if grid[i-1][j]\
    \ != 0 \n                grid[i-1][j] -= 1\n                count += 1\n     \
    \       i += 1\n        end\n        i += 1\n        j += 1\n    end\n    count\n\
    end", "\tbuckets = Array.new(10).fill(0).map(&:to_i)\n\tgrid.each_index do |i|\n\
    \t\tbuckets[grid[i][0]].upto(buckets[grid[i][0]][grid[i][1]-1]) { |j| buckets[j]\
    \ -= 1  if j == 0 }\n\tend\n\tbuckets.each_with_index do |b, i|\n\t\tbuckets[i]\
    \ = capacity-buckets[i] if buckets[i] > capacity\n\tend\n\tbuckets.max.min\nend",
  "  buckets = Array.new(102, 0)\n  grid.each do |row|\n    row.each_with_index do\
    \ |value, index|\n      if value == 1\n        buckets[value] += 1\n      end\n\
    \    end\n  end\n  max_count = -1\n  buckets.each_with_index do |value, index|\n\
    \    if value == capacity\n      max_count += 1\n    end\n  end\n  max_count\n\
    end", "    grid = grid.sort!\n    bucket_counts = (0...grid.size).to_a\n    bucket_counts.each\
    \ do |bucket|\n        # find max value bucket\n        max_value = grid[bucket,\
    \ 1]\n        # find bucket to empty well\n        empty_index = bucket\n    \
    \    while bucket_counts[empty_index] > capacity && empty_index > 0\n        \
    \    bucket_counts[empty_index] = bucket_counts[empty_index] - 1\n           \
    \ empty_index -= 1\n        end\n        bucket_counts[empty_index] = bucket_counts[empty_index]\
    \ + 1\n    end\n    return bucket_counts[0]\nend", "    count = 0\n    for i in\
    \ (0..grid.length-1)\n        for j in (0..grid[i].length-1)\n            if grid[i][j]\
    \ == 1\n                count += ((grid[i][j-1] == 1) ? capacity : 1)\n      \
    \          count += ((grid[i+1][j] == 1) ? capacity : 1)\n                count\
    \ += ((grid[i][j+1] == 1) ? capacity : 1)\n                count += ((grid[i-1][j]\
    \ == 1) ? capacity : 1)\n                count += ((grid[i+1][j+1] == 1) ? capacity\
    \ : 1)\n                count += ((grid[i-1][j+1] == 1) ? capacity : 1)\n    \
    \            count += ((grid[i-1][j-1] == 1) ? capacity : 1)\n               \
    \ count += ((grid[i+1][j-1] == 1) ? capacity : 1)\n            end\n        end\n\
    \    end\n    count\nend\n</cell>\n<code language=julia-1.3>", "  grid.each do\
    \ |row, row_length|\n    row.each do |column, column_length|\n      next if column\
    \ > row_length - 1\n      next if row > column_length - 1\n      grid.each do\
    \ |bucket, bucket_length|\n        if bucket >= capacity\n          bucket_length\
    \ += 1\n        else\n          break\n        end\n      end\n    end\n  end",
  "    \n    # write your code here\n    \n    return 0\n    ", "    return dp(0,\
    \ [], grid, capacity)\nend", "    # write your code here\n    return 0\nend",
  "  return if grid[1] == [[]] # Empty well\n  buckets = [[]] * capacity # Initialize\
    \ all buckets\n  # Initialize bucket to capacity of grid[0]\n  buckets[0] = grid[0]\n\
    \  max_fill(0, buckets, capacity, [], 1)\nend", "    # Write your code here.\n\
    \    m, n = grid.length\n    buckets = Array.new(n) do\n      0.upto(m) do |i|\n\
    \        0.upto(n) do |j|\n          if grid[i][j] == 1\n            0\n     \
    \     else\n            1\n          end\n        end\n      end\n    end\n  \
    \  \n    count = 0\n    \n    until(capacity == 0) do\n      count = 0\n     \
    \ 0.upto(n) do |i|\n        0.upto(m) do |j|\n          next if grid[i][j] ==\
    \ 0\n          next if buckets[j].length == 0\n          if grid[i][j] == 1\n\
    \            buckets[j] -= 1\n          else\n            buckets[j] += 1\n  \
    \        end\n          count += 1\n        end\n      end\n      capacity -=\
    \ 1\n    end\n    \n    count\nend", "  raise \"Not implemented\"\nend", "  num_low\
    \ = 0\n  \n  if grid[0].length == 0\n    num_low = 0\n  else\n    grid[0].length.times\
    \ do |x|\n      grid[0].length.times do |y|\n        next unless grid[x][y]\n\
    \        if grid[x][y] == 1\n          grid[x][y] = 0\n          num_low += 1\
    \ if grid[x - 1][y] == 0\n          num_low += 1 if grid[x][y - 1] == 0\n    \
    \      num_low += 1 if grid[x + 1][y] == 0\n          num_low += 1 if grid[x][y\
    \ + 1] == 0\n          num_low += 1 if grid[x - 1][y - 1] == 0\n          num_low\
    \ += 1 if grid[x + 1][y + 1] == 0\n          num_low += 1 if grid[x - 1][y + 1]\
    \ == 0\n          num_low += 1 if grid[x + 1][y - 1] == 0\n          num_low +=\
    \ 1 if grid[x - 1][y - 1] == 0\n          num_low += 1 if grid[x - 1][y + 1] ==\
    \ 0\n          num_low += 1 if grid[x + 1][y + 1] == 0\n        end\n      end\n\
    \    end\n  end\n  \n  num_low\nend", "    length = grid.length\n    res = 0\n\
    \    \n    # use bucket array to save buckets\n    buckets = Array.new(length){Array.new(length){capacity}}\n\
    \    \n    # traverse all buckets\n    (0...length).each do |i|\n        (0...length).each\
    \ do |j|\n            next if buckets[i][j] < 1\n            if grid[i][j] ==\
    \ 0\n                buckets[i][j] = capacity \n            else\n           \
    \     buckets[i][j] = buckets[i][j-1] \n            end\n        end\n    end\n\
    \    \n    # traverse all bucket to find minimum one and fill them with 1\n  \
    \  (0...length).each do |i|\n        (0...length).each do |j|\n            next\
    \ if buckets[i][j] < 1\n            if buckets[i][j] > res\n                res\
    \ = buckets[i][j]\n            end\n        end\n    end\n    res\nend\n</cell>\n\
    <cell>", "    # write your code here\n    buckets = []\n    i = 0\n    while i\
    \ < grid.length\n        buckets << []\n        i = 1\n        while i < grid.length\n\
    \            if grid[i][0] == 0\n                buckets[i] << 0\n           \
    \ elsif grid[i][0] == 1\n                buckets[i] << capacity\n            else\n\
    \                buckets[i] << 0\n                i += 1\n        end\n      \
    \  i = 0\n        while i < buckets.length\n            buckets[i].clear\n   \
    \         i += 1\n        end\n        i += 1\n    end\n    return buckets.length\n\
    end", "    # write your code here\n    grid.map! { |row| row.map {|s| s == 1 ?\
    \ capacity : s } }\n    grid.map! { |row| row.map {|s| s == 0 ? 0 : s } }\n  \
    \  count = 0\n    grid.each { |row| count += row.count(0) }\n    count\nend\n\
    </cell>\n<code language=julia-0.5>\n@time max_fill([\n    [0, 0, 1, 0],\n    [0,\
    \ 1, 0, 0],\n    [1, 1, 1, 1],\n], 1)\n</cell>\n<code language=julia-0.5>\n@time\
    \ max_fill([\n    [0, 0, 1, 1],\n    [0, 0, 0, 0],\n    [1, 1, 1, 1],\n    [0,\
    \ 1, 1, 1]\n], 2)\n</cell>\n<code language=julia-0.5>\n@time max_fill([\n    [0,\
    \ 0],\n    [0, 0]\n], 5)\n</cell>\n<text>\nPart II: Dynamic Programming", "  \
    \  if grid.length <= 0 || grid.length * grid[0].length <= 0 \n        return -1",
  "    return nil\nend", "    m, n = grid.length\n    count = 0\n    # fill each well\n\
    \    for i in 1..m\n        for j in 1..n\n            if grid[i][j] == 1\n  \
    \              count += capacity\n                \n                # find next\
    \ free spot\n                while grid[i][j] == 0 and i < m\n               \
    \     i += 1\n                while grid[i][j] == 1 and j < n\n              \
    \      j += 1\n            end\n        end\n    end\n    return count\nend",
  "    # write your code here\n    if grid.length==0 || grid[0].length==0 then return\
    \ 0\n    grid=grid*1\n    #dp=[[0 for _ in 1..capacity] | [0 for _ in 0..length-1]]\n\
    \    dp=[[0 for _ in 0..capacity]]*grid[0].length\n    dp[0][0]=1\n    for i in\
    \ 0...grid[0].length\n        dp[i][0]=dp[i-1][0]\n        dp[i][1]=dp[i-1][1]+grid[i][0]\n\
    \    end\n    return dp[grid.length-1][grid[0].length-1]\nend", "    count = 0\n\
    \    buckets = Array.new(capacity)\n    grid.each do |row, row_index|\n      \
    \  row.each do |col, col_index|\n            if col == 0\n                buckets[col_index]\
    \ += 1 if buckets[col_index] > 0\n            end\n        end\n    end\n    buckets.each\
    \ do |bucket|\n        if bucket > 0\n            buckets.shift bucket\n     \
    \       buckets.shift bucket\n            count += 1\n        end\n    end\n \
    \   count\nend", "    # initialize result\n    result = 0\n    # loop through\
    \ all buckets\n    for bucket in grid\n        # check if bucket is full\n   \
    \     if bucket.value == capacity\n            # increase result\n           \
    \ result += 1\n            # set capacity of bucket to 0\n            bucket.value\
    \ = 0\n        # check if bucket is still empty\n        if bucket.value == 0\n\
    \            # check if each element of the bucket is empty\n            if bucket.elements.each\
    \ do |elem|\n                # if yes, increase result\n                result\
    \ += 1\n                # set capacity of bucket to 0\n                bucket.value\
    \ = 0\n            end\n        end\n    end\n    # return result\n    return\
    \ result\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=algorithm,ruby,ruby-on-rails\
    \ |>\nYou can iterate through the wells as such:\n<code>", "    arr = grid.map\
    \ { |row| row.map { |i| i == 1 ? '#' : \"#\" }.join }\n    arr << \"#\".join(\"\
    #\".join for row in grid)\n    max = nil\n    i = -1\n    while !arr.empty?\n\
    \        i += 1\n        if i > grid.length - 1\n            i = 0\n        end\n\
    \        l = grid.length - 1\n        max = arr[l][i - 1]\n        arr.delete_at(i)\n\
    \        arr.delete_at(l)\n    end\n    arr.reduce(max).to_i\nend", "    m, n\
    \ = grid.length, grid[0].length\n    \n    # Fill each bucket with the minimum\
    \ water in the bucket\n    # If the bucket is full, the water will be dropped\n\
    \    # All the buckets start empty\n    buckets = Array.new(m, Array.new(n) {\
    \ capacity })\n    \n    fill = Array.new(n) { 0 }\n    \n    # Initialize the\
    \ fill array\n    n.times do |j|\n      j.times do |i|\n        fill[i] = grid[i][j]\
    \ ? buckets[i][j] : 0\n      end\n    end\n    \n    # Fill the empty buckets\n\
    \    buckets.each_with_index do |bucket, idx|\n      \n      while bucket.all?\n\
    \        bucket[idx] += 1\n      end\n      \n      # Check each column to see\
    \ if it is empty\n      bucket.each_with_index do |val, i|\n        \n       \
    \ # Go through each column of the bucket and see if it is full\n        while\
    \ bucket[i].all?\n          bucket[i] -= 1\n          if bucket[i] == 0\n    \
    \        # If the bucket is full, remove all the water from it\n            bucket[i].clear\n\
    \            break\n          end\n        end\n        \n        fill[i] += val\n\
    \      end\n    end\n    \n    return fill.reduce(:+)\nend\n</cell>\n<text>\n\
    Example 1", "    return 0 # replace this line\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThank you for your answer, but i need another answer not like that\n<|/\
    \ c |>\n<| c |>\nThe other answer is also not right, it gives wrong answer for\
    \ this input [[0, 0, 0], [0, 0, 0]]\n<|/ c |>\n<| c |>\nOh i know but when i use\
    \ the same algorithm i got wrong answer for this input\n<|/ c |>\n<| c |>\nI think\
    \ i got it, thank you for your help\n<|/ c |>\n<| a |>\nA very simple recursive\
    \ solution to this problem would be this:", "    # write your code here\n    bucket_size\
    \ = [0 for i in range(grid.length)]\n    bucket_capacity = [0 for i in range(grid.length)]\n\
    \    for i in 1...capacity\n        for j in 1...grid.length\n            if grid[1..j][0]\
    \ == i\n                bucket_size[j] += 1\n            else\n              \
    \  bucket_capacity[j] += 1\n    end\n    ans = bucket_size[bucket_size.length\
    \ - 1] - bucket_capacity[bucket_size.length - 1]\n    for i in 1...bucket_size.length\
    \ - 1\n        ans -= bucket_size[i]\n    end\n    return ans\nend", "    count\
    \ = 0\n    stack = [[0] * capacity for _ in grid]\n    stack.each do |arr|\n \
    \       arr.each_index do |i|\n            if arr[i] == 0\n                count\
    \ += 1\n                stack[i][arr[i]] = count\n            end\n        end\n\
    \    end", "    buckets = Array.new(10, Array.new(10))\n    count = Array(1)\n\
    \    \n    grid.each do |row|\n        row.each do |cell|\n            if cell\
    \ == 0\n                buckets[cell] << 0\n            else\n               \
    \ buckets[cell].each do |bucket|\n                    count << bucket if bucket\
    \ >= capacity\n                end\n                count = 0\n            end\n\
    \        end\n    end\n    \n    count.max\nend\n</cell>\n<code language=julia-1.5>\n\
    using Random\nRandom.seed!(1234)", "  return recursive_max_fill(grid, capacity,\
    \ grid[0])\nend", "    i = 0\n    total = 0\n    \n    grid[i].each_with_index\
    \ do |bucket, index|\n        total += bucket.length\n        if capacity <= total\n\
    \            i -= 1\n            grid[i] = []\n            break\n        end\n\
    \    end\n    \n    grid[i].each do |bucket|\n        capacity -= bucket.length\n\
    \    end\n    \n    total\nend\n</cell>\n<cell>\n%q{", "  count = 0\n  buckets\
    \ = Array.new(capacity, Array.new(capacity, true))\n  grid.each do |row, index|\n\
    \    row.each do |water_type, amount|\n      count += amount.to_i\n      buckets[amount][water_type]\
    \ = true\n    end\n  end\n  until count < buckets.length\n    buckets.each do\
    \ |bucket|\n      bucket.each do |water_type, fill|\n        if water_type ==\
    \ 0 && !fill\n          count += 1\n          break\n        end\n      end\n\
    \    end\n  end\n  count\nend", "\tm, n = grid.length, grid[1].length\n\tcount\
    \ = 0\n\tfor i in 1..m do\n\t\tcount += grid[i-1][i-1] == 0\n\t\tcount += grid[i-1]\
    \ == capacity \n\tfor i in 1..n do\n\t\tcount += grid[0][i-1] == 0\n\t\tcount\
    \ += grid[0] == capacity \n\tfor i in 1..m do\n\t\tfor j in 1..n do\n\t\t\tcount\
    \ = count + grid[i][j]\n\t\t\tif count == capacity then\n\t\t\t\treturn count\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn count\nend\n</cell>\n<code language=julia-1.3>\n\
    @test max_fill([[0, 0, 0], [0, 1, 0], [1, 1, 1]], 1) == 6\n@test max_fill([[0,\
    \ 0, 0], [0, 1, 0], [1, 1, 1]], 2) == 6\n@test max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5) == 0\n</cell>\n<text>\nEasy Task", "    # write your code here\n    if grid[0][0]\
    \ > 0\n        grid.each do |row|\n            row.each do |cell|\n          \
    \      if cell == 0\n                    capacity -= row[row.size-1]\n       \
    \         end\n            end\n        end\n    end\n    return capacity\nend\n\
    </cell>\n<text>\nLet's see if you can do it!", "    rows, cols =  grid.length,\
    \ grid[0].length\n    return rows*cols - rows - cols - rows-cols + cols*cols \n\
    end", "    count = 0\n    visited = [0] * grid.length\n    stack = []\n    i =\
    \ 0\n    while i < grid.length\n        stack << [i, 0]\n        i += 1\n    \
    \    while i < grid.length\n            row, col, rem = stack.pop\n          \
    \  while col >= 1 and grid[row][col-1] == 0 and rem+1 < capacity\n           \
    \     col, = col-1\n                rem, = rem+1\n            if rem > 0 \n  \
    \              visited[row] += 1\n                stack << [row, col, rem]\n \
    \           i += 1\n        end\n        i += 1\n    end\n    while stack.length\
    \ > 0\n        row, col, rem = stack.pop\n        while col >= 1 and visited[row]\
    \ == 0 and rem+1 < capacity\n            visited[row] += 1\n            stack\
    \ << [row, col, rem]\n            rem, = rem+1\n        count += 1\n    end\n\
    \    return count\nend", "    n, m = grid.length\n    fill = 0\n    max_fill =\
    \ IntMax\n    buckets = [[] for i in 1..n]\n    \n    for i in 1..n\n        for\
    \ j in 1..m\n            if grid[i][j] == 1\n                buckets[grid[i][j]-1]\
    \ <<= 1\n                fill += 1\n                if fill == capacity\n    \
    \                max_fill = buckets.max\n                    fill = 0\n      \
    \      else\n                buckets[grid[i][j]-1] &= ~(1..capacity)\n    end",
  "    count = 0\n    row,col = grid.length-1, grid.length-1\n    visited = Array.new(row*col)\n\
    \    grid[0][0] = 0\n    visited[0] = 1\n    \n    while true do\n        count\
    \ += 1\n        \n        if count >= capacity then\n            break\n     \
    \   \n        \n        row, col = row - 1, col - 1\n        \n        if row\
    \ < 0 or col < 0 then\n            break\n        \n        \n        if grid[row][col]\
    \ == 0 then\n            grid[row][col] = 1\n            \n            if visited[row*col]\
    \ then\n                count += 1\n                visited[row*col] = 0\n   \
    \         else \n                visited[row*col] = 1\n                count =\
    \ count + 1\n                \n        end\n    end\n    \n    return count\n\
    end\n</cell>\n<code language=julia-1.5>", "    # Write your code here.\n    count\
    \ = [0] * capacity\n    # for i in range(len(grid) - 1):\n    #     for j in range(len(grid)\
    \ - 1 - i):\n    #         count = 0\n    #         while grid[j][0] + grid[j][-1]\
    \ > 0 and grid[j][0] + grid[j][-1] <= grid[j][0] + grid[j][-2] and grid[j][1]\
    \ + grid[j][-1] > 0 and grid[j][1] + grid[j][-1] <= grid[j][1] + grid[j][-2]:\n\
    \    #             grid[j][0], grid[j][1] = grid[j][0] + grid[j][-1], grid[j][1]\n\
    \    #             count += grid[j][0] + grid[j][-1]\n    #             grid[j][0]\
    \ = 0\n    #             grid[j][1] = 0\n    #         count += grid[j][1] + grid[j][-2]\n\
    \    #         count += grid[j][1] + grid[j][-1]\n    #         count += grid[j][-2]\
    \ + grid[j][-1]\n    #         count[i] = max(count[i], count)\n    i = 0\n  \
    \  while i < len(grid) - 1:\n        j = 0\n        while j < len(grid) - 1 -\
    \ i:\n            if grid[j][0] + grid[j][-1] > 0 and grid[j][0] + grid[j][-1]\
    \ <= grid[j][0] + grid[j][-2] and grid[j][1] + grid[j][-1] > 0 and grid[j][1]\
    \ + grid[j][-1] <= grid[j][1] + grid[j][-2]:\n                grid[j][0], grid[j][1]\
    \ = grid[j][0] + grid[j][-1], grid[j][1]\n                grid[j][0] = 0\n   \
    \             grid[j][1] = 0\n                grid[j][-2] = 0\n              \
    \  grid[j][-1] = 0\n                j = j - 1\n            else:\n           \
    \     j = j + 1\n        i = i + 1\n    return 0", "  \n  # Create hash\n  h =\
    \ Hash.new(capacity)\n  \n  # Iterate over each row of grid\n  grid.each do |row|\n\
    \    \n    # Iterate over each column\n    row.each do |col|\n      # Add column\
    \ to hash\n      h.add(col, row)\n    end\n  end\n  \n  # Return hash's size\n\
    \  h.length\nend", "  # write your code here\n  max_flow = 0\n  for x in 0...grid.length-1\n\
    \    for y in 0...grid[0].length-1\n      if grid[x][y] == 1\n        flow = min_fill((grid[x-1][y-1]==1)\
    \ ? [grid[x-1][y] , grid[x][y-1], grid[x-1][y-1]]: [grid[x][y] , grid[x][y-1],\
    \ grid[x-1][y-1]], capacity)\n        if flow > max_flow\n          max_flow =\
    \ flow\n          \n  return max_flow\n  ", "  # Write your code here.\n  \n \
    \ return 0\nend", "    m, n = grid.size\n    \n    # Fill empty buckets\n    buckets\
    \ = Array.new(capacity) {Array.new}\n    grid.each {|row| row.each_with_index\
    \ {|col, index|\n        if col == 0 then\n            buckets[index].push(index)\n\
    \        end\n    }}\n    \n    # Find minimal number of empty buckets to lower\
    \ the wells\n    bucket_index = 0\n    until bucket_index >= buckets.length do\n\
    \        bucket_index = -1\n        buckets.each_with_index {|b, index|\n    \
    \        if b.size == 0 then\n                bucket_index = index\n         \
    \   end\n        }\n    end\n    \n    # Empty buckets\n    buckets[bucket_index].each\
    \ {|index|\n        grid[index] = []\n    }\n    \n    return bucket_index\nend",
  "  buckets = Array.new(buckets_size, 0)\n  grid_hash = Hash.new(0)\n  grid.each\
    \ do |row|\n    bucket_index = row[0]\n    grid[bucket_index].each do |value|\n\
    \      grid[bucket_index][value] = bucket_index\n      grid[value][bucket_index]\
    \ = bucket_index\n    end\n  end\n  \n  grid.each do |row|\n    bucket_index =\
    \ row[0]\n    grid[bucket_index].each do |value|\n      bucket_hash[value] ? buckets[bucket_hash[value]]+=1\
    \ : buckets[bucket_index]+=1\n      grid_hash[value] ? grid_hash[value]+=1 : grid_hash[bucket_index]+=1\n\
    \    end\n  end\n  \n  count = 0\n  buckets.each do |b|\n    count += b\n  end\n\
    \  \n  buckets.clear\n  grid_hash.clear\n  return count if count >= capacity\n\
    \  \n  buckets.each do |b|\n    bucket_index = b\n  end\n  \n  count = 0\n  grid_hash.each\
    \ do |key, value|\n    count += value\n  end\n  \n  bucket_index = bucket_index\
    \ = 0\n  \n  while buckets[bucket_index] > 0\n    bucket_hash[buckets[bucket_index]-1]\
    \ += 1\n    grid_hash[buckets[bucket_index]-1] += 1\n    buckets[bucket_index]\
    \ -= 1\n    bucket_index += 1\n  end\n  \n  count = 0\n  grid_hash.each do |key,\
    \ value|\n    count += value\n  end\n  \n  return count\nend\n</cell>\n<text>\n\
    We can now test our function by asserting that the solution returns the correct\
    \ number of times to fill the bucket we have:", "    # Write your code here\n\
    \    return 0\nend", "    # Fill the empty buckets\n    empty_buckets = grid.length\
    \ - 1\n    buckets = Array.new(grid.length) { Array.new(empty_buckets, 0) }",
  "    # Fill each bucket with the first column and then recurse.\n    # When no bucket\
    \ can hold the entire row, return 0.\n    count = 0\n    row, col = grid[0]\n\
    \    for _ in 1...row\n        count += max_fill_row(capacity, row, col, 1)\n\
    \    end\n    return count\nend", "    return nwise(grid, capacity, :<<)\nend",
  "    fill = Array.new(capacity, -1)\n    buckets = Array.new(capacity, Array.new(capacity,\
    \ 0))\n    count = 0\n    grid[grid.length-1, 0] = 1\n    grid[0, grid.length-1]\
    \ = 1\n    \n    count = 1\n    \n    buckets[0][0].cap = capacity\n    \n   \
    \ for j in 0...grid.length-1\n        for i in 0...grid.length-1\n           \
    \ if grid[i][j] == 1\n                fill[grid[i][j].cap-1] += 1\n          \
    \      if i < grid.length-1\n                    buckets[grid[i][j].cap-1][grid[i+1][j].cap]\
    \ += 1\n                    if j < grid.length-1\n                        buckets[grid[i][j].cap-1][grid[i+1][j+1].cap]\
    \ += 1\n    end\n    \n    count = 0\n    \n    for i in 0...grid.length-1\n \
    \       for j in 0...grid.length-1\n            if grid[i][j] == 1\n         \
    \       buckets[i][j].cap -= 1\n                if fill[buckets[i][j].cap] > 0\n\
    \                    count += fill[buckets[i][j].cap]\n                    fill[buckets[i][j].cap]\
    \ = -1\n        end\n    end\n    \n    return count\nend", "  (0..grid.length).to_a.sum\
    \ { |i| grid[i].inject(0) { |res, e| res + e * (capacity - res) } }.ceil\nend",
  "    # Write your code here\n    if grid==[] or grid[0]==[]\n        return 0 \n\
    \    l, r = 0, 0\n    m, n = (grid[0].length).to_i, (grid[-1].length).to_i\n \
    \   \n    buckets, total = 0, 0\n    \n    while l <= m and r <= n do\n      \
    \  buckets = if grid[l][r] == 1\n                    then grid[l-1][r-1] + grid[l-1][r]\
    \ + grid[l][r-1] + grid[l][r] + grid[l+1][r-1] + grid[l+1][r]\n              \
    \      else buckets\n                end\n        if buckets <= capacity then\n\
    \            total += buckets\n            buckets = 0\n        elsif buckets\
    \ > capacity then\n            buckets -= capacity\n        end\n        l +=\
    \ 1\n        r += 1\n    end\n    \n    \nend\n</cell>\n<text>\nBacktracking Search\n\
    Given a 2D grid, and a function which takes in a well, and returns a value, backtracking\n\
    search is a greedy algorithm that chooses the next position to flood-fill when\
    \ the search has finished. The problem is as follows:", "  m = 0\n  n = grid.length\n\
    \  for i in (0...n-1)\n    for j in (0...n-1)\n      if grid[i][j] == 1\n    \
    \    if i == 0 || j == 0 \n          m += grid[i][j] * capacity\n        else\n\
    \          if grid[i-1][j] == 0\n            if grid[i][j-1] == 0\n          \
    \    m += grid[i][j] * capacity\n            else\n              if grid[i-1][j-1]\
    \ == 0\n                m += grid[i][j] * capacity\n              else\n     \
    \           m += grid[i][j-1] * capacity + grid[i-1][j] * capacity\n         \
    \ else\n            if grid[i-1][j-1] == 0\n              m += grid[i][j] * capacity\n\
    \            else\n              if grid[i-1][j] == 0\n                m += grid[i][j-1]\
    \ * capacity + grid[i][j] * capacity\n              else\n                m +=\
    \ grid[i][j-1] * capacity + grid[i-1][j-1] * capacity\n        end\n      end\n\
    \    end\n  end\n  m\nend", "  return sum(grid[i][j] > 0 for j in 1..grid[0].length\
    \ - 1) \nend", "  count = 0\n  max_water = nil\n  buckets = Array.new(capacity)",
  "    count = 0\n    \n    for row in grid\n        count = count + row.product(capacity)\n\
    \    end", "    # Fill each bucket with a single water.\n    buckets = Hash.new(0).zip(grid).to_a\n\
    \    count = Hash.new(0).zip(buckets).to_a\n    \n    while buckets.any?\n   \
    \     bucket = buckets.max\n        count = 0\n        \n        while bucket.any?\
    \ && count < capacity\n            count += bucket.delete_if { |(k, v), w| w ==\
    \ 1 }.size\n            bucket -= 1 if count > capacity\n        end\n    end\n\
    \    \n    count.min\nend", "    # Write your code here.\n    count = [0] * capacity\n\
    \    for x in range(grid[0].length)\n        for y in range(grid[1].length)\n\
    \            count[grid[x][y]] += 1\n    return count(0)", "  rows = (grid[0].map(&:length).max).floor\n\
    \  columns = (grid[0].map(&:length).max).ceil\n  grid = grid.permutation.map do\
    \ |row|\n    row.map {|cell| cell == 1 ? capacity : cell}\n  end.flatten\n  grid\
    \ = grid.map do |cell|\n    cell.map.with_index do |value, index|\n      value\
    \ = cell[index].to_i\n      cell[index] = value == 0 ? 1 : 0\n      value\n  \
    \  end\n  end.compact\n  grid.inject(0) {|memo, cell| memo += cell.count(0); memo}\n\
    end\n</cell>\n<code language=other-env>", "    # Fill the entire grid with a single\
    \ bucket of capacity \n    \n    # Write your code here.\n    if grid.length ==\
    \ 0 or grid[0].length == 0 then\n        return 0\n    \n    filled_wells = 0\n\
    \    \n    # Traverse the grid\n    for i in 0...grid.length-1 do\n        for\
    \ j in 0...grid[0].length-1 do\n            if grid[i][j] == 1 then\n        \
    \        filled_wells = filled_wells + capacity - grid[i][j]\n               \
    \ grid[i][j] = 0\n            else\n                filled_wells = filled_wells\
    \ + grid[i][j]\n                grid[i][j] = 1\n            end\n        end\n\
    \    end\n    return filled_wells\nend", "    # Fill each well using the max bucket\
    \ possible\n    # Fill each row using max bucket possible\n    # Fill each column\
    \ using max bucket possible\n    # Fill each row and column using max bucket possible\n\
    \    # Fill all wells using max bucket possible\n    # Return the max bucket used\n\
    \    \n    count = 0\n    for i in range(0, len(grid[0])):\n        for j in range(0,\
    \ len(grid)):\n            if grid[j][i] == 1:\n                count += 1\n \
    \               if count > capacity:\n                    return count\n    for\
    \ j in range(0, len(grid[0])):\n        for k in range(0, len(grid)):\n      \
    \      if grid[j][k] == 1:\n                count += 1\n                if count\
    \ > capacity:\n                    return count\n    for j in range(0, len(grid)):\n\
    \        for i in range(0, len(grid[0])):\n            if grid[j][i] == 1:\n \
    \               count += 1\n                if count > capacity:\n           \
    \         return count\n    for j in range(0, len(grid[0])):\n        for i in\
    \ range(0, len(grid)):\n            if grid[i][j] == 1:\n                count\
    \ += 1\n                if count > capacity:\n                    return count\n\
    \    \n    return count", "    # write your code here\n    if grid[0].length <=\
    \ 0 || grid[0][1].to_i == 0 then\n        return 0\n    \n    max_count = grid[0].length\n\
    \    \n    for row in grid\n        if row.length > max_count then\n         \
    \   max_count = row.length\n        end\n    end\n    \n    max_count = 0\n  \
    \  \n    for row in grid\n        if row.length > max_count and row.to_i != 0\n\
    \            max_count = row.length\n        end\n    end\n    \n    if capacity\
    \ == max_count then\n        return 0\n    end\n    \n    return max_fill_recursive(grid,\
    \ 0, capacity, max_count)\nend", "    # Write your code here\n    if grid.length\
    \ == 0 || grid.length == 1 && grid[0].length == 0\n        return 0\n    \n  \
    \  buckets = Array.new(capacity) do\n        Array.new(capacity)\n    end\n  \
    \  \n    wells = Array.new(grid.length) do\n        Array.new(grid[0].length)\n\
    \    end\n    \n    grid.each_index do |i|\n        wells[i].each_index do |j|\n\
    \            if grid[i][j] == 1\n                buckets[grid[i][j] - 1][i][j]\
    \ = 1\n            end\n        end\n    end\n    \n    i = 0\n    j = 0\n   \
    \ \n    while i < buckets.length\n        buckets[i].each_index do |k|\n     \
    \       if buckets[i][k] == 0\n                buckets[k].each do |l|\n      \
    \              if buckets[k][l] == 1\n                        buckets[k][l] =\
    \ 0\n                    end\n                end\n            end\n        end\n\
    \        i += 1\n    end\n    \n    count = 0\n    \n    while j < wells.length\n\
    \        wells[j].each do |l|\n            if wells[j][l] == 0\n             \
    \   wells[j][l] = 1\n                count += 1\n            end\n        end\n\
    \        j += 1\n    end\n    \n    return count\nend", "  return max_fill_aux(grid,\
    \ 0, capacity)\nend", "    # Fill the buckets\n    buckets = []\n    for i in\
    \ 1..grid.length\n        # Skip the bucket that doesn't have capacity\n     \
    \   if grid[i][1] == capacity\n            buckets << [grid[i][0]]\n        end\n\
    \    end", "    i, j = 0, 0\n    ans = 0\n    while(i < grid.length and j < grid[i].length)\n\
    \        if grid[i][j] == 1\n            ans = Math.max(ans, max_fill(grid,capacity))\n\
    \        end\n        i += j\n        j += 1\n    end\n    return ans\nend", " \
    \   i = 0\n    buckets = Array.new(capacity)\n    grid_size = grid.length\n  \
    \  while i < grid_size\n        buckets[grid[i][0]].push(grid[i][1])\n       \
    \ i += 1\n    i -= 1\n    j = 0\n    count = 1\n    while i <= grid_size - 1\n\
    \        if buckets[j].length >= capacity\n            count += buckets[j].length\n\
    \            j -= 1\n        else\n            i += 1\n    end\n    count\nend\n\
    </cell>\n<code language=julia-1.5>", "    buckets = Array.new(10+1, '0') \n  \
    \  count = 0\n    grid.each_with_index do |row, index|\n        row.each_with_index\
    \ do |col| \n            if col == 1\n                count += 1\n           \
    \     buckets[capacity-row] = 1 \n            else\n                if buckets[capacity-row]\
    \ == 0\n                    buckets[capacity-row] = 1\n                    count\
    \ += 1\n                end\n            end\n        end\n    end\n    return\
    \ count\nend", "    # Fill the buckets\n    while grid.size > 0\n        well\
    \ = grid.shift\n        bucket = well[0]\n        \n        until bucket.size\
    \ >= capacity\n            bucket.push(*well[1..-1]) # push water into bucket\n\
    \        end\n    end\n    \n    grid.size\nend", "    # Write your code here\n\
    \    count = capacity\n    i = 0\n    while i < grid.length - 1\n        count\
    \ -= grid[i][1]\n        i += 1\n    return count\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nIf you think this answer is helpful, you can upvote or accept it by clicking\
    \ the green checkmark on the left.\n<|/ c |>\n<| a tags=algorithm dscore=0 |>\n\
    Here is my solution in C#, using brute force O(n^2) solution.\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;", "    fill = 0\n    grid.each { |i| i[1] } # remove\
    \ zero buckets\n    buckets = buckets(grid, capacity)\n    grid.each { |i| i[1]\
    \ = 0 if buckets[i].length == 0 else buckets[i].length }\n    \n    grid.each\
    \ do |i|\n        bucket = buckets.delete_if{|b| b == 0}\n        fill = fill\
    \ + (bucket.length * i[1])\n    end\n    \n    return fill\nend", "  count = 0\n\
    \  for row,col in grid\n    count += row > col ? 1 : 0\n  end\n  return count\n\
    end\n</cell>\n<code language=julia-0.5>", "    # Your code here\n    return 0",
  "    # write your code here\n    \n    i, j = 0, 0\n    count = 0\n    \n    while\
    \ i < grid.length and j < grid.columns.length:\n        if grid[i][j] == 0:\n\
    \            \n            # increment the count\n            count += 1\n   \
    \         \n            # move to the next row\n            i += 1\n         \
    \   \n            # move to the next column\n            j += 1\n        \n  \
    \      else:\n            # decrement the count\n            count -= 1\n    \
    \        \n            # move to the next row\n            i += 1\n          \
    \  \n            # move to the next column\n            j -= 1\n            \n\
    \    return count\n        \n    ", "  counter = 0\n  for i in 1..grid.length\n\
    \    counter += 1\n    buckets = 0..capacity\n    filling_grid = grid[0..i-1]\n\
    \    filling_grid.length.times do |i|\n      filling_grid.each_index do |j|\n\
    \        filling_grid[j] = 0\n        buckets[j] -= filling_grid[j]\n      end\n\
    \    end\n    filling_grid.length.times do |i|\n      buckets[i] += filling_grid[i]\n\
    \    end\n    counter -= buckets.sum\n    break if buckets.sum == 0 && i == grid.length\n\
    \  end\n  return counter\nend", "    # Write your code here\n    grid = Array2D.new(grid)\n\
    \    grid.map { |row| row.reverse! if row.length == 1 }\n    \n    left,right\
    \ = grid.minmax_by(&:length)\n    left.each do |b|\n      b.fill(capacity)\n \
    \   end\n    \n    left.each do |b|\n      b.fill(capacity)\n    end\n    \n \
    \   left.each do |b|\n      b.fill(capacity)\n    end\n    \n    left.each do\
    \ |b|\n      b.fill(capacity)\n    end\n    \n    left.each do |b|\n      b.fill(capacity)\n\
    \    end\n    \n    left.each do |b|\n      b.fill(capacity)\n    end\n    \n\
    \    left.each do |b|\n      b.fill(capacity)\n    end\n    \n    left.each do\
    \ |b|\n      b.fill(capacity)\n    end\n    \n    left.each do |b|\n      b.fill(capacity)\n\
    \    end\n    \n    left.each do |b|\n      b.fill(capacity)\n    end\n    \n\
    \    left.each do |b|\n      b.fill(capacity)\n    end\n    \n    left.each do\
    \ |b|\n      b.fill(capacity)\n    end\n    \n    left.each do |b|\n      b.fill(capacity)\n\
    \    end\n    \n    left.each do |b|\n      b.fill(capacity)\n    end\n    \n\
    \    left.each do |b|\n      b.fill(capacity)\n    end\n    \n    left.each do\
    \ |b|\n      b.fill(capacity)\n    end\n    \n    left.each do |b|\n      b.fill(capacity)\n\
    \    end\n    \n    left.each do |b|\n      b.fill(capacity)\n    end\n    \n\
    \    left.each do |b|\n      b.fill(capacity)\n    end\n    \n    left.each do\
    \ |b|\n      b.fill(capacity)\n    end\n    \n    left.each do |b|\n      b.fill(capacity)\n\
    \    end\n    \n    left.each do |b|\n      b.fill(capacity)\n    end\n    \n\
    \    left.each do |b|\n      b.fill(capacity)\n    end\n    \n    left.each do\
    \ |b|\n      b.fill(capacity)\n    end\n    \n    left.each do |b|\n      b.fill(capacity)\n\
    \    end\n    \n    left.each do |b|\n      b.fill(capacity)\n    end\n    \n",
  "    return max([ min([\n                math.floor(\n                    min(grid[i][j]\
    \ for j in range(i+1, len(grid)))\n                    / capacity\n          \
    \      ),\n                math.floor(\n                    min(grid[j][i] for\
    \ i in range(1, len(grid)))\n                    / capacity\n                ),\n\
    \            ])\n                for i in range(len(grid[0])) for j in range(len(grid))\
    \ if grid[i][j] == 0 ]\n    )", "    # Write your code here.\n    grid=Array.new(2)\n\
    \    for i in (0..grid.length-1)\n        grid[i]=Array.new\n    end\n    bucket=Array.new(capacity)\n\
    \    i=0;\n    bucket.fill(0)\n    grid[0].length.times do |j|\n        bucket[j]=grid[0][j]\n\
    \    end\n    grid[0][j].times do |i|\n        bucket[i].times{bucket[i]-=1}\n\
    \    end\n    max=0;\n    maxi=0;\n    grid[1].length.times do |j|\n        if\
    \ bucket[j]==0\n            if maxi==0\n                maxi=j\n            end\n\
    \        end\n    end\n    max+=maxi\n    grid[1].length.times do |j|\n      \
    \  if bucket[j]==0\n            if maxi==j\n                max+=j\n         \
    \   end\n        end\n    end\n    max-=maxi\n    puts max\nend\n</cell>\n<code\
    \ language=julia-0.6>", "    # write your code here\n    ans = -1\n    well =\
    \ grid.length\n    while well > 0 and capacity > 0:\n        bucket = capacity\
    \ / well\n        bucket_remain = capacity % well\n        if bucket_remain ==\
    \ 0:\n            bucket_remain = 1\n        bucket_remain = bucket_remain + 1\n\
    \        for i in range(bucket):\n            if grid[well - i][bucket_remain]\
    \ == 1:\n                grid[well - i][bucket_remain] = 0\n        capacity =\
    \ bucket_remain\n        well = well - 1\n        ans = ans + 1\n    return ans\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "    m, n = (grid.length / 2).divmod(2)\n\
    \    \n    return m.times {\n        grid.map { |row| \n            row.map {\
    \ |val| \n                if val == 0 then \n                    capacity \n \
    \               elsif val == 1 then \n                    capacity - 1 \n    \
    \            end \n            } \n        } \n    }\nend", "    # initialize\
    \ an answer to return\n    count = 0\n    # for each possible row and column pair\n\
    \    for i in 1..grid[0].length\n        for j in 1..grid.length\n           \
    \ # check if any cell in the row is used\n            if grid[i-1][j]\n      \
    \          # if so, set capacity to capacity\n                count = count +\
    \ (capacity - grid[i-1][j])\n                # set capacity to 0, and set grid\
    \ to 0, since cells are used now\n                grid[i-1][j] = 0\n         \
    \       count = 0\n            # otherwise, check if any cell in the column is\
    \ used\n            if grid[j-1][i]\n                # if so, set capacity to\
    \ capacity\n                count = count + (capacity - grid[j-1][i])\n      \
    \          # set capacity to 0, and set grid to 0, since cells are used now\n\
    \                grid[j-1][i] = 0\n                count = 0\n    # return answer\n\
    \    return count\nend", "  return nil if capacity < 1 || grid.nil?\n  m = grid.length\n\
    \  return 0 if m == 0 || m == 1\n  \n  num_wells = 0\n  while m < 10^9\n    m\
    \ = m / 10\n    begin\n      well = grid.shift\n      num_wells = num_wells +\
    \ 1\n      while well\n        if well[0] < capacity\n          num_wells = num_wells\
    \ + 1\n        end\n        if well[1] < capacity\n          num_wells = num_wells\
    \ + 1\n        end\n        well = well.shift\n      end\n    end\n  end\n  return\
    \ num_wells\nend", "  count = 0\n  \n  # O(n^2)\n  grid.each do |row|\n    row.each_with_index\
    \ do |i, index|\n      row[index] ? count += 1 : nil\n    end\n  end\n  \n  count\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe second solution works in O(n log n). However,\
    \ the first solution only works in O(n).\n<|/ c |>\n<| c |>\nyeah, that's a mistake\
    \ on my part - I used the wrong name in the first one. Fixed now\n<|/ c |>\n<|\
    \ a tags=algorithm,dynamic-programming,ruby,ruby-on-rails,math |>\nThis is a problem\
    \ similar to counting peaks, a very common question for DSA.\nGiven an array A\
    \ of integers sorted in non-decreasing order, count how many distinct peaks are\
    \ in A starting at any given position (i.e. how many distinct peaks are there\
    \ in A[1]? A[2]? A[3]?).\nThe problem is basically a modified variant of Kadane's\
    \ algorithm. Since the array is already sorted, we can use the binary search algorithm\
    \ to find the correct answer very efficiently. Since the binary search algorithm\
    \ only requires one pass over the array, and thus runs O(log n) times, the overall\
    \ complexity is O(n log n). Here is a Java solution:\n<code>\npublic int numPeaks(int[]\
    \ A) {\n    int low = 0, high = A.length - 1;\n    if (A[low] > A[high]) {\n \
    \       return 0;\n    }\n    int mid = (low + high) / 2;\n    int ans = 1;\n\
    \    while (low < high) {\n        int mid = (low + high) / 2;\n        if (A[mid]\
    \ > A[mid+1]) {\n            high = mid - 1;\n        } else {\n            low\
    \ = mid + 1;\n        }\n        ans += (mid+1) * 2;\n    }\n    return ans;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis problem is equivalent to counting\
    \ peaks, a very common problem for DSA. Given an array A of integers sorted in\
    \ non-decreasing order, count how many distinct peaks are in A starting at any\
    \ given position (i.e. how many distinct peaks are there in A[1]? A[2]? A[3]?).\n\
    The problem is basically a modified variant of Kadane's algorithm. Since the array\
    \ is already sorted, we can use the binary search algorithm to find the correct\
    \ answer very efficiently. Since the binary search algorithm only requires one\
    \ pass over the array, and thus runs O(log n) times, the overall complexity is\
    \ O(n ", '  return 0', "    # Fill the buckets first\n    bucket_size = 1\n  \
    \  bucket_capacity = capacity\n    bucket_filled = HashMap.new\n    bucket_empty.add(capacity)\n\
    \    \n    for i in (1..grid.length)\n        for j in (1..grid[i].length)\n \
    \           if grid[i][j] == 1\n                bucket_filled.set(bucket_size)\
    \ \n                bucket_capacity -= 1\n                if bucket_capacity ==\
    \ 0\n                    bucket_size = bucket_size + 1\n                else\n\
    \                    bucket_size += 1\n                end\n            end\n\
    \        end\n    end", "    count = 0\n    grid = [grid.clone] unless grid.is_a?(Array)\n\
    \    grid.map do |row|\n        row.each do |item|\n            item = item.to_i\n\
    \            count += 1 if item == 1\n        end\n    end\n    return count if\
    \ capacity == 0\n    grid = grid.sort_by!{|v| -v[0]}\n    count = 0\n    grid.each\
    \ do |row|\n        row.each do |item|\n            item = item.to_i\n       \
    \     count += 1 if item == 0\n        end\n    end\n    return count if count\
    \ > capacity\n    count = 0\n    grid.each do |row|\n        row.each do |item|\n\
    \            item = item.to_i\n            count += 1 if item == 1\n        end\n\
    \    end\n    count\nend\n</cell>\n<code language=julia-0.6>\nfunction max_fill(grid,\
    \ capacity)\n    count = 0\n    grid = [grid.clone] unless grid.is_a?(Array)\n\
    \    grid.map do |row|\n        row.each do |item|\n            item = item.to_i\n\
    \            count += 1 if item == 1\n        end\n    end\n    return count if\
    \ capacity == 0\n    grid = grid.sort_by!{|v| -v[0]}\n    count = 0\n    grid.each\
    \ do |row|\n        row.each do |item|\n            item = item.to_i\n       \
    \     count += 1 if item == 0\n        end\n    end\n    return count if count\
    \ > capacity\n    count = 0\n    grid.each do |row|\n        row.each do |item|\n\
    \            item = item.to_i\n            count += 1 if item == 1\n        end\n\
    \    end\n    count\nend\n</cell>\n<code language=julia-0.6>\nfunction max_fill(grid,\
    \ capacity)\n    count = 0\n    grid = [grid.clone] unless grid.is_a?(Array)\n\
    \    grid.map do |row|\n        row.each do |item|\n            item = item.to_i\n\
    \            count += 1 if item == 1\n        end\n    end\n    return count if\
    \ capacity == 0\n    grid = grid.sort_by!{|v| -v[0]}\n    count = 0\n    grid.each\
    \ do |row|\n        row.each do |item|\n            item = item.to_i\n       \
    \     count += 1 if item == 0\n        end\n    end\n    return count if count\
    \ > capacity\n    count = 0\n    grid.each do |row|\n        row.each do |item|\n\
    \            item = item.to_i\n            count += 1 if item == 1\n        end\n\
    \    end\n    count\nend\n</cell>\n<code language=julia-0.6>\nfunction max_fill(grid,\
    \ capacity)\n    count = 0\n    grid = ", "    sum = 0\n    len = grid.length\n\
    \    \n    (0...len).each do |i|\n        (0...len).each do |j|\n            next\
    \ if grid[i][j] == 0\n            sum += grid[i][j] * capacity\n        end\n\
    \    end\n    \n    sum\nend\n</cell>\n<cell>", "  return \nend", "    # write\
    \ your code here\n    if grid.length==0 or grid.at(0).to_int()==0\n        0\n\
    \    else\n        max_value=grid[0].to_int()\n        length=grid.length\n  \
    \      width=grid[0].to_int()\n        for i in range(1,length-1)\n          \
    \  value=grid[i].to_int()\n            if value>max_value\n                max_value=value\n\
    \            else\n                max_value=max_value+value\n    end\nend\n</cell>\n\
    <text>\n[Coding Part 2]\nWe also need a function that can fill the well. fill_well\n\
    Fills a single well.\nReturns the number of cells left.\nFor an example:", " \
    \   return helper(grid, capacity, 0, 0)\nend", "    grid.each do |row|\n     \
    \   row.each do |cell|\n            if cell == 0\n                row = row.drop(1).max\n\
    \            end\n        end\n    end\n    return row.drop(1).max\nend\n</cell>\n\
    <text>\nQ9\nGiven a 2-dimensional array arr = [[5, 8, 4], [2, 4, 1]]\nFind the\
    \ index of the maximum value along each row.\nThe function should return the index\
    \ as shown in the example below:\n[5, 8, 4] => [5, 8, 4] => [1, 2, 3]\nThe function\
    \ should return -1 if the array is empty or contains negative numbers.", "   \
    \ # write your code here\n    # max_fill\n    count = 0\n    # write your code\
    \ here\n    # count all row\n    for row in grid.each_index\n        # count column\n\
    \        for column in grid\n            # count the grid[i][j]\n            count\
    \ += grid[column][row]\n            # check capacity\n            if count < capacity\n\
    \                # refill with min_fill\n                count += min_fill(grid,\
    \ capacity - count)\n            else\n                # count the grid[i][j]\n\
    \                count -= capacity\n            # stop when count < 0\n      \
    \      count\n    end\nend\n</cell>\n<text>\nThe last three methods are the most\
    \ complex. The first method can simply calculate the number of rows and columns,\
    \ and count the number in the rows and columns, and also count the number that\
    \ can fill the bucket. The second method is the most complex. It is a recursive\
    \ function. In recursion, we need to count the number that can fill the bucket\
    \ before we lower the bucket. Here we calculate the number of fill and the number\
    \ of lower the bucket. We only keep lower the bucket when the number of fill equals\
    \ the capacity. If the number of fill is 0, then the bucket is already empty.",
  "    # Write your code here\n    \n    m, n = grid.length, n\n    count = 0\n  \
    \  \n    \n    for row in 0...m\n        count = 0\n        for col in 0...n\n\
    \            if grid[row][col] == 1\n                count += 0\n            else\n\
    \                count += (capacity - 1) if (capacity - 1) > grid[row][col] else\
    \ 1\n        end\n        if count > capacity\n            count += 1\n      \
    \  end\n    end\n    \n    return count\nend\n</cell>\n<text>\n\u6700\u5927\u586B\
    \u5145\n\u5728\u4E0A\u4E00\u9898\u4E2D\uFF0C\u6211\u4EEC\u63D0\u51FA\u4E86\u4E00\
    \u79CD\u7B80\u5355\u7684\u65B9\u5F0F\uFF0C\u8FD9\u6837\u6211\u4EEC\u53EF\u4EE5\
    \u5BF9\u6BCF\u4E2A\u5355\u5143\u683C\u90FD\u8FDB\u884C\u586B\u5145\uFF0C\u8FD9\
    \u6837\u5C31\u53EF\u4EE5\u5F97\u51FA\u6700\u5927\u586B\u5145\u7684\u76EE\u7684\
    \u3002\u4F46\u662F\u8FD9\u79CD\u65B9\u5F0F\u6709\u4E2A\u7F3A\u70B9\uFF0C\u5C31\
    \u662F\u586B\u5145\u540E\u4F1A\u591A\u51FA\u4E00\u4F4D\u586B\u5145\u7684\u5355\
    \u5143\u683C\u3002\u8FD9\u79CD\u65B9\u5F0F\u6709\u4E00\u4E2A\u5F88\u597D\u7684\
    \u89E3\u51B3\u529E\u6CD5\u3002\n\u9996\u5148\uFF0C\u6211\u4EEC\u5B9A\u4E49\u4E00\
    \u4E2A\u66F4\u7B80\u5355\u7684\u65B9\u5F0F\u6765\u8BA1\u7B97\u586B\u5145\u540E\
    \u7684\u76EE\u7684\u3002", "  n = grid.length\n  m = grid[0].length\n  ans = 0\n\
    \  grid_buckets = Array.new(n, Array.new(m))\n  grid = grid.map{|i| i.map{|j|\
    \ grid[i][j] ? grid_buckets[i][j] : 0}}\n  grid_buckets.each{|row| row.each{|col|\
    \ col >= capacity ? ans += 1 : grid_buckets[row][col] = -1}}\n  ans\nend", " \
    \   # Write your code here.\n    arr = [0] * (grid.length + 1)\n    for i in 1..grid.length\n\
    \        arr[i] = arr[i-1] + grid[i-1].count\n    end\n    ans = 1\n    for i\
    \ in 1..arr.length\n        ans = max(ans, arr[i])\n    end\n    return ans\n\
    end", "  return 0\nend", "    return nil\nend\n</cell>\n<text>\nBacktracking is\
    \ a recursion algorithm\nBacktracking is one of the most common algorithms to\
    \ solve a problem.\nThis approach divides the problem into smaller parts, solves\
    \ them separately, and then combines these solutions.\nTo solve a problem recursively\
    \ we start from a base case and recursively solve each smaller problem.\nRecursive\
    \ backtracking algorithm is very similar to the algorithm described in Wikipedia.\n\
    The only difference is that instead of breaking down the problem into smaller\
    \ parts we continue to solve the problem until we find a solution or we run out\
    \ of possible moves.", "    i = 0\n    j =  0\n    count=0\n    while (i < grid.length\
    \ && j < grid[i].length)\n        if grid[i][j] == 0 then\n            count =\
    \ count + 1\n            i = i + 1\n            j = j + 1\n            i = i -\
    \ 1\n            j = j - 1\n        else\n            i = i + 1\n            j\
    \ = j + 1\n            count = count + 1\n        end\n    end\n    return count\n\
    end\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails-3,arrays |>\n<| a tags=algorithm,ruby,ruby-on-rails-3,arrays\
    \ |>\nHere's a recursive solution using Array#transpose and Array#count:\n<code>",
  "    count = 0\n    rows = grid.length\n    cols = grid[0].length\n    \n    grid1\
    \ = Array.new(rows) do |i|\n        Array.new(cols) do |j|\n            if i ==\
    \ 0 || j == 0 || j == cols-1 || i == rows-1\n                0\n            elsif\
    \ grid[i][j] == 0\n                0\n            else\n                grid[i][j]\n\
    \            end\n        end\n    end\n    \n    grid2 = Array.new(rows) do |i|\n\
    \        Array.new(cols) do |j|\n            if i == 0 || j == 0 || j == cols-1\
    \ || i == rows-1\n                0\n            elsif grid1[i][j] == 0\n    \
    \            0\n            else\n                grid1[i][j]\n            end\n\
    \        end\n    end\n    \n    until capacity == 0\n        grid3 = Array.new(rows)\
    \ do |i|\n            Array.new(cols) do |j|\n                count = count +\
    \ 1\n                grid2[i][j] = grid1[i][j]\n                grid1[i][j] =\
    \ 0\n                \n                until count == capacity\n             \
    \       count = count + 1\n                    grid3[i][j] = grid1[i][j]\n   \
    \                 grid1[i][j] = 0\n                end\n                grid2[i][j]\
    \ = grid3[i][j]\n                grid1[i][j] = 0\n            end\n        end\n\
    \    end\n    \n    count = 0\n    until count == capacity\n        count = 0\n\
    \        grid4 = Array.new(rows) do |i|\n            Array.new(cols) do |j|\n\
    \                count = count + 1\n                grid2[i][j] = grid1[i][j]\n\
    \                grid1[i][j] = 0\n                \n                until count\
    \ == capacity\n                    count = count + 1\n                    grid4[i][j]\
    \ = grid1[i][j]\n                    grid1[i][j] = 0\n                end\n  \
    \              grid2[i][j] = grid4[i][j]\n                grid1[i][j] = 0\n  \
    \          end\n        end\n    end\n    \n    count = 0\n    until count ==\
    \ capacity\n        count = 0\n        grid5 = Array.new(rows) do |i|\n      \
    \      Array.new(cols) do |j|\n                count = count + 1\n           \
    \     grid2[i][j] = grid1[i][j]\n                grid1[i][j] = 0\n           \
    \     \n                until count == capacity\n                    count = count\
    \ + 1\n                    grid5[i][j] = grid1[i][j]\n                    grid1[i][j]\
    \ = 0\n                end\n                grid2[i][j] = grid5[i][j]\n      \
    \          grid1[i][j] = 0\n            end\n        end\n    end\n    \n    count\
    \ = 0\n    until count == capacity\n        count = 0\n        grid6 = Array.new(rows)\
    \ do |i|\n            Array.new(cols) do |j|\n                count = count +\
    \ 1\n                grid2[i][j] = ", "    m, n = grid.length\n    \n    buckets\
    \ = Array.new(1, Array.new(m, 0))\n    \n    grid.each_with_index do |row, row_index|\n\
    \        row.each_with_index do |col, col_index|\n            buckets[row_index][col_index]\
    \ += 1\n        end\n    end\n    \n    filled_cells = 0\n    \n    buckets.each_with_index\
    \ do |bucket_arr, index|\n        filled_cells += bucket_arr.uniq.count{|cell|\
    \ cell == 1}\n    end\n    \n    return filled_cells if filled_cells < capacity\
    \ and filled_cells != 0\n    return 0\nend\n</cell>\n<cell>\ntest_max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]])\n</cell>\n<cell>\ntest_max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]])\n</cell>\n<cell>\ntest_max_fill([[0,\
    \ 0, 0], [0, 0, 0]])\n</cell>\n<text>\nSolution\nSince this is a common interview\
    \ question, I created a solution in Ruby.", "  return 0 \nend", "  n = grid.length\n\
    \  m = grid.first.length\n  buckets = [ArrayNode.new(capacity, Array.new)]\n \
    \ grid.each do |row|\n    row.each do |bucket|\n      buckets << bucket\n    end\n\
    \  end\n  count = 0\n  while buckets.length >= 1\n    buckets.shift \n    buckets.last.each\
    \ do |bucket|\n      count = bucket.empty? ? count + 1 : count\n    end\n  end\n\
    \  count\nend", "    # write your code here\n    num_of_buckets = grid[0].length\n\
    \    num_of_wells = grid.length\n    left = 0\n    right = 0\n    if num_of_buckets\
    \ <= capacity:\n        left = 0\n        right = num_of_buckets\n    else:\n\
    \        left = int(math.ceil(capacity / num_of_buckets))\n        right = capacity\
    \ - left\n    # calculate the number of empty buckets\n    num_of_empty_buckets\
    \ = 0\n    for bucket in grid[0]:\n        if bucket == 0:\n            num_of_empty_buckets\
    \ += 1\n            right -= 1\n        if bucket == 1:\n            right +=\
    \ 1\n    \n    while left < num_of_wells and right < num_of_buckets:\n       \
    \ grid[num_of_empty_buckets][left] = 1\n        grid[num_of_empty_buckets][right]\
    \ = 1\n        if num_of_empty_buckets >= num_of_buckets:\n            break\n\
    \        grid[num_of_empty_buckets][num_of_buckets] = 1\n        if num_of_empty_buckets\
    \ < num_of_buckets:\n            num_of_empty_buckets += 1\n            right\
    \ += 1\n        right += 1\n        left += 1\n    return num_of_empty_buckets",
  "  grid.length.times do |i|\n    grid[i].length.times do |j|\n      grid[i][j] =\
    \ grid[i][j].next\n    end\n  end\n  grid.length.times do |i|\n    grid[i].length.times\
    \ do |j|\n      grid[i][j].next -= 1 if grid[i][j] < capacity\n    end\n  end\n\
    \  grid.length.times do |i|\n    grid[i].length.times do |j|\n      grid[i][j].next\
    \ -= 1 if grid[i][j] <= 0\n    end\n  end\n  grid.length.times do |i|\n    grid[i].length.times\
    \ do |j|\n      grid[i][j].next += 1 if grid[i][j] < capacity\n    end\n  end\n\
    \  grid.length.times do |i|\n    grid[i].length.times do |j|\n      grid[i][j].next\
    \ += 1 if grid[i][j] <= 0\n    end\n  end\n  grid.length.times do |i|\n    grid[i].length.times\
    \ do |j|\n      grid[i][j].next += 1 if grid[i][j] >= capacity\n    end\n  end\n\
    \  grid.length.times do |i|\n    grid[i].length.times do |j|\n      grid[i][j].next\
    \ -= 1 if grid[i][j] >= 0\n    end\n  end\n  return grid.length.times.inject(0)\
    \ {|sum, i| sum += grid[i].length}\nend\n</cell>\n<cell>", "    # write your code\
    \ here\n    sum = 0\n    grid_height = grid.length\n    grid_width = grid[0].length\n\
    \    grid_capacity = capacity * grid.length\n    for i in 1..grid_height-1\n \
    \       for j in 1..grid_width-1\n            sum += grid[i][j] * (capacity /\
    \ grid_capacity)\n    sum += grid[grid_height-1][grid_width-1] * (capacity / grid_capacity)\n\
    \    return sum", "    return max_fill_aux(grid, capacity, 0)\nend", "    return\
    \ nil if grid.length == 0 or grid[0].length == 0\n    buckets = build_buckets(grid,\
    \ capacity)\n    count = -1\n    buckets.each do |key, value|\n        count +=\
    \ 1 if key == 0\n    end\n    return count\nend", "    return \nend", "    # write\
    \ your code here\n    max_fill = 0\n    bucket = Array(capacity).init_with(0)\n\
    \    (rows, cols) = grid.shape\n    bucket.each { |i| bucket[i] = grid[i][0] }\n\
    \    (rows - 1).downto(0) {|i|\n        (cols - 1).downto(0) {|j|\n          \
    \  if bucket[j] == 0 && (bucket[j] == bucket[j + 1] || bucket[j] == bucket[j -\
    \ 1]) {\n                bucket[j] = 0\n                bucket[j + 1] = 1\n  \
    \              bucket[j - 1] = 1\n                max_fill = max_fill + 1\n  \
    \          }\n        }\n    }\n    return max_fill\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
