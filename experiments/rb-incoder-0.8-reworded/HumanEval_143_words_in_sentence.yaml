name: HumanEval_143_words_in_sentence
language: rb
prompt: "# You are given a string representing a sentence,\n# the sentence contains\
  \ some words separated by a space,\n# and you have to return a string that contains\
  \ the words from the original sentence,\n# whose lengths are prime numbers,\n# the\
  \ order of the words in the new string should be the same as the original one.\n\
  # Example 1:\n# >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example\
  \ 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n\
  # * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n\
  \    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"\
  This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"\
  ))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available\
  \ here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"\
  ))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\
  \", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"\
  ))\n  end\nend\n"
completions: ["    s = sentence.split(\" \")\n    n = s.length\n    sum = 1\n    ans\
    \ = []\n    for i in s\n        sum *= i.length\n        if sum > n\n        \
    \    break\n        ans << i\n        sum += i.length\n    return ans.join(\"\
    \ \")\nend\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"This is a\
    \ test\")\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"lets go for\
    \ swimming\")\n</cell>\n<code language=julia-1.0>", "    arr = sentence.split(\"\
    \ \").sort\n    arr.uniq.map do |word|\n        len = word.length.to_i\n     \
    \   prime? len\n    end.compact\nend\n</cell>\n<code language=julia-1.4>", " \
    \ new_sentence = ''\n  count = 0\n  i = 0\n  while i < sentence.length\n    if\
    \ count%2 != 0\n      new_sentence += sentence[i]\n    count += 1\n    i += 1\n\
    \  end\n  return new_sentence\nend", "  # Split sentence into a list of words\
    \ and flatten the result set\n  words = sentence.split(\" \")\n  \n  # Generate\
    \ a list of numbers that are primes up to 100\n  primes = generate_primes(100)\n\
    \  \n  # Initialize an empty string \n  ret = \"\"\n  \n  # For each prime number\
    \ in the list of primes\n  primes.each do |prime|\n    # Check if the length of\
    \ the current word is prime number or not\n    word.chars.all(&:prime?).each do\
    \ |character|\n      # Append the current word if the current word length is equal\
    \ to prime number\n      if word.length == prime\n        ret << word\n      end\n\
    \    end\n  end\n  \n  ret\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=1 |>\n\
    <| a dscore=1 |>\nHere's a solution using Ruby's inject method:\n<code>", "  \
    \  word_count = {}\n    new_sentence = []\n    sentence = sentence.split(\" \"\
    )\n    i = 0\n    \n    while i < len(sentence)\n        if sentence[i] !~ /[a-zA-Z]/\n\
    \            word_count[sentence[i]] = 0\n        end\n        new_sentence[i]\
    \ = sentence[i]\n        i += 1\n    end\n    i = 0\n    \n    while i < len(new_sentence)\n\
    \        if word_count.key?(new_sentence[i])\n            word_count[new_sentence[i]]\
    \ += 1\n        else\n            word_count[new_sentence[i]] = 1\n        end\n\
    \        i += 1\n    end\n    i = 0\n    \n    while i < len(new_sentence)\n \
    \       if word_count[new_sentence[i]] == 2\n            new_sentence[i] << \"\
    \ \"\n        end\n        i += 1\n    end\n    sentence = new_sentence\n    sentence.join\n\
    end\n</cell>\n<cell>", "    # Fill this in.\nend", "  sentence.split(' ').map{|word|\
    \ is_prime?(word) ? word : nil }.compact\nend", "  sentence\nend", "    sentence.split('\
    \ ')\n    result = \"\"\n    l = len(sentence)\n    prime = True\n    while prime\
    \ and l > 0:\n        result = result + sentence[l-1] + ' '\n        l -= 1\n\
    \        prime = is_prime.call(result)\n    return result\n</cell>\n<cell>", " \
    \ return []\nend\n\"\"\"", "    words = sentence.split(' ')\n    prime_words =\
    \ Array.new()\n    prime_words.fill(0)", "  # +++your code here+++\n  return \"\
    \"\nend", "  words = []\n  sentence = sentence.split(' ')\n  for i in 1..100\n\
    \    if sentence.include?(i)\n      if i == 1 \n        words.push sentence[i-1]\n\
    \      else\n        words.push sentence[i-1]+sentence[i]\n      end\n    end\n\
    \  end\n  words.join(' ')\nend\n</cell>\n<text>\n\u56DE\u7B54:", "  count = 0\n\
    \  result = []\n  \n  # Iterate through the given sentence.\n  for i in sentence.split(\"\
    \ \").each do\n    # Check if the length is prime\n    if i.length == i.to_i\n\
    \      # If it is prime add it to the result\n      result << i\n    end\n  end\n\
    \  \n  return result.join(\" \")\nend", "    # Your code here\n    sentence =\
    \ sentence.split(' ')\n    l = len(sentence)\n    word_list = sentence\n    for\
    \ i in range(l):\n        for j in range(i+1, l):\n            if is_prime(ord(word_list[i])\
    \ + ord(word_list[j])):\n                word_list.remove(word_list[i])\n    sentence\
    \ = ' '.join(word_list)\n    return sentence", "  # Your code here\n  count =\
    \ 0\n  result = \"\"\n  sentence.split(\" \").each do |word|\n    count += 1 if\
    \ word != \"\"\n  end\n  return result if count == 1\n  \n  result = 0\n  result\
    \ = 1\n  sentence.split(\" \").each do |word|\n    if word != \"\"\n      result\
    \ = result + Math.sqrt(word.size)\n    end\n  end\n  \n  return result if result\
    \ == 1\nend\n</code>\n<|/ a tags=ruby,algorithm,string |>\n<| c |>\nThis doesn't\
    \ work when `length == 1` because `sqrt` will give `0` for that case.\n<|/ c |>\n\
    <| c |>\nAh, now that I think about it, that's not a great test case to have\n\
    <|/ c |>\n<| c |>\nYou're right. I'll just change my answer accordingly.\n<|/\
    \ c |>\n<| a dscore=0 tags=ruby,algorithm,string |>\nA solution that works with\
    \ an arbitrary number of words and an arbitrary number of spaces:\n<code>", " \
    \   sentence = sentence.downcase\n    words = sentence.split(' ')\n    result\
    \ = \"\"\n    divisors = []\n    i = 0\n    while i < words.length\n        divisor\
    \ = words[i].to_s.length\n        divisors << divisor\n        i += 1\n    end\n\
    \    divisors.sort! { |a,b| a <=> b }\n    divisors.each do |divisor|\n      \
    \  for i =0 .. (divisor-1).to_s.length-1\n            result << words[i].to_s\
    \ << \" \"\n        end\n    end\n    result.delete!(\" \")\n    return result\n\
    end", "  # Your code here\n  return \"is \"", "  string = \"\"\n  string.concat(words_in_sentence(sentence.split(\"\
    \ \")).split(\" \"))\n  return string\nend", "    # Write your code here\n   \
    \ \n    return \"\"\n    ", "  return \"\n\"\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby |>\nI believe this can be solved using recursion\n<code>", "  sentence\
    \ = sentence.split(\" \")\n  word_list = []\n  prime_count = 0\n  prime = 0\n\
    \  for i in sentence\n    i = i.upcase\n    prime = 0\n    count = 0\n    prime_count\
    \ = 0\n    while i < 100\n      prime += 1\n      if prime > count\n        prime_count\
    \ = count\n      i += 1\n      count += 1\n    word_list.push i\n  word_list.reject!{\
    \ |x|\n    prime_count != x\n  }\n  return word_list\nend", "    # @return a list\
    \ of strings, where each string is the word in the sentence\n    word = sentence.split(\"\
    \ \")\n    word_list = []\n    str_length = 1\n    str_length += 2\n    i = 0\n\
    \    while i < len(word):\n        if str_length == 1:\n            str_length\
    \ += 2\n            word_list.append(word[i])\n        else:\n            if str_length\
    \ == int(word[i]):\n                str_length += 2\n                word_list.append(word[i])\n\
    \            else:\n                str_length = int(word[i])\n              \
    \  word_list.append(word[i])\n        i += 1\n    return \" \".join(word_list)",
  "    words = sentence.split\n    words_in_sentence = []\n    max_length = 1", " \
    \ str=sentence.split(' ')\n  str.map!{|x| x.gsub(/\\W+/,'')}\n  str.map!{|x| x.split('').uniq.sort}\n\
    \  return str.join\nend", "    sentence_words = sentence.split\n    sentence_words.each\
    \ {|word| return word if word.prime?}\nend\n</code>\n<|/ a tags=string,ruby |>\n\
    <| c |>\nThat is awesome! I didn't know Ruby had those methods, very cool! Thanks!\n\
    <|/ c |>\n<| c |>\nI hope you enjoy Ruby! :)\n<|/ c |>\n<| a |>\n<code>", "  i\
    \ = 0\n  while i < sentence.length\n    if is_prime? i \n    i += 1\n  end\n \
    \ \nend\n</code>\n<|/ a |>\n<| c |>\nYou don't need a recursive function. Just\
    \ an iteration.\n<|/ c |>\n<| c |>\nI didn't know how to iterate in a recursive\
    \ way. That's why I added the example. I will edit the post to remove it again\n\
    <|/ c |>\n<| a |>\nYou can try this way:\n<code>", "  word = sentence.split('\
    \ ')\n  word.each do |word|\n    if !word.to_i.is_prime?\n      puts word\n  \
    \  end \n  end\nend", "  sentence=sentence.split(\" \").sort\n  sentence.length.downto(0).map{|l|\n\
    \    sentence.select {|w| w.length == l}.length\n  }.join.uniq\nend\n</code>\n\
    <|/ a tags=ruby,algorithm dscore=2 |>\n<| a dscore=2 |>\nThis is similar to some\
    \ of the other answers but doesn't require a hash and is very concise.\n<code>",
  "  return sentence.split(\" \").inject([], :<<)\nend\n</pre>\n</div>\n</div>\n</div>\n\
    </div>\n</div>\n</div>\n<div id=\"footer\">\n<div id=\"footer-text\">\nLast updated\
    \ 2020-10-18 16:35:23 W. Europe Daylight Time\n</div>\n</div>\n</body>\n</html>",
  "    words = sentence.split(' ')\n    count = 0\n    words_in_sentence = []\n  \
    \  next_words = []\n    word_nums = []\n    count_next = 0\n    for word in words\n\
    \        word_num = getNum(word)\n        words_in_sentence << word\n        word_nums\
    \ << word_num\n    end\n    word_nums.each do |x|\n        next_words.each do\
    \ |y|\n            count = count + 1\n            count = count - 1\n        \
    \    count_next = count_next + 1\n            count_next = count_next - 1\n  \
    \          if x == y\n                if count == 0\n                    words_in_sentence.delete(words_in_sentence.last)\n\
    \                    words_in_sentence.delete(words_in_sentence.last)\n      \
    \              words_in_sentence.delete(words_in_sentence.last)\n            \
    \    end\n            end\n        end\n        count = 0\n        count_next\
    \ = 0\n    end\n    words_in_sentence.join(' ')\nend", "    # Write your code\
    \ here\n    words = sentence.split(\" \")\n    words_prime = []\n    prime_numbers\
    \ = [2,3,5,7,11,13,17,19,23,29]\n    prime_numbers_set = prime_numbers.to_set\n\
    \    prime_numbers_set.each do |prime|\n        prime_numbers_set = words_prime\
    \ << words[prime]\n    end\n    words_prime.join(' ')\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThe OP mentioned he already had a method which could get the words from\
    \ a sentence, just needed to know how to get the length of a word. This is the\
    \ method I used - `def word_length(word)\n        word = word.strip\n        word\
    \ = word.downcase\n        word = word.gsub(/[aeiou]/, '')\n        word = word.gsub(/[,.;]/,\
    \ ' ')\n        word.split(' ').length\n    end`\n<|/ c |>\n<| c |>\n: I didn't\
    \ say you were wrong about your method (it worked when I tested it). Rather, I\
    \ said that the question seemed quite open to interpretation at first. Rather\
    \ than assuming that everyone knew the exact problem, a better way to approach\
    \ the problem would have been to state the problem precisely and provide sample\
    \ input and output for the most common cases. If the OP was able to do that, I\
    \ think they would have had a chance to understand why your method didn't work\
    \ as intended, which would have made it easier to fix the problem.\n<|/ c |>\n\
    <| c |>\nI fully agree with you on that, but if the OP states he already has a\
    \ working method for a method that gets word lengths, then why would you add an\
    \ extra method to solve the problem?\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ result = ''\n  for i in sentence.split(//)\n    if i.length == 1 && !i.match(/[aeiou]/)\n\
    \      result += i\n    end\n  end\n  return result\nend", "  word = sentence.split('\
    \ ')\n  result = []\n  length.call(word, result)\n  return result.join(' ')\n\
    end", "    sentence.gsub(\" \", \"\").split(\"\").each do |word|\n        result\
    \ << (prime ? word : nil)\n    end\n    result.join(\" \")\nend\n</code>\nAs soon\
    \ as you see a space in the input string, you have to remove it and split the\
    \ remaining input into words, then check if the length of the words is prime or\
    \ not and finally join them back together to form the output.\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nThere are many ways to approach this problem. \nMy first\
    \ approach would be a more naive brute-force approach: Iterate over all possible\
    \ length combinations (starting at length 2) and test whether they are prime or\
    \ not. If so, then print the combination as your answer. \n<code>", "  # Your\
    \ code here\n  words_in_sentence_dict = {}\n  sentence = \"#{sentence}\"\n  sentence\
    \ = sentence.split(\" \")\n  for i in 1..sentence.length\n    if sentence[i].to_s.length\
    \ == i\n      words_in_sentence_dict[i.to_s] = sentence[i].to_s\n    end\n  end\n\
    \  string = \"\"\n  for i in 1..words_in_sentence_dict.length\n    string += words_in_sentence_dict[i].to_s\
    \ + \" \"\n  end\n  string\nend", "  count = 0\n  new_sentence = \"\"\n  new_sentence\
    \ = sentence\n  words = new_sentence.split(\" \") #Splits sentence into a list\
    \ of words (separated by spaces)\n  words.each do |word| #Iterates through the\
    \ list of words\n    if word.to_i.is_prime? #Checks if the word is an integer\
    \ and is prime\n      count += 1\n    end\n  end\n  new_sentence = count + words.join(\"\
    \ \") #Concatenates the count of prime numbers and the list of words\n  new_sentence.chomp!.downcase!\n\
    \  new_sentence\nend\n</code>\n<|/ a tags=primes,ruby |>\n<| c |>\nThis question\
    \ was already asked in [this topic](https://stackoverflow.com/questions/5450473/efficient-algorithm-for-n-number-of-primes).\
    \ Just because there is a similar algorithm to calculate the primes does not mean\
    \ there will be an easy solution to solve the question. Also, the problem asks\
    \ for *one* solution, not a few solutions, which is what the other question asks\
    \ for.\n<|/ c |>\n<| c |>\nThis question was asked in CS SE. That's why you found\
    \ the similar problem and solution on the other SO topic. I am also learning Ruby\
    \ and I don't want to do some copy-pasting just to get some hint. :)\n<|/ c |>\n\
    <| a tags=primes,ruby |>\n<code>", "  strs = sentence.split(\" \")\n  strs.map!(&:capitalize)\n\
    \  strs.map { |str| str.split(//).map(&:to_i).to_a.reduce(&:+)==str.size? str\
    \ : nil }.join(\" \")\nend", "  words_in_sentence.answer = []\n  words_in_sentence.answer\
    \ = sentence.split.uniq\n  words_in_sentence.answer\nend", "  count = 0\n  result\
    \ = ''\n  for i in sentence\n    if chars.include?(i)\n      count += 1 \n   \
    \   result << i\n    end\n  end\n  result = result.reverse if count % 2 != 0\n\
    \  result\nend", "    arr = sentence.split(' ')\n    sorted_arr = arr.sort\n \
    \   prime_arr = sorted_arr.take_while{ |x| x.is_prime? }\n    prime_arr.join(\"\
    \ \")\nend", "  words = []\n  split_sentence = sentence.split(\" \")\n  split_sentence.each\
    \ do |word|\n    word = word.downcase\n    if word.length == 2 && word.include?(\"\
    a\")\n      words.push(word)\n    end\n  end\n  words.sort!\n  new_words = []\n\
    \  words.each do |word|\n    new_words << word\n  end\n  new_words.join(\" \"\
    )\nend", "    # Your code here\n    words = []\n    count = 0\n    for i in sentence.split(\"\
    \ \")\n        if i.length % 2 == 0\n            count += 1\n            words.push\
    \ i\n    return words.join(\" \")\nend\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"\
    This is a test\")\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"lets\
    \ go for swimming\")\n</cell>\n<code language=julia-1.0>", "    # Your code here\n\
    \    i = 0\n    ans = \"\"\n    while i < len(sentence)\n        words = sentence[i].split()\n\
    \        i += 1\n        prime_number = 0\n        for word in words\n       \
    \     if word != \"\"\n                prime_number += 1\n        end\n      \
    \  if prime_number == 0\n            ans += sentence[i]\n            i += 1\n\
    \        end\n    end\n    return ans\nend", "  return sentence.split(\" \").select{|word|\
    \ word =~ /^\\p{Lu}$/}.sort.uniq.join(\" \")\nend\n</code>\n<|/ a dscore=3 tags=ruby,regex\
    \ |>\n<| c |>\nThank you for your reply, but I think your solution doesn't work\
    \ well for words starting with digits, it returns \"34\" instead of \"345 67\"\
    . I've edited my post and added the constraint of digit words in the beginning\
    \ of the sentence.\n<|/ c |>\n<| a tags=ruby,regex |>\nYour problem is probably\
    \ that the regex you gave is matching \"12345\" instead of \"1234567\".\nYou could\
    \ use a negative lookahead to make sure you do not match \"1234567\" and then\
    \ a negative lookbehind to make sure you do not match \"12345\":\n<code>\n/(^|[^0-9])12345(?!$|[^0-9])/i\n\
    </code>\nNote that you would need some special handling for \"1234567\" because\
    \ this would also match \"12345670\".\n<|/ a dscore=2 |>\n<| c |>\nI used a variation\
    \ of your solution. `(^|[^0-9])12345(?!$|[^0-9])` It didn't work well for words\
    \ starting with digits and also for words ending with a digit.\n<|/ c |>\n<| c\
    \ |>\nYes, I agree that my solution is more general, which was why I added it\
    \ as a comment.  But I did not test it with your additional constraint.\n<|/ c\
    \ |>\n<| c |>\nThe regex I gave will match \"1234567\" but not \"12345\" because\
    \ a negative lookahead of \"1234567\" will match the pattern and make the match\
    \ fail and a negative lookbehind of \"12345\" will make the match fail and thus\
    \ you do not get \"345\" but \"345\".\n<|/ c |>\n<| c |>\nRight, but this fails\
    \ for \"345 67\", so it should return \"345\".\n<|/ c |>\n<| c |>\n\"345 67\"\
    \ has two spaces between the 3 and 4.  How would you handle that?\n<|/ c |>\n\
    <| a |>\n<code>\ns = \"This is  a test 123\"", "    # Fill this in.\n    # Return\
    \ the solution\nend\n</cell>\n<text>\nTEST CASES\nTest.describe(\"Example 1 from\
    \ above\")\nTest.it(\"should return the string \\\"is\\\" when given \\\"This\
    \ is a test\\\"\")\nTest.it(\"should return the string \\\"go for swimming\\\"\
    \ when given \\\"lets go for swimming\\\"\")", "    primes = []\n    words = sentence.split(\"\
    \ \").map(&:strip)\n    words.each_index do |i|\n        if primes.include?(words.length)\n\
    \            primes << words.length\n            break\n        end\n        primes.push(words[i].length)\n\
    \    end\n    primes.uniq\nend", "  sentence.split(' ').inject({}) do |prime_words,\
    \ word|\n    prime_words[word] = true\n    prime_words\n  end\nend", "    str_len\
    \ = sentence.length\n    int_arr = str_len.to_i\n    primes = Prime.primes(int_arr)\n\
    \    words = []\n    str_arr = sentence.to_s.split(' ').map &:to_i\n    str_arr.each\
    \ do |word|\n      word = str_arr[word]\n      primes.each do |n|\n        if\
    \ word % n == 0\n          words.push(n)\n          break\n        end\n     \
    \ end\n    end\n    words.sort.join\nend", "    sentence.split(' ').each do |word|\n\
    \        next if word.empty?\n        word = word.chars.reduce(:+).to_i\n    \
    \    break word if prime word\n    end\nend\n</cell>\n<text>\n15. Write a function\
    \ that returns true if the word occurs in the given word sequence in a string\
    \ sequence (a list of strings).", "  # initialize an array to store the result\n\
    \  result = \"\"\n  \n  # get the length of the sentence\n  sentence_length =\
    \ get_sentence_length(sentence)\n  \n  # iterate through each word in the sentence\n\
    \  for word in sentence.split(' ')\n    \n    # if the word is a prime number,\n\
    \    if is_prime_number(word)\n      \n      # add the word to the result\n  \
    \    result = result + \" \" + word\n      \n  # return the result\n  result\n\
    end", "  words = sentence.split(' ')\n  result = \"\"\n  result.concat(words[1])\n\
    \  result.concat(words[2])\n  result.concat(words[3])\n  result.concat(words[4])\n\
    \  result.concat(words[5])\n  return result\nend\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nThis doesn't handle non-prime numbers of words.\n<|/ c |>\n<| a\
    \ dscore=0 tags=string,ruby |>\nThe best way I could think of to do this would\
    \ be to use recursion.\n<code>", "  str_words = sentence.split(' ')\n  str_words.each\
    \ { |word| return word if word.length == 1 && word.upcase.gsub(/[^A-Z]/, '').to_s.length\
    \ == 1 }\n  str_words.each { |word| return word if word.length == 2 && word.upcase.gsub(/[^A-Z]/,\
    \ '').to_s.length == 2 }\n  str_words.each { |word| return word if word.length\
    \ == 3 && word.upcase.gsub(/[^A-Z]/, '').to_s.length == 3 }\n  str_words.each\
    \ { |word| return word if word.length == 4 && word.upcase.gsub(/[^A-Z]/, '').to_s.length\
    \ == 4 }\n  str_words.each { |word| return word if word.length == 5 && word.upcase.gsub(/[^A-Z]/,\
    \ '').to_s.length == 5 }\n  str_words.each { |word| return word if word.length\
    \ == 6 && word.upcase.gsub(/[^A-Z]/, '').to_s.length == 6 }\n  str_words.each\
    \ { |word| return word if word.length == 7 && word.upcase.gsub(/[^A-Z]/, '').to_s.length\
    \ == 7 }\n  str_words.each { |word| return word if word.length == 8 && word.upcase.gsub(/[^A-Z]/,\
    \ '').to_s.length == 8 }\n  str_words.each { |word| return word if word.length\
    \ == 9 && word.upcase.gsub(/[^A-Z]/, '').to_s.length == 8 }\n  str_words.each\
    \ { |word| return word if word.length == 10 && word.upcase.gsub(/[^A-Z]/, '').to_s.length\
    \ == 10 }\n  str_words.each { |word| return word if word.length == 11 && word.upcase.gsub(/[^A-Z]/,\
    \ '').to_s.length >= 11 }\n  str_words.each { |word| return word if word.length\
    \ == 12 && word.upcase.gsub(/[^A-Z]/, '').to_s.length == 12 }\n  str_words.each\
    \ { |word| return word if word.length == 13 && word.upcase.gsub(/[^A-Z]/, '').to_s.length\
    \ == 13 }\n  str_words.each { |word| return word if word.length == 14 && word.upcase.gsub(/[^A-Z]/,\
    \ '').to_s.length == 14 }\n  str_words.each { |word| return word if word.length\
    \ == 15 && word.upcase.gsub(/[^A-Z]/, '').to_s.length == 15 }\n  str_words.each\
    \ { |word| return word if word.length == 16 && word.upcase.gsub(/[^A-Z]/, '').to_s.length\
    \ == 16 ", "  new_sentence = sentence\n  prime_lengths.each { |p|\n    if new_sentence.include?(p.first)\n\
    \      new_sentence = new_sentence.replace(p.first, \"\")\n    end\n  }\n  new_sentence\
    \ = new_sentence.split(\" \")\n  new_sentence = sorted_array(new_sentence)\n \
    \ new_sentence = prime_order(new_sentence)\n  new_sentence.join(\" \")\nend",
  "    # write your code here\n    words = []\n    chars = sentence.split(//).map(&:to_i)\n\
    \    chars.each { |c|\n        chars.each { |c2|\n            if (c * c2) <= c\
    \ && c * c <= c2 && c <= c2\n                words.push(c)\n                break\n\
    \            end\n        }\n    }\n    return words.join(\" \")\nend", "    #\
    \ ...\nend", "  sentence.split(' ').each do |word|\n    return word if prime?(word.length)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\nWhile I understand that\
    \ this isn't a solution to the question asked (which is apparently about factors),\
    \ this answer is much more comprehensive and informative than any other answer\
    \ given in this thread that I have seen.\n<|/ c |>\n<| c |>\nThis is not a solution\
    \ to the question asked. This is an explanation of how to solve a specific problem.\
    \ This solution is very inefficient, though - it splits up the sentence into words\
    \ and then loops over all words to check if they are a prime number. He wants\
    \ a more efficient approach. He should be able to do this by himself.\n<|/ c |>\n\
    <| c |>\nWhile I agree with that sentiment, I am afraid to comment on why a solution\
    \ is inefficient. Certainly my method is *not* inefficient since it uses only\
    \ a fraction of the time it would take to solve the problem as presented, and\
    \ that's very small compared to many other methods. It's also not slower than\
    \ any proposed solution in most programming languages. I would be concerned about\
    \ any approach that takes significant time to solve that takes significant time\
    \ to find the answer.\n<|/ c |>\n<| c |>\n, agreed. I just wanted to make sure\
    \ I wasn't missing something here.\n<|/ c |>\n<| c |>\n, you're absolutely right\
    \ that it's not a solution to the question asked. I was just commenting on the\
    \ fact that you're solution does not solve the question asked. Also, since I wrote\
    \ this answer before I noticed the question changed, I thought it worth mentioning\
    \ that you had made a mistake in the second solution. The second solution should\
    \ be `words_in_sentence([word])`. I also noticed that your solution was using\
    \ an assignment statement (`=`) instead of a comparison operator (`==`).\n<|/\
    \ c |>\n<| a dscore=3 tags=ruby,primes |>\n<code>", "    length_of_words = []\n\
    \    primes = []\n    string_of_words = []\n    words = sentence.split(' ')\n\
    \    string_of_words = ''\n    length_of_words = [len(word) for word in words]\n\
    \    length_of_words.sort()\n    for word in words:\n        prime = True\n  \
    \      for n in range(1,len(length_of_words)):\n            if length_of_words[n]\
    \ < len(word):\n                if length_of_words[n] == len(word):\n        \
    \            if n == length_of_words.index(len(word)):\n                     \
    \   prime = False\n                if length_of_words[n] == len(word):\n     \
    \               if n == length_of_words.index(len(word)):\n                  \
    \      prime = False\n                    break\n            if prime:\n     \
    \           primes.append(n)\n                break\n    return string_of_words\n\
    </cell>\n<text>\nLet's test our function", "  # Your code here\n  words = sentence.split(\"\
    \ \")\n  primes = []\n  index = 0\n  prime_words = []\n  while index < len(words):\n\
    \      prime = true\n      count = 0\n      for word in words:\n        prime\
    \ = prime and word.count(words[index]) == 1 and word not in prime_words\n    \
    \    if prime and word not in prime_words:\n          count += word.count(words[index])\n\
    \      if prime and count > 2:\n        primes.append(count)\n        prime_words.append(words[index])\n\
    \      index += 1\n  return \" \".join(prime_words)", "  sentence.split.each do\
    \ |word|\n    word = word.length.to_s\n    word += 1 if word.length % 2 == 1\n\
    \  end\n  return sentence\nend", "    sentence.split(\" \").collect do |word|\
    \ \n        word.to_s.length.odd? ? word : nil\n    end.join(\" \")\nend", " \
    \   words = sentence.split(' ')\n    words_in_words = []\n    words.each do |word|\n\
    \      words_in_words << word\n    end\n    words_in_words.uniq!\n    words_in_words.sort.reverse!\n\
    \    words_in_words.each do |word|\n      if word != words_in_words.last\n   \
    \     if word.to_s.chars.uniq.size == 1\n          words_in_words.delete(word)\n\
    \        end\n      end\n    end\n    words_in_words.uniq!\n    words_in_words.sort.reverse!\n\
    \    words_in_words.join(' ')\nend\n</cell>\n<text>\nQ4. Longest Word", "  # initialize\
    \ your result string here\n  result = \"\"\n  # iterate through each word in the\
    \ given sentence\n  sentence.split(' ').each do |word|\n    # check if each word\
    \ has length <= 2\n    if word.size <= 2\n      result << word\n    end\n  end\n\
    \  # return your result string\n  return result\nend", "    return sentence.split.join(Array.new(2).each.with_object([])\
    \ {|s, arr|\n        arr << s[0] if arr.empty? || arr.inject{|acc, c| acc + c}\
    \ > s.inject(0) {|acc, c| acc + c.downcase}\n    }).downcase.split.uniq.sort\n\
    end", "    # Write your code here.\n    return nil\nend", "  prime = []\n  sentence.split('\
    \ ').each do |word|\n    prime = PrimeWords.prime_word(word)\n  end\n  sentence.split('\
    \ ').sort.uniq.join(' ')\nend", "    sentence.split.to_enum.select {|x| is_prime?(x)}.join(\"\
    \ \")\nend", "  sentence = sentence.split(\" \")\n  sentence = sentence.map! {|x|\
    \ x.chars.join(\"\")}\n  sentence.length.prime_factor!\n  sentence\nend", "  letters\
    \ = []\n  index = 0\n  while index < sentence.length\n    letter = sentence[index]\n\
    \    index = index + 1\n    if letter !~ /[a-z]/\n      break\n    letters <<\
    \ letter\n  end\n  letters.uniq\nend", "  strs = sentence.split(\" \")\n  strs.length.each\
    \ { |i| return i if i.prime? }\nend", "  sentence_array = sentence.split(\" \"\
    )\n  sentence_array.sort!\n  result = ''\n  i = 1\n  while i < sentence_array.size\n\
    \    word_to_add = sentence_array[i-1]\n    if !is_prime(word_to_add.size)\n \
    \     result << word_to_add\n      i += 1\n    else\n      result << \" \" <<\
    \ word_to_add\n      i += 1\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=algorithm,ruby,primes\
    \ |>\n<| c |>\nNice solution (+1). The only problem with this solution is that\
    \ `is_prime` would have to be called 100*100 times which would make it unusable.\
    \ Also, it would be better to cache the primes instead of checking each number\
    \ on its own like that.\n<|/ c |>\n<| c |>\nYes, that is what I am looking for.\
    \ But, since you wrote the algorithm, can you please explain me what the algorithm\
    \ is? I mean what does it do and how it is used? And also, can you please provide\
    \ me the Ruby code for the same?\n<|/ c |>\n<| c |>\nI added some comments to\
    \ explain things. I used the Sieve of Eratosthenes algorithm. There are other\
    \ approaches that could be used but I think this is the best one since it's very\
    \ short, easy to understand and easy to implement.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  sentence.split\n  new_sentence = \"\"\n  sorted_words = sentence.split('\
    \ ')\n  sorted_words.sort\n  sorted_words.each_index.select do |index|\n    new_sentence\
    \ << sorted_words[index] if sorted_words[index] % 2 == 0\n  end\n  new_sentence\n\
    end\n</cell>\n<cell>", "  # Split sentence into words\n  words = sentence.split(\"\
    \ \").sort\n  words_in_sentence = []\n  # For each word\n  words.each do |word|\n\
    \    # If the word is a prime.\n    next if prime?(word.length)\n    # Add word\
    \ to list of words\n    words_in_sentence << word\n  end\n  # Join the words in\
    \ sentence\n  words_in_sentence.join.strip\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI'm a beginner at Ruby, so I don't know how to do this, but I will try\
    \ it out. Thanks :)\n<|/ c |>\n<| c |>\nThis code is pretty much straightforward,\
    \ I suggest you just try to understand it and modify it according to your needs.\
    \ The only thing you need to do is copy/paste the code and run it (I assume you're\
    \ on rails) and you should be good to go. Also keep in mind that this code is\
    \ not optimized in any way. It's the most straightforward way I can think of right\
    \ now.\n<|/ c |>\n<| c |>\nThanks for your help, I understand it a lot better\
    \ now. Yeah, I haven't learned anything about arrays or hashes yet, so I still\
    \ need to do some reading before I can use this. I was thinking of maybe implementing\
    \ it in Python, since I'm more familiar with that language.\n<|/ c |>\n<| c |>\n\
    You're welcome! Just keep in mind that if you have time I'd love to hear your\
    \ thoughts on this problem. I'm sure a more experienced Ruby coder will have a\
    \ better solution than mine :)\n<|/ c |>\n<| c |>\nThank you, I think I understand\
    \ it better now :)\n<|/ c |>\n<| a dscore=0 |>\nYou can try this :\n<code>\nsentence\
    \ = \"This is a test sentence.\"", "  new = \"\"\n  (0..(sentence.length)).step(2).each\
    \ do |i|\n    new += sentence[i]\n  end\n  new\nend", "    # Write your code here\n\
    \    vowels = \"aeiou\"\n    numbers = \"1234567890\"\n    sorted_list = sorted(sentence)\n\
    \    \n    result = []\n    \n    for word in sorted_list:\n        if word[0]\
    \ in vowels:\n            if word[len(word) - 1] in vowels:\n                result.append(\"\
    is\")\n            else:\n                result.append(\"are\")\n        else:\n\
    \            if word[len(word) - 1] in vowels:\n                result.append(\"\
    was\")\n            else:\n                result.append(\"were\")\n        \n\
    \    for word in sorted_list:\n        if word[0] in numbers:\n            if\
    \ word[len(word) - 1] in numbers:\n                result.append(word)\n     \
    \       else:\n                result.append(\"and\")\n        else:\n       \
    \     if word[len(word) - 1] in numbers:\n                result.append(word)\n\
    \            else:\n                result.append(\"and\")\n        \n    return\
    \ ' '.join(result)", "  arr = sentence.split.to_a\n  arr.uniq.map do |item|\n\
    \    item.length\n  end.reduce(:+).prime?\nend", "    words = sentence.split(\"\
    \ \")\n    words_length = len(words)\n    string = \"\"\n    primes = []", " \
    \ sentence = sentence.split\n  result = ''\n  primes = []\n  n = 2\n  i = 2\n\
    \  while i < n do\n    prime? << i\n  end\n  while i < n do\n    if sentence[i].length\
    \ == primes[i] then\n      result << sentence[i]\n    end\n    i += 1\n  end\n\
    \  result\nend", "  puts \"#{sentence.split(' ').map{ |e| e.split('').reduce(:+).to_i\
    \ if e.is_a?(String) }.uniq.sort}\"\nend", "    string1 = \"\\\"#{sentence}\\\"\
    \".gsub(/\\\"/, '')\n    words = []\n    word = \"\"\n    count = 0\n    # Loops\
    \ through characters in string1\n    for i in string1\n        if i.is_alpha?\n\
    \            word += i\n        else\n            words.push(word)\n         \
    \   word = \"\"\n            count = 0\n        end\n    end\n    words.push(word)\n\
    \    words.sort!\n    words.each do |w|\n        if !w.prime? && !w.prime?\n \
    \           count += w.length\n        end\n    end\n    return words.join(\"\
    \ \")\nend", "  puts \"You are given a string representing a sentence,\" \n  puts\
    \ \"the sentence contains some words separated by a space,\" \n  puts \"and you\
    \ have to return a string that contains the words from the original sentence,\"\
    \ \n  puts \"whose lengths are prime numbers,\" \n  puts \"the order of the words\
    \ in the new string should be the same as the original one.\"\n  puts \"Example\
    \ 1:\"\n  puts \"#{sentence}\"\n  puts \"#{'is'}\"\n  puts \"Example 2:\"\n  puts\
    \ \"#{sentence}\"\n  puts \"#{'go'} for\"\nend\n</code>\n<|/ q dscore=1 tags=ruby,string\
    \ |>\n<| c |>\nYour code only works if the first and last words are the same length.\
    \ If you try the string \"foo bar\" you'll get an IndexError because the `index`\
    \ method returns nil if it can't find the string you're looking for.  You'll want\
    \ to use the `rindex` method instead. Have you tried anything yet? There are many\
    \ answers on this site that demonstrate how to do things like this.\n<|/ c |>\n\
    <| a dscore=2 |>\nTry this simple code :\n<code>", "    str_words = sentence.split(\"\
    \ \")\n    str_words.sort.uniq\nend", "    arr = []\n    for w in sentence.split\n\
    \        if w.chars.all? {|c| c >= 'a' && c <= 'z'}\n            arr.push w\n\
    \        end\n    end\n    arr.sort!\n    arr.uniq\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "    str = sentence.split(\"\
    \ \").sort\n    return str.join(\" \")\nend", '  return if sentence.empty? then
    return end', "    # Your code here\n    new_sentence = \"\"\n    chars = \"\"\n\
    \    str_arr = sentence.split(\" \") \n    length = len(str_arr)\n    \n    \n\
    \    for str in str_arr:\n        for char in str:\n            chars += char\n\
    \        if int(chars) % 2 == 0:\n            new_sentence += str\n          \
    \  \n    return new_sentence", "  # first, we create a blank string and append\
    \ the words from sentence to it\n  new = \"\"\n  new_sentence = sentence\n  while\
    \ new_sentence != \"\"\n    first = new_sentence.index(\" \")\n    last = new_sentence.index(\"\
    \ \")\n    if first != last and new_sentence[first - 1] == \" \" and new_sentence[last\
    \ + 1] == \" \"\n      first = last + 1\n      last = new_sentence.index(\" \"\
    )\n      new << new_sentence[first..last]\n      new_sentence = new_sentence[first..last]\n\
    \    else\n      new << new_sentence[first..last]\n      new_sentence = new_sentence[first..last]\n\
    \    end\n  end\n  return new\nend", "  # Your code here\n  return nil\nend",
  "  sentence.scan(/\\w+/).map{|word| word.length}.uniq == sentence.inject(:+)\nend",
  "  result = \"\"\n  words_in_sentence = sentence.split(\" \")\n  words_in_sentence.length.each\
    \ do |x|\n    result += words_in_sentence[x] + \" \"\n  end\n  result\nend", " \
    \   # Your code here\n    arr = sentence.split(\" \").to_a\n    arr.select {|s|\
    \ s[0..1] == \"a\"}\nend", "    words = sentence.split(\" \")\n    primes = prime_number(words.length)\n\
    \    words = words.map{|x| x == words[primes.index(primes.index(x))] ? x : nil}\n\
    \    return words.compact.join(\" \")\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    A few notes, first, the word \"prime\" is generally a synonym of \"primes\". Secondly,\
    \ in the second code example, I think it should be `primes.index(x)` instead of\
    \ `primes.index[primes.index(x)]`. Third, this doesn't actually answer the question\
    \ asked. I'm afraid it's not very helpful in an actual competition setting, though\
    \ it may have been helpful in an interview situation.\n<|/ c |>\n<| c |>\nOh,\
    \ I totally agree, `primes` and `prime` are similar words, but in this case I\
    \ prefer to refer to them as one. `primes` is the array with the prime numbers\
    \ and it could be used to find out if a number is prime or not (by comparing it\
    \ with another number). I'll correct my answer accordingly.\n<|/ c |>\n<| c |>\n\
    Also, for those interested in how I came up with the algorithm: I first thought\
    \ to create a hash table of prime numbers (i.e. `primes`, `hash = {primes.first\
    \ => 1, primes.rest => 1}`). Then, I just iterate over the array `words` from\
    \ `0` to `words.length`, checking `hash[words[i]]` when `i == words.length`, which\
    \ will tell me if the number is prime or not.\n<|/ c |>\n<| a |>\nI agree with\
    \ that you should use primes instead of prime or any such word. However, if you\
    \ still want this problem to be solved using 'primes', here it is.\nFirst we need\
    \ to find out all the prime numbers in the input string 'test'. So, for that,\
    \ we will use prime numbers calculator at http://www.codewars.com/kata/prime-number-calculator.\n\
    We will first take out each word in the input string and then divide each number\
    \ in the word using prime numbers calculator. \nFor example, if our input string\
    \ is 'test', we will divide 'test' by 2 and 2 and get 2.2 which is our prime number.\
    \ Now we will find out if the input string contains any word which is a multiple\
    \ of 2 in the prime numbers calculator.\n<code>", "    word_list = sentence.split(\"\
    \ \").sort\n    return word_list.join(\" \")\nend\n\"\"\"", "    \n    sentence=sentence.split(//).reverse.join//\n\
    \    sentence=sentence.downcase//\n    \n    hash={}\n    \n    for i in sentence\n\
    \        hash[i]=hash.get(i,0)+1\n    \n    for i in hash\n        if hash[i]%2==0\n\
    \            new=sentence.slice(0,i)\n            new=new.join(\" \")\n      \
    \      new=new.upcase//\n            return new\n    end\nend", "  return\nend\n\
    \"\"\"", "  sentence.split(\" \").inject([]) do |list, word|\n    list.each do\
    \ |word_length|\n      return word if (word_length..word_length+1).all? { |num|\
    \ num.odd? }\n    end\n    list\n  end.join(' ')\nend", "  sentence.split(\" \"\
    ).each do |word|\n    if PrimeWordLength.call(word.size) == true\n      puts word\n\
    \    end\n  end\nend", "    s = sentence.split(%r(\\s+))\n    s = s.map { |x|\
    \ x.split(%r(\\w+)) }\n    s = s.map { |x| x.sort.map(&:capitalize) }\n    s =\
    \ s.map { |x| x.uniq.join(' ') }\n    return s.join\nend", "    puts \"#{sentence.gsub(\"\
    \ \", \"\").split(' ').map(&:length).uniq.length} #{puts sentence.gsub(\" \",\
    \ \"\").split(' ').map(&:length).uniq.sort {|x, y| y<=>x } }\"\nend", "  new_sentence\
    \ = \"\"\n  i = 0\n  while i < sentence.length\n    if sentence.slice!(i).length\
    \ == 2\n      i += 2\n      next\n    end\n    new_sentence << sentence.slice!(i)\n\
    \    i += 1\n  end\n  return new_sentence\nend", "    str_split = sentence.split\
    \ \" \"\n    ret_str = \"\"\n    str_split.each do |word|\n        str_length\
    \ = word.length\n        is_prime = true\n        (str_length-1).downto(0) do\
    \ |i|\n            prime = str_length % i\n            if is_prime\n         \
    \       is_prime = (prime == 0)\n            else\n                is_prime =\
    \ (prime != 0)\n            end\n        end\n        ret_str += word\n      \
    \  if str_length % 2 == 1\n            ret_str += \" \"\n        else\n      \
    \      ret_str += \" \"\n        end\n    end\n    return ret_str\nend", "   \
    \ # Your code here\n    split_sentence = sentence.split(\" \")\n    word_list\
    \ = []\n    for word in split_sentence\n        if word_list.count(word) == 0\
    \ \n        word_list << word\n        word_list.uniq.sort\n    sentence.join(word_list)\n\
    end\n</cell>\n<code language=julia-1.3>", "  return \"not implemented\"\nend",
  "    str.split(sentence).each{|x| x.chars.each{|char| return char.to_s}.size ==\
    \ 0 }\nend", "    count = 0\n    for i in sentence.split(\" \")\n        count\
    \ += i.length\n    count = 0\n    for i in sentence.split(\" \")\n        count\
    \ += i.length\n    count\n    if count < 2\n        count\n    else \n       \
    \ sentence\nend", "  new_words = []\n  n = 2\n  while n <= 100\n    new_words.push(sentence[n])\n\
    \    n += 1\n  end\n  return new_words\nend", "    i = 0\n    str_prime = sentence.to_s\n\
    \    str_prime.length_of_prime\n    str_prime.length\n    str_prime = str_prime.split(//)\n\
    \    str_prime.length\n    while i < str_prime.length\n        if str_prime.include?(str_prime[i]).length\n\
    \            return str_prime[i]\n        i += 1\n    end\nend\n</cell>\n<cell>",
  "  sentence.split(' ').select { |e| e[/^\\d+$/] }.join.split(//)\nend", "    arr\
    \ = sentence.split\n    arr.each{|x| return x if x.to_i**2 == x.to_i**2}\nend",
  "  i = 0\n  result = []\n  while i < sentence.length\n    if i % 2 == 0\n      result.push(sentence[i])\n\
    \    i += 1\n  end\n  result\nend", "  sentence = sentence.split(' ')\n  n = sentence.length\n\
    \  result = ''\n  is_prime = true\n  for i in 1..n\n    prime = true\n    for\
    \ j in 1..i\n      if ((sentence[j] != sentence[j-1]) && (sentence[j] % i == 0))\n\
    \        prime = false\n        break\n    if is_prime\n      result << sentence[j]\n\
    \    end\n    is_prime = prime\n  end\n  result\nend", "    sentence = sentence.split(\"\
    \ \").map { |word| word.downcase }\n    prime_factors = 2.upto(Math.sqrt(sentence.size)).select\
    \ { |i| i != sentence.size }\n    prime_factors.zip(sentence).map { |factors,\
    \ word|\n        \"#{factors} #{word}\"\n    }.join(\" \")\nend", "  result =\
    \ \"\"\n  words = sentence.split.to_a\n  words.each do |word|\n    result << word\n\
    \    break if prime_number(result.length) == result.length\n  end\n  return result\n\
    end\n</cell>\n<text>\nNow we apply the function to the sentence \"This is a test\"\
    \ and we get \"is\".", "  new_sentence = \"\"\n  words = sentence.split(\" \"\
    )\n  last_prime = 0\n  new_sentence = \"\"\n  last_prime = 0\n  i = 0\n  while\
    \ i < words.length\n    if words[i].length == last_prime\n      new_sentence <<\
    \ words[i]\n      last_prime = words[i].length\n    else\n      if last_prime\
    \ != 0\n        new_sentence << \" \"\n      last_prime = 0\n      new_sentence\
    \ << words[i]\n    end\n    i += 1\n  end\n  new_sentence\nend", "  sentence =\
    \ sentence.downcase\n  words = sentence.split(' ')\n  return words.join.downcase.split(\"\
    \ \").map(&:size).inject(:+).reject(&:odd?).to_a\nend", "  words = []\n  index\
    \ = 0\n  length = sentence.length\n  while index < length\n    word = sentence.substring(index,\
    \ index+1)\n    if word.chars.count(\"\\n\") > 0\n      word = word.substring(0,(word.chars.count(\"\
    \\n\")-1))\n    words.push(word);\n    index+=1\n  end\n  primes = []\n  primes.push(2)\n\
    \  primes.push(3)\n  primes.push(5)\n  primes.push(7)\n  index = 0\n  while index\
    \ < primes.length\n    word = words.shift()\n    length = word.length\n    index\
    \ = index + 1\n    sum = 0\n    while index < length\n      sum += word.substring(index,\
    \ index+1).to_i\n      index+=1\n    end\n    primes.push(sum)\n  end\n  ret =\
    \ \"\"\n  index = 0\n  while index < primes.length\n    word = words.shift()\n\
    \    word = word.substring(0,(word.chars.count(\"\\n\") - 1))\n    ret += word\n\
    \    length = (word.length + 1)\n    index = index + 1\n  end\n  return ret\n\
    end", "    puts \"#{sentence}\"\n    puts \"#{sentence.split(' ').select {|x|\
    \ x.prime?}.join(' ')}\"\nend", "\tsentence = sentence.downcase\n\twords = sentence.split(\"\
    \ \")\n\treturn words_in_words(words)\nend", "    s = ''\n    i = 0\n    while\
    \ i < len(sentence)\n        if isPrime(sentence[i:i+1]) == true # change this\
    \ part\n            s += sentence[i:i+1]\n        i += 1\n    return s\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "  return \"a solution\"\nend", "    str.split(sentence).map(&:length).uniq.sort\n\
    end", "  new_sentence = \"\"\n  length_of_new_sentence = 0\n  temp_count = 0\n\
    \  count_of_words = 1", "  return sentence.split(' ').map{|word| word.length}.uniq.join('\
    \ ')\nend", "    # initialize a boolean variable and set it to false\n    prime_nums\
    \ = false", "  words = sentence.split\n  words.map do |word|\n    word = word.to_s\n\
    \    if word.length == 2\n      prime(word[0])\n      prime(word[1])\n      word\
    \ = word[0]+word[1]\n    elsif word.length == 3\n      prime(word[0])\n      prime(word[1])\n\
    \      prime(word[2])\n      word = word[0]+word[1]+word[2]\n    end\n    word\n\
    \  end.join(\" \")\nend", "    words = sentence.split(' ')\n    words_in_sentence\
    \ = nil\n    primes = []\n    prime_numbers = PrimeNum.prime_numbers(words.length)\n\
    \    prime_numbers.length.times do |i|\n        prime_numbers[i].times do |j|\n\
    \            if primes.include? j\n            else\n                primes.push\
    \ j\n            end\n        end\n    end\n    prime_numbers.each do |n|\n  \
    \      words_in_sentence = words_in_sentence + words[prime_numbers[n]]\n    end\n\
    \    return words_in_sentence\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c\
    \ |>\nThank you very much for your effort. But i am getting time limit exceeded\
    \ at line 13. Can you please help me out from this.\n<|/ c |>\n<| c |>\nI think\
    \ it is because i have to print all prime number in between 10. Thanks alot for\
    \ your help.\n<|/ c |>\n<| c |>\nSorry, I meant the line 14. You should probably\
    \ use an Array. Updated my answer, hope that helps!\n<|/ c |>\n<| c |>\nThank\
    \ you very much for your effort. But i am getting time limit exceeded at line\
    \ 14. Can you please help me out from this. I dont know where i m doing mistake.\n\
    <|/ c |>\n<| c |>\nSorry, I meant the line 14. You should probably use an Array.\
    \ Updated my answer, hope that helps!\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n\
    <code>", "    # Your code here\n    result = \"\"\n    sentence = sentence.split(\"\
    \ \")\n    length = len(sentence)\n    prime = 0\n    for i in range(length):\n\
    \        word = sentence[i]\n        if word[0].isalpha():\n            prime\
    \ += 1\n        if prime:\n            result += \" \" + word\n            prime\
    \ = 0\n    return result", "  arr = sentence.split\n  result = \"\"\n  for i in\
    \ arr\n    if i % 2 == 0\n      result += i\n    end\n  end\n  return result\n\
    end", '  new_words = []', "    sentence = sentence.strip.downcase\n    word_arr\
    \ = sentence.split(\" \")\n    \n    prime_words = []\n    \n    prime_words.push(word_arr[1])\n\
    \    \n    # Go through each word in the array\n    word_arr.each do |word|\n\
    \        # If the word is not prime\n        if !(word.to_i).prime?\n        \
    \    # Push the word into the prime_words array\n            prime_words.push(word)\n\
    \        end\n    end\n    \n    prime_words.each do |word|\n        # join the\
    \ string\n        sentence = sentence + \" \" + word\n    end\n    \n    return\
    \ sentence\nend\n</cell>\n<text>\n\U0001F522 Exercise: What is the expected output\
    \ of words_in_sentence(\"A quick brown fox jumps over the lazy dog\")?", "  str_to_return\
    \ = \"\"\n  words = sentence.split(' ')\n  words.each do |word|\n    if prime(word.length)\
    \ == word.length\n      str_to_return << word\n    end\n  end\n  str_to_return\n\
    end", "    return sentence.split(' ').map{|s| s.split(//).map{|w| w[1]}.select{|w|\
    \ w.length == w[1]}.inject(:+)}.reduce(:+)\nend\n</cell>\n<text>\n4. Factorial\n\
    A factorial is a number multiplied by itself, reversed, starting from 1. That\
    \ means, if you multiply factorial(2) with itself twice, you'll get factorial(2),\
    \ and if you multiply factorial(3) with itself, you'll get factorial(3) * factorial(2).",
  "    # Write your code here\n    prime = Prime(sentence.length)\n    prime_array\
    \ = Prime.to_array(sentence)\n    new_string = ''\n    i = 0\n    while i < sentence.length\n\
    \        if prime_array[i] == true then\n            new_string += sentence[i]\n\
    \            i += 1\n        else\n            i += 1\n        end\n    end\n\
    \    return new_string\nend", "  sentence = sentence.split(//).map(&:downcase)\n\
    \  sentence.length.prime?\n  sentence = sentence.uniq.sort\n  sentence.join\n\
    end", "  sentence = sentence.upcase\n  word_array = sentence.split\n  word_array.each\
    \ do |w|\n    next if w.length != 1\n    next if w.split('').inject(true) do |acc,\
    \ _| acc && w != _; end\n    puts w\n  end\nend", "  new_list = []\n  length =\
    \ nil", "    \n    prime_words = []\n    \n    if sentence == nil\n        return\
    \ \"nil\"\n    end\n    \n    words = sentence.split(\" \")\n    \n    for word\
    \ in words\n        if prime_words.length < word.length\n            prime_words.push(word)\n\
    \        end\n    end\n    \n    prime_words.sort()\n    \n    return prime_words.join(\"\
    \ \")\nend", "  return sentence.split(' ').map{|word| word.split(//).filter{|c|\
    \ c =~ /^[aeiou]$/}.length.prime?}.join(' ')\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=ruby,primes,algorithm |>\nAnother way using enumerator and Array#partition\n\
    <code>\nstr = \"lets go for swimming\"", "    words = sentence.split(\" \")\n\
    \    words.map!{|s| s.to_i}\n    string = \"\"\n    words.each{|word|\n      \
    \  if ((word.length % 2) == 0)\n            string += word + \" \"\n        end\n\
    \    }\n    string\nend", "  words = sentence.split(\" \")\n  n = words.length\n\
    \  result = \"\"\n  i = 0\n  while i < n\n    while n % i == 0\n      i += 2\n\
    \    result = result + \" \" + words[i]\n    n /= i\n  end\n  result\nend", " \
    \   # Write your code here\n    str_arr = sentence.split(\" \") #split the sentence\
    \ into a list of words\n    prime_list=[]\n    for i in str_arr:\n        if (len(i)==2)\
    \ and (i[0]!='s') and (i[0]!='a') and (i[0]!='o'):\n            prime_list.append(i[0])\n\
    \        else:\n            break\n    word_list = []\n    for i in str_arr:\n\
    \        if i not in prime_list:\n            word_list.append(i)\n    return\
    \ \" \".join(word_list)", "  str1 = sentence.strip.downcase\n  str1.split.each\
    \ do |x|\n    x.split(' ').each do |y|\n      str2 = y\n      if y.to_i.prime?\n\
    \        puts str2.strip\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nIt works, thanks, but is there a way to do it without using the\
    \ split method ? Because the split method uses too much memory and crashes my\
    \ program whenever i run it\n<|/ c |>\n<| c |>\nI changed the code. Maybe this\
    \ can help you.\n<|/ c |>\n<| c |>\nThe code looks so much more complicated but\
    \ i really like it. Thanks !\n<|/ c |>\n<| c |>\nYou are welcome. Happy coding!\n\
    <|/ c |>\n<| a |>\nYou can create your primes array:\n<code>\nprimes = Primes.new.primes\n\
    </code>\nAnd then remove all non-primes from your string:\n<code>\nprimes.each\
    \ { |x| str1.delete(x) }\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\n`Primes`\
    \ uses `prime_numbers` in it's implementation. `prime_numbers` will give you an\
    \ `Array` of primes up to `1000`.\n<|/ c |>\n<| a |>\nYour first attempt fails\
    \ because the method String#split takes one or two arguments, not three.\n<code>\n\
    2.2.2 :002 > \"asdasdf\".split('a','s','d','f')\nArgumentError: wrong number of\
    \ arguments (given 3, expected 2)\n        from (irb):2:in `split'\n        from\
    \ (irb):2\n        from C:/Ruby22-x64/bin/irb:12:in `<main>'\n</code>\nYour second\
    \ attempt fails because String#split doesn't return a string. String#split returns\
    \ a Enumerable. Your attempt to iterate over the enumerable returned by the String#split\
    \ method fails, because Enumerable#each yields objects, not strings.\n<code>\n\
    2.2.2 :003 > \"asdasdf\".split('a','s','d','f').each { |x| p x }", "  sentence\
    \ = sentence.downcase\n  sentence = sentence.split.map(&:to_i)\n  sentence.sort.reduce(&:+).prime_division.map\
    \ { |prime| [prime, true] }.compact.first\nend", "    \n    # Your code here\n\
    \    res = []\n    i = 0\n    while i < sentence.length\n        res << sentence.slice(i,\
    \ i+2).split(' ').each_with_index do |word, index|\n            prime_numbers\
    \ = 2\n            i = index\n            while i < word.length && prime_numbers\
    \ < word.length\n                prime_numbers << word.chars.map { |char| char.ord.prime\
    \ }.inject(:+)\n                i += 1\n            end\n        end\n       \
    \ i += 1\n    end\n    res.join(' ')\nend", "    sentence = sentence.downcase.split(\"\
    \ \")\n    words = sentence.select { |word| word.is_a? String }\n    unique_words\
    \ = []\n    unique_words.push(\"\")\n    words_with_lengths = []\n    words_with_lengths.push(\"\
    \")", "    word = nil\n    answer = nil\n    count = 0\n    if sentence == \"\"\
    \n        word = \"nil\"\n        answer = \"nil\"\n    end\n    words = sentence.split(\"\
    \ \")\n    words.each do |word|\n        if word.length % 2 == 0 && word.include?(\"\
    \ \")\n            count = word.length / 2\n            word = word[1..count.to_i]\n\
    \            answer = answer[0...answer.length-word.length-1] + word + answer[word.length..-1]\n\
    \        else\n            answer = answer[0...answer.length-word.length-1] +\
    \ word + answer[word.length..-1]\n        end\n    end\n    answer\nend\n</code>\n\
    <|/ a tags=string,ruby,algorithm |>\n<| c |>\nPlease explain what your code is\
    \ doing. Also, try to make it more Ruby like.\n<|/ c |>\n<| c |>\nWhile this code\
    \ may answer the question, providing additional context regarding how and/or why\
    \ it solves the problem would improve the answer's long-term value.\n<|/ c |>\n\
    <| c |>\nHow does this answer match the problem description? The question was\
    \ _\"Find the longest sub-sequence of words separated by spaces of a given string,\
    \ where each sub-sequence is of length greater than one.\"_. The answer only provides\
    \ an algorithm to find the longest word of a sub-sequence. Also, it does not handle\
    \ the case where an individual word is a sub-sequence itself.\n<|/ c |>\n<| c\
    \ |>\n- I think the problem is poorly worded because the OP explicitly stated\
    \ that his code was giving wrong results for some test cases. Your algorithm does\
    \ not match the problem description. It does not handle cases where a word is\
    \ a sub-sequence of itself (which is what OP explicitly stated), and it does not\
    \ find the longest word in a sub-sequence. Your algorithm should return \"nil\"\
    \ for those test cases. If you read the question carefully you will see that OP\
    \ explicitly stated that they were required to return \"nil\" in those cases.\
    \ Your algorithm does not do so.\n<|/ c |>\n<| c |>\nI added my own answer to\
    \ my question and I believe that it's an improvement. Since I am not that good\
    \ at Ruby, I will say that while it solves the problem, it does not in any way\
    \ encourage me to learn Ruby as much as I should.\n<|/ c |>\n<| a dscore=0 |>\n\
    This is the solution I came up with:\n<code>", "    \n    # Your code here\n \
    \   count = 0\n    count1 = []\n    for i in sentence.split(\" \")\n        count\
    \ = count + 1\n        if count % 2 != 0\n            count1.append(i)\n     \
    \   count = 0\n    return \" \".join(count1)\nend", "    s = sentence.split(\"\
    \ \").sort\n    (2..s.length).each { |i|\n        s[i] = s[i-1] if s[i-1].is_prime?\n\
    \    }\n    sentence.join(\" \")\nend\n</code>\n<|/ a dscore=1 tags=ruby,primes,algorithm\
    \ |>\n<| c |>\nThanks, your solution works perfectly and is the simplest to implement\
    \ for me.\n<|/ c |>\n<| a tags=ruby,primes,algorithm dscore=0 |>\n<code>", " \
    \   arr = sentence.split(\" \")\n    return arr.select { |word| is_primal?(word.length)\
    \ }.map(&:downcase).join(\" \")\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", " \
    \   # Your code here\n    if sentence == \"NULL\"\n        return \"NULL\"\n \
    \   words = []\n    for i in sentence.split(' ')\n        if i.to_s.length % 2\
    \ == 0\n            words.push(i)\n    return words\n</code>\n<|/ a |>\n<| c |>\n\
    what does \"length\" refer to?\n<|/ c |>\n<| c |>\ni just wanted to point out\
    \ that your answer is still wrong. it will return [\"asd\"] which is incorrect.\
    \ it needs to return \"asd\" because it's just checking if the length of the word\
    \ is even. your code is incorrect.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n\
    I used the following solution:\n<code>", "    words = sentence.split\n    prime_words\
    \ = []\n    prime_words_count = 0\n    prime_words_string = \"\"\n    words_in_sentence\
    \ = \"\"\n    while prime_words.length \n        prime_words_count += 1\n    \
    \    prime_words_string += \"#{prime_words_count}\"\n        prime_words_string\
    \ += \" \"\n    prime_words.push(words.shift) while words.length > 0\n       \
    \ prime_words.push(words.shift)\n    prime_words.each do |prime_word|\n      \
    \  if prime_words.count > prime_words_count\n            prime_words_string +=\
    \ \"#{prime_word}\"\n        elsif prime_words.count == prime_words_count\n  \
    \          prime_words_string += \"#{prime_word} \"\n        end\n    end\n  \
    \  words_in_sentence = prime_words_string\n    return words_in_sentence\nend",
  "  letters = sentence.split(' ')\n  \n  result = nil\n  \n  letters.each do |letter|\n\
    \    \n    if result\n      result = result + letter\n    else\n      result =\
    \ letter\n    end\n    \n  end\n  \n  return result\nend", "  sentence = sentence.to_s.split(\"\
    \ \").collect(&:to_i)\n  new_sentence = sentence.select {|i| i.prime?}\n  new_sentence.join(\"\
    \ \")\nend\n</cell>\n<code language=julia-1.5>\n@time words_in_sentence(\"lets\
    \ go for swimming\")\n</cell>\n<text>\nThe solution above works perfectly fine,\
    \ but we may do better, since we only need to check the first word and the second\
    \ word of the sentence.", "    words = sentence.split(' ')\n    primes = []\n\
    \    prime_words = []\n    prime_counter = 0\n    for word in words\n        prime_counter\
    \ = prime_counter + 1\n        if prime_counter == 2\n            prime_words.push(word)\n\
    \        elsif prime_counter == 3\n            prime_words.push(word)\n      \
    \  elsif prime_counter == 5\n            prime_words.push(word)\n        elsif\
    \ prime_counter == 7\n            prime_words.push(word)\n        elsif prime_counter\
    \ == 11\n            prime_words.push(word)\n        end\n    end\n    prime_words.join('\
    \ ')\nend\n</cell>\n<cell>", "    # Your code here\n    return 0\n    # Your solution\
    \ ends here\nend\n</cell>\n<cell>", "  str = \"\"\n  i = 0\n  while i < sentence.length\n\
    \    if checkPrime(sentence.length)\n      if sentence[i] == \" \" or sentence[i]\
    \ == \"\"\n        str += sentence[i]\n        i += 1\n      else\n        if\
    \ str.length == 0 \n          str += \" \" + sentence[i]\n        else\n     \
    \     if sentence[i-1] == \" \" \n            str += \" \" + sentence[i]\n   \
    \       else\n            if str.length != 0\n              str += \" \" + sentence[i]\n\
    \            end\n          end\n        end\n      end\n    end\n  end\n  str.rstrip\n\
    end", "  # write your code here\n  sentence.split(' ')\n  ret = ''\n  primes =\
    \ []\n  prime_words = {}\n  for i in sentence.split(' ').each_index do |i|\n \
    \   prime_words[sentence.split(' ')[i]] = true\n  end\n  sentence.split(' ').each_with_index\
    \ do |word, i|\n    if prime_words[word]\n      ret += word\n      while not primes.include?\
    \ word.length\n        ret += ' ' if i==0\n        primes << word.length\n   \
    \   end\n    end\n  end\n  return ret\nend", "  arr = sentence.split(\" \")\n\
    \  new_string = \"\"\n  primes = []\n  n = 2\n  while n < arr.length\n    prime_found\
    \ = false\n    primes.each do |prime|\n      if prime.is_a?(Integer) and prime\
    \ * n < arr.length\n        if arr[n] * n == arr.length\n          prime_found\
    \ = true\n          break\n        end\n      end\n    end\n    if prime_found\n\
    \      new_string += arr[n]\n      primes << arr[n]\n    end\n    n += 1\n  end\n\
    \  new_string.split(\" \").sort.join(\" \")\nend", "    # write your code here\n\
    \    words = sentence.split(\" \")\n    primes = prime_numbers(words)\n    return\
    \ \" \".join(words[primes])\nend", "  arr = sentence.split(\" \")\n  primes =\
    \ []\n  new_arr = []\n  prime = true\n  for i in arr\n    if i % 2 == 0\n    \
    \  prime = false\n    else\n      prime = true\n      new_arr.push(i)\n    end\n\
    \  end\n  if prime == true\n    primes.push(new_arr.length)\n  end\n  new_arr.each\
    \ do |i|\n    primes.each do |j|\n      if i == j\n        prime = false\n   \
    \     break\n      end\n    end\n  end\n  new_arr.each do |i|\n    if primes.include?\
    \ new_arr.length\n      new_arr.push(i)\n    end\n  end\n  return new_arr.join(\"\
    \ \")\nend\n</cell>\n<text>\nNow you can define your solution as a function that\
    \ returns a string and receives a string as its parameter.", "  str1=sentence.split(\"\
    \ \")\n  str2=[]\n  for i in str1\n    if i.length==2\n      str2 << i[0]+i[1]\n\
    \    end\n  end\n  return str2.join(\" \")\nend", "    str = sentence\n    prime\
    \ = []\n    i = 0\n    prime_found = false\n    while i < 100\n        if (str.charAt[i]\
    \ == 32)\n            prime_found = false\n        else\n            if (is_prime(str.charAt[i]))\n\
    \                prime_found = true\n            end\n        end\n        prime\
    \ = prime + [str.charAt[i]]\n        i = i + 1\n        if prime_found\n     \
    \       prime_found = false\n        end\n    end\n    prime = \"\"\n    i = 0\n\
    \    while i < 100\n        if prime_found\n            prime = prime + \" \"\
    \ + str.charAt[i]\n        else\n            prime = prime + str.charAt[i]\n \
    \       end\n        i = i + 1\n    end\n    return prime\nend\n</code>\n<|/ q\
    \ dscore=0 |>\n<| c |>\nWhy should it be possible for the first element to occur\
    \ in a list?\n<|/ c |>\n<| c |>\nbecause in maths there is the concept of prime\
    \ numbers. A prime number is a positive integer that has only two distinct prime\
    \ factors. That is if you have a list with one element that is prime its the same\
    \ as the first element in the list. Thats why the first element doesn't have prime\
    \ numbers and will never happen in the list.\n<|/ c |>\n<| a |>\nThe problem statement\
    \ is clear. It says", "  strs=sentence.split(\" \").map{|x| x.to_i}\n  strs.collect!{|x|\
    \ x if is_prime?(x)}.sort\n  strs\nend", "    sentence = sentence.split\n    result\
    \ = \"\"\n    prime_words = []\n    # Your code here\n    sentence = sentence.split.map!\
    \ { |word| word.downcase }\n    sentence = sentence.map { |word| word.split('\
    \ ') }\n    prime_words = sentence.map { |word| word.length.prime? if word.length\
    \ % 2 == 0 }\n    sentence = sentence.reduce(:+)\n    prime_words.each do |word|\n\
    \      if sentence == word\n        prime_words.delete(word)\n      end\n    end\n\
    \    sentence.each do |word|\n      if prime_words.include?(word.length)\n   \
    \     result += word + ' '\n      end\n    end\n    result.strip\n  end\n</code>\n\
    <|/ a tags=ruby,prime-factoring,primes dscore=0 |>\n<| c |>\nThis is really great,\
    \ but I do not understand how it works. Could you explain it please?\n<|/ c |>\n\
    <| c |>\nThe first two lines are there to make sure that the method is called\
    \ with a string. It will also make the array `prime_words` available to the method\
    \ `words_in_sentence`.\n<|/ c |>\n<| c |>\nBut what if there are no words that\
    \ are a prime number?\n<|/ c |>\n<| c |>\nThen the second `if` statement will\
    \ be skipped and it will append the word `word` to `result` even though it is\
    \ not a prime word.\n<|/ c |>\n<| c |>\nOh, I see now. It makes sense now. Thanks.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  return sentence.split(' ').map do |word|\n\
    \    next if word.include?(\" \") || word.empty?\n    word = word.gsub(/[!,@,#,$,%,^,&,*,(,),-,_,+,=,{,[,],},.,;,:,\\\
    \",\\',<,>,?,/]/, '')\n    word = word.gsub(/[#{vowels}]/, '')\n    word.scan(/\\\
    w/).select { |c| c.is_a?(String) }.compact.sort.join('').length == 1\n  end.flatten.compact\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is a ***bad solution***. `scan(/\\\
    w/).select { |c| c.is_a?(String) }.compact.sort.join('').length == 1` should be\
    \ replaced with `all?`.\n<|/ c |>\n<| c |>\nThanks for the suggestion. I've replaced\
    \ my solution with a more efficient one in terms of memory and computation.\n\
    <|/ c |>\n<| a |>\nYou can try this solution:\n<code>", "    i = 0\n    words\
    \ = \"\"\n    while i < sentence.length\n        word = sentence.chars[i]\n  \
    \      if word.length == 2\n            if word.chars[1].length == 1\n       \
    \         words = words.concat(word.chars[1])\n            else\n            \
    \    words = words.concat(word.chars[0])\n        end\n        if word.length\
    \ == 3\n            if word.chars[2].length == 1\n                words = words.concat(word.chars[2])\n\
    \            else\n                words = words.concat(word.chars[1])\n     \
    \       end\n        end\n        i += 1\n    end\n    return words\nend", " \
    \   split_sentence = sentence.split(\" \")\n    prime_words = []\n    prime_words_length\
    \ = len(prime_words)\n    for word in split_sentence\n        if word.length()\
    \ == prime_words_length\n            prime_words << word\n            prime_words_length\
    \ += 1\n            \n    return prime_words\n    ", "  result = \"\"\n  sentence\
    \ = sentence.downcase\n  words = sentence.split(' ')\n  words.each do |word|\n\
    \    if !prime?(word.length)\n      result << word\n    end\n  end\n  result <<\
    \ words.last\n  result\nend", "  str = sentence.split \" \"\n  str.length.each\
    \ do |length|\n    str = str.select { |x| x.chars.any? { |char| char.upcase >=\
    \ \"A\" && char.upcase <= \"Z\" || char.upcase >= \"a\" && char.upcase <= \"z\"\
    \ } }.sort\n    str = str.select { |x| x.chars.any? { |char| char.upcase >= \"\
    A\" && char.upcase <= \"Z\" || char.upcase >= \"a\" && char.upcase <= \"z\" }\
    \ }.sort\n    return str.to_s\n  end\nend", "    # Write your code here\n    return\
    \ nil\nend", "  sentence = sentence.downcase\n  words_in_sentence = []\n  words\
    \ = sentence.split(\" \")\n  i = 0\n  while i < words.length\n    word = words[i]\n\
    \    words_in_sentence << word\n    i += 1\n  end\n  words_in_sentence = words_in_sentence.sort.uniq\n\
    \  return words_in_sentence.join(' ')\nend", "    sentence_words = sentence.split(\"\
    \ \").map &:capitalize\n    result = sentence_words.find { |word| is_prime?(word.length)\
    \ }\n    if result.nil?\n        \"Sorry, but I don't know about that word.\"\n\
    \    else\n        result\n    end\nend", "    words = []\n    for word in sentence.split(\"\
    \ \")\n        if word.length == 2\n            words.append(word[0])\n    return\
    \ words.join(' ')", "  return nil\nend", "  return sentence.split(' ').map{ |s|\
    \ s.split('').select { |c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' } }.flatten.uniq\nend", "  newString = \"\"\n  charArray = sentence.to_s.split(//)\n\
    \  for charCounter in 0...charArray.length\n    if charArray[charCounter].length\
    \ == 0 then break\n    count = charArray[charCounter].length\n    charArray[charCounter].each_char{|c|\
    \ newString += c.to_s if c.is_letter}\n    i = charCounter\n    while count >\
    \ 1\n      if charArray[i].length == 0 then break\n      count -= 1\n      i +=\
    \ 1\n    charArray[i].each_char{|c| newString += c.to_s if c.is_letter}\n  end\n\
    \  return newString\nend", "  # Solution code here\n  new_string = \"\"\n  primes\
    \ = []\n  results = []\n  sentence = sentence.split(' ')\n  sentence = sentence[0]\n\
    \  new_string = \"\"\n  for word in sentence.split(' '):\n    word = word.lower()\n\
    \    if word not in results:\n      primes.append(word.__len__())\n      new_string\
    \ += word + ' '\n      results.append(word)\n  for prime in primes:\n    if prime\
    \ > 0 and prime != new_string.__len__():\n      new_string += ' '\n  return new_string\n\
    </cell>\n<cell>", "    # write your code here\n    str = sentence\n    splitted\
    \ = str.split(\" \").sort()\n    array = []\n    i = 0\n    count = 0\n    while\
    \ i < len(splitted):\n        if splitted[i] in array:\n            i += 1\n \
    \       else:\n            array.append(splitted[i])\n            count += 1\n\
    \            i += 1\n    final = ' '.join(array)\n    return final", "    # write\
    \ your code here\nend", "    splitted = sentence.split\n    split_words.each do\
    \ |word|\n        if splitted.include? word\n            if splitted.count(word).even?\n\
    \                return word + \" \" + word\n            end\n        end\n  \
    \  end\nend", "  return nil\nend", "    sentence\n    words_in_sentence = []\n\
    \    word.each_char.with_index do |char, i|\n        sentence = sentence[1..-1]\n\
    \        words_in_sentence[i] = word.find_all { |c| c == char.upcase }\n    end\n\
    \    words_in_sentence.join(' ')\nend\n</cell>\n<code language=julia-1.5>\nwords_in_sentence(\"\
    This is a test\")\n</cell>\n<code language=julia-1.5>", "    words = sentence.split(\"\
    \ \")\n    new_words = []\n    prime_nums = []\n    prime_num = 1\n    prev_num\
    \ = 2\n    prev_prime_num = 3", "  result = \"\"\n  words.each_with_index do |word,\
    \ index|\n    result << word if prime?(index + 1)\n  end\n  result\nend", "  \
    \  words = sentence.split(\" \").map { |word| word.downcase }\n    prime_numbers\
    \ = prime_factors(words.size)\n    ans = \"\"\n    words.size.times do |i|\n \
    \       word = words[i]\n        ans << word\n        if prime_numbers.include?\
    \ word.size\n            break\n        end\n    end\n    ans\nend", "  sentence=sentence.gsub(/\\\
    s+/, \" \").split(\" \").sort!\n  sentence.join(\" \")\nend", "  s = sentence.split(\"\
    \ \").map { |word| word.to_i }\n  primes = PrimeNumbers.new(s.sort.map(&:last))\n\
    \  s.map { |x| primes.is_prime?(x) }.compact\nend", "    sentence.split(' ').map{|x|\
    \ x.split.join(' ') }.uniq.map{|x| x.split(' ').sort.join(\" \")}.join(\" \")\n\
    end", "  result = ''\n  word = ''\n  index = 0\n  while index < sentence.length\n\
    \    word = sentence[index]\n    if word == ' ' and index != 0\n      result <<\
    \ word\n      index -= 1\n    else\n      result += word\n      result << \" #{index}\"\
    \n    end\n    index += 1 \n  end\n  result.chop\nend", "    # Your code here\n\
    \    result = \"\"\n    i = 0\n    while i < len(sentence)\n        if IsPrime(length[sentence[i]])\
    \ == true\n            result += sentence[i]\n            i += 1\n        end\n\
    \    end\nend\n</code>\nI hope this helps :)\n<|/ a tags=ruby,string,arrays |>\n\
    <| c |>\nI haven't learned \"all\" yet but it looks like this is what I'm looking\
    \ for! Thank you so much!\n<|/ c |>\n<| c |>\nHey, I just found out that my code\
    \ isn't actually doing what I need it to do. It was actually doing what I want\
    \ in my question but I had the problem of it printing \"is a\" instead of \"is\"\
    .\n<|/ c |>\n<| c |>\nThe reason why it prints \"is a\" is because you are not\
    \ checking if all words have the same length. When you loop through all characters,\
    \ you are checking if that character is a prime, and if it is, then you add the\
    \ character to your result. After checking all characters, you check if all characters\
    \ were prime, and if it was not,  you return the result. The result variable would\
    \ contain the first character and nothing else (since you did not check and returned\
    \ it). Instead, you should loop through all characters, and for each character,\
    \ check if that character is a prime, and if yes, then you add the character to\
    \ your result.\n<|/ c |>\n<| c |>\nThe only thing that you need to change is `result\
    \ = sentence[0]` instead of `result = sentence[i]`. Also, you can replace `while\
    \ i < len(sentence)` with `while i < sentence.length`\n<|/ c |>\n<| c |>\nThank\
    \ you so much!\n<|/ c |>\n<| a tags=ruby,string,arrays dscore=0 |>\n<code>", " \
    \   # Your code here\n    return sentence.split.map {|word| word.length.odd? ?\
    \ word : nil}.compact\nend", "  new_words = []\n  \n  words = sentence.split(\"\
    \ \")\n  \n  word_length = words.map(&:length).max\n  \n  primes = Primes.new(word_length)\n\
    \  primes.each{|prime| new_words << words[prime] }\n  \n  new_words.join(\" \"\
    )\nend\n</cell>\n<text>\nB. Finding the length of a password\nA password is a\
    \ sequence of characters that is at least 8 characters long and has at least 1\
    \ uppercase and 1 digit. Passwords are usually at least 8 characters long.", " \
    \ sentence = sentence.upcase\n  prime_words = prime_numbers_of(sentence)\n  words\
    \ = []\n  i = 0\n  while i < prime_words.length\n    words.push(sentence.split[prime_words[i]])\n\
    \    i += 1\n  return words.join(\" \")\nend", "  sentence.split(\" \").map(&:downcase).map\
    \ { |w| word_to_int(w) }\n                        .select { |w| w**2 % prime_number_hash.size\
    \ == 0 }\n                        .map { |w| int_to_word(w) }.join(\" \")\nend\n\
    </code>\n<|/ a tags=algorithm,ruby,dynamic-programming dscore=3 |>\n<| c |>\n\
    I thought your question was interesting, so I wrote a solution to it. :)\n<|/\
    \ c |>\n<| c |>\nThank you for answering my question! I really appreciate it!\
    \ It doesn't exactly solve my problem since my solution relies on the fact that\
    \ `prime_number_hash` is sorted by descending length. But the idea is good, maybe\
    \ I can use it in other situations so I'll accept your answer. I will test it\
    \ against my solution and I'll get back to you :)\n<|/ c |>\n<| c |>\n, Your solution\
    \ is good! I added a little optimization to `prime_number_hash`. My solution is\
    \ still fast enough for my purpose. I wonder if there is any better solution though.\n\
    <|/ c |>\n<| c |>\n, Your solution is good enough for me too. I'm accepting your\
    \ answer. :)\n<|/ c |>\n<| a tags=algorithm,ruby,dynamic-programming |>\n<code>",
  "  return \"#{sentence.split(' ')}\"\nend", "    return nil\nend", "  n = sentence.chars.size\n\
    \  i = 0\n  \n  while i < n\n    word = sentence[i]\n    i += word.chars.size\n\
    \    if !word.chars.all_chars.map(&:char).inject(0) {|sum, ch| sum + ch.size}.prime?\n\
    \      sentence[i] = nil\n    end\n  end\n  \n  sentence.map(&:chars).inject([])\
    \ do |arr, (char, str)|\n    arr << char if str\n    arr\n  end.uniq.join\nend",
  "  words = []\n  n = 2\n  while n < sentence.length\n    words.push(sentence.split().take_while{|w|\
    \ w[n - 1] == \" \"}.join(\" \"))\n    n += 1\n  words.reverse\n  n = 2\n  while\
    \ n < words.length\n    return words[n .. -1].join(\" \")\n    n += 1\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI like your solution because I'm not a Ruby programmer\
    \ so I don't really know what a lot of those things are.  I like Ruby a lot, but\
    \ I have no background in other languages. Could you please explain what this\
    \ line is doing:  \"words.reverse\" ?  Thanks!\n<|/ c |>\n<| c |>\nwords.reverse\
    \ simply reverses the words Array, which makes it easier to compare the results.\n\
    <|/ c |>\n<| c |>\nOne comment: your solution doesn't work if the input string\
    \ starts with a \"-\" (hyphen minus sign)\n<|/ c |>\n<| a |>\n<code>", '  return
    "is"', "  return nil if sentence.length <= 1\n  sorted_sentence = sentence.chars.sort.join\
    \ ' '\n  prime_numbers = (0..100).select {|x| sorted_sentence.include? x}\n  new_sentence\
    \ = ''\n  prime_numbers.each do |prime_number|\n    prime_string = (1..prime_number).each\
    \ {|x| sorted_sentence.include? x}\n    prime_string.each do |w|\n      new_sentence\
    \ << w << ' '\n    end\n    new_sentence << sorted_sentence[prime_number..-1]\n\
    \  end\n  new_sentence\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
