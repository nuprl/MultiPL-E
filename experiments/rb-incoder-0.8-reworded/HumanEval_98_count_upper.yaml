name: HumanEval_98_count_upper
language: rb
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"\
  abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n\
  \    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"\
  ))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"\
  dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"\
  U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"\
  EEEE\"))\n  end\nend\n"
completions: ["  return 0 if s == \"\" else s.chars.find { |x| x =~ /[AEIOU]/i }\n\
    end\n</code>\nHere is a recursive version, which I personally find easier to read:\n\
    <code>", "  s.scan(/(.)(?=[A-Z])/) {|m| m[1].size % 2 == 0 ? m[0].size : 0}\n\
    end", "  if s.length < 1\n    return 0\n  a = s.dup\n  b = s.dup\n  cased_a =\
    \ a.downcase\n  cased_b = b.downcase\n  a.slice!(0..-1)\n  b.slice!(0..-1)\n \
    \ a.each_index do |i|\n    a[i] = cased_a[i].ord >= 65 && cased_a[i].ord <= 90\n\
    \    a[i] = !cased_b[i].ord >= 65 && cased_b[i].ord <= 90\n  end\n  a.length\n\
    end", "  count = 0\n  for i in 0 .. s.length-1\n    count += true if s[i] == \"\
    A\" || s[i] == \"a\" || s[i] == \"I\" || s[i] == \"i\"\n  end\n  return count\n\
    end", "  return s.chars.reduce(0) do |n|\n    n += 1 if n % 2 == 0\n    n\n  end\n\
    end", "\ts.each_index {|i| s[i] <=> upper[i]}\n\ts.count {|i| upper[i] == i}\n\
    end", "  s.scan(/[a-z](?!\\Z)/)\n  s.count { |c| (c == 'A' || c == 'E') }\nend",
  "  count = 0\n  index = 0\n  while index < s.length\n    char = s[index]\n    if\
    \ char >= \"A\" && char <= \"Z\"\n      count += 1\n    index += 1\n  end\n  return\
    \ count\nend", "  s.each_index { |i| return 0 if s[i] =~ /[AEIOU]/; break 1 if\
    \ s[i] == 'Z' } \nend\n ", "  s = s.to_s\n  even_indexes = s.count(\"o\") + s.count(\"\
    O\")\n  odd_indexes = s.count(\"e\") + s.count(\"E\")\n  return odd_indexes -\
    \ even_indexes\nend", "  (0..s.length-1).each do |i|\n    next unless s[i] =~\
    \ /[aeiouy]/\n    next if i % 2 == 0\n    next if s[i+1] =~ /[aeiouy]/\n    return\
    \ 1 if s[i+2] =~ /[aeiouy]/\n  end\n  return 0\nend", "    count = 0\n    i =\
    \ 0\n    while i < s.length\n        if s[i] == 'A' || s[i] == 'E' || s[i] ==\
    \ 'I' || s[i] == 'O' || s[i] == 'U'\n            count += 1\n        end\n   \
    \     i += 1\n    return count\nend", "  s.each_char do |c|\n    next if c.upcase\
    \ == c\n    next if c.upcase == \"A\"\n    next if c.upcase == \"a\"\n    next\
    \ if c.upcase == \"E\"\n    next if c.upcase == \"e\"\n    next if c.upcase ==\
    \ \"I\"\n    next if c.upcase == \"i\"\n    next if c.upcase == \"O\"\n    next\
    \ if c.upcase == \"o\"\n    next if c.upcase == \"U\"\n    next if c.upcase ==\
    \ \"u\"\n    return 1 if c.upcase == \"a\"\n    return 1 if c.upcase == \"e\"\n\
    \    return 1 if c.upcase == \"i\"\n    return 1 if c.upcase == \"o\"\n    return\
    \ 1 if c.upcase == \"u\"\n  end\nend", "  s.each_char.with_index.inject(0) { |c,\
    \ (ev, idx)| ev + 1 if c == 'A' && (idx == 0 || s[idx-1] == 'A') }\nend", "  s.gsub(/[^A-Z]/,\
    \ \"X\").scan(/[Aa]/) do |a|\n    if $even_num\n      a.count(\"A\") + 1\n   \
    \ else\n      a.count(\"a\")\n    end\n  end\nend", "  count = 0\n  s.each_char\
    \ do |c|\n    next if c > 'Z'\n    case c\n    when 'A'..'E'\n      count += 1\n\
    \    end\n  end\n  count\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for\
    \ sharing your solution. Could you provide some explanations as to what each line\
    \ is doing?\n<|/ c |>\n<| c |>\nYou can't call `split` on a `String`; `split`\
    \ accepts a `Regexp` as the argument and it only splits on `Regexp`s so you get\
    \ an array and not a string. Also, you can't chain `map` and `each_char` on a\
    \ `String`.\n<|/ c |>\n<| a |>\nI think this is pretty easy to read, easy to understand,\
    \ and works:\n<code>", "  s.chars.inject(0) do |total, ch|\n    total+1 if ch.upcase\
    \ =~ /[AEIOU]/\n    total\n  end\nend", "    i = 0\n    count = 0\n    while i\
    \ < s.length\n        if s[i] =~ /[AEIOU]/i\n            count += 1\n        end\n\
    \        i += 1\n    end\n    return count\nend\n</cell>\n<code language=julia-0.5>",
  "    s.each_char do |c|\n        if ((c.upcase == c) && (c =~ /[AEIOU]/i))\n   \
    \         s.count(\"A\"..\"Z\")\n        else\n            0\n        end\n  \
    \  end\nend", "  if s.length <= 0\n    return 0\n  result = 0\n  i = 0\n  while\
    \ i < s.length\n    result += (s[i] != s[i].upcase? 1 : 0)\n    i += 1\n  end\n\
    \  result\nend", "  return s.gsub(/[AEIOU]/i).count.even? ? 1 : 0\nend", "  s.chars.each_with_index.inject(0)\
    \ do |c,(n,i)| \n    c += 1 if n % 2 == 0 && s.chars[i+1].upcase == s.chars[i]\n\
    \    c\n  end\nend", "  s.count(\"A\"..\"Z\").zero? ? 0 : 1\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis answer works great for strings that are longer than 1 character.\
    \ The accepted answer does not. For example, \"abcdefg\" has 6 uppercase characters,\
    \ but only 5 are capitalized vowels. Using the accepted answer will return 6.\
    \ This answer will correctly return the number of uppercase characters.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  return 0 if s.empty? || s[0] == s[-1] && s[0,\
    \ 1] == \"u\" else 1\nend", "  s.scan(/[A-Z]/ ){|s| s.size % 2 == 0 ? s.size :\
    \ 0}.inject(:+)\nend", "  s.to_s.scan(/(.)(.*)/).each_with_index.inject(0) do\
    \ |counter, (match, $2, i)|\n    counter += 1 if i % 2 == 0 and $2.upcase == $2\n\
    \    counter\n  end\nend\n</cell>\n<cell>", "  s.chars.with_index.with_object(0)\
    \ do |(char, idx), total|\n    total += 1 if char.upcase == \"A\" && idx % 2 ==\
    \ 0\n    total += 1 if char.upcase == \"B\" && idx % 2 == 1\n    total += 1 if\
    \ char.upcase == \"C\" && idx % 2 == 2\n    total += 1 if char.upcase == \"D\"\
    \ && idx % 2 == 3\n    total += 1 if char.upcase == \"E\" && idx % 2 == 4\n  \
    \  total += 1 if char.upcase == \"F\" && idx % 2 == 5\n    total += 1 if char.upcase\
    \ == \"G\" && idx % 2 == 6\n  end\nend\n</cell>\n<text>\nNow let's use our count_upper\
    \ function on some different inputs and print the results:", "  return s.downcase.gsub(/[aeiou]/i).count\
    \ { |x| x =~ /[AEIOU]/i }\nend", "  return 1 if s[/[AEIOU]/].downcase != s[/[AEIOU]/].upcase\
    \ else 0\nend", "  # Initialize the count variable\n  count = 0\n  # For every\
    \ character in s\n  for c in s\n    # If c is an uppercase letter and it is even\
    \ in the even indices\n    if c >= 'A' and c <= 'Z' and c % 2 == 0\n      # Increment\
    \ the count variable\n      count += 1\n  # Return count\n  return count\n  #\
    \ Note: The above is how you count the number of elements in a list.\n  # The\
    \ above is also how the code above will work for strings as well.\n  # The only\
    \ difference is instead of returning count, we return 0\n  # (this value won't\
    \ be used in practice).\n  ", "  s.chars.each_with_index.reduce(0) do |s, (_,\
    \ i)|\n    next s if i % 2 == 0\n    s.succ\n  end\nend", "  count = 0\n  for\
    \ i in 0...s.length\n    if s[i] >= 'A' and s[i] <= 'Z'\n      count += 1\n  \
    \  end\n  end\n  count\nend", "    s.downcase!\n    count = 0\n    for i in 0...s.length\n\
    \        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I'\n            count += 1\n\
    \        end\n    end\n    count\nend", "  s.each.with_index { |c, i| return 0\
    \ if i % 2 == 0 and c.upcase == c }\nend", "  i = 0\n  while i < s.length\n  \
    \  if s[i] >= 'a' && s[i] <= 'z'\n      i += 1\n    elsif s[i] >= 'A' && s[i]\
    \ <= 'Z'\n      i += 1\n    else\n      i += 1\n    end\n  end\n  i\nend", "\t\
    i = 0\n\twhile i < s.length\n\t\treturn 0 if s[i] == \"A\" or s[i] == \"a\" else\
    \ 1\n\t\ti += 1\n\tend\nend", "  return s.split('').map.with_index{|x,i| i.odd?\
    \ ? x.upcase : 0}.sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt's always fun\
    \ to see a variation on the theme of counting vowels in a string.\n<|/ c |>\n\
    <| a |>\nRuby has Enumerable which provides the method any? that can be used to\
    \ check if any element in a collection is true.\nTo check if any element in a\
    \ collection is true you can use the any? method as follows:\n<code>\nletters.any?{|x|\
    \ x == 'a'} # => true\nletters.any?{|x| x == 'o'} # => false\n</code>\nYou can\
    \ create this method as follows:\n<code>", "  even = s.chars.each_with_index.reduce(0)\
    \ do |c, (i, v)|\n    if i % 2 == 0\n      c + v if v >= 65 && v <= 90\n    end\n\
    \  end\n  even\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThank you for\
    \ the excellent explanation! One thing that still confuses me is why `/\\A(\\\
    w)(\\W)/` doesn't work. Doesn't the second capture group contain all of the letters\
    \ in `\\w`?\n<|/ c |>\n<| c |>\n`\\A` matches the beginning of a string, and `\\\
    w` matches only letters. `/\\w/ === \"aAbBcCdDeEfFgGh\"` so `/\\A(\\w)(\\W)/`\
    \ matches the whole string `aAbBcCdDeEfFgGh`, which is not what you want. `/\\\
    w/` === \"aAbBcCdDeEfFgGh\" because it is anchored at the beginning. `/^\\w/`\
    \ === \"aAbBcCdDeEfFgGh\" because it is anchored at the beginning of a line.\n\
    <|/ c |>\n<| c |>\nI see. So `/\\A(\\w)(\\W)/` will match the whole string `aAbBcCdDeEfFgGh`,\
    \ but `/^(\\w)/` will match only the first letter? But why is `\\A` necessary\
    \ here? I thought `/^(\\w)/` would only match the first letter, since it only\
    \ has one capture group.\n<|/ c |>\n<| c |>\n`\\A` matches a position where a\
    \ newline can safely be inserted (it must start at the beginning of the string).\n\
    <|/ c |>\n<| a tags=ruby,regex dscore=2 |>\nYou can count using just one line\
    \ of code:\n<code>\n\"aAbBcCdDeEfFgGh\".scan(/\\w/).count {|e| e.upcase }", " \
    \ s.scan(/[AEIOU]/).size\nend", "  s.scan(/[AEIOU]/)\n  s.inject(:+).to_i\nend",
  "  s.gsub(/[AEIOU]/) { |s| s.eql?('A') ? 1 : 0 }\nend\n</cell>\n<text>\nAs a more\
    \ general exercise, write a function which takes a string and counts the number\
    \ of lowercase letters in each word of the string followed by a lowercase letter.\n\
    For example\n>>> count_lower_cont.call(\"aBCdEf\")\n[0, 3, 1]\n>>> count_lower_cont.call(\"\
    aBCdef\")\n[1, 2, 1]", "  s = 0\n  for i in 0..length(s)\n    if s[i] >= 'A' &&\
    \ s[i] <= 'Z'\n      s += 1 if s[i].upcase == 1\n    end\n  end\n  s\nend\n</code>\n\
    <|/ a |>\n<| a |>\nOne Liner using charAt\n<code>\nfunction count_upper(s)\n return\
    \ s.charAt((s.indexOf('A')||0)+1).downcase.count.upcase\nend\n</code>\n<|/ a tags=ruby,string\
    \ dscore=0 |>\n<| a tags=ruby,string |>\n<code>", "  even = s.each_char.map {\
    \ |c| c.upcase }.select { |c| c =~ /[AEIOU]/i }\n  (even.size - even.count(false)).floor\n\
    end", "  i = 0\n  while i < s.length\n    ch = s[i]\n    if ch == \"a\"\n    \
    \  i += 1\n    elsif ch == \"A\"\n      i += 1\n    elsif ch == \"e\"\n      i\
    \ += 1\n    elsif ch == \"E\"\n      i += 1\n    elsif ch == \"i\"\n      i +=\
    \ 1\n    elsif ch == \"I\"\n      i += 1\n    elsif ch == \"o\"\n      i += 1\n\
    \    elsif ch == \"O\"\n      i += 1\n    elsif ch == \"u\"\n      i += 1\n  \
    \  elsif ch == \"U\"\n      i += 1\n    elsif ch == \"y\"\n      i += 1\n    elsif\
    \ ch == \"Y\"\n      i += 1\n    elsif ch == \"y\"\n      i += 1\n    elsif ch\
    \ == \"Y\"\n      i += 1\n    end\n  end\n  0 if i % 2 == 0\nend", "  s.downcase!\n\
    \  count = 0\n  (0...s.length).each do |i|\n    count += 1 if s[i]=~/[AEIOU]/\
    \ && s[i].upcase=~/\\A[AEIOU]/\n  end\n  count\nend", "  i = 0\n  result = 0\n\
    \  while i < s.length\n    if s[i] == 'A' || s[i] == 'a'\n      result += 1 if\
    \ s[i].upcase == true else 0\n    i += 1\n  result\nend", "  s.each_index { |i|\
    \ s[i] = s[i].upcase if s[i].upcase =~ /[AEIOU]/i }\n  s.count(\"AEIOU\")\nend",
  "  s.each_char.with_index.inject(0) { |s, (e, c), i| i == 0 || s[i] == s[i - 1]\
    \ && s[i] == c ? s + 1 : s }\nend", "  s.gsub(/[AEIOU]/) { |match| match.to_s.upcase\
    \ } =~ /[AEIOU]/\nend", "  return s.length() - (s.downcase.length - s.upcase.length)\n\
    end", "  return 0 unless s\n  return 1 if s.index(\"a\").odd?\n  return 1 if s.index(\"\
    A\").odd?\n  return 0 if s.index(\"e\").odd?\n  return 0 if s.index(\"E\").odd?\n\
    \  return 1 if s.index(\"i\").odd?\n  return 0 if s.index(\"I\").odd?\n  return\
    \ 1 if s.index(\"o\").odd?\n  return 0 if s.index(\"O\").odd?\n  return 1 if s.index(\"\
    u\").odd?\n  return 0 if s.index(\"U\").odd?\n  return 1\nend", "\tcount = 0\n\
    \tfor i in 0...s.length\n\t\tif s[i] >= 'a' and s[i] <= 'z'\n\t\t\tcount += 1\n\
    \t\tend\n\tend\n\treturn count\nend", "  s.each_char.inject(0) { |sum, char| sum\
    \ + 1 if char.upcase == char }\nend", "\ts.downcase!\n\ts.chars.each do |char|\n\
    \t\treturn 0 if char.upcase == 'AEIOU'\n\tend\n\treturn s.size\nend", "  str.upcase(s).split('').inject(0)\
    \ {|s, c| s + 1 if c == 'A'}\nend", "  s.each_char.with_object(Hash.new(0)).with_index\
    \ { |c,h| (h[c] ||= 0) + 1; h[c].even? ? h[c] : 0 }\nend\n</pre>", "  count =\
    \ 0\n  s.each_char do |c|\n    count += if c =~ /[AEIOU]/\n              0\n \
    \           else\n              1\n            end\n  end\n  count\nend", "  s.gsub(/[AEIOU]/i)\
    \ { |m| m.size % 2 == 0 && m.upcase }\nend", "  return s.upcase ? 0 : s[1..-1].map\
    \ { |c| c =~ /[AEIOU]/i ? 0 : 1 }.inject(:+)\nend", "  result = nil\n  s.each_char.with_index\
    \ do |v, i|\n    if i % 2 == 0 && v >= 'A' && v <= 'Z'\n      result = 1 + result\n\
    \    end\n  end\n  result\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\n\
    `each_char.with_index` would be more idiomatic in Ruby than `each_with_index`.\n\
    <|/ c |>\n<| c |>\nRuby 2 `each_char` accepts a block, so `each_char.with_index\
    \ {|v, i| ... }` would be more idiomatic in Ruby than `each_with_index {|v, i|\
    \ ... }`\n<|/ c |>\n<| c |>\nThat's exactly what I meant, but as I was trying\
    \ to write it I thought I'd change it to `each_char.with_index`\n<|/ c |>\n<|\
    \ c |>\nIt's really not as big of a deal in this case, but `each_char.with_index`\
    \ will perform better because it doesn't actually call `to_proc` on `&:upcase`.\n\
    <|/ c |>\n<| a dscore=1 |>\nTo see how many times a character (not letter) is\
    \ uppercase, simply count how many times a character is \"A\" or  \"a\", or \"\
    B\" or  \"b\", or \"C\" or  \"c\", or \"D\" or  \"d\", or \"E\" or  \"e\", or\
    \ \"F\" or  \"f\", or \"G\" or  \"g\", or \"H\" or  \"h\", or \"I\" or  \"i\"\
    , or \"J\" or  \"j\", or \"K\" or  \"k\", or \"L\" or  \"l\", or \"M\" or  \"\
    m\", or \"N\" or  \"n\", or \"O\" or  \"o\", or \"P\" or  \"p\", or \"Q\" or \
    \ \"q\", or \"R\" or  \"r\", or \"S\" or  \"s\", or \"T\" or  \"t\", or \"U\"\
    \ or  \"u\", or \"V\" or  \"v\", or \"W\" or  \"w\", or \"X\" or  \"x\", or \"\
    Y\" or  \"y\", or \"Z\" or  \"z\".\n<code>", "  s.gsub(/(.)(\\1)*/) {|m| m.length*2}.count('\\\
    1')\nend", "  return s.count(\"A\") + s.count(\"a\") + s.count(\"E\") + s.count(\"\
    e\") + s.count(\"I\") + s.count(\"i\") + s.count(\"O\") + s.count(\"o\") + s.count(\"\
    U\") + s.count(\"u\")\nend", '  return s.gsub(/[aeiouAEIOU]/i).length', "  s.split('').inject(0)\
    \ { |sum, char| sum + 1 if char.upcase }.to_i\nend", "  s.split.each_with_index.inject(0)\
    \ do |sum, (v, i)|\n    sum += i & 1 ? 'a' < v ? 'A' : v : v\n  end\nend", " \
    \   s.gsub!(/[^aeiouAEIOU]/, '')\n    s.chars.each do |c|\n        if c == \"\
    A\" then\n            true\n        elsif c == \"E\" then\n            true\n\
    \        elsif c == \"I\" then\n            true\n        elsif c == \"O\" then\n\
    \            true\n        elsif c == \"U\" then\n            true\n        elsif\
    \ c == \"a\" then\n            if c == \"A\" then\n                true\n    \
    \        else\n                false\n            end\n        elsif c == \"e\"\
    \ then\n            if c == \"E\" then\n                true\n            else\n\
    \                false\n            end\n        elsif c == \"i\" then\n     \
    \       if c == \"I\" then\n                true\n            else\n         \
    \       false\n            end\n        elsif c == \"o\" then\n            if\
    \ c == \"O\" then\n                true\n            else\n                false\n\
    \            end\n        elsif c == \"u\" then\n            if c == \"U\" then\n\
    \                true\n            else\n                false\n            end\n\
    \        end\n    end\nend\n</code>\nThe first method takes a string and uses\
    \ regular expressions to remove non-alphabetic characters and count the vowels\
    \ in even indices.\nThe second method takes an array of strings and just counts\
    \ the number of occurrences of each uppercase vowel.\n<|/ a dscore=2 |>\n<| a\
    \ |>\nAnother solution:\n<code>", "  count = 0.chr(0)\n  s.each_index do |i|\n\
    \    if i.even?\n      count += 1\n      count += s[i].upcase\n    end\n  end\n\
    \  count\nend", "  return s.size*[s.first].count(s.first)\nend", "  s = 0\n  i\
    \ = 0\n  while i < s.length\n    if s[i] >= 'A' && s[i] <= 'Z'\n      s += 1\n\
    \      i += 1\n    else\n      i += 1\n    end\n  end\n  return s\nend", "  count=0\n\
    \  i=0\n  while i<s.length\n    if s[i].upcase?\n      count+=1\n      i+=1\n\
    \      i+=1\n    end\n    i+=1\n  end\n  count\nend", "  count = 0\n  s.gsub(/[^AEIOU]/)\
    \ { count += 1; $_.upcase } unless s.empty?\n  count\nend", "  s.upcase.size.times\
    \ do |i|\n    next if s[i] =~ /[A-Z]/\n    next\n  end\n  0\nend", "  return s.chars.each_with_index.with_object(Hash.new(0)){|(ch,\
    \ index), acc| acc[ch =~ /[AEIOU]/] += 1 if index % 2 == 0 }\nend", "  s.length.times\
    \ do |i|\n    if s[i].upcase == \"A\" or s[i].upcase == \"a\" then\n      count\
    \ = count + 1\n    end\n  end\n  count\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nAh... I like that approach! I remember learning that it's common to see\
    \ `s.each_index.select` used somewhere, but I forgot it was a method on String\
    \ (that isn't the entire String's class).\n<|/ c |>\n<| c |>\n: That's actually\
    \ the entire String's class, though, and it's just an alias for [`Enumerable#each_index`](http://www.ruby-doc.org/core-2.0.0/Enumerable.html#method-i-each_index).\n\
    <|/ c |>\n<| c |>\n`each_index` is more general, since it allows you to choose\
    \ the starting index. `each_with_index` would allow you to choose the starting\
    \ index, but `with_index` would allow you to choose the ending index.\n<|/ c |>\n\
    <| c |>\nYes, I guess I should've explained that better. `each_with_index` will\
    \ give you the index of the current element while `each_index` gives you the element\
    \ itself. I didn't say it would give you a starting index, I said it would give\
    \ you the element *and* the index.\n<|/ c |>\n<| c |>\nYes, of course; I didn't\
    \ notice that you also mentioned it.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>",
  "  s.gsub(/[AEIOUaeiou]/){|s| s.upcase if s.upcase =~ /[AEIOU]/i}.count\nend", '    return
    s.count("A") + s.count("a") - (s.count("a") & s.count("A"))', "  s.split(\"\"\
    ).inject(0) { |sum, elem| sum + elem.upcase % 2 == 0 && sum}\nend", "  s.each_index\
    \ { |i| if i&1 != 0 then return 0 else return 1 end }\nend", "    count = 0\n\
    \    s.each_char do |char|\n        next if char == ?a\n        count += 1 if\
    \ char == ?A\n    end\n    count\nend", "  return s.each_index.inject(0) { |m,\
    \ i| m + (i % 2 == 0 ? 0 : nil) }\nend", "  i = 0\n  while i < s.length\n    if\
    \ s[i].upcase == true\n      i += 1\n    else\n      i += 1\n    end\n  end\n\
    \  return i\nend", "  return s.chars.map(&:upcase).count(&:even?)\nend", "   \
    \ return s.count { |c| (c.ord >= 65 && c.ord <= 90) }\nend", "  return 1 if s\
    \ =~ /[aeiou]/i || s =~ /[aeou]/i || s =~ /[aeiouy]/i || s =~ /[aeouy]/i else\
    \ 0\nend", "  return s.chars.zip(&:upcase).reject { |char,rest| rest.length <=\
    \ 1 }.count\nend", "  s = s.split('')\n  s.map!{ |x| x.upcase }\n  s.each_with_index.inject{|t,i|\
    \ t+(i%2==0 ? 0 : 1) }\nend", "  s = s\n    .downcase\n    .gsub(/./, \"\")\n\
    \    .gsub(/[AEIOU]/, '\\0')\n    .gsub(/\\0+/)\n    .split(\"\\0\")\n    .select\
    \ { |s| s[0] == \"A\" || s[0] == \"E\" || s[0] == \"I\" || s[0] == \"O\" || s[0]\
    \ == \"U\" }\n    .size\n  s.zero? ? 0 : 1\nend", "    s.each_index {|i| next\
    \ unless s[i].upcase == \"A\"[i]; }\n    s.count(\"A\"..\"Z\")\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks Alistair! Your solution is probably more elegant, but\
    \ the point of this exercise was to learn the .each_index method and how to get\
    \ around the problem without it. I tried a for loop, and it worked, but I wanted\
    \ to learn more about .each_index\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  count\
    \ = 0\n  for i in 0..s.length-2\n    if s[i] == 'A' and s[i+1] == 'A' and s[i+2]\
    \ == 'A'\n      count += 1\n    end\n  end\n  count\nend\n</code>\nHere's our\
    \ version (not counting the special cases, though):\n<code>", "  s.gsub(/[aeiou]/)\
    \ do |match|\n    ((match.index(\"a\") + match.index(\"e\") + match.index(\"i\"\
    )) + match.index(\"o\") + match.index(\"u\"))/6\n  end\nend", "  upper = 0\n \
    \ idx = 0\n  while idx < s.length\n    char = s[idx]\n    if char =~ /[AEIOU]/\n\
    \      upper = upper + 1\n    end\n    idx = idx + 1\n  end\n  upper\nend", " \
    \ s.length <= 2 ? 0 : (s.scan(/[aeiou]/i).inject(:+) + 1)\nend\n</code>\n<|/ a\
    \ tags=string,ruby |>\n<| a |>\n<code>", "  s.scan(/[aeiou]/) do |char|\n    return\
    \ 0 if even? index\n    char_upper = char.upcase\n    yield(char_upper)\n  end\n\
    end", "  return s.gsub(/[aeiou]/i).length % 2 == 0 ? s.length / 2 : 0\nend", " \
    \ s.downcase!\n  s.tr!('A-Z','A').count('A')\nend", "    i = 0\n    while i <\
    \ s.length\n        ch = s[i]\n        i += 1\n        if ch == ?uppercase_vowel\n\
    \            return i\n    return 0\nend\n</code>\n<|/ a tags=ruby,python dscore=0\
    \ |>\n<| c |>\nThis solution assumes strings are ASCII.\n<|/ c |>\n<| c |>\nThanks.\
    \ I guess you meant that \"aBCdEf\" are ASCII strings. I thought they were unicode\
    \ strings, so I converted them to ascii strings. Do you think I can still convert\
    \ them to ASCII?\n<|/ c |>\n<| c |>\n: Thanks for pointing that out. I've edited\
    \ my answer accordingly.\n<|/ c |>\n<| c |>\n: It should be noted that Ruby has\
    \ `str.isalpha` for this, and `chr`/`ord` for this. Those are much more reliable\
    \ than the `?uppercase_vowel` stuff.\n<|/ c |>\n<| a tags=ruby,python dscore=0\
    \ |>\nThis should be fairly efficient (and can be easily extended for special\
    \ characters)\n<code>", "  count = 0\n  i = 0\n  while i < s.length\n    if s[i]\
    \ =~ /[AEIOU]/\n      count += 1\n    end\n    i += 1\n  end\n  count\nend", " \
    \ s, = s.split\n  s.each_index { |i| s[i] = (s[i] =~ /[AEIOU]/ ? 0 : 1) }\n  s.count('U')\n\
    end", "  s.chars.each_with_index.inject(0) { |s, (a, (i, _))| if a == \"A\" ||\
    \ a == \"E\" || a == \"I\" || a == \"O\" || a == \"U\" || (i % 2 == 0) then s\
    \ +1 end; s }\nend", "    i = 0\n    while i < s.length\n        if s[i] == \"\
    a\"\n            i += 1\n        elsif s[i] == \"A\"\n            i += 1\n   \
    \     elsif s[i] == \"e\"\n            i += 1\n        elsif s[i] == \"E\"\n \
    \           i += 1\n        elsif s[i] == \"i\"\n            i += 1\n        elsif\
    \ s[i] == \"I\"\n            i += 1\n        elsif s[i] == \"o\"\n           \
    \ i += 1\n        elsif s[i] == \"O\"\n            i += 1\n        elsif s[i]\
    \ == \"u\"\n            i += 1\n        elsif s[i] == \"U\"\n            i +=\
    \ 1\n        elsif s[i] == \"y\"\n            i += 1\n        elsif s[i] == \"\
    Y\"\n            i += 1\n        else\n            i += 1\n        end\n    end\n\
    \    return i\nend\n</code>\n<|/ q dscore=0 |>\n<| a dscore=0 |>\nIt seems you\
    \ are trying to do too much at once in the wrong place.  You don't need all those\
    \ nested if/elsif/elsif/elsif/else statements, just use plain old if/else, e.g.:\n\
    <code>", "  count0 = 0\n  count1 = 0\n  count2 = 0\n  count3 = 0\n  count4 = 0\n\
    \  count5 = 0\n  count6 = 0\n  count7 = 0\n  count8 = 0\n  count9 = 0\n  count10\
    \ = 0\n  count11 = 0\n  count12 = 0\n  count13 = 0\n  count14 = 0\n  count15 =\
    \ 0\n  count16 = 0\n  count17 = 0\n  count18 = 0\n  count19 = 0\n  count20 = 0\n\
    \  count21 = 0\n  count22 = 0\n  count23 = 0\n  count24 = 0\n  count25 = 0\n \
    \ count26 = 0\n  count27 = 0\n  count28 = 0\n  count29 = 0\n  count30 = 0\n  count31\
    \ = 0\n  count32 = 0\n  count33 = 0\n  count34 = 0\n  count35 = 0\n  count36 =\
    \ 0\n  count37 = 0\n  count38 = 0\n  count39 = 0\n  count40 = 0\n  count41 = 0\n\
    \  count42 = 0\n  count43 = 0\n  count44 = 0\n  count45 = 0\n  count46 = 0\n \
    \ count47 = 0\n  count48 = 0\n  count49 = 0\n  count50 = 0\n  count51 = 0\n  count52\
    \ = 0\n  count53 = 0\n  count54 = 0\n  count55 = 0\n  count56 = 0\n  count57 =\
    \ 0\n  count58 = 0\n  count59 = 0\n  count60 = 0\n  count61 = 0\n  count62 = 0\n\
    \  count63 = 0\n  count64 = 0\n  count65 = 0\n  count66 = 0\n  count67 = 0\n \
    \ count68 = 0\n  count69 = 0\n  count70 = 0\n  count71 = 0\n  count72 = 0\n  count73\
    \ = 0\n  count74 = 0\n  count75 = 0\n  count76 = 0\n  count77 = 0\n  count78 =\
    \ 0\n  count79 = 0\n  count80 = 0\n  count81 = 0\n  count82 = 0\n  count83 = 0\n\
    \  count84 = 0\n  count85 = 0\n  count86 = 0\n  count87 = 0\n  count88 = 0\n \
    \ count89 = 0\n  count90 = 0\n  count91 = 0\n  count92 = 0\n  count93 = 0\n  count94\
    \ = 0\n  count95 = 0\n  count96 = 0\n  count97 = 0\n  count98 = 0\n  count99 =\
    \ 0\n  count100 = 0\n  count101 = 0\n  count", "  result = 0\n  i = 0\n  while\
    \ i < s.length\n    if s[i] == \"A\" || s[i] == \"a\" then\n      result = result\
    \ + 1\n    end\n    i = i + 1\n  end\n  result\nend\n</cell>\n<text>\nThe method\
    \ count_upper takes one argument, the string, s and returns the number of uppercase\
    \ vowels in even indices. If there is no vowel at an even index, then the method\
    \ returns 0.", "  (0...s.length).detect {|i| s[i] =~ /[aeiou]/}\nend", "  return\
    \ s.length / 2 < 0 ? 0 : s.scan(/[aeiou]/).count { |m| m.to_s.upcase == \"A\"\
    \ || m.to_s.upcase == \"E\" }\nend", "  s = String(s).to_a\n  (1..s.length).map\
    \ { |i| s[i] == s[i] ? 'a' : 'A' }.inject(0) do |r, i|\n    r += 1 if s[i + 1]\
    \ == 'A'\n    r\n  end\nend", "    s.downcase!\n    s.each_char.with_index do\
    \ |c, i|\n        if i % 2 == 0\n            c >= 'A' && c <= 'Z' ? (s += 1) :\
    \ c >= 'a' && c <= 'z' ? (s += 1) : s\n        end\n    end\n    s\nend", "  \
    \  vowels = \"AEIOUYaeiou\"\n    s = 0\n    for c in s\n        if vowels.index(c)\
    \ % 2 == 0\n            s += 1 \n    end\n    return s\nend", "  return s.scan(/[A-Z][a-z]+/).inject(0)\
    \ do |n,(idx,c)|\n    n < idx+1 ? 0 : n + (c == 'A' ? 1 : 0)\n  end\nend", " \
    \ s = 0\n  for i in 0 .. s.length - 1 do\n    if s[i] = s[i] = ?\n      s += 1\n\
    \    end\n  end\n  s\nend\nfunction count_upper.call(x)\n  if x.is_a?(String)\n\
    \    x.count(?A)\n  else\n    0\n  end\nend\n</cell>\n<text>\nProblem 4\nWrite\
    \ a function that takes a string and returns the length of that string.\nA string\
    \ is a sequence of characters enclosed within square brackets, or a string surrounded\
    \ by single quotes. \nWrite a second function that takes a string and counts the\
    \ number of times a specific character appears.\nFor example, if the input string\
    \ is \"[cat]dogdogdog\", then your function should return 3, since there are three\
    \ 'c's in the string.\nUse your first function as a building block, and your second\
    \ function as an extension.", "  if s[0]==nil or s[0]=='' or s[0]==\" \"\n   \
    \ return 0\n  end\n  c=0\n  for i in 0..s.length-1\n    if s[i]==nil or s[i]==''\
    \ or s[i]==\" \"\n      return 0\n    end\n    if s[i]==\"A\" or s[i]==\"a\" or\
    \ s[i]==\"E\" or s[i]==\"e\" or s[i]==\"I\" or s[i]==\"i\" or s[i]==\"O\" or s[i]==\"\
    o\" or s[i]==\"U\" or s[i]==\"u\"\n      c+=1\n    end\n  end\n  return c\nend",
  "    return s.scan(/[a-z]/).inject(0) do |sum, item|\n        sum + item.size if\
    \ item.match?(/[aeiou]/)\n    end\nend", "  i = 0\n  while i < s.length\n    unless\
    \ s[i] == ?a\n      return 0 if i % 2 == 0\n    end\n    i += 1\n  end\n  0\n\
    end\n</code>\nTo count uppercase characters, you need to count the characters\
    \ in each run of characters starting from the first and ending with the last character\
    \ of the run. So, when counting \"aBCdEf\", there are two runs: one beginning\
    \ with \"a\" and one ending with the \"d\". The number of uppercase characters\
    \ in each run is equal to the number of times you call count_upper(\"aBCdEf\"\
    ) with that string. Thus you can do the following:\n<code>", "  evens = s.chars.take_while\
    \ { |c| c =~ /[aeiou]/ && $~.index % 2 == 0 }.count\n  odd = s.chars.take_while\
    \ { |c| c =~ /[aeiou]/ && $~.index % 2 != 0 }.count\n  evens - (odd+1)\nend",
  "  return s.count('a') + s.count('e') + s.count('i') + s.count('o') + s.count('u')\n\
    end", "\ts.scan(/[aeiou](?![aeiou]\\B)/)\n\ts.count(\"A\"..\"Z\")\nend", "  s.chars.each_with_index.inject(0)\
    \ do |total, (i, c)|\n    if c.upcase != c\n      total += 1\n    end\n    total\n\
    \  end\nend\n</code>\n(See String#each_char for details.)\n<|/ a |>\n<| c |>\n\
    Wow, I really didnt think of that, thank you so much!\n<|/ c |>\n<| c |>\n: Don't\
    \ be sorry. It's not very difficult at all.\n<|/ c |>\n<| c |>\n: I like it! \
    \ I like that `each_char` is lazy and won't scan the entire string until it needs\
    \ to.\n<|/ c |>\n<| c |>\n: That's very true, but it's not the end of the world.\
    \ If the OP needs to handle very long strings, it may be a better solution. :-)\n\
    <|/ c |>\n<| a dscore=1 |>\nFor those who are concerned about performance\n<code>",
  "\ts.scan(/./u) {|c| return c if c =~ /[A-Z]/; 0} + 1\nend", "  s.chars.each_with_index.inject(0)\
    \ do |n, (c,i)|\n    n if c == 'A'\n  end\nend", "  return s.scan(/[aeiou]/)[1].count(\"\
    aeiou\")\nend", "  # For Python3, can use s.uppercase instead of s.upper()\n \
    \ upper = s.upper()\n  count = 0\n  for i in 0...s.length\n    if s[i] == upper[i]\n\
    \      count += 1\n    end\n  end\n  count\nend", "  s.gsub(/[aeiou](?![aeiou])/,\
    \ \"\\0\").scan(/[aeiou]\\0|./).size\nend", "  s = 0\n  for i in 0...s.length\n\
    \    if s[i].upcase == true\n      s += 1\n    end\n  end\n  return s\nend", " \
    \ if s.length < 2\n    return 0\n  end\n  even_index = 0\n  for i in 0..length\n\
    \    if i % 2 == 0\n      even_index += 1\n    end\n    if s[i] != uppercase and\
    \ s[i] != lowercase\n      even_index = 0\n    end\n  end\n  return even_index\
    \ / 2\nend", "  s.upcase!\n  even = (even = s.each_char.with_object(Hash.new(0))\
    \ { |char, i| even[i.even?] += 1 }).values\n  even & (even - 1)\nend", "  s.to_s.scan(/[a-z]/\
    \ ) do |x|\n    next if x.zero?\n    ((x.index % 2).zero? ? 1 : 0) + x.upcase.length\n\
    \  end\nend", "  s.chars.to_a.chunk {|a| a[0] % 2 == 0}.count {|_, a| a.all? {\
    \ |c| c == 'A' || c == 'E' }}\nend", "\tcount = 0\n\tfor i in 0..s.length-1\n\t\
    \tif s[i] >= 'A' && s[i] <= 'Z'\n\t\t\tcount += 1\n\treturn count\nend", "   \
    \ count = 0\n    char_index = 0\n    while char_index < s.length\n        if s[char_index].upcase?\
    \ && s[char_index].ascii? && s[char_index].ascii?\n            count += 1\n  \
    \      char_index += 1\n    count\nend", "  s.split('').select { |ch| ch =~ /[AEIOUY]/i\
    \ }.map { |ch| ch.count('E') }\nend", "  s.each_char.with_index { |c,i| if i %\
    \ 2 == 0 and c.upcase == c }.length\nend", "  return s.each_index.with_index.inject(:+).to_i\
    \ \\\n  / s.each_char.with_index.inject(:+).to_i\nend\n</code>\nAnd this is how\
    \ we can get your desired result:\n<code>", "  s.downcase! # force downcase\n\
    \  s.chars.each_with_index.inject(0) do |sum, (_, index)|\n    return sum + 1\
    \ if index.even?\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this\
    \ idea. Although I think it could be simplified using Ruby's [Range#to_proc](http://ruby-doc.org/core-1.9.3/Range.html#method-i-to_proc)\
    \ method and using the splat operator: `s.chars.each_with_index.to_a.count { |(_,\
    \ index), value| index.even? && value =~ /[A-Z]/i }`\n<|/ c |>\n<| a |>\n<code>",
  "  s.chars.map { |x| x =~ /[AEIOU]/ ? 1 : 0 }.sum\nend", "  return s.chars.uniq.count(&:upcase)\n\
    end\n</code>\nThe downside of counting using chars is that we are counting all\
    \ the characters in the string, even the ones in odd indices.  To avoid this,\
    \ we can keep track of the number of characters in each position, and test if\
    \ a character is one of them.\n<code>", "    s.upcase.count('a'..'z')\nend", " \
    \   s.gsub(/(^|[^a-z])([A-Z])/) do\n        $2.succ\n    end\nend", "  s.downcase!\n\
    \  s.each_char do |c|\n    return 0 if c == c.upcase and c != c.downcase\n  end\n\
    \  s.count(\"A\"..\"Z\")\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c |>\n\
    You don't need the `each_char` call.  `s.downcase!; s.count(\"A\"..\"Z\").count(\"\
    a\"..\"z\")` will do just fine.\n<|/ c |>\n<| c |>\nSweet solution! It will also\
    \ avoid the nasty bug that would happen if you used `each_char` instead of `each_char.to_a`.\n\
    <|/ c |>\n<| a |>\nOne could use gsub, gsub!, and String#count:\n<code>", "  \
    \  i = 0\n    while i < s.length\n        if s[i] == ?u\n            i += 1\n\
    \        elsif i % 2 == 0\n            i += 1\n        else\n            i = 0\n\
    \        end\n    end\n    s.length == i\nend", "  s.each_char do |c|\n    (c.upcase\
    \ + c).to_i.even?\n  end\nend", "  s.scan(/[A-Z][A-Z]+/).inject(0) { |s, x| s+1\
    \ if x[-1]==\"A\" or x[-1]==\"E\" }\nend", "  return s.upcase.scan(/[AEIOU]/).inject(0)\
    \ do |sum, i|\n    return sum if i % 2 == 0\n    sum + 1\n  end\nend", "    s.split(\"\
    \").map {|char| char.upcase }.select {|char| char == \"A\"} .count\nend", "  count\
    \ = 0\n  for i in 0...s.length\n    if s[i] >= 'A' && s[i] <= 'Z'\n      count\
    \ += 1\n    end\n  end\n  return count\nend", "  s.gsub(/[aeiouy]/, '').size.odd?\
    \ ? 0 : 1\nend", "    i = 0\n    while i < s.length\n        if s[i...].include?((\"\
    A\", \"E\", \"I\", \"O\", \"U\"))\n            i += 1\n        else\n        \
    \    i += 1\n        end\n    end\n    return i\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nI really like the look of your code, although the output is not what I was\
    \ expecting. I am looking for a return value that would tell me how many times\
    \ a vowel is repeated in the string.\n<|/ c |>\n<| c |>\nThe code now returns\
    \ a count. As your question indicates, I assumed you wanted to know the number\
    \ of times a vowel was repeated.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>",
  "    count = 0\n    (index, _) = s.partition('a')\n    if index == nil\n       \
    \ return count\n    (index, _) = index.partition('e')\n    (index, _) = index.partition('i')\n\
    \    (index, _) = index.partition('o')\n    (index, _) = index.partition('u')\n\
    \    if index == nil\n        return count\n    count += 1\n    return count\n\
    end", "  return s.downcase.scan(/[AEIOU]/).size % 2 == 1\nend", "  return s.downcase.count(\"\
    A\") + s.downcase.count(\"E\")\nend", "  i = 0\n  while i < s.length\n    # If\
    \ the letter is uppercase:\n    if s[i].upcase == 1\n      # Increment the counter:\n\
    \      i += 1\n      # Then skip to the next letter:\n      i += 1\n    end\n\
    \  end\n  # Return the counter value:\n  return i\nend", "  # do it in one line\n\
    \  s.scan(/[a-z]/) do |a|\n    next if a.nil?\n    a[-1].upcase!\n  end\nend\n\
    </code>\n<|/ a |>\n<| a |>\nRuby has a method to detect characters in strings:\n\
    <code>", "  even.count(s[0,1]).call(0)\nend", "  s.scan(/[a-z]/i) do |match|\n\
    \    match.odd? ? 0 : 1\n  end\nend", "  return s.gsub(/[AEIOU]/, '').length\n\
    end\n</cell>\n<code language=julia-1.0>", "  s.scan(/[a-z]+/).flatten.uniq.select\
    \ { |x| (x.downcase == 'a' || x.downcase == 'e' || x.downcase == 'i' || x.downcase\
    \ == 'o' || x.downcase == 'u') }.size\nend", "  s.tr!(\"A-Z\",\"A\")\n  s.count(\"\
    A\")\nend", "    count = s[0] - 'A'\n    for i in 2..s.length-1\n        count\
    \ += s[i] == 'A' ? 0 : s[i] == 'a' ? 1 : s[i] == 'e' ? 2 : s[i] == 'I' ? 3 : s[i]\
    \ == 'o' ? 4 : s[i] == 'U' ? 5 : 0\n    count\nend\n</cell>\n<code language=julia-1.6>",
  "  count = 0\n  s.chars.each_with_index do |x, i|\n    break if i % 2 == 0 && x\
    \ =~ /[AEIOUYaeiouy]/\n    count += 1\n  end\n  count\nend\n</code>\nIf you have\
    \ a long string, then instead of looping through each character (as above - with\
    \ each_char), you can use a faster character iterator like each_char (which creates\
    \ a lazy enumerator) with a predicate that stops the enumeration if the character\
    \ is uppercase vowel.\n<code>\ncount_upper = proc do |s|\n  s.each_char.with_object(0)\
    \ do |x, count|\n    break if x == 'A' || x == 'O' || x == 'E' || x == 'I' ||\
    \ x == 'U'\n    count += 1\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    This is nice but I am not very experienced with proc. How would I write this with\
    \ a proc?\n<|/ c |>\n<| c |>\nI added an example using a `proc`.\n<|/ c |>\n<|\
    \ a dscore=2 tags=ruby,string |>\nThis is a possible implementation:\n<code>",
  "  s.chars.each_with_index.inject(0) { |sum, (e, i)| sum + 1 if i % 2 == 0 && e.upcase\
    \ == e }\nend", "  return s.each_char.with_index.reduce(0) do |sum, (_, i)|\n\
    \    if i.odd? and i.char.upcase == \"A\"\n      sum += 1\n    end\n    sum\n\
    \  end\nend", "  s.scan(/[aeiou]/)\n  s.length.odd? ? 0 : 1\nend\n</code>\nThe\
    \ same pattern can be applied to the count_lower method which counts the number\
    \ of lowercase letters in a string. \n<code>", "  s.each_char.with_index.with_index\
    \ do |char, index|\n    if index % 2 == 0\n      char.upcase!\n      true\n  \
    \  end\n  end\n  s.length\nend", "\ts.gsub!(/[^aeiou]/, '') \n\ts.gsub!(/[aeiou]/)\
    \ {|c| c =~ /e/ ? 2 : 1}\n\ts.chars.inject{ |t,c| t + 1 }\nend\n  ", "  return\
    \ s.scan(/[AEIOU]/).count(&:odd?)\nend", "  s.chars.each_with_index do |c, i|\n\
    \    if i % 2 == 0 && c.upcase == c\n      yield i + 1\n    end\n  end\nend",
  "  return s.count.upcase\nend", "  s.chars.each_with_index.reduce(0) do |t, (ch,\
    \ i)|\n    t.zero? if i % 2 != 0\n    t.update(ch.upcase) if ch.upcasecase?\n\
    \    t\n  end\nend", "  count = 0\n  s.each_char.with_index do |c,i|\n    if i.even?\
    \ and c == 'A'\n      count += 1\n    end\n  end\n  count\nend\n</code>\nA variation\
    \ on this approach is to build a hash containing the number of occurrences of\
    \ each letter, and then return 1 if the hash has a value greater than 0.\n<code>",
  "  i = 0\n  upper = Set.new\n  while i < s.length\n    if s[i] == 'A'\n      i +=\
    \ 1\n      upper.add s[i]\n    else\n      i += 1\n    end\n  end\n  upper.length\n\
    end", "  s.split('').map{|char| char.upcase! unless char == char.upcase}.count('a'..'z')\n\
    end", "  s.chars.inject(0) {|s,c| s if c.upcase } % 2\nend\n</code>\nThe inject\
    \ method takes a block to execute on each element of the collection. In the example\
    \ above I use the % operator to return the count of even-indexed elements but\
    \ the final value is returned by the block. Alternatively, you can use inject{...}\
    \ to return the count of even elements in a single statement:\n<code>\ns.chars.inject(0)\
    \ {|s,c| s if c.upcase }\n</code>\n<|/ a dscore=5 tags=ruby |>\n<| a tags=ruby\
    \ dscore=5 |>\nOne can use #each_char method and Enumerable#count method:\n<code>\n\
    \"aBCdEf\".each_char.count { |c| c == \"A\" || c == \"a\" }", "  s.scan(/../)\n\
    \  s.scan(/[aeiouy]/)\n  s.scan(/[AEIOUY]/)\n  s.count(\"U\") - (s.count(\"a\"\
    ) + s.count(\"e\") + s.count(\"i\") + s.count(\"o\") + s.count(\"u\"))\nend\n\
    </code>\n<|/ a tags=ruby dscore=1 |>\n<| a dscore=1 |>\n<code>", "  return s.chars.each.with_object(Hash.new(0))\
    \ { |c, h| h[c] +=1 ; h[c] > 1 }.invert[0]\nend", "  return s.gsub(/([a-z])/)\
    \ { $1 + $1.upcase }.length\nend\n</code>\nThe advantage of this solution is that\
    \ the regex does not need to be compiled; it can be passed as an argument to String#gsub\
    \ (i.e. a closure). Also, the regex only needs to match a single character each\
    \ time (+1 instead of +). Also, the regex does not need to capture any groups\
    \ (i.e. $1, $2, etc.).\n<|/ a |>\n<| c |>\nI like the use of the closure, and\
    \ I'm sure that this is much faster than the OP's solution, especially on longer\
    \ strings. I haven't tested it though.\n<|/ c |>\n<| a dscore=4 tags=ruby,string\
    \ |>\nYou might want to consider a case-insensitive regex to find each vowel,\
    \ then use a simple string comparison. Here's an example:\n<code>\n'aAbcDef'.scan\
    \ /[aeiou]/", "    i = 0\n    s.each.with_index do |e, _|\n        if e == \"\
    B\"\n            i += 1 if (i % 2 == 0)\n        elsif e == \"E\"\n          \
    \  i += 1 if (i % 2 == 1)\n        end\n    end\n    return i\nend\n</code>\n\
    <code>", "  even = s.chars.map { |c| (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' ) ? 1 : 0 }.inject(:+)\n  odd =  s.chars.map { |c| (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' ) ? 0 : 1 }.inject(:+)\n  (even\
    \ + odd) / 2\nend", "  s.each_index.map { |i| s[i] == ?A ? 1 : 0 }.inject(:+)\n\
    end", "  s.split(\"\").map.with_index {|c,i| i % 2 == 0 ? c.upcase : c.downcase}.length\n\
    end", "  s.downcase!\n  (s.length * [\"\"]).fill do |i|\n    c = s[i]\n    (c\
    \ >= 'A' && c <= 'Z') ? i + 1 : i\n  end\nend", "  s.scan(/[Aa](?=[BbCcDdEeGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz])/)\n\
    end", "    i = 0\n    while i < s.length\n        if s[i].is_a? String\n     \
    \       if s[i] == s[i]+s[i]\n                i += 1\n            else\n     \
    \           i += 1\n        else\n            i += 1\n    end\n    return i\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYes, that works well. But it doesn't\
    \ work when I add another if statement to check if s[i] is equal to s[i]+s[i]\
    \ or s[i] is equal to s[i]+s[i]+s[i]\n<|/ c |>\n<| c |>\nOkay, I understand why\
    \ it is doing that, but I don't know how to fix it.\n<|/ c |>\n<| c |>\nI've edited\
    \ my answer, I hope it helps.\n<|/ c |>\n<| c |>\nThanks so much for the help!\
    \ This works perfectly but now the code doesn't work for strings longer than 2\
    \ characters. For example, this works fine for strings of length 4 or 5. I was\
    \ thinking I could add an if statement that would check if s.length is > 2. And\
    \ that if statement would not increment i if s[i] was equal to s[i]+s[i] or s[i]+s[i]+s[i].\n\
    <|/ c |>\n<| c |>\nOh right, sorry, my mistake. I just updated the code. It should\
    \ work for longer strings now!\n<|/ c |>\n<| a |>\n<code>", "  s.gsub!(/[a-zA-Z]/)\
    \ { |c| c[0].upcase } if s.length > 0\n  s.length.to_i\nend", "  count = 0\n \
    \ s.each_byte do |byte|\n    if (byte >= 0x41 && byte <= 0x5A)\n      count +=\
    \ 1\n    end\n  end\n  return count\nend\n</code>\nI should also note that Ruby\
    \ has a built-in method called String#gsub that can be used to replace a single\
    \ string with another, like so\n<code>\ns.gsub!('b','')\n</code>\nbut this will\
    \ not replace all instances of the letter 'b', instead it will replace each occurrence\
    \ of 'b' with the empty string. For example, if you were to run s.gsub!('b','c'),\
    \ you would get 'ccccccc' as the output. The gsub! method returns 's' for convenience\
    \ so that you can chain together multiple string operations together. \nFor this\
    \ example, we can use gsub!('b','').gsub!('c','') to remove all the 'b's and then\
    \ remove all 'c's.\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThis won't work. `gsub`\
    \ will replace the entire string, not just parts of it.\n<|/ c |>\n<| c |>\n`gsub!`\
    \ will, yes.\n<|/ c |>\n<| c |>\n`gsub!` doesn't return the original string, which\
    \ is why I mentioned that you could use chaining so that your new string could\
    \ still be used later if you need it, but I should have clarified that in the\
    \ answer.\n<|/ c |>\n<| c |>\nAh, I missed that part about the requirements to\
    \ return `0`. I updated the answer to reflect that now. Thanks for the feedback.\n\
    <|/ c |>\n<| a dscore=0 |>\nI would do it this way\n<code>", "  s.chars.map.with_index\
    \ do |c,i|\n    (i % 2 == 0 && c == \"A\") || c == c.upcase ? 1 : 0\n  end\nend",
  "  s.count('a'..'z').inject(0) { |m, c| m + (c == 'A' ? 1 : 0) }\nend\n</code>\n\
    If you know Ruby's inject method, you can also do the following:\n<code>", " \
    \ s.scan(/[AEIOU]/).size\nend\n</code>\n<|/ a tags=regex,ruby dscore=2 |>\n<|\
    \ c |>\nNice solution! I love the use of `Enumerable#scan`. +1\n<|/ c |>\n<| a\
    \ dscore=2 |>\nI would go for:\n<code>", "  return s.scan(/[A-Z]/).inject(0) do\
    \ |count,match|\n    match ? 0 : count + 1\n  end\nend", "  return s.count(\"\
    A\") + s.count(\"a\") + s.count(\"E\") + s.count(\"e\") + s.count(\"I\") + s.count(\"\
    i\") + s.count(\"O\") + s.count(\"o\") + s.count(\"U\") + s.count(\"u\")\nend",
  "  s.gsub(/[a-z]/) do |c| \n    next c unless c.upcase && c[0,1] == c.upcase\n \
    \   c.size == 1 ? 0 : c[0,1] == c.upcase ? 1 : 2\n  end\nend", "  i = 0\n  while\
    \ i < s.length\n    char = s[i]\n    if char.upcase == char.downcase\n      i\
    \ += 1\n    else \n      i += 1\n  end\n  return i\nend", "  count = 0\n  s.each_index\
    \ {|i| count += s[i].upcase if i.even? }\n  count\nend\n</pre>\n<p>\nThe <code>each_index</code>\
    \ method is also available as an instance method on\n<code>String</code>:\n</p>\n\
    <pre>", "  s.chars.each_with_index.reduce(0) do |sum, (letter, i), r| \n    (i\
    \ % 2).zero? && (sum + ord(letter).upcase == ord(r).upcase) ? sum + 1 : sum\n\
    \  end\nend", "  s.each.with_index(1).with_object(0) do |char, index|\n    index\
    \ += 1 if char.upcase == \"A\"\n    next\n  end\nend", "  count = Hash.new(0)\n\
    \  each_char(s,\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch| count[ch.upcase]\
    \ += 1; },\n    proc{|ch| count[ch.upcase] += 1; },\n    proc{|ch", "\ts.downcase!\n\
    \ts.scan(/[AEIOUaeiou]/)\n\ts.size.times{ |i| s[i].upcase! }\n\ts.count{ |i| s[i].upcase\
    \ == s[i] }\nend", "  s.scan(/[aeiou]/)\n  s.count {|x| x == \"A\" || x == \"\
    E\" || x == \"I\" || x == \"O\"}\nend", "  s.each_char.with_index.inject(0) {\
    \ |c, (a,i,b)| a + (c == 'A' && i % 2 == 0) }\nend", "  count = 0\n  s.each_char.with_index\
    \ do |char, index|\n    if index%2 == 0 && char.upcase != char\n      count +=\
    \ 1\n    end\n  end\n  count\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks\
    \ Kevin for your time!\n<|/ c |>\n<| c |>\nHi Kevin, I got the below error when\
    \ I tried your code with Ruby 2.4.  ", "  s.scan(/[AEIOU]/)\n  s.count.nonzero?\n\
    end", "  s.gsub(/[aeiou]/).with_index { |match, index| index.odd? ? match : nil\
    \ }.length\nend", "  s.downcase!\n  even = s.each_char.with_index { |c,i| i %\
    \ 2 == 0 }\n  even.inject(0) { |c,_| c += 1 if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u'}\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
