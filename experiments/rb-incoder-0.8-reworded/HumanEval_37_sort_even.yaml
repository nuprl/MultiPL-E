name: HumanEval_37_sort_even
language: rb
prompt: "# This function takes an array l and returns an array l' such that\n# l'\
  \ is identical to l in the odd indicies, while its values at the even indicies are\
  \ equal\n# to the values of the even indicies of l, but sorted.\n# >>> sort_even.call([1,\
  \ 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n\
  \    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1,\
  \ 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5,\
  \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12,\
  \ 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\n\
  end\n"
completions: ["  even = l.select { |x| x % 2 == 0 }\n  odd = l.select { |x| x % 2\
    \ != 0 }\n  even.zip(odd).flatten\nend\n</code>\nNow all we need to do is call\
    \ the function twice, to sort both odd and even numbers:\n<code>\nodds = sort_odd.call(l)\n\
    evens = sort_even.call(l)\n</code>\nAnd we're done:\n<code>\n$ irb\n>> odds =\
    \ sort_odd.call([5, 6, 3, 4])\n>> evens = sort_even.call([5, 6, 3, 4])\n>> p odds\n\
    [3, 5, 6, 4]\n>> p evens\n[3, 5, 6, 4]\n>> \n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nI like your solution. It makes me think of using `collect` to create\
    \ a hash and then `sort_by` to sort it by value. That way you avoid creating lots\
    \ of arrays, just as you were already doing. That would also mean that you wouldn't\
    \ need the `to_a` at the end, since `sort_by` would return a hash. I'll try to\
    \ write up an example shortly, but I like your solution!\n<|/ c |>\n<| c |>\n\
    Nice one! I like that `sort` method too, but I like my `sort_even` function better.\
    \ That's a nice example of how one can use `select`, but `select` isn't the right\
    \ tool for the job.\n<|/ c |>\n<| a |>\nThis should work for you:\n<code>", " \
    \ return l[l.index(l[0]):]\nend\n</code>\nHere's my attempt at a solution:\n<code>\n\
    function sort_even(l)\n  l = sort_even.(l, l)\n  l\nend", "  even = l.select {\
    \ |x| x % 2 == 0 }\n  odd = l.select { |x| x % 2 == 1 }\n  odd.zip(even).sort.flatten\n\
    end", "  even = []\n  odd = []", "  l.each_with_index do |e, i|\n    if i.odd?\n\
    \      l[i] = e\n    end\n  end\n  l\nend", "  l.each_with_index do |el, index|\n\
    \    next if index&1 \n    l.delete_at(index)\n    l.insert(index, el)\n  end\n\
    end", "  even = Array.new\n  odd = Array.new", "  l.each.with_index do |x, i|\n\
    \    if i % 2 == 0\n      l[i] = x.send(:<=>)\n    end\n  end\n  l\nend", "  l.sort_by\
    \ { |v| v % 2 }\nend", "  l = [*l]\n  even = []\n  odd = []\n  for i in (0...l.length)\n\
    \    even << l[i..(i+1)]\n    odd << l[i..(i+1)]\n    even.sort!\n    odd.sort!\n\
    \    even.each{|x| odd << x}\n    odd\n  end\nend", "  even = l[1..-1].each_with_index.reduce(:+)\n\
    \  odd =  even.each_with_index.reduce(:+)\n  [odd, even.sort]\nend", "  even =\
    \ l.clone\n  even.sort.reverse\n  even.each_with_index do |e, i|\n    (i + 1)\
    \ % 2 != 0 && even[i] = e\n  end\n  return even\nend", "  even = Array.new\n \
    \ odd = Array.new\n  for i in 0...l.length-1\n    if (i.even?)\n      even <<\
    \ l[i]\n    else\n      odd << l[i]\n    end\n  end\n  even.concat(odd.sort_by!(&:to_i))\n\
    end", "  l.map { |i| (i & 1).zero? ? i : nil }.compact.reverse\nend", "  l.sort.with_index\
    \ { |element, index|\n    index % 2 == 0 ? element : element\n  }\nend", "  even\
    \ = []\n  odd = []\n  i = 0\n  while i < l.length\n    if i % 2\n      odd <<\
    \ l[i]\n    else\n      even << l[i]\n    end\n    i += 1\n  end\n  even.sort_by!\
    \ { |x| x }\n  odd + (even - even)\nend", "  return l.sort_by { |e| e % 2 == 0\
    \ }.uniq\nend\n</cell>\n<text>\nThe sort_even function works by applying a method\
    \ sort_by to array l, and passing lambda { |e| e % 2 == 0 } to sort_by. sort_by\
    \ will then return a sorted version of array l, but will include only even numbers\
    \ (odd numbers stay in their original order). Then uniq is used to remove duplicate\
    \ values from array l.", "  odd = l.select { |x| x % 2 == 0 }\n  even = l.select\
    \ { |x| x % 2 == 1 }\n  odd.zip(even).flatten\nend", "  l.each_with_index do |e,\
    \ i| l[i] = l[i].sort { |a, b| a <=> b } if i.odd? end\n  l\nend", "  l2 = Array.new(l.length)\n\
    \  i = 0\n  l2.length = l.length\n  while i < l.length\n    if i.odd?\n      l2[i]\
    \ = l[i]\n      i += 1\n    else\n      l2[i / 2] = l[i]\n      i += 1\n    end\n\
    \  end\n  l2\nend", "  even_indices = 0..l.size - 1\n  even_values = l.values_at(*even_indices)\n\
    \  sorted_even_indices = even_indices.sort\n  sorted_even_values = even_values.sort\n\
    \  sorted_l = l.slice!(*sorted_even_indices, *sorted_even_indices)\n  sorted_l.values_at(*sorted_even_indices).zip(sorted_even_values).each\
    \ { |v| v.shift }\n  sorted_l\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nHere's\
    \ a general solution that should work for any array (though I haven't tested it\
    \ exhaustively).\n<code>", "  l.sort_by!(&:odd?)\n  l\nend", "  l.each_index do\
    \ |i|\n    if i.odd?\n      l[i] = l[i].sort\n    end\n  end\n  l\nend", "  evens\
    \ = l.select.{|i| i%2 == 0}\n  evens.sort.merge(evens)\nend", "  n = l.length\n\
    \  l.sort!\n  l[1...n].uniq!\n  return l\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ dscore=0 |>\n<| c |>\nThat `sort_even` looks really nifty. It would be useful\
    \ to add a small comment/explanation of what it's doing\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ dscore=0 |>\nI realize this is an old question, but for anyone else who comes\
    \ across this, I like doing it this way:\n<code>", "  l.each_index {|i| l[i] =\
    \ l[i].sort {|a, b| b - a} if i % 2 == 0}\n  l\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for your answer! I appreciate it. What you suggest is more intuitive\
    \ to me than the one I was using, but I appreciate you going over what I was doing\
    \ wrong. I'm just trying to understand how the `.each_index` works and why it\
    \ works this way.\n<|/ c |>\n<| c |>\nNo problem. `.each_index` just iterates\
    \ over the items in the array and passes an index to each block (the block's curly\
    \ braces). You could say that each block is being passed an index, which it then\
    \ uses within the block to access a specific index of the array. Hope that makes\
    \ sense.\n<|/ c |>\n<| c |>\nAha, that makes sense. Thank you again!\n<|/ c |>\n\
    <| a tags=ruby,arrays,sorting dscore=1 |>\nThis solution is more in line with\
    \ Ruby conventions, by using a block (lambda) within the sort method:\n<code>",
  "  even, odd = l[0...-1], l[1...-1]\n  even.each_index { |i| odd << even[i] if even[i]\
    \ % 2 == 1 }\n  even\nend", "  even.call(l)\n  even.map! { |e| e[even.index(e)]\
    \ }\nend", "  l.each_with_index do |x, i|\n    if i % 2 == 1\n      l[i] = l[i]\n\
    \    else\n      l[i] = l[i-1]\n    end\n  end\n  l\nend", "  if l.length == 0\n\
    \    l.push(0)\n    l.push(0)\n  end\n  \n  l = l.dup\n  \n  l.map! {|x| x ==\
    \ l.last ? x : (x - 1)}\n  l.map! {|x| x == l.last ? x : (x + 1)}\n  \n  return\
    \ l\nend", "  l.sort!\n  (1...l.length).each do |i|\n    l.delete_at(i)\n  end\n\
    \  l\nend", "  l.each_with_index do |val, index|\n    if index % 2 == 0\n    \
    \  l[index] = val\n    end\n  end\nend", "  l.sort!\n  return l\nend", "    even\
    \ = l[1..-1]\n    even.sort { |x, y| x <=> y }\n    even\nend", "  # sort the\
    \ odd indicies of l\n  l = [l[i] for i in [1..(l.length-1/2)]] \n  \n  # take\
    \ the first element of every even indicies of l\n  # and put them all into l'\
    \ at the even indicies\n  l.inject {|s,e| l[s] += e}\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe OP wants the elements at even indices to appear *before* the\
    \ odd ones. Your example outputs them after.\n<|/ c |>\n<| c |>\nYou are right...\
    \ My mistake... I fixed my code now :)\n<|/ c |>\n<| c |>\nThanks. I really like\
    \ this approach. It's very simple and easy to understand.\n<|/ c |>\n<| a |>\n\
    In Ruby, we could write the function like this:\n<code>", "  l.sort.with_index\
    \ { |x, i| i == l.size / 2 ? x : x.to_i }\nend", "  # Sort the even-indicies in\
    \ l\n  even = l[1..-1]\n  # Sort even-indicies in l\n  even.sort! # Ruby 1.9 only!\n\
    \  # Return the even-indicies in l\n  even\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nThe question was about arrays, not hashes. I wanted to sort using an index.\n\
    This code does it:\n<code>", "    even = l.select.{|i| i%2 == 0}\n    odd = l.select.{|i|\
    \ i%2 != 0}\n    odd.zip(even).sort.reduce(:+)\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This does not work if the original list is less than the minimum size in the \"\
    even\" array. For example, for `l = [1,2,3,4,5,6,7]`, this returns `[3, 3, 2,\
    \ 2, 2, 1]`\n<|/ c |>\n<| c |>\nThis was my initial approach, however I was working\
    \ in Ruby 1.8.7, so unfortunately this does not work in my current version.\n\
    <|/ c |>\n<| c |>\n- You asked for an algorithm, I provided the Ruby equivalent.\
    \ Also, you did not specify which version of Ruby you were using in the first\
    \ place.\n<|/ c |>\n<| c |>\nI was using the Ruby version 1.8.7 when I wrote my\
    \ comment :)\n<|/ c |>\n<| c |>\n- I changed my answer to reflect the changes\
    \ in your Ruby version.\n<|/ c |>\n<| a tags=ruby,arrays,sorting dscore=4 |>\n\
    Here is my version:\n<code>", "  l.sort!\n  l.each_with_index do |val, idx|\n\
    \    unless idx % 2 == 0\n      l[idx] = val\n    end\n  end\n  l\nend", "  even\
    \ = l.dup\n  even.sort!\n  even.each_with_index do |v,i|\n    if i % 2 == 0\n\
    \      even[i] = v\n    end\n  end\n  even\nend", "  even = l[1..-1]\n  even.map!(&:to_i)\n\
    \  even.sort!(&:abs)\n  even\nend", "  l'.zip(l).map { |a, b| a % 2 == 0 ? [b,\
    \ a] : b }\nend", "  even = l.delete_at(l.size / 2)\n  even.sort!\n  return even\
    \ + l.take_while { |e| e < even }\nend", "  return l[(l % 2).floor] * l\nend",
  "  l.sort.call(l.indices, l.values.dup.sort_by(l.indices.first))\nend", "  even\
    \ = l.select.with_index { |e, i| i % 2 == 0 }.sort\n  odd = l.select.with_index\
    \ { |e, i| i % 2 == 1 }.sort\n  even.concat odd\nend", "  l.sort\n  even_l = even_indexes(l)\n\
    \  even = even_l.map { |i| l[i] }\n  even_l.map { |i| l[i] = even[i] }\n  l\n\
    end", "  l.sort!\n  l[0..-1].each_index { |i| l[i] > l[i+1] ? l[i], l[i+1] = l[i+1],\
    \ l[i] }\n  l\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nThis is a general\
    \ solution for any kind of enumerable object, including hashes.\n<code>", "  even_indices\
    \ = l.each.with_index(1).reject { |e, i| i % 2 == 1 }\n  even_values = even_indices.each.with_object([])\
    \ { |(e, i), a| a << l[e] }\n  even_values.sort_by!(&:first)\n  even_indices.each\
    \ { |i| l[i] = even_values[i] }\nend", "  even = l\n  odd = l", "  if l.length\
    \ > 0\n    l.sort.call\n    l[2..-1].sort\n  end\n  l\nend", "  # This uses some\
    \ clever list comprehension magic that takes advantage of short-circuit evaluation\n\
    \  # of conditionals\n  return [x for _, b in sorted(enumerate(l), key=lambda\
    \ x: (not x[1], x[0]))\n          for x in b]\nend\n</cell>\n<text>\nNow we have\
    \ everything we need to call these functions to sort our input array. Let's start\
    \ with a small and simple example and build from there.", "  l.sort.call([]) {\
    \ |i| (l.index i) % 2 ? 0 : i }\nend", "  l.sort.call\n  l.reverse!\n  l[1..-1].sort.call\n\
    \  l\nend", "  even = l.select {|e| e % 2 == 0 }\n  even.each { even.delete(e)\
    \ }\n  even\nend\n</cell>\n<text>\nNow let's test our sort function.", "  even\
    \ = []\n  odd = []", "  even = []\n  odd = []\n  for i in l\n    if i % 2 == 0\n\
    \      even.push(i)\n    else\n      odd.push(i)\n    end\n  end\n  even.concat(odd.sort_by{\
    \ |i| i })\nend", "  l'.each do |i|\n    l'.delete_at(i)\n  end\n  l'.insert(l'.length\
    \ / 2, *l'.sort)\n  l'\nend", "  even = l.dup\n  even.sort.with_index { |x, i|\
    \ x.even? ? i.even? : i.odd? ? even.push(x) : even.shift(x) }\n  even\nend\n</code>\n\
    <|/ a dscore=4 tags=ruby,arrays,sorting |>\n<| c |>\nThe original question asked\
    \ for something that returns a new array, rather than mutating the existing array.\
    \ Your answer doesn't allow that.\n<|/ c |>\n<| c |>\nThis is also O(n^2) since\
    \ it creates a temporary array in sort_even.\n<|/ c |>\n<| c |>\nYeah, I'm too\
    \ lazy to fix it, but I figured it wouldn't be too hard to fix, given the answers\
    \ already posted here.\n<|/ c |>\n<| c |>\nThe first part of your code is broken\
    \ in some cases. If you have `[\"a\", \"b\", \"c\", \"d\", \"e\"]` then `sort_even.call([4,\
    \ 5, 3, 2, 1])` returns `[\"c\", \"d\", \"e\", \"b\", \"a\"]`. You probably should\
    \ change your `sort_even` method to take a `&block` instead of a `lambda`\n<|/\
    \ c |>\n<| c |>\nThanks for your feedback. I've fixed the code since it didn't\
    \ take into account `[\"a\", \"b\", \"c\", \"d\", \"e\"].sort_by`.\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>", "  sort_even = l.clone\n  sort_even.each_index do |i|\n\
    \    if i%2 == 1\n      sort_even[i] = l[i].clone\n    end\n  end\n  sort_even\n\
    end", "  odd = 1\n  even = 0\n  l.each_with_index do |value, index|\n    if index\
    \ % 2 == 0 then\n      even = value\n    else\n      odd = value\n    end\n  end\n\
    \  \n  l[(even - 1) + ((odd - even) / 2)]\nend", "    even = l[1::2]\n    odd\
    \ = l[0::2]\n    even.zip(odd).sort.each { |(a,b)| even.insert(a.next, b) }\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis works, but is very inefficient,\
    \ because it requires 2 passes over the list. Try it with a list with 1000 elements\
    \ and you will find out why.\n<|/ c |>\n<| c |>\nI tested and confirmed the speed\
    \ difference, even for large lists.  I posted my code in the original question.\n\
    <|/ c |>\n<| a dscore=2 |>\nThis is an old question, but I just wrote this for\
    \ Python 3, and it seems to do exactly what you want:\n<code>", "  sorted = []\n\
    \  odd = l.select { |i| i.odd? }\n  even = l.select { |i| i.even? }\n  even.each\
    \ { |e| sorted.unshift(e) }\n  sorted.concat(odd)\nend", "  l.length.times do\
    \ |index|\n    index = l[index].odd? ? 0 : index\n    l[index], l[index + 1] =\
    \ l[index + 1], l[index]\n  end\n  l\nend", "  # Sort from smallest to largest\n\
    \  l.sort!\n  # Return an array with all the even indicies equal to the even indicies\
    \ of l\n  even = l.map.with_index { |e, i| i % 2 == 0 }\n  even.zip(l).sort.flatten\n\
    end", "  evens = l.select { |i| i % 2 == 0 }\n  evens.each { |i| evens.shift;\
    \ evens.unshift(i) }\n  evens\nend", "  sorted = []\n  even_index = 0\n  odd_index\
    \ = 1", "  l.each_with_index { |val, i| l[i] = val if i%2 == 0 }\n  l.sort!\n\
    \  l.each_with_index { |val, i| l[i] = val if i%2 == 1 }\n  l\nend", "  l.sort.call(l[0..].each_with_index)\
    \ do |l, index|\n    (index&1) == 0\n  end \nend", "  return l.sort.call([0,1].zip(l))\n\
    end\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nIt might be worth mentioning\
    \ that you can also use `.each_index` instead of `.each` here, but this solution\
    \ seems cleaner. `sort_even.call([1, 2, 3]).each_index {|i| l[i] = l[i].sort.call([0,1].zip(l[i]))\
    \ }`\n<|/ c |>\n<| c |>\nI agree. Edited my answer to include that.\n<|/ c |>\n\
    <| c |>\nThat would be a good improvement, though it might not be as readable.\
    \ Thanks :)\n<|/ c |>\n<| a tags=arrays,ruby dscore=0 |>\nI solved this way:\n\
    <code>", "  l' =  l[1..-1]\n  l' << l[0..-2].sort.reduce(:+)\nend", "  even =\
    \ l[1..-1]\n  odd = l[1..-1].sort_by { |i| i.odd? }\n  even + odd\nend", "   \
    \ even = l[1..-1]\n    odd = l[0..-2]\n    even.zip(odd).sort\nend", "  l1 = l.clone\n\
    \  even = []\n  odd = []\n  while l1.length > 0\n    even.push(l1.shift)\n  end",
  "    even = []\n    odd = []\n    \n    for x in l\n        if x % 2 == 0\n    \
    \        even << x\n        else\n            odd << x\n        end\n    end\n\
    \    \n    even + odd\nend\n</code>\nHere are the tests I am running in Rspec\
    \ and I am expecting to fail.\n<code>\ndescribe \"sort_even function\" do\n  \
    \  before do\n        sort_even.call([3, 2, 1])\n        sort_even.call([10, 20,\
    \ 10, 5])\n        sort_even.call([20, 10, 10, 10])\n        sort_even.call([5,\
    \ 6, 3, 4])\n        sort_even.call([10, 20, 10, 5])\n    end\n    \n    it \"\
    sorts even indicies first and odd indicies second\" do\n        [10, 20, 10, 5].should\
    \ == sort_even([10, 20, 10, 5])\n        [5, 6, 3, 4].should == sort_even([5,\
    \ 6, 3, 4])\n        [10, 20, 10, 5].should == sort_even([20, 10, 10, 10])\n \
    \   end\n    \n    it \"sorts values correctly with even indicies first\" do\n\
    \        [3, 2, 1].should == sort_even([3, 2, 1])\n        [5, 6, 3, 4].should\
    \ == sort_even([5, 6, 3, 4])\n        [20, 10, 10, 10].should == sort_even([20,\
    \ 10, 10, 10])\n    end\nend\n</code>\n<|/ q tags=ruby |>\n<| c |>\nI do not see\
    \ any \"odd indicies\" in your code. Are you looking for `[10, 20, 10, 5].should\
    \ == sort_even([10, 20, 10, 5]).sort.uniq`?\n<|/ c |>\n<| c |>\nWhat is your question?\n\
    <|/ c |>\n<| c |>\nYour code looks like an attempt at a [selection sort](https://en.wikipedia.org/wiki/Selection_sort).\
    \ Please clarify what the question is.\n<|/ c |>\n<| c |>\nI apologize for the\
    \ confusion. I am looking for the test to fail.\n<|/ c |>\n<| c |>\nI am confused\
    \ too. Why would you expect that to fail? It is sorting numbers in ascending order\
    \ (smallest to largest), which is what your spec is testing for. What exactly\
    \ do you want to test for to fail?\n<|/ c |>\n<| a tags=ruby |>\nTo answer the\
    \ question you posted:", "  l.sort\n  even = [l[i] for i in range(0, l.length)\
    \ if i % 2 == 0]\n  return even\nend\n  ", "  return l.sort.uniq.to_a\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,arrays,sorting |>\n<| c |>\nThis will not work if the\
    \ list is non-decreasing, as is asked for.\n<|/ c |>\n<| c |>\nThe OP specified\
    \ the criteria to be \"sorted\", which means that the list is to be sorted as\
    \ is stated. He is not asking for a specific ordering or sort method.\n<|/ c |>\n\
    <| c |>\nHe stated that he wants to sort the list by value. I guess this is an\
    \ interpretation of his question as he stated that he wanted the even indices\
    \ sorted.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\nAssuming you have an array\
    \ of numbers like the one in the question, it's easy to solve this problem by\
    \ creating another array of zeros and using Array#index to change the even values\
    \ into ones and zeroes respectively.\n<code>\narr = [1,2,3,4,5,6,7,8,9,10]", " \
    \ sorted = []\n  even = l.dup\n  even.each.with_index { |x, i| sorted.insert(i\
    \ * 2, x) }\n  even.each.with_index { |x, i| sorted.insert(i * 2 + 1, x) }\n \
    \ sorted.compact!\n  sorted.each { |x| x.reverse! }\n  l.each_index { |i| l[i]\
    \ = l[i].dup }\n  l\nend", "  l.sort!\n  even_indexes = l.each_with_index.with_index\
    \ { |(e,i),a| a.first == a && a.last == a }\n  even_indexes.flatten!\n  even_indexes.zip(l).map\
    \ { |e| e[0] }.sort!\n  even_indexes\nend", "  l.each do |e|\n    i = l.index(e)\n\
    \    l.delete_at(i)\n    l.insert(i, e)\n  end\n  l\nend", "  l.sort!\n  even\
    \ = l.select.with_index { |e, i| i % 2 == 0 }\n  even.sort\n  even.zip(even).map{\
    \ |e, o| o }\nend", "  l = l.dup\n  l.slice!(0..l.length/2).sort_by!(&:to_i)\n\
    \  l\nend", "    l.sort!\n    even_indexes = []\n    odd_indexes = []\n    \n\
    \    (l.size - 1).times do\n        if (l[even_indexes.length] == l[even_indexes.length\
    \ + 1]).zero?\n            even_indexes << even_indexes.length\n        else\n\
    \            odd_indexes << even_indexes.length\n        end\n    end\n    \n\
    \    even_indexes.each_with_index do |e, i|\n        l[odd_indexes[i]] = l[e]\n\
    \    end\n    \n    l\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a |>\nI'm\
    \ sure there are better ways to do this, but this is one way to solve it:\n<code>",
  "  # We sort l in O(nlogn) time, then we sort it in O(n) time\n  l.sort\n  even\
    \ = Array.new(l.length)\n  even.zip(l)\n  even.sort!\n  even\nend", "    even\
    \ = l[1..-1]\n    odd = l[0..-2]\n    even.zip(odd).flatten\nend", "  return l.reject.with_index{\
    \ |e, i| i.odd? }.sort.reverse\nend", "  even = l.select { |x| (x % 2).zero? }\n\
    \  even.sort!\n  even\nend", "    even = l[::2]\n    odd = l[1::2]\n    even.zip(odd).to_a\n\
    end", "  sort_even = method(:sort_even)\n  even = sort_even.call(l)\n  odd  =\
    \ even.dup\n  odd.sort!\n  return odd\nend", "  n = l.length\n  return [l, l].zip([l[n-1],\
    \ *(l[n-2:0:-1])]).flatten\nend", "  if l.length == 1\n    l\n  else\n    l +\
    \ (l[1..-1].sort)\n  end\nend", "  even = l[l.length >> 1]\n  odd = l[l.length\
    \ >> 1]\n  even.zip(odd).sort.each_with_index {|x,y| x.unshift(y) }\nend", " \
    \ l.sort.with_index { |value, index| index%2 == 0 }\nend", "  even = []\n  odd\
    \ = []", "  even = l.select { |x| x.even? }\n  even.sort { |a, b| a.to_i < b.to_i\
    \ ? -1 : a.to_i == b.to_i ? 0 : 1 }\nend", "  l.each_with_index do |e, i|\n  \
    \  l.delete_at(i)\n    l.insert(i, e)\n  end\nend", "    l.sort! do |x|\n    \
    \    if x % 2 == 0\n            x\n        else\n            l.index(x) + 1\n\
    \        end\n    end\n    l # this is probably not needed\nend", "  even = []\n\
    \  odd = []\n  even.push(*l)\n  odd.push(*l)\n  odd.push(*l)\n  odd.push(*l)\n\
    \  odd.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n\
    \  even.push(*l)\n  even.push(*l)\n  even.push(*l)\n", "  l.sort!\n  l.each_with_index\
    \ { |e, i| l[i] == i ? l[i] = e : l[i] = e - i }\n  l\nend", "  even = l.dup\n\
    \  even.sort!\n  (even.inject([]) {|a, x| a << x if (x % 2) == 0; a }).sort!\n\
    end", "  l.each_with_index { |value, index| l[index] = (index % 2) == 0 ? value\
    \ : l[index].sort }\n  l\nend", "  return l[1...l.size] if l.size % 2 == 0 else\
    \ l.sort_by{|i| l[1..(i+1)].size}\nend", "  l = l.dup\n  l = l[0, l.size]\n  even\
    \ = l.index { |x| x % 2 == 0 }\n  even.times do |i|\n    l[even, i] = l[even,\
    \ i]\n  end\n  l\nend\n</cell>\n<cell>", "    odd = l.each_with_index.select {\
    \ |value, index| index % 2 }\n    even = l.each_with_index.select { |value, index|\
    \ not index % 2 }\n    even = even.sort_by { |value, index| index }\n    odd.zip(*even).map(&:flatten).sort\n\
    end", "  even = l.dup\n  even.sort!", "  if l.length == 0\n    throw :NothingToSort\n\
    \  else\n    temp = []\n    even = l.each_with_index {|item, index| item if (index%2\
    \ == 0)}\n    odd = l.each_with_index {|item, index| item if (index%2 != 0)}\n\
    \    even.each {|item| temp << item }\n    temp.concat(odd.reverse)\n  end\nend",
  "  if l.size < 2\n    l.sort!\n  else\n    even_inds = falses(l.size)\n    even_inds[1]\
    \ = true\n    l[even_inds.nonzero] = l[even_inds].sort\n  end\n  return l\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks, this is a very nice solution.\n<|/ c |>\n\
    <| c |>\nI see a small bug in the first line (should have been `sort_even.call`),\
    \ but other than that, this is a very nice solution. Thanks!\n<|/ c |>\n<| a dscore=3\
    \ |>\nI realize this has already been answered, but wanted to add that you can\
    \ also use inject:\n<code>", "    even = l.dup\n    even.sort!\n    even.each_with_index\
    \ do |v, i|\n        even[i] = v\n    end\n    even\nend", "  even_values = l[1..-1].select\
    \ { |element| element.even? }\n  even_values.each { |value| l[1..-1].insert(value,\
    \ value) }\n  l\nend", "  even = l.select.index {|x| x % 2 == 0}\n  sorted = even.map\
    \ {|x| l[x]}\n  sorted.concat even.map {|x| l[x]} # put all the even values next\
    \ to each other\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ dscore=0 |>\nThe easiest way:\n<code>\narray = [1,2,3,4,5,6,7,8,9,10]\narray.group_by\
    \ { |i| i }\n</code>\n<|/ a |>\n<| c |>\n`sort_by { |i| i }` would also do the\
    \ trick.\n<|/ c |>\n<| c |>\nWon't work if the array contains duplicates.\n<|/\
    \ c |>\n<| c |>\nWell, then you'll have to keep track of the count of duplicates\
    \ and use `sort_by` accordingly.\n<|/ c |>\n<| a |>\n<code>\narr = [1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10]\narr.map { |x| [x, arr.count(x)] }.sort { |a, b| b[1] <=>\
    \ a[1] }.map { |x| x.first }\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n<|\
    \ a tags=ruby,arrays |>\n<code>\na = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n => [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10] \na.group_by{ |x| x }.map{ |k, v| [k, v.count] }.sort_by{\
    \ |k, v| -v[1] }\n => [[1, 10], [3, 8], [2, 7], [5, 6], [4, 5], [7, 4], [9, 3]]\
    \ \n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nJust to share my solution (with\
    \ thanks to Boris for the hint):\n<code>", "  l.sort\n  even = []\n  odd = []\n\
    \  i = 0\n  while i < l.length\n    if i % 2 == 0\n      even << l[i]\n    else\n\
    \      odd << l[i]\n    end\n    i += 1\n  end\n  even.concat(odd)\n  even.sort\n\
    \  even\nend", "  even = l.dup\n  even.sort!\n  even.each_index { |i| l[i] = l[i]\
    \ % 2 == 0 ? l[i] + 1 : l[i] }\n  even\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nI really like the simplicity and clarity of this. I'm still new to Ruby,\
    \ but I'm going to have to look into this. Thank you!\n<|/ c |>\n<| a tags=ruby\
    \ |>\nThe fastest way is probably to use group_by, then map the groups to their\
    \ last elements, then flatten the result:\n<code>", "  even = l[1..-1].sort\n\
    \  l[1..-1].concat.concat(even)\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=sorting,ruby,arrays\
    \ |>\nHere's a simple way to sort an array using insertion sort.\n<code>", " \
    \ l.each_with_index do |e, i|\n    l.delete_at(i) if i % 2 == 1\n    break if\
    \ e == l[i]\n    l.insert i, e\n  end\n  l\nend", "  sorted = []\n  even = []",
  "  l2 = []\n  even = l.find{|x| x % 2 == 1}\n  l.each_index{|i| l2[i] = l[even];\
    \ l2.delete_at(even)}\n  l2\nend", "  l2 = []\n  (0..l.length-1).each do |i|\n\
    \    if i.even?\n      l2 << l[i]\n    else\n      l2 << l[i-1]\n    end\n  end\n\
    \  l2\nend", "  even = []\n  odd = []\n  even.concat l\n  odd.concat l\n  odd.each_with_index\
    \ do |value, index|\n    even[index] = l[index] if index % 2 == 0\n  end\n  even\n\
    end\n</code>\n<|/ a tags=sorting,ruby,arrays,ruby-on-rails |>\n<| c |>\nWhile\
    \ this does work, it also sorts the even indices instead of the odd ones. In other\
    \ words, this does not produce the correct sort.\n<|/ c |>\n<| c |>\nOh. Good\
    \ catch. The original question didn't specify that it needed to preserve the original\
    \ order. I'll edit my answer.\n<|/ c |>\n<| c |>\nYeah, the original question\
    \ didn't specify that it needed to preserve the original order. That's why I deleted\
    \ my comment and added an edit to my answer.\n<|/ c |>\n<| a tags=sorting,ruby,arrays,ruby-on-rails\
    \ |>\nHow about:\n<code>", "  l.sort!\n  odds = l[1..-1]\n  evens = l[2..-1]\n\
    \  evens.reverse_each { evens.unshift(l.pop) }\n  [odds, evens]\nend", "    l\
    \ = list(l)\n    l1 = l[0::2]\n    l2 = l[1::2]\n    l1.each_index { |i| l1[i]\
    \ = l1[i].sort }\n    l2.each_index { |i| l2[i] = l2[i].sort }\n    l1\nend",
  "  # Sort the odd indices of the given array\n  l = sort_odd(l)\n  # Find where\
    \ the even indicies start and set them to -1\n  even = []\n  i = 0\n  while i\
    \ < l.size\n    if l[i] % 2 == 0\n      even << i\n    else\n      even << -1\n\
    \    end\n    i += 1\n  end\n  # Move the even indicies at the end of the odd\
    \ indicies\n  i = 0\n  while i < even.size\n    l[even[i]] = l[even[i]]\n    i\
    \ += 1\n  end\n  # Sort the odd indicies and return them\n  l = sort_odd(l)\n\
    \  return l\nend", "    l.size.times do |i|\n        if i % 2 == 0\n         \
    \   l[i] = l[i]\n        end\n    end\n    l\nend\n</code>\nIt was also mentioned\
    \ in the comments that if your array contains nil values, you may want to use\
    \ sort! and that you should use sort_even instead of sort_even.call. The reason\
    \ for this is that sort_even will return nil if l contains nil values, which would\
    \ make the sort! call fail. The call method on the other hand will just return\
    \ nil if l contains nil values, which is what I want.\n<code>", "  n = []\n  l.each_with_index\
    \ do |value, index|\n    if index % 2 == 0\n      n << value\n      n.sort!\n\
    \    end\n  end\n  n\nend", "  l.each_index { |i| l[i] = l[i.even?] }\nend\n</code>\n\
    It would be better to not use each_index because it would require two passes,\
    \ one to iterate over the array and another to rearrange the values. Instead,\
    \ we can simply use each_with_index to iterate over the array without modifying\
    \ the value at each index.\n<code>\nsort_even.call([1, 2, 3])\n=> [1, 2, 3]\n\
    sort_even.call([5, 6, 3, 4])\n=> [3, 6, 5, 4]\n</code>\nThe second pass would\
    \ be unnecessary and wasteful, and we could do the same thing by just iterating\
    \ over the array once and storing values in a hash table.\n<code>\nsorted_even\
    \ = {}\narr.each do |i|\n  if i.even?\n    sorted_even[i] = i\n  end\nend", " \
    \ evens = even_indicies(l)\n  evens.each_index do |i|\n    if evens[i]\n     \
    \ evens[i] = l[i]\n      l[i] = l[i].sort_by{ |x| x}\n    end\n  end\n  l\nend",
  "    l.sort.with_index { |e,i| i & 1 ? (e < l[i] ? i : l[i]) : (e) }\nend", "  even\
    \ = l.select { |i| i.odd? }\n  even.zip(even).flatten!\n  even\nend", "    l =\
    \ l(l)\n    even = []\n    odd = []\n    for i in (0..l.length).step(2).each {|i|\
    \ even.push(l[i])}\n    for i in (0..l.length).step(2).each {|i| odd.push(l[i])}\n\
    \    even.zip(odd).sort_by {|i| i[0]}\nend", "  l2 = l\n  l2.sort do |a, b|\n\
    \    (a % 2).zero? ? 0 : (a-b)\n  end\n  l2\nend\n</pre>", "  even_inds = l.select\
    \ { |x| x % 2 == 0 }\n  even_inds[1..-1].zip(even_inds).to_a\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a tags=ruby dscore=0 |>\n<code>", "  even = l.dup\n  even.rotate!\n\
    \  even.rotate!\n  even.each { even.rotate! }\n  even\nend", "  even_index = []\n\
    \  odd_index = []\n  even_values = l.map {|x| x}\n  odd_values = l.map {|x| x}\n\
    \  even_index << even_values.each_index.select {|i| i % 2 == 0}\n  odd_values\
    \ << even_values.each_index.select {|i| i % 2 != 0}\n  even_index << odd_values.each_index.select\
    \ {|i| i % 2 == 0}\n  odd_values << odd_values.each_index.select {|i| i % 2 !=\
    \ 0}\n  even_index << even_values.each_index.select {|i| i % 2 == 1}\n  odd_values\
    \ << even_values.each_index.select {|i| i % 2 != 1}\n  even_index << odd_values.each_index.select\
    \ {|i| i % 2 == 1}\n  odd_values << odd_values.each_index.select {|i| i % 2 !=\
    \ 1}\n  even_index << even_values.each_index.select {|i| i % 2 == 2}\n  odd_values\
    \ << even_values.each_index.select {|i| i % 2 != 2}\n  even_index << odd_values.each_index.select\
    \ {|i| i % 2 == 2}\n  odd_values << odd_values.each_index.select {|i| i % 2 !=\
    \ 2}\n  even_index << even_values.each_index.select {|i| i % 2 == 3}\n  odd_values\
    \ << even_values.each_index.select {|i| i % 2 != 3}\n  even_index << odd_values.each_index.select\
    \ {|i| i % 2 == 3}\n  odd_values << odd_values.each_index.select {|i| i % 2 !=\
    \ 3}\n  even_index << even_values.each_index.select {|i| i % 2 == 4}\n  odd_values\
    \ << even_values.each_index.select {|i| i % 2 != 4}\n  even_index << odd_values.each_index.select\
    \ {|i| i % 2 == 4}\n  odd_values << odd_values.each_index.select {|i| i % 2 !=\
    \ 4}\n  even_index << even_values.each_index.select {|i| i % 2 == 5}\n  odd_values\
    \ << even_values.each_index.select {|i| i % 2 != 5}\n  even_index << odd_values.each_index.select\
    \ {|i| i % 2 == 5}\n  odd_values << odd_values.each_index.select {", "  l.sort\
    \ { |x, y| (x % 2).zero? ? -1 : 1 }\nend\n</cell>\n<code language=julia-1.1>\n\
    function sort2(l)\n  m = maximum(l)\n  b = Array(m)\n  for i in eachindex(l)\n\
    \    b[i] = l[i]\n  end\n  return b\nend\n</cell>\n<code language=julia-1.1>\n\
    function sort3(l)\n  m = maximum(l)\n  b = Array(m)\n  push!(b,0)\n  for i in\
    \ eachindex(l)\n    b[i] = l[i]\n  end\n  sorted = sort_even(b)\n  return sorted\n\
    end\n</cell>\n<text>\nHere is a function sort_odd_indicies that takes a list l\
    \ and returns the list of all indices that are in the odd positions of l.", " \
    \ l.each_index { |i| l[i..-1].sort.each_index { |j| l[i..-1][j] = l[i..-1][j]\
    \ } }\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,sorting,ruby\
    \ |>\n<code>\na = [\"h\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    i\", \"j\", \"k\", \"l\"]", "  l.each_with_index do |value, index|\n    next if\
    \ index%2 == 1\n    l[index] = l[index + 1]\n  end\nend", "  l.each_with_index\
    \ do |val, index|\n    puts \"#{index} - #{val}\" if index%2 == 0\n  end\nend",
  "    even = []\n    odd = []\n    l.each do |value|\n        if value % 2 == 0\n\
    \            even.push(value)\n        else\n            odd.push(value)\n   \
    \     end\n    end\n    even.zip(odd).sort\nend", "  l.each_with_index do |e,\
    \ i|\n    next if i == 0\n    l[i] = l[i-1]\n  end\nend\n</code>\nThen you can\
    \ sort the numbers in an array, or the whole array, like so:\n<code>\nl = [5,\
    \ 4, 6, 3]\nsort_even.call(l)\n=> [5, 3, 6, 4]\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\nAnother approach without using sort:\n<code>\narray =\
    \ [10,2,11,14,5,13,11,15]\narray.each_with_index.with_index { |(x, i), j| array[j]\
    \ = (array[j] * (i - j)) + x }\np array\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a |>\nHere are two methods you can use to sort an array.\n<code>", '    l.sort!',
  "  l.sort.with_index { |val, index| index % 2 == 0 }\nend\n</code>\nThe second method\
    \ is the same as sort_odd except it is sorted in descending order instead of ascending.\n\
    <|/ a |>\n<| c |>\nThis does work, but only when the list is sorted in ascending\
    \ order. It does not work when it is sorted in descending order.\n<|/ c |>\n<|\
    \ c |>\nThe original answer sorts in ascending order and I didn't notice that\
    \ it was being changed to descending order.  I've updated the answer to include\
    \ a method that sorts in descending order.\n<|/ c |>\n<| a dscore=2 |>\nI find\
    \ it a bit simpler to sort the arrays twice and use the index to decide which\
    \ array to return. I find this more readable than using sort_by.\n<code>", " \
    \ l.sort.call(l.each_index.to_a)\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| a dscore=2 |>\nYou can use a hash. \n<code>", "  l.each_with_index {\
    \ |x, i| l[i] = x.even? ? x.to_i : x }\n  l.sort!\n  l\nend", "  l1 = []\n  l2\
    \ = []\n  l1.concat l\n  l2.concat l\n  l2.each do |i|\n    l1[(i+1)/2-1] = i\n\
    \  end\n  return l1\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nThis\
    \ is definitely more readable than the solution I came up with, thanks! It was\
    \ the only solution I could come up with that actually preserved the order of\
    \ the original array.\n<|/ c |>\n<| a tags=ruby |>\nThis works, but I'd be curious\
    \ to see if there's a better way:\n<code>\narr = [5, 2, 7, 1]\narr.group_by {|v|\
    \ v }.transform_values {|v| v.sort_by!(&:itself).flatten}\n  #=> [5, 2, 7, 1]\
    \ \n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your solution. Very concise,\
    \ but like I mentioned in my post, the solution I came up with is one that preserved\
    \ the order of the original array. I'll post my solution, though.\n<|/ c |>\n\
    <| a dscore=0 |>\nThis solution is still not very readable, but I think it does\
    \ preserve the order:\n<code>", "  new_l = []\n  even_values = []\n  odd_values\
    \ = []\n  for i in(0...l.length)\n    if i % 2 == 0\n      even_values << l[i]\n\
    \    else\n      odd_values << l[i]\n    end\n  end\n  # the odd indicies are\
    \ already sorted, so just sort the even indicies of l\n  new_l.concat even_values.sort\n\
    \  # add the odd indicies of l to the new_l array\n  new_l.concat odd_values\n\
    end\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nI do not understand the second\
    \ part of your code. What is `(0...l.length)` ? I looked at [this](http://stackoverflow.com/questions/2918154/why-cant-i-use-range-in-a-range-in-a-loop-range-loop)\
    \ question and it is pretty clear to me, but I do not know why you use `(0...l.length)`.\
    \ Thanks\n<|/ c |>\n<| c |>\nThe first part is just an example of the sort, you\
    \ might want to use it if you want to sort the even values of a list instead of\
    \ the odd values. The second part is to sort the list at the end to put the even\
    \ values to the end of the sorted list.\n<|/ c |>\n<| a dscore=0 |>\nHere is another\
    \ way using Ruby's inject method. Note I used Integer#to_i to convert the string\
    \ values to integers in the original array.\n<code>\nl = [\"cat\", \"dog\", \"\
    mouse\", \"fish\", \"bird\"]", "  l.each_with_index do |x, i|\n    odd = i % 2\n\
    \    even = (i % 2).zero? ? 0 : i\n    l[even] = l[even] if odd.zero?\n  end\n\
    \  l\nend", "    even = l.select {|x| x % 2 == 0}\n    even.sort!\n    even.reverse!\n\
    \    even\nend", "  l.sort.with_index { |value, index| index % 2 == 0 }\nend\n\
    </code></pre>\n      </section>\n      <section>\n        <h3>Exercise</h3>\n\
    \        <pre><code data-trim class=\"line-numbers python\">", "  l.dup.sort!\n\
    \  l.each_with_index { |e,i| e[i&1] = e[i&1] > e[i&1] ? e[i&1] : e[i&1].dup }\n\
    \  l\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nIf you do this,\
    \ it will destroy `l`, which is probably not what you want.\n<|/ c |>\n<| c |>\n\
    : Yes, it does. I didn't think of that. Thanks.\n<|/ c |>\n<| a dscore=1 |>\n\
    I think there are two approaches.  First, sort only if the elements are not unique,\
    \ thus avoiding problems with sorting:\n<code>", "  # Using a while loop because\
    \ I could not figure out a way to use map/reduce to sort it properly.\n  i = 0\n\
    \  while i < l.length/2\n    l[i..-1] = l[i..-1].sort\n    i += 1\n  end\n  l\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis answer works very well for me but\
    \ I'm just curious, how would you refactor the code to solve this problem in general\
    \ without using map/reduce to sort the array? I really like your solution because\
    \ it doesn't require any extra methods. Any ideas? I'm thinking about using nested\
    \ loops but I feel like there should be a way to do this with map/reduce that\
    \ I'm not thinking of.\n<|/ c |>\n<| c |>\nI think that would be a better question.\
    \ As long as you are not trying to write a very complex sorting algorithm, I wouldn't\
    \ worry about refactoring it. I would just go ahead and write it like I did, which\
    \ I believe is how you would write it in Ruby.\n<|/ c |>\n<| c |>\nI agree with.\
    \  In Ruby, I'd write the same thing that you're trying to write.  You didn't\
    \ need to use map/reduce because you already had the right idea, you just needed\
    \ to rewrite it in Ruby.  It's not clear to me that you're familiar enough with\
    \ Ruby that it's relevant to refactor your code in Ruby, but if you've already\
    \ written the function in Ruby, refactoring it shouldn't be too hard.\n<|/ c |>\n\
    <| c |>\n: Thanks for your comment. I just wanted to know if there was a way to\
    \ refactor the code in general before I start writing a more complex algorithm\
    \ with map/reduce. I guess I should have asked if there was a way to do it with\
    \ map/reduce without refactoring my code and then rewriting my function in Ruby.\
    \ I just want to know if there is a way to do it without refactoring my code.\n\
    <|/ c |>\n<| c |>\nYes, you can do it without refactoring my code. Just go ahead\
    \ and write it in Ruby.\n<|/ c |>\n<| a tags=ruby,sorting |>\nHere is an example\
    \ of how to use Ruby's sort_by, group_by, and each_slice method to do this:\n\
    <code>", "  l.map!(&:to_i)\n  even = (0...l.length).select {|i| i % 2 == 0}\n\
    \  even.zip(even.map(&l))\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting,arrays,ruby-on-rails\
    \ |>\n<| a tags=ruby,sorting,arrays,ruby-on-rails |>\nI wrote a Ruby library that\
    \ does exactly that: https://github.com/ljharb/sort_by_attribute\n<|/ a dscore=0\
    \ |>\n<| c |>\nI noticed that your code does a case-insensitive sort on any attribute.\
    \ Is that intentional? If you want case-sensitive sort, you should call it by\
    \ attribute name only.\n<|/ c |>\n<| c |>\nThanks for pointing out the issue.\
    \ I fixed it now. I also added a comment on how to set the attribute. Now it defaults\
    \ to case-sensitive sort. Also it also has a test to validate your implementation\
    \ matches the specs: https://github.com/ljharb/sort_by_attribute/blob/e25cf434b662b1ef690c25d88a24f40331b9a885/spec/sort_by_attribute_spec.rb#L19-L32\n\
    <|/ c |>\n<| a |>\nHere's an approach\n<code>", "  l.sort.each { |e| e = (e %\
    \ 2 == 0 ? e : e + 1); l.insert(e, l.delete(e)) }\n  l\nend", "  l.sort.with_index\
    \ { |x,y| y%2 == x%2 ? x : x.to_i }\nend", "  # sort l' by calling sort_even.call()\
    \ on its even indicies, then sort those results\n  l'.unshift(sort_even.call(l.splice(0)))\n\
    \  \n  l'.sort\nend", "  l.each_with_index { |e, i| l[i] = e if i.odd? }\n  l.sort_by\
    \ { |e| e }\nend\n</code>\nI hope this helps.\n<|/ a dscore=4 |>\n<| a dscore=4\
    \ |>\nSince Ruby v2.2, the sort_by method accepts a block. So you can do it in\
    \ much more readable way:\n<code>\nl = [2,4,1,3,5]", "  if l.length % 2 != 0\n\
    \    return l\n  l = (l.clone || l).sort!", "  odd = l.select { |e| e % 2 == 1\
    \ }\n  even = l.select { |e| e % 2 == 0 }\n  even.zip(even).flatten\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  sorted = []\n  for i in 0..l.size-1\n\
    \    if i % 2 == 0\n      sorted.push l[i]\n      sorted.push l[i+1]\n    else\n\
    \      sorted.push l[i+1]\n      sorted.push l[i]\n  end\n  return sorted\nend",
  "  l.each_with_index { |n, i| l[i] = l[i].even? ? l[i].dup : l[i].dup }\n  l\nend",
  "  l.sort { |a, b| a % 2 != b % 2 ? a > b ? 1 : a < b ? -1 : a : a }\nend", "  l.each_with_index\
    \ do |value, index|\n    if index % 2 != 0\n      l[index] = value\n    end\n\
    \  end\n  l\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  even = []\n  odd = []\n\
    \  even.concat(l)\n  odd.concat(l.drop(even.count))\n  even.zip(odd).sort\nend",
  "    odd = l[l.size/2:end]\n    even = l[1...l.size/2]\n    even.zip(odd).sort.flatten!\n\
    end", "  l.sort { |a, b| b % 2 ? -1 : a % 2 ? 1 : a <=> b }\nend", "  l'.sort\
    \ { |x, y| y % 2 == 0 && x < y ? -1 : (x > y ? 1 : 0 ) }\n  l\nend", "    odd\
    \ = trues(l)\n    even = l.take(even)\n    even.zip(odd).sort!\n    even\nend\n\
    </code>\nAnd this works for both sets and arrays.\n<code>\nsort_even([1, 2, 3])",
  "  even = l.select.with_index { |el, i| i % 2 == 0 }.sort\n  l = even.inject(l)\
    \ { |a, e| a.insert e, e }\n  l = l.sort\nend", "    l.each_with_index do |e,\
    \ i|\n        if i%2 == 0\n            l.insert(i, e) \n        elsif i%2 == 1\n\
    \            l.insert(i, e) \n            l.insert(i, e) \n        end\n    end\n\
    \    \n    l\nend\n</code>\n<|/ a |>\n<| c |>\n+1 for giving the correct answer.\
    \  Although this solution modifies the original list, it also creates a new one\
    \ that has the effect of sorting the original list, without mutating it.  For\
    \ a situation where you are not concerned about mutations, this is definitely\
    \ the way to go.\n<|/ c |>\n<| c |>\nIf you need to do any more complex sorting\
    \ than just inserting into an array in order, you're better off creating a temporary\
    \ list, sorting it, then replacing your original with the sorted list.  It makes\
    \ the code clearer, and probably faster (although probably not by much).\n<|/\
    \ c |>\n<| c |>\nAgreed, I was just doing an example of what the OP was trying\
    \ to do.\n<|/ c |>\n<| c |>\n, do you mind explaining how this solution could\
    \ be improved? I am still learning ruby and the code looks quite unconventional.\n\
    <|/ c |>\n<| c |>\n- I added an explanation below, let me know if it helps\n<|/\
    \ c |>\n<| a tags=ruby |>\nJust for fun, here is a solution that uses partition,\
    \ instead of inserting into the list twice:\n<code>", "  l.sort_by { |e| e % 2\
    \ }\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nYou probably want to\
    \ define `sort_odd`, too, to avoid `sort_odd` becoming a synonym of `sort_even`.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  l.length.times do |index|\n    if index&1\
    \ == 1\n      l.insert(index, l.delete_at(index))\n    end\n  end\n  l\nend",
  "  l.sort!\n  l.each_with_index { |e,i| l[i] = l[i].modulo(2).zero }\n  return l\n\
    end", "  even = l[0]\n  evens = even.sort\n  [evens, l.clone].flatten\nend", " \
    \ l.sort.with_index do |elem, index|\n    if index % 2 == 0\n      elem\n    else\n\
    \      l[index + 1]\n    end\n  end\nend", "  l.size.times do |i|\n    l.swap(i,\
    \ i + 1)\n  end\n  l = l.sort\n  l.size.times do |i|\n    l.swap(i, 0)\n  end\n\
    \  l\nend\n</cell>\n<text>\nsort_even\nLet's test out the function sort_even.",
  "  l.each do |i|\n    index = l.index(i)\n    l.insert(index, i)\n    l.delete_at(index)\
    \ # delete i at the even index\n  end\n  l\nend", "  even_indices = l.select.select.select.select(&:odd?)\n\
    \  even_values = even_indices.map { |i| l[i] }\n  even_values.sort { |a,b| a.to_s\
    \ <=> b.to_s }\n  even_indices.zip(even_values)\nend", "  even_ind = 0..t\n  even_ind[0..-1].each_index\
    \ { |i| even_ind[i] = i }\n  even_ind[-1] = 0\n  even_ind\nend", "  even_indexes\
    \ = []\n  odd_indexes = []\n  odd_indexes.push(0)\n  even_indexes.push(l.length)\n\
    \  \n  even_indexes.each do |index|\n    l.each_with_index do |value, index|\n\
    \      if((index > 0) && (index%2 == 0))\n        odd_indexes << index\n     \
    \ else\n        even_indexes << index\n      end\n    end\n  end\n  \n  even_indexes.each\
    \ do |index|\n    even_indexes.delete(index)\n    odd_indexes.delete(index)\n\
    \  end\n  \n  even_indexes.each do |index|\n    l.insert(index, l[index])\n  \
    \  even_indexes.delete(index)\n  end\nend", "  even.sort.call(l.to_a)\nend", " \
    \ l = l.clone\n  l.sort\n  l.each_with_index {|a,i|\n    l.insert(i, a) if i%2\
    \ == 0}\n  l\nend", "  sorted = []\n  even = l.map {|e| e}\n  even.each_with_index\
    \ do |element, index|\n    even.delete_at(index) if index%2 != 0\n    sorted.unshift(element)\n\
    \  end\n  return sorted\nend", "  l.each_with_index do |x, i|\n    if i % 2 ==\
    \ 0\n      l[i] = l[i]\n      l[i + 1] = l[i + 1]\n    end\n  end\n  l\nend",
  "    even = l[2..-1]\n    odd = l[0..-2]\n    odd.sort!\n    even.zip(odd).flatten!\n\
    end", "  evens = l[1..-1].each_with_index.select { |e, _| e % 2 == 0 }\n  evens.zip(evens.map{\
    \ |e| e })\nend\n</cell>\n<cell>", "  even = l.dup\n  even.delete_if { |e| e.odd?\
    \ }\n  even.sort!\n  even\nend", "  return l[l.index { |i| i & 1 }]\nend", " \
    \ l.map!(&:to_i).sort!\n  l.zip([l[l.length-1]] * (l.length-1).to_a).map(&:flatten)\n\
    end", "  l.sort!\n  l.zip(l[0..-1]).map do |(a,b)| a <=> b end\nend\n</code>\n\
    <|/ a dscore=0 tags=sorting,ruby,arrays |>\n<| c |>\nI like the use of the `<=>`\
    \ operator for comparison, but it's worth noting that it isn't necessarily a good\
    \ idea. Ruby doesn't guarantee what order the arguments are evaluated in, so the\
    \ results may not always be consistent from run to run and in Ruby 1.9, it may\
    \ not be reliable in earlier versions. http://stackoverflow.com/questions/193954/what-is-the-difference-between-and-in-ruby-on-rails\n\
    <|/ c |>\n<| c |>\nYes it is. I've found that it's generally good enough.\n<|/\
    \ c |>\n<| a dscore=0 tags=sorting,ruby,arrays |>\n<code>", "  l.each_with_index\
    \ { |e, i| l[i] = e if i & 1 }.sort\nend\n</code>\nUsing a combination of sort_by\
    \ and uniq I come up with this code:\n<code>", "    l.each_with_index do |x, i|\n\
    \        if i % 2 == 0\n            l[i] = l[i - 1]\n        end\n    end\n  \
    \  l.sort!\n    return l\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<|\
    \ a dscore=0 tags=ruby,sorting,arrays |>\nI prefer the answer using each_cons.\
    \ I like this answer since it uses the each_cons method from Enumerable.\n<code>",
  "  l.sort.with_index { |value, index| index&1 }\nend", "  l.sort.call(&:even?)\n\
    end", "  l.map! {|i| i}\n  l.sort!\n  l.map! {|i| l[i % 2].nil? ? i : l[i % 2].to_i}\n\
    end", "  l.each_with_index do |n, i| l[i] = l[i].to_i if i % 2 == 0 end\n  l.sort\n\
    \  l\nend", "  l.each_index { |i| l[i] = l[i].to_i if i % 2 == 0 }\n  l.sort!\n\
    \  l.each_index { |i| l[i] = l[i] % 2 ? l[i] : l[i].to_i }\n  l\nend", "  l2 =\
    \ Array.new(l)\n  l2.length.times do |i|\n    if i % 2 == 0\n      l2[i] = l2[i\
    \ - 1]\n    end\n  end\n  l2\nend\n</pre>\n<p>\nIn Ruby 1.8, you can also use\
    \ <tt>Array#sort_by</tt> to sort arrays that way, or <tt>Enumerable#sort</tt>\
    \ if you are doing it in Ruby 1.8.\n</p>\n<pre>", "  l.each do |value|\n    if\
    \ value % 2 == 0\n      even = sort_even([value])\n      even << value\n     \
    \ return even\n    end\n  end\n  return l\nend", "  sorted = []\n  evens = []\n\
    \  \n  sorted = l.dup\n  evens = sorted.dup\n  \n  evens.sort! do |i|\n    sorted.index(i)\n\
    \  end\n  \n  sorted.concat(evens)\nend", "  l.each do |i|\n    j = l.index(i)\n\
    \    l.delete_at(j) if j % 2 != 0\n    l.insert(j, i)\n  end\n  l\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby,functional-programming |>\n<| c |>\nThanks. Though I\
    \ wonder why this would be called an \"in-place\" sorting.\n<|/ c |>\n<| c |>\n\
    , it's an in-place sorting because you are modifying the array in place instead\
    \ of returning a new array that's sorted as you wanted.\n<|/ c |>\n<| a dscore=3\
    \ |>\nA functional solution (as opposed to more imperative ones like Array#sort)\n\
    <code>\nsorted_array = Array.new\nsorted_array.push(*array.each.with_index.sort\
    \ {|a,b| b <=> a })\n</code>\n<|/ a tags=ruby,functional-programming |>\n<| c\
    \ |>\nIt's a nice solution and probably the fastest in most cases. But `each`\
    \ isn't needed in this case.\n<|/ c |>\n<| a |>\nThis is another solution that\
    \ is fairly concise that does not require any additional modules:\n<code>\narray.sort_by\
    \ {|x| x.odd? ? x.even? : -1 }.last(array.size)\n</code>\n<|/ a dscore=3 tags=ruby,functional-programming\
    \ |>\n<| c |>\nWhat is `odd?`? I can't find that method in ruby\n<|/ c |>\n<|\
    \ c |>\nThe method is not in the standard library. `odd?` is part of `Array` but\
    \ `Array#sort` returns `Enumerator` and does not implement `Enumerable`, hence\
    \ the need for `last`.\n<|/ c |>\n<| c |>\n`odd?` is part of [`Fixnum`](https://ruby-doc.org/core-2.5.0/Fixnum.html)\n\
    <|/ c |>\n<| c |>\n`odd?` is an instance method of `Fixnum` (as well as `Integer`,\
    \ `Float`, `Rational`, `Bignum`, etc)\n<|/ c |>\n<| a tags=ruby,functional-programming\
    \ dscore=1 |>\nUsing Enumerable#chunk:\n<code>\narray = [1, 2, 3, 10, 20, 30,\
    \ 40, 50, 60, 70]\narray.chunk(&:even?).map(&:last).flatten", "  l.each.with_index(1)\
    \ { |e, i| l[i] = e }\n  l.each.with_index(1) { |e, i| l[i] = nil if e % 2 !=\
    \ 0 }\nend", "  l.each_with_index do |a, i|\n    a.even?         ? l[i] = l[i]\n\
    \                       : l[i] = a\n  end\n  l\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThanks for the detailed explanation. My original approach was to sort\
    \ the list and then put it back in order. However the `sort_by` and `sort_by!`\
    \ methods require a block. Is there a way to solve this using just an array?\n\
    <|/ c |>\n<| c |>\nYou can pass a block to `sort_by` and `sort_by!`; I added an\
    \ example of how you could do it by using a `block`.\n<|/ c |>\n<| c |>\nThat's\
    \ great. Thanks!\n<|/ c |>\n<| a |>\nTry this out :\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
