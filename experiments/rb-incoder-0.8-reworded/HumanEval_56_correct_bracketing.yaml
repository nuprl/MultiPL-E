name: HumanEval_56_correct_bracketing
language: rb
prompt: "# brackets is a string of \"<\" and \">\".\n# return true if every opening\
  \ bracket has a corresponding closing bracket.\n# >>> correct_bracketing.call(\"\
  <\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"\
  <<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n\
  \    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"\
  <>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true,\
  \ candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"\
  ))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false,\
  \ candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n  \
  \  assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\"\
  >\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false,\
  \ candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"\
  <><><<><>><>>><>\"))\n  end\nend\n"
completions: ["  brackets = brackets.to_s.chars.map(&:to_i)\n  brackets.each_with_index\
    \ do |pair, index|\n    if pair[0] == pair[1] # a pair of brackets\n      return\
    \ false if index != 0 && brackets[index-1][0] == pair[0]\n      return false if\
    \ index != 0 && brackets[index+1][0] == pair[1]\n    else\n      return true if\
    \ index != 0 && brackets[index-1][1] == pair[0]\n      return true if index !=\
    \ 0 && brackets[index+1][1] == pair[1]\n    end\n  end\n  true\nend", "  brackets.gsub!(/[\\\
    [\\{]/,\"\").gsub!(/[\\]\\}]/,\"\").gsub!(/[<>]/,\"\")\n  brackets.to_s.gsub!(/\\\
    <\\>/,\"\")\n  return brackets.to_s.split(\" \").all? { |s| s =~ /^<.*\\>$/ }\n\
    end", "  # This code assumes that brackets is a string of \"<\" and \">\".\n \
    \ brackets = brackets.to_s.gsub(/[<>]/,'').downcase\n  result = brackets.include?('<')\n\
    \  result && brackets.include?('>')\nend", "    opening = brackets.count(\"<\"\
    ) + brackets.count(\">\")\n    closing = brackets.count(\"</\") + brackets.count(\"\
    />\")\n    return opening == closing\nend", "  bracket_counts = brackets.scan(/[<>]/)\n\
    \  bracket_counts[brackets.count(\"<\")] = 0\n  bracket_counts[brackets.count(\"\
    <>\")] = 0\n  bracket_counts.any? && bracket_counts == brackets.counts\nend",
  "  brackets = brackets.to_s\n  brackets = brackets.upcase\n  # remove left and right\
    \ brackets\n  brackets.gsub!(/\\(|\\)//, \"\")\n  # remove nested brackets\n \
    \ brackets.gsub!(/\\[|\\]//, \"\")\n  return brackets == brackets.gsub(/\\(|\\\
    )/, \"*\")\nend", "  brackets = brackets.to_s\n  correct_brackets = false\n  brackets.reverse_each\
    \ do |open|\n    if open == \">\" && correct_brackets then\n      correct_brackets\
    \ = false\n      correct_brackets = true\n    elsif open == \"<\" && correct_brackets\
    \ == false then\n      correct_brackets = true\n    end\n  end\n  correct_brackets\n\
    end", "  brackets = brackets.split('>')\n  brackets.each do |b|\n    b.split('<').each\
    \ do |c|\n      c.split('<').each do |d|\n        d.split('<').each do |e|\n \
    \         e.split('<').each do |f|\n            f.split('<').each do |g|\n   \
    \           g.split('<').each do |h|\n                h.split('<').each do |i|\n\
    \                  i.split('<').each do |j|\n                    j.split('<').each\
    \ do |k|\n                      k.split('<').each do |l|\n                   \
    \     l.split('<').each do |m|\n                          m.split('<').each do\
    \ |n|\n                            n.split('<').each do |o|\n                \
    \              o.split('<').each do |p|\n                                p.split('<').each\
    \ do |p|\n                                  p.split('<').each do |q|\n       \
    \                             q.split('<').each do |r|\n                     \
    \                 r.split('<').each do |s|\n                                 \
    \       s.split('<').each do |t|\n                                          t.split('<').each\
    \ do |u|\n                                            u.split('<').each do |v|\n\
    \                                              v.split('<').each do |w|\n    \
    \                                            w.split('<').each do |x|\n      \
    \                                            x.split('<').each do |y|\n      \
    \                                              y.split('<').each do |z|\n    \
    \                                                  z.split('<').each do |0|\n\
    \                                                        0.split('<').each do\
    \ |1|\n                                                          1.split('<').each\
    \ do |2|\n                                                            2.split('<').each\
    \ do |3|\n                                                              3.split('<').each\
    \ do |4|\n                                                                4.split('<').each\
    \ do |5|\n                                                                  5.split('<').each\
    \ do |6|\n                                                                   \
    \ 6.split('<').each do |7|\n                                                 \
    \                     7.split('<').each do |8|\n                             \
    \                                           8.split('<').each do |9|\n       \
    \                                                                   9.split('<').each\
    \ do |10|\n                                                                  \
    \         10.split('<').each do |11|\n                                       \
    \                                      11.split('<').each do |12|\n          \
    \                                                                     12.split('<').each\
    \ do |13|\n                                                                  \
    \               13.split('<').each do |14|\n                                 \
    \                                                  14.split('<').each do |15|\n\
    \                                                                            \
    \         15.split('<').each do |16|\n                                       \
    \                                                16.split('<').each do |17|\n\
    \                                                                            \
    \             17.split('<').each do |18|\n                                   \
    \                                                        18.split('<').each do\
    \ |19|\n                                                                     \
    \                        19.split('<').each do |20|\n                        \
    \                                                                       20.split('<').each\
    \ do |21|\n                                                                  \
    \                               21.split('<').each do |22|\n                 \
    \                                                                            \
    \      ", "  brackets.chars.all? do |char|\n    open_bracket, close_bracket =\
    \ brackets.scan(/[<>]/)\n    char == \"<\" && open_bracket && open_bracket[0]\
    \ == close_bracket[0]\n  end\nend\n</code>\nBut you might notice that it's too\
    \ hard to prove correctness of that function in general.  We could for example\
    \ have brackets like \">><<\" which doesn't have correct opening and closing pairs.\
    \  But if we want to prove it correctness, we need to find out how many such cases\
    \ exist and write code that handles them.  In this case, the number of such cases\
    \ would equal the number of pairs, i.e. \"<<>>\".  So our function would look\
    \ like this:\n<code>", "  brackets = brackets.to_s.gsub(/\\A<\\//,'').gsub(/\\\
    A\\/>\\Z/,'')\n  brackets = brackets.gsub(/\\A\\<\\//,'<').gsub(/\\A\\>\\Z/,'>')\n\
    \  brackets = brackets.gsub(/</,'').gsub(/>/,'')\n  brackets = brackets.scan(/[<>]/).size\
    \ == brackets.length\nend", "    # Your code here\n    false\nend", "  return\
    \ brackets.count { |b| %w[><].include?(b) } == 0\nend", "  brackets.gsub!(/</,\"\
    \ < \")\n  brackets.gsub!(/>/,\" > \")\n  brackets.gsub!(/[^<>]+/, \"\")\n  brackets.gsub!(/></,\"\
    \ > < \")\n  brackets.gsub!(/</,\" < \")\n  return brackets.gsub(/>$/, \" > \"\
    )\nend", "  brackets.scan(/([^<>]*)/) do |string|\n    string.scan(/\\<\\<\\>/)\
    \ do |character|\n      return false unless character == \">\"\n    end\n    string.scan(/\\\
    <\\>/) do |character|\n      return false unless character == \"<\"\n    end\n\
    \  end\n  true\nend", "  stack = []\n  open_count = 0\n  close_count = 0\n  brackets.each_char\
    \ do |char|\n    case char\n    when \">\"\n      close_count += 1\n    when \"\
    <\"\n      open_count += 1\n    when \" \"\n    when \"{\"\n      open_count +=\
    \ 1\n      close_count += 1\n    when \"}\"\n      open_count += 1\n    end",
  "  (brackets.size == 1) && return true\n  brackets.size == 2 && return false\n \
    \ brackets.size % 2 == 0 && return false\n  \n  (index1 = 0) != (index2 = 0) &&\n\
    \  brackets.each_char.with_index {|char, i| return false if i > index1 && i <\
    \ index2 }\n  true\nend\n</code>\n<|/ a tags=algorithm,ruby dscore=4 |>\n<| c\
    \ |>\nI'm going to have to give this a try, I'm a bit confused on how the function\
    \ would look after it's done its work. I'm assuming I can call it on brackets\
    \ but I'm not really sure what the next steps would be.\n<|/ c |>\n<| c |>\nThis\
    \ is very cool but I think it suffers from the same problems that some of the\
    \ other answers have with the \"no open brackets\" edge case.\n<|/ c |>\n<| c\
    \ |>\nGood point, I'll update my answer with that correction.\n<|/ c |>\n<| c\
    \ |>\nThis is really awesome, thank you very much for taking the time to write\
    \ this out and explaining it.\n<|/ c |>\n<| a dscore=4 tags=algorithm,ruby |>\n\
    The \"no open brackets\" case can be solved by simply traversing the string from\
    \ left to right, tracking when you've encountered an opening bracket:\n<code>",
  "  # For every bracket, count how many times it appears.\n  count = Hash.new(0)\n\
    \  brackets.scan(/</) do |open|\n    count[open] += 1 unless open == \"<\"\n \
    \ end\n  brackets.scan(/>/) do |close|\n    count[close] += 1 unless close ==\
    \ \">\"\n  end\n  # If any count is zero, no brackets are balanced.\n  return\
    \ true if count.empty?\n  # If all counts are equal, all brackets are balanced.\n\
    \  return false if count.values.all? { |num| num == 1 }\n  # If any count is greater\
    \ than 1, some brackets are balanced.\n  return false if count.values.any? { |num|\
    \ num > 1 }\n  # A pair of brackets is balanced if they are a pair, no matter\
    \ what\n  # their opening or closing pair is.\n  return true if count.values.all?\
    \ { |num| num == 2 }\n  # Neither opening nor closing pair is balanced.\n  return\
    \ false\nend", "  brackets.downcase!\n  brackets.gsub!(/[^>]>?/,\"\")\n  brackets.gsub!(/>?</,\"\
    >\")\n  brackets.gsub!(/\\>?</,\">\")\n  brackets.gsub!(/(\\[|\\])/,\"\\\\$1\"\
    )\n  brackets.gsub!(/[\\(]/,\"\\\\(\")\n  brackets.gsub!(/[\\)]/,\"\\\\)\")\n\
    \  brackets.gsub!(/\\[\\]/,\"\\\\[\")\n  brackets.gsub!(/\\]/,\"\\\\]\")\n  brackets.gsub!(/[\\\
    {]/,\"\\\\{\")\n  brackets.gsub!(/[\\}]/,\"\\\\}\")\n  brackets.gsub!(/[\\,]/,\"\
    \\\\,\")\n  brackets.gsub!(/[\\.]/,\"\\\\.\") \n  brackets.gsub!(/[\\\\_]/,\"\\\
    \\\\\\\")\n  brackets.gsub!(/[\\#]/,\"\\\\#\")\n  brackets.gsub!(/[\\$]/,\"\\\\\
    $\")\n  brackets.gsub!(/[\\^]/,\"\\\\^\")\n  brackets.gsub!(/[\\|]/,\"\\\\|\"\
    )\n  brackets.gsub!(/\\&/,\"\\\\&\")\n  brackets.gsub!(/[\\?]/,\"\\\\?\")\n  brackets.gsub!(/[\\\
    ~]/,\"\\\\~\")\n  brackets.gsub!(/[\\\\<]/,\"\\\\\\\\<\")\n  brackets.gsub!(/[\\\
    >]/,\"\\\\\\\\>\")\n  brackets.gsub!(/[\\?]/,\"\\\\\\\\?\")\n  brackets.gsub!(/[\\\
    !]/,\"\\\\\\\\!\")\n  brackets.gsub!(/[\\&]/,\"\\\\\\\\&\")\n  brackets.gsub!(/\\\
    |/,\"\\\\|\")\n  brackets.gsub!(/\\+/,\"\\\\+\")\n  brackets.gsub!(/\\*/,\"\\\\\
    *\")\n  brackets.gsub!(/\\.\\*/,\"\\\\*\")\n  brackets.gsub!(/\\./,\"\\\\.\")\n\
    \  brackets.gsub!(/\\./,\"\\\\.\")\n  brackets.gsub!(/\\?/,\"\\\\?\")\n  brackets.gsub!(/\\\
    */,\"\\\\*\")\n  brackets.gsub!(/[^>]>?/,\"\")\n  brackets.gsub!(/>?</,\">\")\n\
    \  brackets.gsub!(/\\>?</,\">\")\n  bracket", "  brackets.chars.each do |char|\n\
    \    next if char.match(/[^>]/)\n    next if char.match(/^<$/)\n    next if char.match(/>$/)\n\
    \    next if char.match(/^>$/)\n    next if char.match(/^/>$/)\n    next if char.match(/^</)\n\
    \    next if char.match(/^>/)\n    next if char.match(/^</)\n    next if char.match(/^>/)\n\
    \    next if char.match(/^>>$/)\n    next if char.match(/^<<$/)\n    next if char.match(/^<>>>$/)\n\
    \    next if char.match(/^<<<$/)\n    next if char.match(/^>>>>$/)\n    next if\
    \ char.match(/^<><>>$/)\n    next if char.match(/^>>>>>$/)\n    next if char.match(/^<<<<<$/)\n\
    \    next if char.match(/^>>>>>>$/)\n    next if char.match(/^<><><>>$/)\n   \
    \ next if char.match(/^<<<><>>$/)\n    next if char.match(/^<><><><>>$/)\n   \
    \ next if char.match(/^<<<><><><>>$/)\n    next if char.match(/^<><><><><><>>$/)\n\
    \    next if char.match(/^<><><><><><><><>>$/)\n    next if char.match(/^<><><><><><><><><><><>>$/)\n\
    \    next if char.match(/^<><><><><><><><><><><><><><><>>$/)\n    next if char.match(/^<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><",
  "  brackets.each_char.with_index.reject do |char, i|\n    char =~ /[<>]/\n  end\
    \ == brackets.size\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby,string,regex\
    \ |>\nYou can use a recursive function with lookaheads like this:\n<code>", " \
    \   open_brackets = brackets.count(\"<\")\n    close_brackets = brackets.count(\"\
    >\")", "  bracket_pairs = brackets.split(\">\")\n  brackets_open = bracket_pairs.collect{|b|\
    \ b.split(\">\")}\n  brackets_closed = bracket_pairs.collect{|b| b.split(\"<\"\
    )}\n  \n  brackets_open.size.times do |i|\n    return false unless brackets_closed.size\
    \ == i\n    bracket_pair = brackets_open[i]\n    return false unless bracket_pair.size\
    \ == bracket_pairs.size\n    \n    bracket_pairs.each do |b_left, b_right|\n \
    \     return false if b_left == b_right\n    end\n    \n    bracket_pairs.pop\n\
    \  end\n  \n  return true\nend", "  brackets.split(\"\").each do |open|\n    open\
    \ =~ /\\</ ? next : next if open !~ /\\>/ && open != \">\"\n    close =~ /\\>/\
    \ ? next : next if close !~ /\\</ && close != \"<\"\n    next if close == open\n\
    \    true\n  end\n  false\nend", "    bracket_stack = []\n    if brackets.empty?\n\
    \        true\n    else\n        brackets.chars.each do |char|\n            if\
    \ char == \"<\"\n                bracket_stack.push \"<\"\n            else\n\
    \                bracket_stack.push char\n            end\n        end\n     \
    \   while bracket_stack.length > 0\n            if bracket_stack.pop == \"<\"\n\
    \                bracket_stack.push \"<\"\n            else\n                bracket_stack.push\
    \ bracket_stack.pop\n            end\n        end\n        if bracket_stack.empty?\n\
    \            true\n        else\n            false\n        end\n    end\nend",
  "  brackets.scan(/([^<]>){2}/) do |open_bracket, close_bracket|\n    next false\
    \ unless open_bracket == close_bracket\n    next false if open_bracket == \"<\"\
    \n    next true if open_bracket == \">\"\n    true\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby,regex,string dscore=2 |>\n<| c |>\n: That is correct.  I am not sure\
    \ if I missed a case but I did not test the case you described\n<|/ c |>\n<| c\
    \ |>\n: It seems that it would be a good idea to show a test case.\n<|/ c |>\n\
    <| c |>\n: It is probably better to use a regex `([^<]>){2}/` and then use `scan`,\
    \ since the regex `/([^<]>){2}/` would match a string that contained `<` or `>`\
    \ *twice*\n<|/ c |>\n<| c |>\n: You are right, I didn't think about that case.\
    \  I have updated the code\n<|/ c |>\n<| c |>\n: Yes, I see your point.  However,\
    \ the OP did say \"I want to find pairs of brackets where the opening and closing\
    \ bracket are the same character\" so I went with the simple solution that only\
    \ uses one character in the regex\n<|/ c |>\n<| a dscore=2 tags=ruby,regex,string\
    \ |>\nIn case you want to find pairs of brackets where the opening and closing\
    \ bracket are the same character, you can use the following regex pattern:\n<code>\n\
    /([^<]|<[^>])(?=[^>]|$)/\n</code>\nThe pattern matches a pair of brackets separated\
    \ by the following condition:", "  brackets.each_char.all? do |c|\n    case c\n\
    \    when \"<\" then c == \"<\"\n    when \">\" then c == \">\"\n    else c ==\
    \ \"<\"\n    end\n  end\nend", "  brackets = brackets.split(\"<>\")\n  brackets.each\
    \ do |b|\n    if b != \"<<>>\"\n      return false\n    end\n  end\n  return true\n\
    end", "    return brackets.scan(/\\<(.)\\>\\<\\<(.)\\>\\>\\<\\<(.)\\>\\>/\\).all?{|x|\
    \ x.scan(/\\<(.)\\>/).size == x.scan(/\\<(.)\\>\\<(.)\\>/).size }\nend", "  brackets.split(//).all?\
    \ { |opening, closing| opening.start_with?(\"<\") && closing.end_with?(\">\")\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\n`split(//)` isn't necessary in the first\
    \ place.\n<|/ c |>\n<| c |>\nThanks for the explanation of what `//` means in\
    \ regular expressions. I'm still learning Ruby and wanted to understand that better.\
    \ :)\n<|/ c |>\n<| c |>\n: Actually, `split(//)` does make a significant difference.\
    \  Consider `'A<B>C'.split('<')` where you want an array `['A', 'B', 'C']`, but\
    \ `'A<B>C'.split(/</)` gives you `['A', 'C']`, with the trailing `'C'` split off\
    \ from the last `'A'` element.  In your example, `'<'.end_with?(\">\")` will never\
    \ be true because `\"<\"` is always one character long.\n<|/ c |>\n<| c |>\n:\
    \ I suppose I should have mentioned that I tested it on Ruby 1.9.2 and it didn't\
    \ make any difference with or without `split(//)`, it just made things slightly\
    \ more complicated because I had to use `split(//).all?` instead of just `all?`.\
    \  I guess my point was that the `//` modifier doesn't really make a difference\
    \ in this case, but it did affect my test cases when I wasn't expecting it to.\n\
    <|/ c |>\n<| a tags=ruby,regex |>\nTo answer the second question:\n<code>", " \
    \ if brackets.blank?\n    false\n  else\n    brackets.gsub(/[<>]/) {|b| b == \"\
    >\" || b == \"<\" || b == \">>\" || b == \"<<\" || b == \"<=\" || b == \"<=>\"\
    }\n  end\nend", "  return brackets.gsub(\"[<>]\", \"&lt;&gt;\").length == 0\n\
    end", '  return (brackets =~ /\<\<|\<\>|\<<|\>\<|\>\>|\>\>|\<<|\>\>|\<\>|\>\>|\>\<|\>\<|\>\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>|\<\>',
  "  return brackets =~ /\\{[^{}]*\\}/\nend", "  brackets.scan(/\\(|\\)|\\[\\]|\\\
    {\\}/) do |bracket|\n    if bracket.to_s.include?(\"[\")\n      brackets.scan(/\\\
    [/) do |bracket|\n        brackets.scan(/\\]/) do |bracket|\n          brackets.scan(/\\\
    (|\\)|\\[\\]|\\{\\}/) do |bracket|\n            true\n          end\n        end\n\
    \      end\n    end\n    false\n  end\n  true\nend\n</code>\nThe regex should\
    \ match any set of brackets within any other set of brackets, and it should match\
    \ only a set of brackets itself.  \nSo when we have this input:\n<code>\n<[[[[[[[[[[[<]]]]]]]]]]]]]]]>\n\
    </code>\nThe regex should return true because the outer most set of brackets has\
    \ only two matching brackets, and the inner most set has three.  \nBut when we\
    \ have this input:\n<code>\n<[[[[[[[[[[[[[[[[<]]]]]]]]]]]]]]]]]>\n</code>\nThe\
    \ regex should return false because there are five opening brackets within the\
    \ same set of closing brackets.\n<|/ a tags=regex,ruby |>\n<| c |>\nThis is an\
    \ excellent answer. The explanation is great. Thank you.\n<|/ c |>\n<| c |>\n\
    `<[[[[[[[[[[[[[[[[[[[[<]]]]]]]]]]]]]]]]]]]>`.scan(/\\(|\\)|\\[\\]|\\{\\}/) do\
    \ |bracket| ... end => `<[[[[[[[[[[[[[[[[[[<]]]]]]]]]]]]]]]]]]]>`.scan(/\\(|\\\
    )|\\[\\]|\\{\\}/)\n<|/ c |>\n<| c |>\n\"this returns false because there are five\
    \ opening brackets within the same set of closing brackets.\" No, it's because\
    \ there are two opening brackets within the same set of closing brackets. What\
    \ you're seeing is exactly what my code does. I ran my code on that exact string,\
    \ and it returned true.\n<|/ c |>\n<| c |>\nsorry my bad you are right, I thought\
    \ you meant nested brackets, my bad\n<|/ c |>\n<| c |>\nAh, thank you for clarifying.\
    \ I was really confused because the code I originally posted had the return false\
    \ for the inner most set of brackets.  I fixed the answer after I saw your response,\
    \ but your explanation helped me better understand your solution.\n<|/ c |>\n\
    <| a d", '  brackets = brackets.to_s', "  brackets.split(//).each_with_index do\
    \ |s, i|\n    (i % 2).zero? ? s.gsub!(/\\</, \"<\") : s.gsub!(/\\>/, \">\")\n\
    \  end\n  brackets.empty?\nend", "    brackets.gsub!(/(<(\\S+))>/, '\\1 \\2')\
    \ # add whitespace\n    brackets.gsub!(/<(\\S+)/, '\\1') # remove whitespace\n\
    \    brackets.gsub!(/>(\\S+)/, '\\1') # remove whitespace\n    brackets.gsub!(/<(\\\
    S+)\\>/, '\\1 \\2') # add whitespace\n    brackets.gsub!(/>(\\S+)/, '\\1') # remove\
    \ whitespace\n    brackets.gsub!(/>(\\S+)/, '\\1 \\2') # add whitespace\n    brackets.gsub!(/<(\\\
    S+)\\>/, '\\1 \\2') # add whitespace\n    brackets.gsub!(/>(\\S+)/, '\\1') # remove\
    \ whitespace\n    brackets.gsub!(/\\1(\\S+)/, '\\1 \\2') # add whitespace\n  \
    \  brackets.gsub!(/\\1(\\S+)/, '\\1') # remove whitespace\n    brackets.gsub!(/<(\\\
    S+)\\>/, '\\1 \\2') # add whitespace\n    brackets.gsub!(/<(\\S+)\\>/, '\\1')\
    \ # remove whitespace\n    brackets.gsub!(/\\1(\\S+)/, '\\1 \\2') # add whitespace\n\
    \    brackets.gsub!(/\\1(\\S+)/, '\\1') # remove whitespace\n    brackets.gsub!(/(?<=\\\
    1<)</, '>') # add whitespace before <\n    brackets.gsub!(/(?<=\\1></, '<') #\
    \ remove whitespace after >\n    brackets.gsub!(/(?=\\1<)</, '>') # add whitespace\
    \ before <\n    brackets.gsub!(/(?=\\1></, '<') # remove whitespace after >\n\
    \    brackets.gsub!(/\\1</, '>') # add whitespace after >\n    brackets.gsub!(/\\\
    1</, '<') # remove whitespace after <\n    brackets.gsub!(/</, '>') # add whitespace\
    \ before <\n    brackets.gsub!(/</, '<') # remove whitespace before >\n    brackets.gsub!(/(?<=\\\
    1<)/, '>') # add whitespace before <\n    brackets.gsub!(/(?<=\\1>/, '<') # remove\
    \ whitespace after >\n    brackets.gsub!(/(?=\\1<)/, '>') # add whitespace before\
    \ <\n    brackets.gsub!(/(?=\\1>/, '<') # remove whitespace after >\n    brackets.gsub!(/(?<=\\\
    1<)/, '>') # add whitespace before ", "  brackets = brackets.split(\"<\")\n  brackets.each\
    \ { |b| correct_bracketing(b) }\n  return (brackets.size == brackets.uniq.size)\n\
    end", "  # split brackets and loop through pairs\n  brackets.split(\"\").each\
    \ { |b|\n    # return false if there are any incorrect brackets\n    return false\
    \ if b == \"<\" or b == \">\"\n    # return the index if the opening bracket has\
    \ a corresponding closing bracket\n    return b if b == \"<\"\n  }\n  # all brackets\
    \ are correctly matched\n  true\nend", "  brackets.gsub!(\"<\") { |x| \">\" }\n\
    \  brackets.gsub!(\">\") { |x| \"<\" }\n  brackets.empty?\nend\n</code>\n<|/ a\
    \ dscore=2 tags=ruby,regex |>\n<| c |>\nI find `/[<>]/` easier to read. :)\n<|/\
    \ c |>\n<| a dscore=2 |>\nIf you like to use regex, this one should do the job:\n\
    <code>\n/((?<=\\<)|(?=\\>))/\n</code>\nThis lookarounds make sure you have a correct\
    \ pair of opening and closing brackets.\n<|/ a tags=ruby,regex |>\n<| a dscore=1\
    \ |>\nIf you don't like lookahead/lookbehind you can use this:\n<code>\n/[(<)]/\n\
    </code>\n<|/ a tags=ruby,regex |>\n<| a tags=ruby,regex |>\nThe answers here are\
    \ great, but I thought I would elaborate on the use of square brackets.\nThe square\
    \ brackets are called character classes, which can be used in several ways:\n\
    To match any character inside them, you can use a plus sign:\n<code>\n[<]\n</code>\n\
    Or to match any character inside them, you can use a caret, with the caret inside\
    \ the square brackets:\n<code>\n[<]\n</code>\nOr to match any of the characters\
    \ in between them, you can use a hyphen with the hyphen inside the square brackets:\n\
    <code>\n[<-]\n</code>\nThere are many other characters that can be used to match\
    \ characters. For example, to match a literal plus sign you could use:\n<code>\n\
    [+]\n</code>\nOr to match a literal caret you could use:\n<code>\n[<^]\n</code>\n\
    In your case you want to match any two character combination. Using the square\
    \ brackets you can match any of those two characters. To match a combination of\
    \ two characters you can use the pipe character:\n<code>\n[<>|]\n</code>\nUsing\
    \ these examples you could match any opening or closing bracket pair or two character\
    \ combination, as follows:\n<code>\n<\n>\n<<\n>>\n<+\n>+\n<-\n>-\n<^\n>^\n[<]\n\
    [<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n[<]\n\
    [<]\n[<]\n", "  bracket_regex = /([<>])/\n  brackets.scan(bracket_regex) do |open_bracket,\
    \ close_bracket|\n    return false if open_bracket != close_bracket\n  end\n \
    \ true\nend\n</code>\nThe regular expression \"([<>])\" matches a character from\
    \ the set \"<\" and \">\", and captures them in the array $1, $2, ...\nThe method\
    \ scan iterates through the string in the parameter brackets, and for each character\
    \ in the string, it executes the block:", "    brackets.split(\"<\").each_with_object([])\
    \ do |s, a|\n        if a.last.nil? || s.match(/</)\n            a.last << s\n\
    \        else\n            a.last << a.last.last.dup\n        end\n    end.flatten.all?\
    \ {|s| s.match(/</)}\nend\n</code>\n<|/ a tags=string,ruby,regex |>\n<| a dscore=1\
    \ |>\n<code>", "  brackets.each_char.all? { |b| b == \"<\" } && !brackets.ends_with?(\"\
    <>\")\nend", "  return brackets =~ /\\<[^<>]+\\>/ and brackets =~ /\\<\\>/ and\
    \ brackets =~ /\\<\\<[^<>]+\\>\\>/ and brackets =~ /\\<\\<\\>\\>/ and brackets\
    \ =~ /\\<\\<\\<[^<>]+\\>\\>\\>/ and brackets =~ /\\<\\<\\<\\>\\>\\>/ and brackets\
    \ =~ /\\<\\<\\<\\<[^<>]+\\>\\>\\>\\>/ and brackets =~ /\\<\\<\\<\\<\\>\\>\\>\\\
    >/\nend", "    brackets = brackets.split(\"\")\n    opening_counts = Hash.new(0)\n\
    \    closing_counts = Hash.new(0)\n    openings = Array.new(length(brackets))\n\
    \    closings = Array.new(length(brackets))\n    # Find the openings and closing\
    \ brackets by counting how many times each opening or closing brackets appears.\n\
    \    brackets.each do |char|\n        if char == '<'\n            openings[opening_counts[char]]\
    \ +=1\n            opening_counts[char] += 1\n        else\n            closings[closing_counts[char]]\
    \ +=1\n            closing_counts[char] += 1\n        end\n    end\n    # Return\
    \ true if every opening bracket has a corresponding closing bracket.\n    openings.each_with_index\
    \ do |count, i|\n        if openings[i] == 0 && closings[i] == 0\n           \
    \ return false\n        end\n    end\n    return true\nend", "  brackets = brackets.gsub(/\\\
    (|\\)/, '')\n  brackets.gsub!(/[^<>]*/, '')\n  brackets.gsub!(/(<)(>)/, '\\1\\\
    2')\n  brackets.gsub!(/(<)(*>)/, '\\1\\2*')\n  brackets.gsub!(/(<)(\\*)/, '\\\
    1\\2*')\n  brackets.gsub!(/(>)(<)/, '\\1\\2')\n  brackets.gsub!(/(>)(\\*)/, '\\\
    1\\2*')\n  brackets.gsub!(/(>)(>)/, '\\1\\2')\n  brackets.gsub!(/([<>])(<)(\\\
    *)/, '\\1\\2\\3')\n  brackets.gsub!(/([<>])(\\*)(<)/, '\\1\\2\\3')\n  brackets.gsub!(/([<>])(\\\
    *)(>)/, '\\1\\2\\3')\n  brackets.gsub!(/([<>])(>)(<)/, '\\1\\2\\3')\n  brackets.gsub!(/([<>])(\\\
    *)(\\*)/, '\\1\\2\\3')\n  brackets.gsub!(/([<>])(\\*)(\\*)/, '\\1\\2\\3')\n  brackets.gsub!(/([<>])(\\\
    *)(\\*)/, '\\1\\2\\3')\n  brackets.gsub!(/(<)(>)\\*+/, '\\1\\2\\*')\n  brackets.gsub!(/(<)(\\\
    *)\\*+/, '\\1\\2\\*')\n  brackets.gsub!(/(<)(\\*)(>)/, '\\1\\2\\3')\n  brackets.gsub!(/(<)(\\\
    *)(\\*)/, '\\1\\2\\3')\n  brackets.gsub!(/(\\*)(<)(\\*)/, '\\1\\2\\3')\n  brackets.gsub!(/(\\\
    *)(\\*)(<)/, '\\1\\2\\3')\n  brackets.gsub!(/(\\*)(\\*)(>)/, '\\1\\2\\3')\n  brackets.gsub!(/(\\\
    *)(\\*)(\\*)/, '\\1\\2\\3')\n  brackets.gsub!(/(\\*)(\\*)(\\*)/, '\\1\\2\\3')\n\
    \  brackets.gsub!(/(\\*)(\\*)(\\*)/, '\\1\\2\\3')\n  brackets.gsub", "  brackets.gsub!(\"\
    [<>]\", \"<\").gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"<>\", \"[\").gsub!(\"\
    <>\", \"[\")\n  brackets.gsub!(\"[<>]\", \"\").gsub!(\"<>\", \"\")\n  brackets.gsub!(\"\
    <<>\", \"\")\n  return brackets != \"\"\nend\n</code>\nThis works because gsub!\
    \ is doing an in-place replacement of the string and any change is saved back\
    \ in brackets. As you can see we had to modify brackets in three places including\
    \ the last one because we want to make sure the last one is the only one left\
    \ empty - otherwise we would have changed the string that we are still interested\
    \ in.\nNow we know how to use regexes in Ruby. We can use them to find the position\
    \ of matching brackets, and extract them to a hash as we see them in the string:\n\
    <code>\nbrackets_pos = brackets.match(/[<>]+/).to_h\n</code>\nThis gives us something\
    \ like:\n<code>\n{ \"<\" => 1, \">\" => 2, \"<>\" => 3 }\n</code>\nNow we are\
    \ going to use these positions to extract each bracket from the string and replace\
    \ it with its correct corresponding opening or closing bracket.\n<code>", "  return\
    \ brackets.gsub(/\\<\\>/) do |x|\n    x == \">\" || x == \">>\" || x == \"<<\"\
    \ || x == \">>\" || x == \"<<\" ? \"true\" : \"false\"\n  end\nend", "  return\
    \ false if brackets.empty? || brackets.size < 2\n  brackets.split('').all? do\
    \ |char|\n    bracket = brackets.include? char ? '>' : '<'\n    next false if\
    \ bracket == '<'\n    next false if bracket == '>'\n    next false if bracket\
    \ == '<<'\n    next false if bracket == '>>'\n    bracket == '<<'\n  end\nend",
  "  brackets =~ /\\A<[<>]+\\>\\Z/ and brackets !~ /\\A<[<>]+>\\Z/\nend", "  # The\
    \ '<' and '>' characters are special here. They have special meaning in\n  # regexes,\
    \ and they need to be escaped.\n  regex = /\\A<.*?>|\\<.*?>|<.*?>|<.*>|\\</.*>|\\\
    </.*>|\\<.*>|\\<.*\\>/\n  brackets = brackets.split('</')\n  correct_brackets\
    \ = true\n  for bracket in brackets\n    # Escape all brackets so that we can\
    \ use them to match the correct ones in\n    # regexes.\n    bracket_escaped =\
    \ bracket.gsub(\"<\", \"\\\\<\")\n    bracket_escaped = bracket_escaped.sub(\"\
    >\", \"\\\\>\")\n    if !regex.match(bracket_escaped)\n      correct_brackets\
    \ = false\n      break\n  end\n  correct_brackets\nend", "  return brackets =~\
    \ /(<|>)+/ && brackets =~ /(<\\/?)(>)+/\nend\n</code>\nIf my thinking is correct,\
    \ this method will return true if the brackets are correctly nested. Notice that\
    \ this method will return true if either or both sides of the expression have\
    \ brackets. So if brackets = \"<<><>>\", then it would return true. \nThe next\
    \ method is to check whether the brackets expression is valid. I will just list\
    \ out all the valid brackets expressions below.\n<code>", "  bracket_pairs = []\n\
    \  brackets.split(\">\").each do |bracket_open|\n    bracket_pairs << bracket_open\n\
    \    bracket_pairs << bracket_open.dup\n  end\n  bracket_pairs.size == 0 ? false\
    \ : bracket_pairs.size == bracket_pairs.length - 1\nend", "  brackets.gsub!(\"\
    [<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\",\
    \ \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\"\
    )\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"\
    [<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\",\
    \ \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\"\
    )\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"\
    [<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\",\
    \ \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\"\
    )\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"\
    [<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\",\
    \ \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\"\
    )\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"\
    [<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\",\
    \ \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\"\
    )\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"[<>]\", \"<\")\n  brackets.gsub!(\"\
    [<>]\", \"<\")\n  brackets.gsub!(\"[", "  brackets_array = brackets.split(\">>\"\
    )\n  brackets_array.map!{|bracket| [bracket.split(\">\")] }\n  brackets_array.flatten.all?\
    \ { |bracket| correct_bracketing(bracket) }\nend", "    brackets = brackets.to_s\n\
    \    brackets.gsub!(/</, \"&lt;\")\n    brackets.gsub!(/>/, \"&gt;\")\n    brackets.gsub!(/<</,\
    \ \"&lt;&lt;\")\n    brackets.gsub!(/>>/, \"&gt;&gt;\")\n    brackets.gsub!(/><</,\
    \ \"&gt;&lt;&lt;\")\n    brackets.gsub!(/>></, \"&gt;&gt;&gt;\")\n    brackets.gsub!(/&lt;&lt;</,\
    \ \"&lt;&lt;&lt;\")\n    brackets.gsub!(/&gt;&gt;/, \"&gt;&gt;&gt;\")\n    brackets.gsub!(/&lt;&lt;&lt;</,\
    \ \"&lt;&lt;&lt;&lt;\")\n    brackets.gsub!(/&gt;&gt;&gt;/, \"&gt;&gt;&gt;&gt;\"\
    )\n    brackets.gsub!(/&gt;&gt;&gt;&gt;/, \"&gt;&gt;&gt;&gt;\")\n    brackets.gsub!(/&lt;&gt;&lt;&lt;/,\
    \ \"&lt;&gt;&lt;&lt;&lt;\")\n    brackets.gsub!(/&gt;&lt;&gt;&lt;&gt;/, \"&gt;&lt;&gt;&lt;&gt;&lt;&gt;\"\
    )\n    brackets.gsub!(/&gt;&gt;&gt;&lt;/, \"&gt;&gt;&gt;&gt;&lt;\")\n    brackets.gsub!(/&gt;&gt;&gt;&gt;&lt;/,\
    \ \"&gt;&gt;&gt;&gt;&lt;\")\n    brackets.gsub!(/&lt;&gt;&lt;&lt;&lt;/, \"&lt;&gt;&lt;&lt;&lt;&lt;\"\
    )\n    brackets.gsub!(/&gt;&lt;&gt;&lt;&gt;&lt;/, \"&gt;&lt;&gt;&lt;&gt;&lt;&gt;\"\
    )\n    brackets.gsub!(/&gt;&gt;&gt;&lt;&lt;/, \"&gt;&gt;&gt;&gt;&gt;&gt;\")\n\
    \    brackets.gsub!(/&gt;&gt;&gt;&gt;&gt;&gt;/, \"&gt;&gt;&gt;&gt;&gt;&gt;\")\n\
    \    brackets.gsub!(/&lt;&gt;&lt;&gt;&lt;&gt;/, \"&lt;&gt;&lt;&gt;&lt;&gt;\")\n\
    \    brackets.gsub!(/&gt;&lt;&gt;&lt;&gt;&lt;&gt;/, \"&gt;&lt;&gt;&lt;&gt;&lt;&gt;\"\
    )\n    brackets.gsub!(/&gt;&gt;&gt;&lt;&lt;/, \"&gt;&gt;&gt;&gt;&gt;&gt;\")\n\
    \    brackets.gsub!(/&gt;&gt;&gt;&gt;&gt;&gt;/, \"&gt;&gt;&gt;&gt;&gt;&gt;\")\n\
    \    brackets.gsub!(/&lt;&lt;&lt;&lt;&lt;&lt;/, \"&lt;&lt;&lt;&lt;&lt;&lt;\")\n\
    \    brackets.gsub!(/&gt;&lt;&lt;&lt;&lt;&gt;/, \"&gt;&lt;&lt;&lt;&lt;&gt;\")\n\
    \    brackets.gsub!(/&gt;&gt;&gt;&gt;&gt;&gt;/, \"&gt;&gt;&gt;&gt;&gt;&gt;\")\n\
    \    brackets.gsub!(/&lt;&gt;&lt;&gt;&lt;&gt;/, \"&lt;&gt;&lt;&gt;&lt;&gt;\")\n\
    \    brackets.gsub!(/&gt;&lt;&gt;&lt;&gt;&lt;&gt;/, \"&gt;&lt;&gt;", "    brackets.split('<').each_with_index\
    \ do |l, i|\n        if i < brackets.split('>').length -1\n            if l[i]\
    \ != '>' && l[i] != '>='\n                return false\n            end\n    \
    \    end\n    end\n    true\nend", "  bracket_pos = brackets.index(\">\")\n  until\
    \ bracket_pos == brackets.size-1\n    bracket_pos = brackets.index(brackets[bracket_pos+1])\n\
    \  while not brackets.include?(brackets[bracket_pos+1])\n    bracket_pos += 1\n\
    \  end\n  bracket_pos += 1\n  return bracket_pos == brackets.size\nend", "  brackets.scan(/</).all?\
    \ {|x| brackets.scan(/>/).none? {|y| x==y}} \nend", "  stack = []\n  opening_bracket\
    \ = nil\n  closing_bracket = nil\n  brackets.split('').each do |char|\n    if\
    \ char == \">\"\n      if opening_bracket\n        stack.pop\n        closing_bracket\
    \ = nil\n      else\n        opening_bracket = char\n      end\n    elsif char\
    \ == \"<\"\n      if closing_bracket\n        stack.pop\n        opening_bracket\
    \ = nil\n      else\n        closing_bracket = char\n      end\n    end\n    if\
    \ opening_bracket\n      stack.push char\n    end\n  end\n  if stack.length <\
    \ 2\n    return false\n  elsif stack.length == 1\n    if opening_bracket\n   \
    \   stack.pop\n      opening_bracket = nil\n    end\n    if closing_bracket\n\
    \      stack.pop\n      closing_bracket = nil\n    end\n  end\n  if opening_bracket\n\
    \    stack.pop\n    opening_bracket = nil\n  end\n  if closing_bracket\n    stack.pop\n\
    \    closing_bracket = nil\n  end\n  return stack.length == 0\nend", "  brackets.gsub(/(<\\\
    >)*\\1*/, \"\\0\")\n  !(brackets == \"\\0\")\nend", "  brackets = brackets.gsub(/[<>]/,\
    \ \"\")\n  brackets.gsub(/\\</) { |match| match.gsub(/\\</, \"&lt;\") }\n  brackets.gsub(/\\\
    >/) { |match| match.gsub(/\\>/, \"&gt;\") }\n  brackets == brackets.gsub(/\\</,\
    \ \"&lt;\").gsub(/\\>/, \"&gt;\")\nend", "  opening_brackets = []\n  for i in\
    \ brackets\n    if i == \"<\"\n      opening_brackets << i\n    end\n  end\n \
    \ opening_brackets.each do |opening|\n    if brackets.include?(opening)\n    \
    \  puts \"Incorrect bracketing: #{brackets} should be #{opening}<>#{opening}<\"\
    \n      return false\n    end\n  end\n  true\nend", "  return brackets == '<'\
    \ or brackets == '>'\nend", "  # Your code here.\n  bracket_stack = []\n  bracket_stack\
    \ << brackets\n  while bracket_stack.size > 0\n    next_bracket = bracket_stack.pop\n\
    \    if (next_bracket.size > 1)\n      bracket_stack << next_bracket\n    elsif\
    \ (next_bracket.size == 1)\n      if next_bracket[0] == \"<\"\n        bracket_stack.push(next_bracket.slice(1,next_bracket.size))\n\
    \      elsif next_bracket[0] == \">\"\n        bracket_stack.push(next_bracket.slice(0,next_bracket.size-1))\n\
    \      else\n        bracket_stack.push(bracket_stack.last.slice(0,bracket_stack.last.size-1))\n\
    \    elsif next_bracket.size == 0\n      return true\n    end\n  end\n  false\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  return brackets.chars.map\
    \ do |b|\n    b.chr\n    next b if b.chr == \"<\"\n    if b == \">\"\n      b.chr\n\
    \    else\n      b\n    end\n  end.all? do |b|\n    (0...b.length).all? do |i|\n\
    \      b[i] == \">\"\n    end\n  end\nend", "  # Create a stack for bracket checking.\n\
    \  # The stack stores a tuple of the current position and the current opening\n\
    \  # bracket type.\n  stack = []\n  # Push tuple (current_pos, current_bracket)\
    \ onto the stack.\n  stack.push(brackets.position, \"\")\n  # Loop while there\
    \ are still items on the stack.\n  while stack.length > 0\n    # Get the current\
    \ bracket type.\n    current_bracket = stack.last[1]\n    # Check if the corresponding\
    \ closing bracket is present on the stack.\n    if stack.length > 0 and stack.last[0]\
    \ == brackets.position\n      # If so, set the position to the previous position.\n\
    \      stack.last[0] = brackets.position\n      # Pop the last tuple and set the\
    \ current position to its value.\n      stack.pop\n      # Escape if no more brackets\
    \ available.\n      return false if stack.length == 0\n    # Move one position\
    \ forward in the string.\n    brackets.position += 1\n    # Push the current position\
    \ onto the stack.\n    stack.push(brackets.position, current_bracket)\n  return\
    \ true\nend\n</code>\n<|/ a tags=regex,ruby |>\n<| a dscore=0 |>\n<code>", " \
    \ # Your code here\n  return true\nend", "    brackets = brackets.to_s\n    opening\
    \ = brackets.count(\"<\")\n    closing = brackets.count(\">\")\n    return opening\
    \ == closing\nend", "  brackets.each do |b|\n    return false if b.length != 1\n\
    \    if b.upcase == \"<\"\n      b << \" \" unless b.empty?\n      bracket_stack\
    \ << b\n    elsif b == \"<<\"\n      bracket_stack << \">>\"\n    elsif b == \"\
    <<<\"\n      bracket_stack << \">>\"\n    elsif b == \">>\"\n      return false\
    \ unless bracket_stack.pop == \">>\"\n      bracket_stack << \">>\"\n    end\n\
    \  end\n  return true\nend", "  opening = brackets.split(\"\").map(&:to_i)\n \
    \ closing = brackets.split(\"\").map(&:to_i).reverse\n  (opening - closing).all?\
    \ { |i| opening.include?(i) }\nend", "  brackets.scan(/<|>|(<<|>>)/) do |match|\n\
    \    (match == \"<\" || match == \">\") && brackets.next\n  end\n  brackets.empty?\n\
    end", "  brackets.each_char.all? do |char|\n    next false unless char == \"<\"\
    \n    char == \"<\" && (!brackets.chars.all? { |c| c == \"<\" })\n  end\nend\n\
    </code>\nThe code could be made simpler using a regex that matches either of the\
    \ above conditions, but I wanted to show you what each piece does.  It works by\
    \ keeping track of whether the last character in the input was a closing bracket,\
    \ and checking that the current character is a opening bracket before updating\
    \ the previous character.\n<|/ a dscore=0 tags=arrays,string,ruby |>\n<| c |>\n\
    I really appreciate you taking your time to help me. I don't think the problem\
    \ is as simple as counting brackets. It seems more complicated. The function should\
    \ return true if the string contains two opening and closing brackets and false\
    \ if not. Also, your solution does not work because it will only return true if\
    \ the brackets are in the same order which is not true. For example the string\
    \ \"((()))\" will return true but \"(((()))\" will return false. Thanks again\
    \ for helping me out :)\n<|/ c |>\n<| c |>\n: What is your expected output for\
    \ `\"((()))\"`? Do you expect true or false?\n<|/ c |>\n<| c |>\nI edited my post,\
    \ I think I made it more clear what it needs to be done and why I need it done.\
    \ Thanks again for your help :)\n<|/ c |>\n<| c |>\n: It doesn't matter what order\
    \ you put them in, as long as they're in the same pair, right?  Just put them\
    \ in a string like `\"((()))\"` and run it through my solution, and you'll see\
    \ that it returns `true`.\n<|/ c |>\n<| c |>\nYou are right, thank you for correcting\
    \ me and helping me out. I really appreciate it!\n<|/ c |>\n<| a |>\n<code>",
  "  brackets = brackets.split('>')\n  brackets = brackets.reject { |b| b[0] == '<'\
    \ }\n  brackets = brackets.reject { |b| b[-1] == '>' }\n  brackets.empty?\nend",
  "  opening_matches = []\n  opening_match = \"\"\n  opening_count = 0\n  opening_match\
    \ = brackets.match(/[^<>]+/)\n  opening_count = opening_match.length\n  opening_matches.push([opening_count,\
    \ \"<\"])\n  opening_match = brackets.match(/\\<\\>/)\n  opening_count += 1\n\
    \  opening_matches.push([opening_count, \">\"])\n  opening_match = brackets.match(/\\\
    <\\><\\>/)\n  opening_count += 1\n  opening_matches.push([opening_count, \">\"\
    ])\n  opening_match = brackets.match(/\\<\\>\\>/)\n  opening_count += 1\n  opening_matches.push([opening_count,\
    \ \"<\"])\n  opening_match = brackets.match(/\\<\\><\\>\\>/)\n  opening_count\
    \ += 1\n  opening_matches.push([opening_count, \"<\"])\n  opening_match = brackets.match(/\\\
    <\\>\\><\\>/)\n  opening_count += 1\n  opening_matches.push([opening_count, \"\
    >\"])\n  opening_match = brackets.match(/\\<\\>\\>\\>/)\n  opening_count += 1\n\
    \  opening_matches.push([opening_count, \"<\"])\n  opening_match = brackets.match(/\\\
    <\\><\\>\\><\\>/)\n  opening_count += 1\n  opening_matches.push([opening_count,\
    \ \">\"])\n  opening_match = brackets.match(/\\<\\><\\><\\>\\>/)\n  opening_count\
    \ += 1\n  opening_matches.push([opening_count, \"<\"])\n  opening_match = brackets.match(/\\\
    <\\>\\>\\>\\>/)\n  opening_count += 1\n  opening_matches.push([opening_count,\
    \ \">\"])\n  opening_match = brackets.match(/\\<\\>\\><\\>\\>\\>/)\n  opening_count\
    \ += 1\n  opening_matches.push([opening_count, \"<\"])\n  opening_match = brackets.match(/\\\
    <\\>\\><\\>\\>\\><\\>/)\n  opening_count += 1\n  opening_matches.push([opening_count,\
    \ \">\"])\n  opening_match = brackets.match(/\\<\\>\\>\\>\\>\\><\\>/)\n  opening_count\
    \ += 1\n  opening_matches.push([opening_count, \"<\"])\n  opening_match = brackets.match(/\\\
    <\\>\\>\\>\\>\\><\\>\\>/)\n  opening_count += 1\n  open", "  brackets = brackets.to_s\n\
    \  brackets.gsub!(/[]/, \"\")\n  brackets.gsub!(/[\\[\\]]/, \"\")\n  brackets.gsub!(/<</,\
    \ \"<\")\n  brackets.gsub!(/>>/, \">\")\n  brackets.gsub!(/>>>/, \">>>\")\n  brackets.gsub!(/[]<>/,\
    \ \"\")\n  brackets.gsub!(/<<<>>/, \"<<<>>\")\n  brackets.gsub!(/<<<>/, \"\")\n\
    \  brackets.gsub!(/<>>/, \"\")\n  brackets.gsub!(/<></, \"\")\n  brackets.gsub!(/<<<>><>>/,\
    \ \"<<<>>\")\n  brackets.gsub!(/<<<>></, \"\")\n  brackets.gsub!(/<<<>><>/, \"\
    \")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/<>/, \"\")\n  brackets.gsub!(/<><>/>/,\
    \ \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/>/,\
    \ \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/>/,\
    \ \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/>/,\
    \ \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/>/,\
    \ \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/>/,\
    \ \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/>/, \"\")\n  brackets.gsub!(/<><>/,\
    \ \"\")\n  brackets.gsub!(/<><>/>/, \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub!(/<><>/>/,\
    \ \"\")\n  brackets.gsub!(/<><>/, \"\")\n  brackets.gsub", "    brackets.split(\"\
    \").all? {|b| b.start_with?(\"<\") || b.start_with?(\">\") }\nend\n</code>\nNow\
    \ the main function, which is also a functional program\n<code>", "  brackets.split(\"\
    <\").all? do |opening_bracket|\n    brackets.split(opening_bracket).all? do |closing_bracket|\n\
    \      brackets.split(closing_bracket).all? do |closing_bracket|\n        return\
    \ opening_bracket.include? closing_bracket\n      end\n    end\n  end\n  false\n\
    end", "  return brackets.scan(/</).all? { |x| brackets.scan(/>/).include? x }\n\
    end", "    return brackets =~ /\\A\\<.*\\>\\Z/\nend", "  return brackets.split(\"\
    <\").all? { |x| x.include?(\">\") }\nend\n</code>\nEDIT:\nTo add more to the answer,\
    \ I've also changed your brackets method from returning the string and adding\
    \ it to an array, so that the array can be easily sorted to get the correct order.\n\
    <code>", "  open_brackets = brackets.count(\"<\")\n  close_brackets = brackets.count(\"\
    >\")\n  return open_brackets == close_brackets\nend", "  brackets = brackets.to_s\n\
    \  brackets.gsub!(/(^<)|(>$)/, '')\n  brackets.gsub!(/(<[^<>]*)\\(([^<>]*)\\)/,\
    \ '\\1\\2')\n  return brackets == \"<>\"\nend\n</code>\n<|/ a tags=regex,ruby\
    \ |>\n<| c |>\nYour `correct_bracketing` can be greatly simplified as `brackets.gsub!(/(^<)|(>$)/,\
    \ '')[1..-2].all? { |c| c == '<' }`\n<|/ c |>\n<| a |>\nJust for fun, here's a\
    \ one-liner:\n<code>\n<foo>.split('<').drop(1).map{|x| x}.join(\"\").split(\"\
    >\").last.start_with?('<') #=> true\n<foo>.split('<').drop(1).map{|x| x}.join(\"\
    \").split(\">\").last.start_with?('>') #=> false\n</code>\nEdit:\nAs pointed out\
    \ in the comments, this version doesn't work if < is followed up by another <.\n\
    <code>\n<foo>.split('<').drop(1).map{|x| x}.join(\"\").split(\">\").last.start_with?('<')\
    \ #=> true\n<foo>.split('<').drop(1).map{|x| x}.join(\"\").split(\">\").last.start_with?('<')\
    \ #=> false\n</code>\n<|/ a tags=regex,ruby dscore=1 |>\n<| c |>\n`split` is not\
    \ needed when using the first method. `[foo].split(/<>/).last.start_with?('<')\
    \ #=> true`\n<|/ c |>\n<| c |>\nTrue, but that would make it easier to deal with\
    \ trailing `<`s.\n<|/ c |>\n<| a dscore=1 tags=regex,ruby |>\nA simpler one:\n\
    <code>", "  brackets = brackets.to_s\n  open_brackets = brackets.count(\"<\")\n\
    \  closed_brackets = brackets.count(\">\")\n  \n  # The first opening and last\
    \ closing bracket have to be closed in order\n  # to be correct.\n  if open_brackets\
    \ < closed_brackets\n    brackets.gsub!(/[<>]/,\"\")\n  else\n    brackets.gsub!(/[<>]$/,\"\
    \")\n  end\n  \n  return brackets == brackets.gsub(/(<{2,})|(>{2,})/,\"\")\nend",
  "  return brackets.chars.all? do |char|\n    correct_bracketing.call(char + \"<\"\
    )\n  end\nend", "  brackets.gsub!(/[<>]+/) { \"<#{&}>\" }\n  brackets.scan(/<(\\\
    w+)>/ do |tag|\n    return tag if tag != \"<>\"\n    raise ArgumentError, \"expected\
    \ closing tag, but got #{tag}\"\n  end)\n  brackets.gsub!(/[<>]+/) { \"<#{&}>\"\
    \ }\n  brackets.scan(/</) do |tag|\n    return tag if tag != \"<>\"\n    raise\
    \ ArgumentError, \"expected opening tag, but got #{tag}\"\n  end\n  brackets.gsub!(/<>+/)\
    \ \"\"\nend", "  brackets = brackets.to_s\n  opening_brackets = {}\n  current_bracket\
    \ = []\n  brackets.scan(/[<>]/) do |opening_symbol|\n    current_bracket.push(opening_symbol)\n\
    \    if opening_symbol == \"<\"\n      opening_brackets[opening_symbol] = current_bracket\n\
    \      current_bracket = []\n    elsif opening_symbol == \">\"\n      if opening_brackets[opening_symbol].size\
    \ != 1\n        puts \"Error: Mismatched brackets in #{brackets}. Was expecting\
    \ at most one closing bracket.\"\n        exit 99\n      end\n      opening_brackets.pop(opening_symbol)\n\
    \    end\n  end", "  brackets = brackets.to_s\n  return brackets.count(\"<\")\
    \ + brackets.count(\">\") <= brackets.count(\"<<>>\")\nend", "  brackets.split(\"\
    <\").each do |opening_bracket|\n    next if opening_bracket.empty?\n    next if\
    \ opening_bracket.count != 1", "  brackets.split(\"\").all? { |b| b == \"<\" ||\
    \ b == \">\" }\nend", "  # Only process opening brackets.\n  return brackets =~\
    \ /\\<\\<.*\\>\\>/ ? true : false\nend", "  return brackets.split('<').all? {|x|\
    \ x.split('>').all? {|y| y == x}}\nend", "  brackets = brackets.to_s\n  opening_parentheses\
    \ = brackets[0..1]\n  closing_parentheses = brackets[2..-1]\n  opening_paren_count\
    \ = brackets.count('(', opening_parentheses)\n  closing_paren_count = brackets.count(')',\
    \ closing_parentheses)\n  correct_paren_count = opening_paren_count + closing_paren_count\n\
    \  return opening_paren_count == correct_paren_count\nend", "  brackets.split('<').all?\
    \ do |opener|\n    brackets.split('>').all? do |closer|\n      opener == closer\n\
    \    end\n  end\nend", "  brackets.to_s.chars.all? {|x| x == \">\" || x == \"\
    <\"}\nend", "  return (brackets.count \"<\") == (brackets.count \">\") && brackets\
    \ == \"<>\"\nend\n</cell>\n<text>\nStrings\nNow let's make our function more general\
    \ by accepting Strings instead of characters.", "  open_brackets = \"(\" * brackets.length\n\
    \  close_brackets = \")\" * brackets.length\n  open_brackets.split(\"\").each\
    \ do |x|\n    close_brackets.split(\"\").each do |y|\n      return false unless\
    \ x == y\n    end\n  end\n  true\nend", "  brackets == \"\" or\n    (brackets\
    \ =~ /^(<([<>]))?/ and\n     brackets =~ /^(>([<>]))?$/) or\n    (brackets =~\
    \ /^<([<>])$/ and\n     brackets =~ /^>([<>])$/) or\n    (brackets =~ /^<([<>])$/)\
    \ and\n     brackets =~ /^>([<>])$/)\nend", "    brackets.scan(/([<][^>]*>[^<>]*<[^>]*>[^<]*<)([^<]*)/)\
    \ do |m, left, middle, right|\n        if left != right\n            return false\n\
    \        end\n    end\n    true\nend", "  brackets.scan(/<|>|&|\\[|\\]/)\n  brackets.size\
    \ == brackets.size-1\nend", "  brackets.to_s.chars.all? do |c|\n    c == \">\"\
    \ || c == \">>\" || c == \"<\" || c == \"<<\" || c == \"<\"\n  end\nend", "  return\
    \ brackets =~ /(^|<|>)([^<>]+)(<|$)/ && brackets =~ /^<.*>$/ ?\n    brackets !~\
    \ /[^<>]+<.*>/ : brackets =~ /^<.*>$/ ? true : false\nend", "  brackets.chars.all?\
    \ do |char|\n    char == \"<\" || char == \">\"\n  end\nend", "    brackets =\
    \ brackets.split(\"<\")\n    correct_bracketing = true\n    brackets.each { |bracket|\
    \ correct_bracketing = correct_bracketing &&\n        bracket.include?(\">\")\
    \ }\n    return correct_bracketing\nend\n</code>\n<|/ a tags=ruby,recursion,boolean\
    \ dscore=1 |>\n<| c |>\nOops. Should have noticed the missing \"<\". Fixed now.\n\
    <|/ c |>\n<| a dscore=1 tags=ruby,recursion,boolean |>\nThis is my solution:\n\
    <code>", "  opening = brackets[0...0]\n  closing = brackets[0...0]", "  brackets.chars.sort.each\
    \ do |char|\n    return false if char == \">\"\n    return true if char == \"\
    <\"\n    return false if char == \"<\"\n    return true if char == \">\"\n  end\n\
    \  return true\nend", "  brackets.split('<').map{|x| correct_bracketing(x)}.all?{|x|\
    \ x}\nend\n</code>\n<|/ a |>\n<| c |>\nI'm not the downvoter, but this doesn't\
    \ work for `def correct_bracketing(brackets)\n  brackets.split('<').map{|x| correct_bracketing(x)}.all?{|x|\
    \ x}\nend`\n<|/ c |>\n<| c |>\nIt returns false for me: `correct_bracketing(\"\
    <<><>>\")`\n<|/ c |>\n<| c |>\nAh yes, `correct_bracketing` should be called only\
    \ once per string\n<|/ c |>\n<| c |>\nI edited my solution to handle multiple\
    \ opening brackets.\n<|/ c |>\n<| a |>\nI would use this regular expression:\n\
    <code>\n/\\{([^}]*?)\\}/\n</code>\nThe pattern matches all bracket pairs that\
    \ are not part of a nested pair of brackets. The brackets themselves are captured\
    \ in group 1. In Ruby that would be:\n<code>\n/\\{([^}]*?)\\}/\n</code>\nDemo:\n\
    <code>\n>> string = \"{a}\"\n>> string =~ /\\{([^}]*?)\\}/\n=> 0\n>> $&\n=> \"\
    a\"\n</code>\n<|/ a tags=ruby,regex dscore=3 |>\n<| c |>\nThat was the only answer\
    \ that worked for me. I wish I could select both answers as correct.\n<|/ c |>\n\
    <| a |>\nA simple solution without regex:\n<code>", "  brackets.gsub(/\\<\\>/)\
    \ { |x| x == \">\" || x == \"<\" || x == \"<=\" || x == \"<=>\" } ? false : true\n\
    end", "  brackets = brackets.to_s\n  brackets.gsub!(/\\A</, \"\") # delete leading\
    \ \"<\"\n  brackets.gsub!(/>/, \"\") # delete trailing \">\"\n  brackets.gsub!(/[<>]\\\
    Z/, \"\") # delete trailing \"< >\"\n  brackets.gsub!(/\\A[<>]/, \"\") # delete\
    \ leading \"<\" and trailing \">\"\n  brackets.gsub!(/\\A[<>]\\Z/, \"\") # delete\
    \ leading \"<\" and trailing \">\"\n  return brackets != brackets.to_s\nend\n\
    </code>\nThe method above only works if the brackets are correctly formed, e.g.\
    \ brackets.count(\"<\") + brackets.count(\"<>\") == brackets.count(\"[]\") + brackets.count(\"\
    []\"). Your method will throw an error if brackets is something else (e.g. \"\
    ([])\").\nIf the brackets are correctly formed, you can use the following method\
    \ to determine if brackets are nested and which one to remove:\n<code>", "  brackets.each\
    \ do |bracket_char|\n    next if bracket_char == bracket_char\n    break if bracket_char\
    \ == \"<\" # this prevents </>\n    bracket_char == \"<\"\n  end\n  !brackets.include?(bracket_char)\n\
    end", "  return brackets =~ /\\<\\>/\nend", "  return brackets =~ /\\{|\\}/\n\
    end", "  brackets.gsub(/[{}()<>]/,\"\").empty?\nend", "  brackets = brackets.to_s\n\
    \  return brackets =~ /^<.*>$/\nend", "  bracket_stack = []\n  bracket_stack <<\
    \ brackets[0]\n  correct_bracket = true\n  bracket_stack.each do |b|\n    if b\
    \ != \"<\"\n      correct_bracket = false\n    end\n    bracket_stack << b\n \
    \ end\n  bracket_stack.pop\n  correct_bracket\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\n`<` and `>` are not guaranteed to be the only characters in a string.\n\
    <|/ c |>\n<| c |>\nI was just giving the OP the idea of how to do it.  I'll edit\
    \ my answer to account for the fact that `<` and `>` could be anything.\n<|/ c\
    \ |>\n<| c |>\nI believe that using an external library to solve this problem\
    \ is overkill. Though I appreciate the effort, it doesn't add any real value to\
    \ the question.\n<|/ c |>\n<| c |>\nI agree with you.  I didn't want to get too\
    \ far down the rabbit hole but that's probably why I thought it would be helpful\
    \ to point out that there's multiple ways to do this :)\n<|/ c |>\n<| c |>\nHe\
    \ doesn't need to use any external library to do this, as he already knows how\
    \ to do this with regular Ruby. He just wants some help on implementing it efficiently\
    \ in Ruby.\n<|/ c |>\n<| a |>\nIf your input is very long, consider using Aho-Corasick\
    \ to find all occurrences of substrings in a larger string. Then, you can easily\
    \ see how many times each substring occurs.\n<code>\nrequire 'ahocorasick'", " \
    \ bracket_pairs = brackets.split(\"<>\")\n  opening_brackets = bracket_pairs.map\
    \ { |b| b.split(\"<\").first }\n  closing_brackets = bracket_pairs.map { |b| b.split(\"\
    >\").last }\n  opening_brackets.zip(closing_brackets).all? { |a,b| a <=> b }\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,regex,string |>\nYou could use gsub\n<code>",
  "  brackets.chars.each_with_index do |char, index|\n    # Handle the case where\
    \ there are no more opening brackets\n    if index == brackets.size - 1\n    \
    \  brackets.clear\n      true\n    # Handle the case where there are more closing\
    \ brackets than opening brackets\n    elsif index < brackets.size - 1\n      brackets.clear\n\
    \      false\n    # Handle the case where there are the same number of opening\
    \ brackets as closing brackets\n    else\n      brackets.clear\n      brackets.push\
    \ char\n      correct_bracketing(brackets)\n    end\n  end\nend", "  return brackets.length\
    \ == brackets.gsub(\">\",\"<\").length\nend", "    brackets.split(\"\").each do\
    \ |char|\n        return false if char == \">\"\n        return true if char ==\
    \ \"<\"\n    end\n    true\nend", "  brackets = brackets.to_s\n  brackets = brackets.gsub('>',\
    \ '')\n  brackets = brackets.gsub('<', '')\n  brackets = brackets.gsub('>>', '')\n\
    \  brackets = brackets.gsub('<<', '')\n  brackets = brackets.gsub('>>', '')\n\
    \  brackets = brackets.gsub('<<', '')\n  brackets = brackets.gsub('<<', '')\n\
    \  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('<', '')\n  brackets\
    \ = brackets.gsub('>', '')\n  brackets = brackets.gsub('<', '')\n  brackets =\
    \ brackets.gsub('>', '')\n  brackets = brackets.gsub('<', '')\n  brackets = brackets.gsub('>',\
    \ '')\n  brackets = brackets.gsub('<', '')\n  brackets = brackets.gsub('>', '')\n\
    \  brackets = brackets.gsub('<', '')\n  brackets = brackets.gsub('>', '')\n  brackets\
    \ = brackets.gsub('>', '')\n  brackets = brackets.gsub('<', '')\n  brackets =\
    \ brackets.gsub('>', '')\n  brackets = brackets.gsub('<', '')\n  brackets = brackets.gsub('>',\
    \ '')\n  brackets = brackets.gsub('<', '')\n  brackets = brackets.gsub('>', '')\n\
    \  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n  brackets\
    \ = brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n  brackets =\
    \ brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('>',\
    \ '')\n  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n\
    \  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n  brackets\
    \ = brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n  brackets =\
    \ brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('>',\
    \ '')\n  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n\
    \  brackets = brackets.gsub('>', '')\n  brackets = brackets.gsub('>', '')\n  brackets\
    \ = brackets.gsub('>', '')\n  brackets = brackets.gsub", "  brackets.split('><').uniq.all?{|x|\
    \ brackets.split('><').count(x) == 2}\nend", "  return brackets.count == '<' and\
    \ brackets.count == '>'\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a dscore=0\
    \ tags=ruby |>\nHere's a function that works just like Ruby's built-in Array#sum:\n\
    <code>", "  brackets.split('>').reject(&:empty?).all? {|t| t.start_with?('<')}\n\
    end\n</cell>\n<cell>\n@test correct_bracketing('<<><>>')\n@test correct_bracketing('>')\n\
    </cell>\n<text>\nExercise:", "  brackets = brackets.to_s.strip\n  # If there are\
    \ no brackets then the statement is false.\n  return !brackets.empty?\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nI love this solution, but for me `correct_bracketing(\"\
    <<><>>\")` returns `true`, which is not correct. :(\n<|/ c |>\n<| c |>\nThe solution\
    \ you posted is correct. `correct_bracketing(\"<<><>>\")` returns true because\
    \ of the missing closing bracket and because of the double > sign after the last\
    \ closing bracket. I've added an explanation.\n<|/ c |>\n<| c |>\nYes, I see what\
    \ you mean. I'm going to re-write my answer using your method. Thank you.\n<|/\
    \ c |>\n<| a dscore=3 |>\n<code>", "  bracket_counts = brackets.each_char.with_object(Hash.new(0)){|c,\
    \ h| h[c] += 1 }\n  bracket_counts.all? { |k, v| v == 1 }\nend\n</code>\n<|/ a\
    \ tags=ruby,algorithm |>\n<| c |>\nVery nice. Hadn't thought of using each_char.\n\
    <|/ c |>\n<| c |>\nAren't you missing a `]` in the first `each_char` call?\n<|/\
    \ c |>\n<| c |>\n: yep, was working on it -- fixed\n<|/ c |>\n<| c |>\n: I find\
    \ it hard to read code with lots of parenthesis... I might make an edit, but it\
    \ seems to work...\n<|/ c |>\n<| c |>\nThanks!  I really appreciate all the time\
    \ you spent on this!\n<|/ c |>\n<| a tags=ruby,algorithm |>\nI'd just loop through\
    \ it and use a boolean flag to keep track of which ones were correct.  Then, just\
    \ return that flag.\n<code>", "  return brackets =~ /<|>|<|>|\\(|\\)/\nend", " \
    \ # split the brackets string on whitespace, giving us an array\n  # of substrings\
    \ broken by whitespace.  \"<<<>>>\" would give\n  # ['<<<', '>>>']\n  tokens =\
    \ brackets.split\n  \n  # Now go through the array of substrings looking for pairs\
    \ that\n  # aren't adjacent in any way and are correctly bracketing\n  correct_pair\
    \ = false\n  tokens.each do |pair|\n    # If the substring doesn't match this\
    \ pattern, then it isn't the\n    # correct bracket pair\n    return false if\
    \ !pair.match(/((<)|>(>))|((<)>(>))|((<)(>))/)", "    return brackets.scan(/^(<.*>)$/).none?\n\
    end", "  brackets.gsub(/(>|<)+/) do |bracket|\n    correct_bracketing(bracket)\n\
    \  end\nend", "  brackets = brackets.downcase\n  correct_brackets = (brackets[0..-2].to_s.count(\"\
    <\") +\n                      brackets[-2..-2].to_s.count(\"<\")) == (brackets[0..-2].to_s.count(\"\
    <\") + brackets[-2..-2].to_s.count(\"<\"))\n  correct_brackets &&= (brackets[0..-2].to_s.count(\"\
    </\") -\n                         brackets[-2..-2].to_s.count(\"</\")) == (brackets[0..-2].to_s.count(\"\
    </\") - brackets[-2..-2].to_s.count(\"</\"))\n  correct_brackets\nend", "  # Handle\
    \ the case where the brackets are empty.\n  return brackets.empty? || brackets.chars.all?\
    \ { |char| char == \">\" }\nend", "  brackets.each_char.with_index.reject do |char,\
    \ i|\n    char == \">\" unless i == 0\n  end\nend", "  brackets = brackets.to_s\n\
    \  brackets.reverse!\n  brackets.each_char.with_index do |char, index|\n    return\
    \ false if index == 0\n    return true if char == \">\" and not brackets[index-1].nil?\n\
    \    return true if char == \"<\" and not brackets[index+1].nil?\n  end\n  true\n\
    end", "  opening = false\n  closing = false\n  open = 0\n  close = 0\n  brackets.each_char\
    \ do |char|\n    case char\n    when \"<\" then opening = true if opening then\
    \ close += 1 end\n    when \">\" then closing = true if closing then open += 1\
    \ end\n    when \"(\" then open += 1 end\n    when \")\" then close += 1 end\n\
    \  end\n  (opening==closing) and (open==close)\nend", "  brackets.split('<').each_with_index\
    \ do |open, index|\n    if open != \">\"\n      open < brackets[index + 1]\n \
    \   end\n  end\nend", "  open_brackets = brackets.scan(/[<>]/).map { |x| x ==\
    \ \">\" ? \">\" : x }\n  close_brackets = open_brackets.map { |x| x + \"<\" }\n\
    \  close_brackets.each_cons(2).all? { |left, right| left == right }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI believe your method would be better if you would use `scan`\
    \ instead of `match`, since `scan` returns the same array that `match` returns\
    \ on success, which would let you simplify it quite a bit. Also, please have a\
    \ look at the comment by Eli Bendersky's answer - he pointed out a bug and described\
    \ a similar fix.\n<|/ c |>\n<| c |>\nthanks! I had a feeling you'd get that point.\
    \ I edited my answer accordingly.\n<|/ c |>\n<| c |>\nYeah, the `scan` method\
    \ was my first inclination as well, but I couldn't figure out how to use it for\
    \ this particular problem. `scan` just seemed like a more natural solution. I\
    \ like the idea, though, and I'm definitely going to be using it in future. :)\n\
    <|/ c |>\n<| c |>\nThis looks like it's working with my test cases, but I'm a\
    \ little confused. The only thing I see that differs from my original is that\
    \ the first `scan` call only checks the character before the first `<`, and the\
    \ second `scan` call only checks the character after the first `<`. Is there a\
    \ reason to use one over the other?\n<|/ c |>\n<| c |>\nThe first one checks the\
    \ character before the first `<` and the second one checks the character after\
    \ the first\n<|/ c |>\n<| a dscore=2 |>\nI figured it out. Here's my solution:\n\
    <code>", "  brackets = brackets.to_s\n  brackets.chars.each do |char|\n    if\
    \ char == \">\" || char == \"<\"\n      return false if brackets.count(\"</#{char}\"\
    ) != brackets.count(\"</#{char}>\")\n    end\n  end\n  true\nend", "  brackets\
    \ == bracket_patterns.map {|b| \"<#{b}>\" }.join(\" \")\nend", "  # The string\
    \ \"<<><>>\" has no brackets\n  if brackets.length == 0\n    return false\n  #\
    \ There are at least two characters: an opening bracket and another character.\n\
    \  opening = brackets[0]\n  character = brackets[1]\n  # A closing bracket must\
    \ follow the opening bracket.\n  closing = brackets[brackets.length-1]\n  # The\
    \ opening bracket must occur at the beginning of the string.\n  opening.size ==\
    \ 0 && opening.empty?\n  \n  # The closing bracket must occur at the end of the\
    \ string.\n  closing.size == 0 && closing.empty?\n  \n  # No characters other\
    \ than opening or closing brackets.\n  character.nil? && opening == closing &&\
    \ closing.empty?\n  \n  # The string \"<<><>>\" has at least one opening and one\
    \ closing bracket.\n  opening.empty? && closing.empty?\n  \n  # If there are no\
    \ characters other than an opening or closing bracket, \n  # there are at least\
    \ two characters: an opening bracket and another character.\n  character.nil?\
    \ && opening == brackets[0] && closing.empty?\nend\n</code>\n<|/ a |>\n<| a |>\n\
    Here's a recursive solution that doesn't use a regular expression or anything\
    \ fancy.\n<code>", "  brackets.scan(/\\<+|\\<+\\>+|\\>+\\>+|\\<|\\>|\\>|\\>\\\
    >\\>/)\n  brackets.empty?\nend", "  brackets_ = brackets.split\n  bracket_counts\
    \ = brackets_.collect { |b| b.length }.uniq.to_a\n  bracket_counts == [0, 1, 2,\
    \ 4, 7, 9, 14, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63,\
    \ 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 110, 113, 116,\
    \ 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164,\
    \ 167, 170, 173, 176, 179, 182, 185, 188, 191, 194, 197, 200, 203, 206, 209, 212,\
    \ 215, 218, 221, 224, 227, 230, 233, 236, 239, 242, 245, 248, 251, 254, 257, 260,\
    \ 263, 266, 269, 272, 275, 278, 281, 283, 286, 289, 292, 295, 298, 301, 304, 307,\
    \ 310, 313, 316, 319, 322, 325, 328, 331, 334, 337, 340, 343, 346, 349, 352, 355,\
    \ 358, 361, 364, 367, 370, 373, 376, 379, 382, 385, 388, 391, 394, 397, 400, 403,\
    \ 406, 409, 412, 415, 418, 421, 424, 427, 430, 433, 436, 439, 442, 445, 448, 451,\
    \ 454, 457, 460, 463, 465, 468, 471, 474, 477, 480, 483, 486, 489, 492, 495, 498,\
    \ 501, 504, 507, 510, 513, 516, 519, 522, 525, 528, 531, 534, 537, 539, 542, 545,\
    \ 548, 551, 554, 557, 560, 563, 565, 568, 571, 574, 577, 580, 583, 586, 589, 592,\
    \ 595, 598, 601, 604, 607, 610, 613, 616, 619, 622, 625, 628, 631, 634, 637, 639,\
    \ 642, 645, 648, 651, 654, 657, 660, 663, 666, 669, 672, 675, 678, 681, 684, 687,\
    \ 690, 693, 696, 699, 702, 705, 708, 711, 714, 717, 719, 722, 725, 728, 731, 734,\
    \ 737, 7", "  return brackets.gsub(/[<>]/) {|x| x == \"<\" ? \">\" : x}\nend",
  "  brackets.gsub(/[<>]+/) { |match| match.upcase }\n    .split(//)\n    .all? {\
    \ |bracket| bracket =~ /\\</ }\nend", "  brackets.gsub!(/^<(</) { \"<\" }\n  brackets.gsub!(/^>(</)\
    \ { \"<\" }\n  brackets.gsub!(/^<\\/(</) { \"<\" }\n  brackets.gsub!(/^>\\/(</)\
    \ { \"<\" }\n  brackets.gsub!(/^<\\/(</) { \"<\" }\n  brackets.gsub!(/^>\\/(</)\
    \ { \"<\" }\n  brackets.gsub!(/^<(</) { \"<\" }\n  brackets.gsub!(/^>(</) { \"\
    <\" }\n  brackets.gsub!(/^<\\/)(</) { \"<\" }\n  brackets.gsub!(/^>\\/(</) { \"\
    <\" }\n  brackets.gsub!(/^<\\/)(</) { \"<\" }\n  brackets.gsub!(/^>\\/(</) { \"\
    <\" }\n  brackets.gsub!(/^<(\\/(</) { \"<\" }\n  brackets.gsub!(/^>(\\/(</) {\
    \ \"<\" }\n  brackets.gsub!(/^<\\/)(\\/(</) { \"<\" }\n  brackets.gsub!(/^>\\\
    /(\\/(</) { \"<\" }\n  brackets.gsub!(/^<(\\/(</) { \"<\" }\n  brackets.gsub!(/^>(\\\
    /(</) { \"<\" }\n  brackets.gsub!(/^<)(\\/(</) { \"<\" }\n  brackets.gsub!(/^>)(\\\
    /(</) { \"<\" }\n  brackets.gsub!(/^<\\/(\\/(</) { \"<\" }\n  brackets.gsub!(/^>\\\
    /(\\/(</) { \"<\" }\n  brackets.gsub!(/^<\\/(\\/(</) { \"<\" }\n  brackets.gsub!(/^>\\\
    /(\\/(</) { \"<\" }\n  brackets.gsub!(/^<(</) { \"<\" }\n  brackets.gsub!(/^>(</)\
    \ { \"<\" }\n  brackets.gsub!(/^<)(</) { \"<\" }\n  brackets.gsub!(/^>(</) { \"\
    <\" }\n  brackets.gsub!(/^<\\/)(</) { \"<\" }\n  brackets.gsub!(/^>(</) { \"<\"\
    \ }\n  brackets.gsub!(/^<\\/)(</) { \"<\" }\n  brackets.gsub!(/^>)(</) { \"<\"\
    \ }\n  ", "  brackets.gsub!(/(<)\\1(?(1)>)/, '\\1\\2')\n  brackets.gsub!(/(<\\\
    1>)/, '\\1')\n  brackets.gsub!(/(<\\2>)/, '\\2')\n  brackets.gsub!(/(<\\3>)/,\
    \ '\\3')\n  brackets.gsub!(/(<\\4>)/, '\\4')\n  brackets.gsub!(/(<\\5>)/, '\\\
    5')\n  brackets.gsub!(/(<\\6>)/, '\\6')\n  brackets.gsub!(/(<\\7>)/, '\\7')\n\
    \  brackets.gsub!(/(<\\b>)/, '\\b')\n  brackets.gsub!(/(<\\t>)/, '\\t')\n  brackets.gsub!(/(<\\\
    n>)/, '\\n')\n  brackets.gsub!(/(<\\v>)/, '\\v')\n  brackets.gsub!(/(<\\f>)/,\
    \ '\\f')\n  brackets.gsub!(/(<\\r>)/, '\\r')\n  brackets.gsub!(/(<\\z>)/, '\\\
    z')\n  brackets.gsub!(/(<\\R>)/, '\\R')\n  brackets.gsub!(/(<\\d>)/, '\\d')\n\
    \  brackets.gsub!(/(<\\D>)/, '\\D')\n  brackets.gsub!(/(<\\e>)/, '\\e')\n  brackets.gsub!(/(<\\\
    E>)/, '\\E')\n  brackets.gsub!(/(<\\s>)/, '\\s')\n  brackets.gsub!(/(<\\S>)/,\
    \ '\\S')\n  brackets.gsub!(/(<\\w>)/, '\\w')\n  brackets.gsub!(/(<\\W>)/, '\\\
    W')\n  brackets.gsub!(/(<\\Z>)/, '\\Z')\n  brackets.gsub!(/(<\\Z>)/, '\\Z')\n\
    \  brackets.gsub!(/(<\\a>)/, '\\a')\n  brackets.gsub!(/(<\\A>)/, '\\A')\n  brackets.gsub!(/(<\\\
    i>)/, '\\i')\n  brackets.gsub!(/(<\\I>)/, '\\I')\n  brackets.gsub!(/(<\\o>)/,\
    \ '\\o')\n  brackets.gsub!(/(<\\O>)/, '\\O')\n", "  # replace all opening brackets\n\
    \  bracket_replacements = brackets.gsub(/\\(/, '').gsub(/\\)/, '').gsub(/[\\[\\\
    {\\(]/, '').gsub(/[\\]\\}\\)]/, '')", "  if brackets.nil?\n    return false\n\
    \  end\n  stack = []\n  stack.push(brackets)\n  while !stack.empty?\n    brackets\
    \ = stack.pop\n    case brackets\n    when \">\"\n      return true\n    when\
    \ \"<\"\n      return false\n    else\n      brackets = brackets.next_char\n \
    \     stack.push(brackets)\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks so much everyone! All of you guys are amazing! I really appreciate\
    \ the help and suggestions! I'll have to play around with it and see if I can\
    \ get it to work properly! Thanks again! :)\n<|/ c |>\n<| c |>\nThe solution you\
    \ provided didn't seem to work for me.  For some reason, I was able to get all\
    \ the \">\" and \"<\" symbols to come back as false.  I updated my question above\
    \ with my full test case and the error I'm getting.  I would be super thankful\
    \ if you could provide any insight as to what I'm doing wrong.  Thank you!\n<|/\
    \ c |>\n<| c |>\nI updated my answer to take account of your full test case, and\
    \ show a working implementation of your function using recursion.\n<|/ c |>\n\
    <| c |>\nThank you so much!  I really appreciate your help! :)\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThe problem you're having is probably not due to any coding error\
    \ but an interpreter error of your own making. If you were to run your code from\
    \ the command line, you would get the error:\n<code>\nTraceback (most recent call\
    \ last):\n  File \"test.py\", line 9, in <module>\n    print correct_bracketing(brackets)\n\
    \  File \"/Users/katty/Desktop/test.py\", line 5, in correct_bracketing\n    if\
    \ brackets.nil?\nNameError: name 'brackets' is not defined\n</code>\nThe problem\
    \ is that you're trying to call your method without any arguments. You can either\
    \ add brackets to your method call and make it take a parameter:\n<code>", " \
    \ brackets = brackets.gsub(/[<>]/) { |x| x.to_s.reverse }.gsub(/[\\[\\]]/) { |x|\
    \ x.to_s.reverse }\n  brackets.to_a.any? { |x| x.start_with?(\"<\") && x.end_with?(\"\
    >\") }\nend", "  open_brackets = brackets.scan(/\\(/)\n  close_brackets = brackets.scan(/\\\
    )/)\n  open_brackets = open_brackets.select { |x| not close_brackets.include?(x)\
    \ }\n  open_brackets.empty?\nend", "  brackets.chars.each do |char|\n    bracket_count\
    \ = brackets.chars.count(char)\n    if bracket_count != 1\n      puts \"The bracket\
    \ #{char} is not correctly balanced.\"\n      true\n    end\n  end\n  false\n\
    end", "  return brackets.scan(/<|>|()/).all? { |x| x == \">\" } \nend\n</code>\n\
    <|/ a tags=ruby dscore=3 |>\n<| c |>\nI like your use of the block param on the\
    \ scan method - but would it be possible to explain how the block is working by\
    \ providing a few examples so I can understand the logic behind this? Thanks :)\n\
    <|/ c |>\n<| c |>\nThe block param is just a way to capture and return the results\
    \ of the scan, so it basically is equivalent to something like `result = brackets.scan(/<|>|()/);\
    \ return result.all? { |x| x == \">\" }`.  You can read up more on scan and block\
    \ params in the [docs](http://ruby-doc.org/core-2.4.0/String.html#method-i-scan).\n\
    <|/ c |>\n<| c |>\nI think I understand - thanks for the link and explanation.\n\
    <|/ c |>\n<| a tags=ruby dscore=3 |>\nA good exercise in using the various regular\
    \ expressions in Ruby is probably a good way to improve your Ruby skills.\nHere's\
    \ a solution that avoids the creation of unnecessary arrays:\n<code>", "  brackets.scan(/\\\
    <\\<[^>]*\\>\\>/ do |m|\n    brackets.sub!(m, \"\")\n  end).empty?\nend", "  bracket_stack\
    \ = []\n  stack_count = 1\n  in_open_bracket = bracket_stack.empty?\n  \n  brackets.each_char\
    \ do |char|\n    next if char == \"<\" || char == \">\"\n    \n    next if char\
    \ == \"<\" && in_open_bracket\n    in_open_bracket = true\n    \n    next if char\
    \ == \">\" && in_open_bracket\n    in_open_bracket = false\n    \n    stack_count\
    \ += 1 if in_open_bracket\n    \n    bracket_stack.push(char)\n  end\n  \n  in_open_bracket\
    \ = bracket_stack.empty?\n  \n  stack_count -= 1 if in_open_bracket\n  \n  stack_count\
    \ > 0 ? ((stack_count == 0) and (bracket_stack.empty? == true)) : false\nend",
  "  brackets.chars.each_with_object(Hash.new{|h,k| h[k]=true}) { |c,h| h[c] &= h[c+1]\
    \ }\n  !brackets.chars.empty?\nend", "  brackets.gsub!(/\\[/, \"\")\n  brackets.gsub!(/\\\
    ]/, \"\")\n  brackets.gsub!(/\\{/, \"\")\n  brackets.gsub!(/\\}/, \"\")\n  brackets.gsub!(/\\\
    (/, \"\")\n  brackets.gsub!(/\\)/, \"\")\n  brackets.gsub!(/\\+/, \"\")\n  brackets.gsub!(/\\\
    */, \"\")\n  brackets.gsub!(/\\*/, \"*\")\n  brackets.gsub!(/\\+/, \"+\")\n  brackets.gsub!(/\\\
    +/, \"+\")\n  brackets.gsub!(/\\*/, \"*\")\n  brackets.gsub!(/\\*/, \"*\")\n \
    \ brackets.gsub!(/\\)/, \"/\")\n  brackets.gsub!(/\\)/, \"/\")\n  brackets.gsub!(/\\\
    (/, \"(\")\n  brackets.gsub!(/\\)/, \")\")\n  brackets.gsub!(/\\\"/, \"'\")\n\
    \  brackets.gsub!(/\\{/, \"[\")\n  brackets.gsub!(/\\}/, \"]\")\n  brackets.gsub!(/\\\
    +/, \"::\")\n  brackets.gsub!(/\\*/, \"|\")\n  brackets.gsub!(/\\\"/, \"'\")\n\
    \  brackets.gsub!(/\\\"/, \"'\")\n  brackets.gsub!(/\\[/, \"[\")\n  brackets.gsub!(/\\\
    ]/, \"]\")\n  brackets.gsub!(/\\{/, \"{\")\n  brackets.gsub!(/\\}/, \"}\")\n \
    \ brackets.gsub!(/\\(/, \"(\")\n  brackets.gsub!(/\\)/, \")\")\n  brackets.gsub!(/\\\
    +/, \"+\")\n  brackets.gsub!(/\\*/, \"*\")\n  brackets.gsub!(/\\*/, \"*\")\n \
    \ brackets.gsub!(/\\+/, \"+\")\n  brackets.gsub!(/\\+/, \"+\")\n  brackets.gsub!(/\\\
    */, \"*\")\n  brackets.gsub!(/\\*/, \"*\")\n  brackets.gsub!(/\\)/, \"/\")\n \
    \ brackets.gsub!(/\\)/, \"/\")\n  brackets.gsub!(/\\[/, \"[\")\n  brackets.gsub!(/\\\
    ]/, \"]\")\n  brackets.gsub!(/\\{/, \"{\")\n  brackets.gsub!(/\\}/, \"}\")\n \
    \ brackets.gsub!(/\\(/, \"(\")", "    opening = brackets.count(\"(\")\n    closing\
    \ = brackets.count(\")\")", '  return brackets == "<"', "  return brackets.gsub(/(<{2})|(>{2})/,\
    \ '').empty?\nend\n</code>\nThis implementation is very similar to yours and is\
    \ also very simple. In the first line we call gsub with a regular expression to\
    \ replace all instances of \"< and >\" with \"nothing\". gsub is actually a method\
    \ on the String class and basically does the same thing as your gsub! method,\
    \ but with the added benefit of returning nil if there are no instances of \"\
    < or >\" in the string you are applying it to.\nFinally, we check that the string\
    \ is not empty before continuing. ! is basically the same as empty? but negated.\
    \ ! is generally the opposite of empty?, and therefore an empty string is also\
    \ considered not empty.\n<|/ a tags=ruby |>\n<| c |>\nIt may be useful to mention\
    \ that this particular method (and the one you show) is probably the most common\
    \ \"solution\" in Ruby coding.\n<|/ c |>\n<| c |>\nThank you so much for that.\
    \ I would vote you up but my reputation is too low.\n<|/ c |>\n<| c |>\nNo problem!\
    \ I updated my answer with some explanation on what the code does.\n<|/ c |>\n\
    <| c |>\nThank you for adding some explanation and helping a beginner who was\
    \ struggling with how `gsub` works. That really helps.\n<|/ c |>\n<| a |>\nIt\
    \ will take more time to execute code but it's more accurate.\n<code>", '  return
    brackets.size > 0 && ! brackets.is_a? String', "  bracket_counts = brackets.scan(/<|>|\\\
    {|\\}/)\n  bracket_counts.each do |bc, b|\n    next unless b == 0 or bc == 0\n\
    \    bracket_counts[bc-1] = 0 if bc == 0\n  end\n  bracket_counts.all? { |bc,\
    \ b| bc && b}\nend", "  opening = brackets.gsub(/(<+)/, '<').gsub(/(>+)/, '>')\n\
    \  closing = brackets.gsub(/(<+)/, '>').gsub(/(>+)/, '<')\n  opening == closing\n\
    end", "  brackets.chars.each do |c|\n    next if c != \"<\"\n    return false\
    \ if c != \">\"\n    return true if brackets.chars.any? {|x| x == \"<\"}\n  end\n\
    \  return true\nend", "  return !brackets.nil? and brackets.empty?\nend", "  brackets.scan(/</)\
    \ do |opening_bracket|\n    brackets.scan(/>/) do |closing_bracket|\n      closing_bracket.nil?\
    \ or opening_bracket != closing_bracket\n    end\n  end\nend", "  # TODO: Assumes\
    \ proper bracket pairings.\n  brackets.split(\"\").each_with_index do |char, i|\n\
    \    if char == \"<\"\n      return false if i > 0 && brackets[i - 1] != \"=>\"\
    \n      return false if i + 1 < brackets.length && brackets[i + 1] != \"=>\"\n\
    \      return true\n    end\n  end\n  return true\nend", "  return brackets.chars.all?\
    \ do |c|\n    brackets_table[c] ? true : false\n  end\nend", "  return brackets.split('><').all?\
    \ { |x| brackets.index(x) }\nend", "  brackets = brackets.to_s\n  brackets.gsub!(/([^<>])/,\
    \ '\\1')\n  brackets.gsub!(/>([^<>])/, '\\1\\1')\n  brackets.gsub!(/([^<>])>([^<>])/,\
    \ '\\1\\2\\1')\n  brackets.gsub!(/([^<>])<([^<>])/, '\\1\\2\\3')\n  return brackets\
    \ !~ /[^<>]+/\nend", "  brackets.each_char.with_object({}) {|x,y|\n    y[x] ||=\
    \ y[\"<\"+x] = y[\"<\"+x+\">\"] = x; y[x+\">\"] ||= y[\"<\"+x+\">\"] = x\n  }.all?{|x,y|\
    \ y[x] == y[x+\">\"]} && brackets.size == brackets.count(\"<\")\nend", "  return\
    \ brackets.gsub(/</, \">\").gsub(/>/, \"<\")\nend\n</cell>\n<code language=julia-0.5>",
  "  brackets = brackets.split('>')\n  brackets.each { |b|\n    return false if b.count('<')\
    \ % 2 != 0\n  }\n  return true\nend", "  brackets = brackets.to_s\n  return brackets.gsub(/(<[^<>]*?>)|(<.*?>)|(<.*)|(<.*>)/)\
    \ do |s|\n    if s =~ /^<.*>$/\n      s\n    elsif s =~ /^<[^<>]*>$/\n      s\n\
    \    elsif s =~ /^<.*[^<>]>$/\n      s\n    elsif s =~ /^<.*[^<>]>$/\n      s\n\
    \    else\n      s\n    end\n  end\nend", "  brackets.gsub!(/([<>])/){|match|\
    \ Bracket.new(match)}.map{|b| b.to_s}.join\nend", "  bracket_strings = brackets.split(//)\n\
    \  bracket_strings = bracket_strings.collect {|b| b.tr(\"<<\", \">\") }\n  bracket_strings\
    \ == brackets\nend", "  brackets.scan(/\\(.*\\)|\\[.*\\]|\\{.*\\}/) do |m|\n \
    \   match = m[0]\n    next if match.empty?\n    next unless match == \"(\" or\
    \ match == \"[\"\n    next unless match == \"]\" or match == \"}\"\n    false\n\
    \  end\n  true\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhat about `<<><>`?\n\
    <|/ c |>\n<| c |>\nNo, but you can easily add them to the list.\n<|/ c |>\n<|\
    \ c |>\nI don't think it works, it will return true for \"<<><>>\".\n<|/ c |>\n\
    <| c |>\nYes, it does, I was wrong. Having said that, your solution is much more\
    \ efficient than mine and should be the accepted answer. It also works if the\
    \ input is malformed.\n<|/ c |>\n<| a tags=regex,ruby |>\nI think this would do:\n\
    <code>\n'<<><>>' =~ /\\(.*?\\)|\\[.*?\\]|\\{.*?\\}/", "  brackets.scan(/\\</)\
    \ do |x| \n    next if x == \">\"\n    brackets.scan(/>>/) do |y|\n      next\
    \ if y == \"<\" \n      puts \"Oops, this should not happen: #{x} >> #{y}\" \n\
    \      return false \n    end\n    puts \"Yup, no more >>\"\n    return false\
    \ \n  end \n  puts \"No more < \"\n  return true\nend\n</code>\nThis isn't exactly\
    \ what you want, but it should help you get the idea of how you can solve this\
    \ problem using scan.\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  # replace with\
    \ regular expression\n  brackets_re = /<<(.*?)>>/\n  result = brackets_re.match(brackets)\n\
    \  return result\nend", "  brackets.gsub!(/(<)>/) do\n    match = $1; match[1]\
    \ == \"<\" ? \"<\" : \"(\" + match[1] + \")\";\n  end\n  brackets.gsub!(/(>)>/)\
    \ do\n    match = $1; match[1] == \"<\" ? \"(\" + match[1] + \")\" : \">\";\n\
    \  end\n  brackets.gsub!(/[\\(<]\\)>/) do\n    match = $1; match[1] == \"(\" ?\
    \ \"(\" + match[1] + \")\" : \"<\";\n  end\n  return true\nend\n</cell>\n<text>\n\
    Write a function that takes a string and returns the first letter of each word.\n\
    If there are multiple spaces between words, only the first one counts.\nE.g.\n\
    \"Hello\nWorld\" => \"H\"\n\"I love you\" => \"I\"\n\"This is a cat\" => \"T\"\
    \n\"This is not a cat\" => \"\"", "    brackets.gsub!(\"<\",\"</\")\n    brackets.gsub!(\"\
    >\",\"/>\")\n    brackets.gsub!(\"<>\",\"/>\")\n    brackets.gsub!(\"/>\",\"/>\"\
    )\n    brackets.gsub!(\"<>\",\"/>\")\n    brackets.gsub!(\"/>\",\"/\")\n    brackets.gsub!(\"\
    <>\",\"/\")\n    brackets.gsub!(\"</\",\"<\")\n    brackets.gsub!(\">>\",\"/>\"\
    )\n    brackets.gsub!(\"/>\",\">\")\n    brackets.gsub!(\"<>\",\">\")\n    brackets.gsub!(\"\
    />\",\"/\")\n    brackets.gsub!(\"<>\",\"/\")\n    brackets.gsub!(\"</\",\"<\"\
    )\n    brackets.gsub!(\">>\",\"/>\")\n    brackets.gsub!(\"/>\",\">\")\n    brackets.gsub!(\"\
    <>\",\">\")\n    brackets.gsub!(\"/>\",\"/\")\n    brackets.gsub!(\"<>\",\"/\"\
    )\n    brackets.gsub!(\"</\",\"<\")\n    brackets.gsub!(\">>\",\"/>\")\n    brackets.gsub!(\"\
    />\",\">\")\n    brackets.gsub!(\"<>\",\">\")\n    brackets.gsub!(\"/>\",\"/\"\
    )\n    brackets.gsub!(\"<>\",\"/\")\n    brackets.gsub!(\"</\",\"<\")\n    brackets.gsub!(\"\
    >>\",\"/>\")\n    brackets.gsub!(\"/>\",\">\")\n    brackets.gsub!(\"<>\",\">\"\
    )\n    brackets.gsub!(\"/>\",\"/\")\n    brackets.gsub!(\"<>\",\"/\")\n    brackets.gsub!(\"\
    </\",\"<\")\n    brackets.gsub!(\">>\",\"/>\")\n    brackets.gsub!(\"/>\",\">\"\
    )\n    brackets.gsub!(\"<>\",\">\")\n    brackets.gsub!(\"/>\",\"/\")\n    brackets.gsub!(\"\
    <>\",\"/\")\n    brackets.gsub!(\"</\",\"<\")\n    brackets.gsub!(\">>\",\"/>\"\
    )\n    brackets.gsub!(\"/>\",\">\")\n    brackets.gsub!(\"<>\",\">\")\n    brackets.gsub!(\"\
    />\",\"/\")\n    brackets.gsub!(\"<>\",\"/\")\n    brackets.gsub!(\"</\",\"<\"\
    )\n    brackets.gsub!(\">", "  brackets.gsub!(\"<\") { false }\n  brackets.gsub!(\"\
    >\") { false }\n  brackets.gsub!(\"<>\") { true }\n  brackets.gsub!(\">>\") {\
    \ true }\nend", "  brackets.count(\"<\") == 0\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI think it's important to note that this answer works *only* for strings\
    \ of length 1.\n<|/ c |>\n<| a |>\nI did it with two arrays:\n<code>", "  return\
    \ true if brackets.nil? || brackets.empty?\n  brackets.split(//).each_with_index.all?\
    \ do |left, right|\n    left == right\n  end\nend", "  brackets.chars.each do\
    \ |char|\n    return false if char == \"<\"\n    return true if char == \">\"\n\
    \  end\n  return false\nend", "  brackets = brackets.split('>')", "  brackets.chars.each_with_index\
    \ do |c, i|\n    if c == \"<\"\n      brackets.replace(brackets.chars[i+1], \"\
    <\")\n    end\n    if c == \">\"\n      brackets.replace(brackets.chars[i-1],\
    \ \">\")\n    end\n  end\n  !brackets.empty?\nend\n</code>\nBut you might want\
    \ to use an actual parsing library, like Ruby's parser, because this can be tricky\
    \ with corner cases. For example, consider this text:\n<code>\n<><<><><<><>><><><<><><>>\n\
    </code>\nThe above function would produce this result:\n<code>\n<><><><><>><<><><>>\n\
    </code>\nBut this is more desirable for the parser:\n<code>\n<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><",
  "  return brackets.gsub(\"[]\", \"<>\").gsub(\"<>\", \"[]\").blank?\nend", "  #\
    \ Only allow correct bracketing if the bracket type is allowed\n  if brackets[0]\
    \ == \"<\"\n    # Check that there are corresponding closing brackets\n    closing_brackets\
    \ = brackets[1..-1].split(\"><\")\n    # Check that the last opening bracket is\
    \ the same as the first\n    correct_opening = brackets[0]\n    correct_closing\
    \ = closing_brackets.first\n    closing_brackets.each { |b| correct_opening <=>\
    \ b }\n    # Check that no brackets are missing\n    correct_opening == correct_closing\n\
    \  else\n    # Check the brackets are correct\n    brackets == \"<>\".split(\"\
    <>\")\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis is really helpful.  I have\
    \ also added my original code which was just a basic solution to the problem.\
    \  I appreciate your help on this matter.\n<|/ c |>\n<| c |>\nNo problem! You\
    \ didn't post your code so I thought it would be better to write the code in such\
    \ a way as to make it clear how to modify it if you wanted to make a similar change\
    \ elsewhere. `brackets` is just a variable name, and `brackets[0]` would be the\
    \ first character of the string, `brackets[1]` would be the second character...\
    \ so that's why I use `brackets.chars.first`, which grabs the first character\
    \ of the string as a string (`#chars` grabs all the characters in a string). That\
    \ way if you wanted to use it as a function you could do `brackets.chars.first(2)\
    \ == brackets[1]`... or just `brackets[0] == brackets[1]` if you wanted that specific\
    \ string to be the correct bracket type.\n<|/ c |>\n<| c |>\nI added my original\
    \ code.  It is a solution I just wrote before I saw your answer.  It just has\
    \ some looping which I thought might make it more efficient.\n<|/ c |>\n<| c |>\n\
    Your code makes no sense to me... `def correct_bracketing(brackets)` defines a\
    \ function, but never uses it? `correct_bracketing(\"<\")` calls it and passes\
    \ one argument... but you don't pass a brackets argument, so the function doesn't\
    \ know what `brackets` should be. `brackets = brackets.chars.first` assigns the\
    \ `chars.first` of brackets to a `chars` variable... but `chars` is a string,\
    \ so you can't call `chars` as a method of `brackets`... so I'm not sure where\
    \ you are getting your arguments from and why you are doing it that way. Perhaps\
    \ you should post your real code so I can see what you are trying to do.\n<|/\
    \ c |>\n<| c |>\nI added my original code which was just a basic ", "  return\
    \ brackets.split('<').all? { |x| x =~ /</ }\nend", "  brackets.chars.each_with_index.all?\
    \ do |char, i|\n    next false if i >= brackets.length\n    next false if brackets[i]\
    \ != char\n    char == \">\" ? (i -= 1) : (i + 1)\n  end\nend", "  brackets.chars.each_with_index\
    \ do |c, i|\n    return false if c == '>'\n    return false if i > 0 && brackets.chars[i\
    \ - 1] == '>'\n    return true if brackets.chars[i - 1] == '<' if brackets.chars[i\
    \ + 1] == '<'\n    return true if brackets.chars[i - 1] == '>' if brackets.chars[i\
    \ + 1] == '>'\n  end\nend", "  return brackets =~ /\\A<(.*?)>\\Z/m\nend", "  return\
    \ brackets.each_char.all? do |char|\n    bracket_match(brackets, char)\n  end\n\
    end", "  brackets.scan(/\\<{2,}\\>{2,}/)\n  return brackets == \"\"\nend", " \
    \ brackets = brackets.to_s\n  brackets = brackets.split(//)\n  result = false\n\
    \  brackets.each do |char|\n    char == \"<\" ? (result = true) : (result = false)\n\
    \  end\n  result\nend", "  bracket_count = 0\n  bracket_open = false\n  bracket_close\
    \ = false\n  bracket_list = []\n  if brackets.include?(\"<\")\n    bracket_open\
    \ = true\n  else\n    bracket_open = false\n  end\n  if brackets.include?(\">\"\
    )\n    bracket_close = true\n  else\n    bracket_close = false\n  end\n  brackets.split(\"\
    \").each do |x|\n    if bracket_open == true && x.include?(\"<\")\n      bracket_count\
    \ += 1\n      if bracket_count == 1\n        bracket_list << x\n      end\n  \
    \  end\n    if bracket_close == true && x.include?(\">\")\n      bracket_count\
    \ -= 1\n      if bracket_count == 0\n        bracket_list << x\n      end\n  \
    \  end\n  end\n  bracket_list.count != 0\nend\n</code>\n<|/ a tags=ruby,regex\
    \ dscore=2 |>\n<| c |>\nWhile it works in this case, it fails on `\"()()\"`, which\
    \ has two pairs of parentheses.\n<|/ c |>\n<| c |>\nI see what you mean. You would\
    \ need to modify the code to handle a nested bracket sequence. I'll update my\
    \ answer with some code that does that.\n<|/ c |>\n<| c |>\nIt would be helpful\
    \ if you edited your answer to indicate what the code is doing. Also explain why\
    \ it works.\n<|/ c |>\n<| a dscore=2 |>\nHere's another version that checks both\
    \ sides of the bracket and handles nested brackets:\n<code>", "  brackets.gsub!(/([<>])/,\
    \ '\\1\\1')\n  brackets.gsub!(/(<)(>)/, '\\2\\3')\n  brackets.gsub!(/(<)(\\>)/,\
    \ '\\1\\3')\n  brackets.gsub!(/(<)(\\<)/, '\\2\\3')\n  brackets.gsub!(/(\\<)(>)/,\
    \ '\\1\\2')\n  brackets.gsub!(/(\\<)(\\>)/, '\\1\\2')\n  brackets.gsub!(/(\\<)(\\\
    <)/, '\\2\\1')\n  brackets.gsub!(/(\\<)(\\<)/, '\\2\\1')\n  brackets.gsub!(/(\\\
    >)(\\<)/, '\\1\\2')\n  brackets.gsub!(/(\\>)(\\>)/, '\\1\\2')\n  brackets.gsub!(/(\\\
    >)(\\>)/, '\\1\\2')\n  brackets.gsub!(/(\\>)(\\<)/, '\\2\\1')\n  brackets.gsub!(/(\\\
    >)(\\<)/, '\\2\\1')\n  return brackets !~ /\\<\\>\\>/\nend", "  brackets.gsub(/[\\\
    <\\>]/) do |char|\n    if char == \"<\"\n      char == \">\"\n    else\n     \
    \ char == \"<\"\n    end\n  end\nend", "  brackets.split(\"<\").all? do |left|\n\
    \    brackets.split(\">\").any? do |right|\n      left.to_i == right.to_i\n  \
    \  end\n  end\nend", "  return brackets == \"<>\" ||\n    brackets == \"<<>\"\
    \ ||\n    brackets == \"<<<\" ||\n    brackets == \">>>\"\nend", "  return brackets\
    \ =~ /\\<\\<\\>\\>/\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
