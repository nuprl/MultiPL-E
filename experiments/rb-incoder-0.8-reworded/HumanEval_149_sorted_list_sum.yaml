name: HumanEval_149_sorted_list_sum
language: rb
prompt: "# Write a function that accepts an array of strings as a parameter,\n# deletes\
  \ the strings that have odd lengths from it,\n# and returns the resulted array with\
  \ a sorted order,\n# The array is always an array of strings and never an array\
  \ of numbers,\n# and it may contain duplicates.\n# The order of the array should\
  \ be ascending by length of each word, and you\n# should return the array sorted\
  \ by that rule.\n# If two words have the same length, sort the array alphabetically.\n\
  # The function should return an array of strings in sorted order.\n# You may assume\
  \ that all words will have the same length.\n# For example:\n# >>> list_sort.call([\"\
  aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\"\
  , \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n\
  \    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"\
  aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"\
  school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\"\
  , \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"\
  d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"\
  AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\"\
  , \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"],\
  \ candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"
completions: ["  lst.sort\n  lst.compact.each do |x|\n    x.delete\n  end\n  lst\n\
    end", "  sorted_list = lst\n  sorted_list.sort!\n  sorted_list.each do |word|\n\
    \    while word.count % 2 != 0\n      word.slice!(0)\n    end\n  end\n  sorted_list\n\
    end\nputs sorted_list_sum([\"aa\", \"a\", \"aaa\"]).inspect", "  # Write your\
    \ code here\n  lst.sort! # will sort the array in place\n  lst.reject! {|x| x.length\
    \ % 2 == 0} # will reject the odd length strings\n  lst.sort { |x,y| x.upcase\
    \ <=> y.upcase } # sort them in ascending order\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nI do not need to sort the array. I need to return it as a sorted array with\
    \ the words in sorted order.\n<|/ c |>\n<| a dscore=0 tags=ruby,sorting,arrays\
    \ |>\n<code>", "  lst.sort\n  res=lst.map{|w| w.length}.uniq\n  res.sort{|a, b|\
    \ a.length <=> b.length}\n  res\nend", "  sorted = []\n  sorted_list = []\n  sorted_list2\
    \ = []\n  sorted_list.push = sorted.push\n  sorted.push = sorted_list.push\n \
    \ sorted_list2.push = sorted.push\n  sorted.push = sorted_list2.push\n  for i\
    \ in 0 ... lst.length\n    sorted_list.push lst[i]\n  end\n  for i in 0 ... lst.length\n\
    \    if sorted_list.count > 1\n      sorted_list2.push lst[i]\n    end\n  end\n\
    \  for i in 0 ... lst.length\n    sorted_list.push (lst[i])\n  end\n  for i in\
    \ 0 ... lst.length\n    sorted_list.push i\n  end\n  sorted_list.sort_by! { |x|\
    \ x.length }\n  sorted_list2.sort_by! { |x| x }\n  for i in 0 ... lst.length\n\
    \    if sorted_list.count > 1\n      sorted_list.push (sorted_list2.last)\n  \
    \    sorted_list2.pop\n    end\n  end\n  for i in 0 ... lst.length\n    sorted_list2.push\
    \ i\n  end\n  for i in 0 ... lst.length\n    sorted_list.push i\n  end\n  return\
    \ sorted_list\nend", "  \n  return lst.sort_by { |word| word.length }\nend", " \
    \ res = []\n  sorted = lst.sort.reverse\n  lst.each do |x|\n    x.split(\" \"\
    ).each do |y|\n      res << y\n    end\n  end\n  return res\nend", "  lst.sort\n\
    end", "  lst.sort\n  lst.group_by{|word| word.length}.to_a.map{|group| group.first}.compact\n\
    end", "  new_lst = []\n  \n  new_lst = lst.map{|x| x.split(\"\")}\n  new_lst.map!{|x|\
    \ x.delete_if{|y| y.odd?}}", "  lst.sort!\n  lst.select { |i| i.length % 2 ==\
    \ 1 }\nend", "  arr = lst.sort\n  arr.uniq.sort\nend", "  lst.sort_by { |str|\
    \ str.size }\n  lst.sort_by { |str| str[0] if str[0] != str[1] }\nend", "    sorted\
    \ = []\n    temp = []\n    odd_length = []\n    odd_length.push(0)\n    sorted\
    \ = sorted.concat(odd_length)\n    sorted = sorted.concat([0,1])\n    sorted =\
    \ sorted.concat([1,2])\n    sorted = sorted.concat([2,3])\n    sorted = sorted.concat([3,4])\n\
    \    sorted = sorted.concat([4,5])\n    sorted = sorted.concat([5,6])\n    sorted\
    \ = sorted.concat([6,7])\n    sorted = sorted.concat([7,8])\n    sorted = sorted.concat([8,9])\n\
    \    sorted = sorted.concat([9,10])\n    sorted = sorted.concat([10,11])\n   \
    \ sorted = sorted.concat([11,12])\n    sorted = sorted.concat([12,13])\n    sorted\
    \ = sorted.concat([13,14])\n    sorted = sorted.concat([14,15])\n    sorted =\
    \ sorted.concat([15,16])\n    sorted = sorted.concat([16,17])\n    sorted = sorted.concat([17,18])\n\
    \    sorted = sorted.concat([18,19])\n    sorted = sorted.concat([19,20])\n  \
    \  sorted = sorted.concat([20,21])\n    sorted = sorted.concat([21,22])\n    sorted\
    \ = sorted.concat([22,23])\n    sorted = sorted.concat([23,24])\n    sorted =\
    \ sorted.concat([24,25])\n    sorted = sorted.concat([25,26])\n    sorted = sorted.concat([26,27])\n\
    \    sorted = sorted.concat([27,28])\n    sorted = sorted.concat([28,29])\n  \
    \  sorted = sorted.concat([29,30])\n    sorted = sorted.concat([30,31])\n    sorted\
    \ = sorted.concat([31,32])\n    sorted = sorted.concat([32,33])\n    sorted =\
    \ sorted.concat([33,34])\n    sorted = sorted.concat([34,35])\n    sorted = sorted.concat([35,36])\n\
    \    sorted = sorted.concat([36,37])\n    sorted = sorted.concat([37,38])\n  \
    \  sorted = sorted.concat([38,39])\n    sorted = sorted.concat([39,40])\n    sorted\
    \ = sorted.concat([40,41])\n    sorted = sorted.concat([41,42])\n    sorted =\
    \ sorted.concat([42,43])\n    sorted = sorted.concat([43,44])\n    sorted = sorted.concat([44,45])\n\
    \    sorted = sorted.concat([45,46])\n    sorted = sorted.concat([46,47])\n  \
    \  sorted = sorted.concat([47,48])", "  sorted = []\n  sorted_list_length.each\
    \ do |len|\n    sorted = sorted.concat(sorted_list_length(lst, len).sort.uniq)\n\
    \  end\n  sorted\nend", "  sorted_list = Array.new\n  sorted = nil\n  i = 0\n\
    \  while i < lst.length\n    if sorted_list.include?(lst[i])\n      sorted_list[i]\
    \ = lst[i]\n      i += 1\n      next\n    end\n    i += 1\n    j = i\n    while\
    \ j > 0 && lst[j] == lst[j-1]\n      j += 1\n    end\n    sorted = sorted_list.push(lst[j])\
    \ if j > 0\n  end\n  sorted_list\nend", "  result = []\n  sorted_list = lst.sort\n\
    \  sorted_list.each{|x| result.push(x)}\n  return result\nend", "  # Write your\
    \ code here.\n  result = []\n  count = 0\n  for i in 0..(lst.length-1)\n    if\
    \ lst[i].length%2 == 1\n      result = lst[i] + result\n      count += 1\n   \
    \ else \n      result = result + lst[i]\n      count += 1\n  result = result.sort\n\
    \  count = count-1\n  while count != 0\n    result.sort!\n    result.delete(result.last)\n\
    \    count = count - 1\n  return result\nend\n</code>\n<|/ a dscore=0 tags=ruby,sorting,arrays\
    \ |>\n<| a |>\nUsing Enumerable#partition :\n<code>\narr = [\"a\", \"ab\", \"\
    cd\", \"c\", \"aa\"]\narr = arr.partition {|e| e.length > 2}\narr.flatten.sort",
  "  return lst.sort!\nend\nputs sorted_list_sum([\"a\", \"b\", \"c\", \"d\"]) # [\"\
    a\", \"b\", \"c\", \"d\"]\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nThe\
    \ question asked for the array to be sorted. This code just sorts the strings.\
    \ That is one thing that people often want to do with arrays. If you want an array\
    \ sorted (ascending) then add `lst.sort!`.\n<|/ c |>\n<| c |>\nThe question asked\
    \ for \"in place\" sorting. The code only sorts by the first character of the\
    \ string. This is something that people often want to do with arrays and is why\
    \ I posted the comment saying that sort! modifies the array. I wanted to show\
    \ that the sort method was used.\n<|/ c |>\n<| c |>\nIt is not \"in place\" sorting.\
    \ `sort!` sorts in place and returns `nil`.\n<|/ c |>\n<| c |>\nThe question said\
    \ \"in place\" sorting by length. `sort!` sorts in place and returns `nil`. This\
    \ does not mean that `sort!` modifies the array.\n<|/ c |>\n<| a tags=ruby |>\n\
    Try this:\n<code>", "  # Write your code here\n  lst.sort!\n  lst.group_by{|word|\
    \ word.length}.sort_by{|word_len, words| word_len}\nend\n</cell>\n<code language=conda-env-adventofcode-py>",
  "  # your code here\n  return sorted_list_sum\nend", "    sorted = []\n    sorted\
    \ = sorted.concat(lst.sort{|a,b| a.length <=> b.length}.reverse)\n    sorted.concat(lst.sort{|a,b|\
    \ a.length <=> b.length && a.upcase <=> b.upcase}.reverse)\n    sorted\nend",
  "    sums.each do |n|\n        sums.delete(n)\n    end\n    sums.sort\nend", " \
    \ result = lst.group_by{|x| x.size}.values\n  result.sort! do |a, b|\n    if a.length\
    \ < b.length\n      1\n    elsif a.length > b.length\n      -1\n    elsif a.length\
    \ == b.length\n      a.chars.sort_by{|x| x}\n    end\n  end\n  return result\n\
    end\nsorted_list_sum([\"a\", \"b\", \"c\", \"d\", \"d\", \"f\", \"d\", \"b\",\
    \ \"g\", \"h\"])", "    array.uniq(lst)\n    return lst.sort\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't really answer the OP's question, since he's not\
    \ asking how to implement the functionality as a method, he's asking how to convert\
    \ a Ruby array into an *array of arrays*.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>\narray1.map {|e| [e]}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis\
    \ is by far the simplest and most intuitive solution that works when you are dealing\
    \ with arrays with one level of nesting (not an array of arrays)\n<|/ c |>\n<|\
    \ a dscore=4 |>\nThe simplest solution is:\n<code>\narray = [1, 2, 3, 4, 5, 6]\n\
    array.map { |e| [e] }", "    sorted = []\n    sorted = sorted.concat(sortByLength(lst))\n\
    \    sorted = sorted.concat(sortByLength(sorted))\n    sorted = sorted.concat(sortByLength(sorted))\n\
    \    sorted = sorted.concat(sortByLength(sorted))\n    sorted = sorted.concat(sortByLength(sorted))\n\
    \    sorted = sorted.concat(sortByLength(sorted))\n    sorted = sorted.concat(sortByLength(sorted))\n\
    \    sorted = sorted.concat(sortByLength(sorted))\n    sorted = sorted.concat(sortByLength(sorted))\n\
    \    return sorted\nend", "  lst.sort! # Sort the array\n  lst.map! { |el| el.split(\"\
    \ \").map{|e| e.to_i }.sum }\n  lst.sort! { |el1, el2| el1[0].length <=> el2[0].length\
    \ }\n  lst\nend", "  lst.sort!\n  lst.group_by{ |x| x }.values\nend", "  return\
    \ lst.reverse.sort.map{|str| str.split.size}\nend", "  return lst.sort.group_by{|x|\
    \ x.split.length}.map{|x| x.last}\nend\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ so much for the detailed answer, it was very helpful. I am new to Ruby and am\
    \ trying to figure out a way to sort the array by length in descending order.\
    \ Would you mind explaining how you would do that with this implementation? Thank\
    \ you again.\n<|/ c |>\n<| c |>\nSure, added a quick explanation at the end of\
    \ the answer. Happy to help if needed.\n<|/ c |>\n<| c |>\nThank you again. One\
    \ thing that confuses me is how your method returns the sorted array. I am not\
    \ seeing how that would work in practice. Could you possibly write out the steps\
    \ you would take to test it? As a beginner I think it is a little confusing to\
    \ understand how the sorted array is returned. I understand how the method is\
    \ written and can run it myself on its own but I am not seeing how that would\
    \ work in this situation.\n<|/ c |>\n<| c |>\nYou can run a Ruby script in interactive\
    \ mode (REPL) by running `ruby myscript.rb` and it will run as you type it. You\
    \ can run this script by saving it to a file (e.g. `myscript.rb`) and then running\
    \ it from the command line (e.g. `ruby myscript.rb`) `ruby myscript.rb` `puts\
    \ list_sort.call([\"aa\", \"a\", \"aaa\"])`\n<|/ c |>\n<| c |>\nThank you again,\
    \ that helps. I ended up figuring out the last part (sorting the array in descending\
    \ order based on the length of the string) by changing the last part in the block\
    \ to this:     `x.last.to_i.reverse if x.last.to_i` but I am not sure if that\
    \ is exactly the correct way to do it. I will update my question with the new\
    \ code.\n<|/ c |>\n<| a dscore=0 tags=sorting,arrays,ruby |>\nTo sort an array\
    \ of strings by string length, in descending order, you can use the following\
    \ code:\n<code>\n[\"aa\", \"a\", \"aaa\"].sort_by { |string| string.length }.each\
    \ do |string|\n    puts string\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ the suggestion. I am having some difficulty understanding how to implement this\
    \ in practice. I tried running the block of code above with my array in question\
    \ and it did not seem to sort it in descending order based on length. I would\
    \ like to understand how to implement the code in order to test it myself.\n<|/\
    \ c |>", "\treturn(lst.sort{|a,b| (a.length<b.length) ? -1 : 1})\nend", "    sorted\
    \ = []\n    lst.sort\n    return sorted\nend", "    sorted = []\n    sorted.concat(lst.sort{|a,\
    \ b| a.length <=> b.length} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a.downcase <=> b.downcase} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a.upcase <=> b.upcase} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a.capitalize <=> b.capitalize} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a <=> b} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a <=>\
    \ b} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a.strip <=> b.strip}\
    \ if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a.to_s <=> b.to_s}\
    \ if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a <=> b} if lst.include?(sorted))\n\
    \    sorted.concat(lst.sort{|a, b| a <=> b} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a.to_i <=> b.to_i} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a.to_f <=> b.to_f} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a.to_i <=> b.to_i} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a.to_f <=> b.to_f} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a,\
    \ b| a <=> b} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a <=>\
    \ b} if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a.to_i <=> b.to_i}\
    \ if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a.to_f <=> b.to_f}\
    \ if lst.include?(sorted))\n    sorted.concat(lst.sort{|a, b| a.to_i <", "  unique\
    \ = unique_l(lst)\n  unique.sort\n  return unique\nend", " \n  \n    \n    \n\
    \    # Write your code here.\n    \n    \n    return lst\n    \n    # Your code\
    \ here", "  sorted = []\n  sorted = sort_by_length(lst)\n  sorted = sorted.delete_duplicates\n\
    \  sorted = sorted.sort\nend", "  lst.map!(&:downcase).sort!\n  return lst\nend",
  "  arr = lst.sort\n  arr.uniq.sort!\n  arr\nend", " \n \n \n  # Your code here\n\
    \  return\nend", "  # Your code here\n  return(sorted(lst))\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\n<code>", " \n\
    \    # Create a counter for keeping track of words that are repeated in lst\n\
    \    dups = Hash.new(0)\n    \n    # Create a Hash which holds words that are\
    \ duplicates of each other\n    dups_count = Hash.new(0)\n    \n    # Add the\
    \ values from lst to the Hash\n    dups.merge!(Hash[lst])\n    \n    # Find the\
    \ words that have same length as other words and add them\n    # to the Hash\n\
    \    lst.each do |word|\n        dups_count.merge!(Hash[word]) unless dups.key?(word)\n\
    \    end\n    \n    # Go through all the values that are repeated more than once\n\
    \    # and delete them\n    dups_count.each do |word, count|\n        \n     \
    \   if count > 1\n            \n            # Create a temporary array to hold\
    \ the words that are repeated\n            # more than once\n            dups.delete_if\
    \ {|word| word == word}\n            \n            # Create a temporary array\
    \ of the words that are repeated\n            # more than once and add them to\
    \ the dups Hash\n            dups.merge!(Hash[dups.keys]) unless dups.key?(word)\n\
    \        end\n    end\n    \n    # Get the keys of the Hash\n    dups = dups.keys\n\
    \    \n    # Sort the Hash\n    dups.sort!\n    \n    # Create a temporary array\
    \ and add the words from the Hash\n    dups.each do |word|\n        lst.delete_at(lst.index(word))\n\
    \    end\n    \n    # Return the sorted array\n    lst\nend", "  # Your code here\n\
    \  sorted = []\n  temp = []\n  for x in lst\n    if x != nil\n      temp << x\n\
    \    end\n  end\n  sorted = temp\n  sorted.sort!\n  return sorted\nend", "  lst.sort!\n\
    \  lst.compact << \"\"\n  lst.compact.uniq!\n  lst.map! do |word|\n    word.split(//).sort!.join\n\
    \  end\n  lst\nend", "  # Your code here\n  \nend", "    odd_lst = lst.select\
    \ { |i| i.length % 2 == 1 }\n    sorted_odd_lst = odd_lst.sort { |a, b| a.length<=>b.length\
    \ }\n    sorted_odd_lst.sort { |a, b| a<=>b }\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/15328685)\n<|/ c |>\n<| c |>\nWhat is your\
    \ answer? Why do you think it is wrong?\n<|/ c |>\n<| c |>\nThis solution doesn't\
    \ sort the array and only checks if the length is even or odd. This is different\
    \ than what the OP wants.\n<|/ c |>\n<| c |>\n, I think I got it now. Sorry for\
    \ the misunderstanding :)\n<|/ c |>\n<| c |>\n- No, this is actually better. +1\n\
    <|/ c |>\n<| a tags=arrays,ruby dscore=1 |>\nYou could also use Ruby's built in\
    \ Enumerable methods: sort_by and partition:\n<code>\nmy_array = [\"a\", \"b\"\
    , \"c\", \"d\"]\nmy_array.sort_by { |word| word.length }\n  .partition{ |word|\
    \ word.length % 2 != 0 }\n  .map(&:join)\n</code>\nThis should return:\n<code>\n\
    [[\"a\", \"d\"], [\"b\", \"c\"]]\n</code>\n<|/ a |>\n<| a dscore=1 |>\nMy solution\
    \ is to sort alphabetically then remove the odd elements from the array.\n<code>",
  '  lst.sort!', "  newList = [lst[0]]\n  lst.each_with_index do |word, index|\n \
    \   if index % 2 == 1\n      newList << word\n    else\n      newList << word.upcase\n\
    \    end\n  end\n  newList\nend\nputs sorted_list_sum([\"aa\", \"a\", \"aaa\"\
    ]) # => [\"aa\", \"aaa\"]\nputs sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"\
    ]) # => [\"ab\", \"cd\"]\nputs sorted_list_sum([\"abc\", \"a\", \"abcd\", \"abcd\"\
    ]) # => [\"abc\", \"abcd\"]", "  lst.sort\nend", "  sum = []\n  i = 0\n  while\
    \ i < lst.length\n    sum << lst[i]\n    i += 1\n  end\n  i = lst.length\n  while\
    \ i > 0\n    sum.delete(sum[i])\n    i -= 1\n  end\n  sum.sort\n  sum.join\nend\n\
    print sorted_list_sum([\"aa\", \"a\", \"aaa\"])", "  res=list.sort\n  res=res[lst.length.to_a]\n\
    \  res=res[res[0..-2].uniq.to_a]\n  res=res[res[0..-2].uniq.to_a]\n  return res\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis was my first question, thank you for the\
    \ advice.\n<|/ c |>\n<| c |>\nI like how you were able to fix your code. Thank\
    \ you for sharing!\n<|/ c |>\n<| c |>\nI believe that \"res=res[lst.length.to_a]\"\
    \ should just be \"res=lst.length.to_a\" since the length property is an integer.\
    \ Not sure if thats a typo or a misunderstanding of mine though. Also, \"res=res[res[0..-2].uniq.to_a]\"\
    \ should be \"res=res[res.uniq.to_a]\" (no need for negative indexing)\n<|/ c\
    \ |>\n<| c |>\nNope, that's actually wrong. `res[res.uniq.to_a]` is actually `res[0..-2].to_a`,\
    \ which means \"return elements 1 through 2, inclusive, of the array `res`\".\
    \ Try `['asdf', 'qwerty', 'zxcvb'].uniq.to_a` vs `['asdf', 'qwerty', 'zxcvb']`.\n\
    <|/ c |>\n<| c |>\nThanks very much. I've always wondered why it wasn't returning\
    \ a range. Now I know. Thanks again.\n<|/ c |>\n<| a tags=ruby,arrays |>\nThis\
    \ is how I would do it:\n<code>\nrequire 'set'", "  # Your code here\n  return\n\
    end", "    lst = lst.sort\n    size = lst.size\n    result = []\n    i = 0\n \
    \   while i < size\n        if i\n            if lst.include?(lst.last)\n    \
    \            lst.last.next\n                lst.last.next = nil\n            end\n\
    \        end\n        if lst.include?(lst[i])\n            result[i] = lst[i]\n\
    \            result[i+1] = lst[i+1]\n            i += 2\n        end\n    end\n\
    \    return result\nend\n</code>\n<|/ a tags=sorting,arrays,ruby |>\n<| c |>\n\
    This is O(n^2). It's not that it's not sorting, it's just that the sorting will\
    \ take O(n*log(n)), which makes this solution O(n^2).\n<|/ c |>\n<| c |>\nThe\
    \ array size is not constant since `sort` will re-sort the array. `arr.reverse.sort`\
    \ works fine.\n<|/ c |>\n<| c |>\nYour code is still O(n^2), but because of the\
    \ way you use `include?`, it's O(nlogn). `include?` is O(n). `sort` is O(n^2).\
    \ I don't believe there's any way to avoid O(nlogn) without using an entirely\
    \ different data structure.\n<|/ c |>\n<| c |>\nI agree that `include?` is O(n).\
    \ `sort` is O(n^2), but you assume that it is O(n). It's an assumption and it\
    \ doesn't have to be true every time. My code assumes O(n), which is correct since\
    \ it sorts first and only then iterates over array and picks unique elements.\
    \ I believe that it's more reliable than yours, but it is also O(n^2).\n<|/ c\
    \ |>\n<| c |>\nThe array size is not constant, since `sort` will re-sort the array.\
    \ `arr.reverse.sort` works fine.\n<|/ c |>\n<| a tags=sorting,arrays,ruby |>\n\
    Here's another solution that doesn't require sorting at all.\n<code>", "  sum\
    \ = []\n  sum.sort_by { |i| i.length }\n  sum.each { |i| sum << i }\n  sum.sort\
    \ { |a, b| a <=> b }\nend", "    sorted_list = Array.new(lst.size) do []\n   \
    \     sorted_list.sort! do |x, y|\n            if x.to_s.size != y.to_s.size\n\
    \                x.to_s.size\n            elsif x.to_s.size == y.to_s.size\n \
    \               x.to_s <=> y.to_s\n            else\n                x.to_s <=>\
    \ y.to_s\n            end\n        end\n    end\n    return sorted_list.to_a\n\
    end", "  sorted_lst = []\n  lst.each do |word|\n    unless sorted_lst.include?\
    \ word\n      sorted_lst.push(word)\n    end\n  end\n  sorted_lst.sort!\n  return\
    \ sorted_lst\nend", "  return lst.sort.uniq\nend", "  sorted = []\n  sorted =\
    \ sorted.concat(lst)\n  sorted.sort!\n  sorted.uniq!\n  return sorted\nend", " \
    \ # Write your solution here\nend", "  return lst\nend", "  sorted = []\n  odd_index\
    \ = 0\n  even_index = 1\n  even_index2 = 0\n  odd_index2 = 0\n  even_index3 =\
    \ 0\n  odd_index3 = 0", "  sorted = []\n  sorted = lst.sort { |a,b| a.length <=>\
    \ b.length }\n  sorted = sorted.sort { |a,b| a.casecmp(b) }\n  return sorted\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt works well, but when I am applying\
    \ your method in the text \"ab cc cd\". It does not work\n<|/ c |>\n<| c |>\n\
    It works for me, please check your input and output\n<|/ c |>\n<| c |>\nI did\
    \ run it on ruby 2.2.2 and i get this error: \"undefined method `casecmp' for\
    \ nil:NilClass\" it seems to work on the ruby 2.2.0 version\n<|/ c |>\n<| c |>\n\
    Hm, the code works fine on ruby 2.2.0. Maybe you just copied the wrong method.\
    \ Try to run my code.\n<|/ c |>\n<| c |>\nI'm sorry, I checked my own code and\
    \ I wrote the wrong method name on the second line. Now it's working fine. Thank\
    \ you very much :)\n<|/ c |>\n<| a dscore=0 |>\nThis might help you get started:\n\
    <code>", "  sorted_array = List.new\n  lst.each do |string|\n    if sorted_array.include?\
    \ string \n      sorted_array.delete_at sorted_array.index(string)\n    else \n\
    \      sorted_array << string\n    end\n  end\n  sorted_array.sort do |string1,\
    \ string2|\n    if string1.length == string2.length\n      if string1.length >\
    \  string2.length\n        string1.split('').sort <=> string2.split('').sort\n\
    \      elsif string1.length < string2.length\n        string2.split('').sort <=>\
    \ string1.split('').sort\n      else\n        string1.split('').sort <=> string2.split('').sort\n\
    \      end\n    elsif string1.length < string2.length\n      string1.split('').sort\
    \ <=> string2.split('').sort\n    else\n      string2.split('').sort <=> string1.split('').sort\n\
    \    end\n  end\nend", "    sorted = []\n    sorted = [item for item in lst if\
    \ item!=[]]\n    sorted.sort\n    sorted = sorted.join(\" \")\n    sorted = sorted.split(\"\
    \")\n    sorted = sorted.sort\n    return sorted\n    end\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "  lst.delete_if { |x| x.length % 2 == 1 }\n  lst.sort\
    \ { |a,b| a.length <=> b.length }\nend", "  lst.sort! { |a,b| a.length <=> b.length\
    \ }\n  lst.sort!\n  return lst\nend", "    lst = lst.sort\n    sorted = []\n \
    \   sorted = lst.uniq.length\n    return sorted.sort\n    ", "    sorted = []\n\
    \    sorted = lst.sort\n    sorted.each do |word|\n        word.each_with_index\
    \ do |char, index|\n            if index > 0\n                word.delete_at(index)\
    \ if word.chars.length % 2 == 1\n            end\n        end\n    end\n    return\
    \ sorted\nend\n</code>\n<|/ a |>\n<| c |>\nThis answer has a great example for\
    \ implementing a bubble sort algorithm if you need it. [Click here to see an example\
    \ of how to implement it.](http://rosettacode.org/wiki/Bubble_sort#Ruby)\n<|/\
    \ c |>\n<| a tags=arrays,ruby dscore=4 |>\nHere's my answer, which also works\
    \ for arrays of any objects that implement the Comparable interface:\n<code>\n\
    arr = [\n  Thing.new(1),\n  Thing.new(3),\n  Thing.new(8),\n  Thing.new(2),\n\
    \  Thing.new(4),\n  Thing.new(9),\n  Thing.new(7),\n  Thing.new(5)\n]", "    sorted\
    \ = []\n    count = 0\n    list.map do |element|\n        if element.length %\
    \ 2 == 0\n            sorted.push(element)\n        else\n            count =\
    \ count + 1\n        end\n    end\n    sorted.sort!\n    sorted.map do |element|\n\
    \        count = count + 1\n    end\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays,sorting\
    \ |>\n<| a |>\n<code>\nrequire 'set'", "  puts \"Sorted list sum:\"\n  puts lst.sort\
    \ {|a, b| b.length <=> a.length || a <=> b }\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\n<code>", "    \n    # Write your code here\n    \n    return sorted(lst)",
  "  lst.delete_if {|s| s.length % 2 != 0}\n  lst.sort\nend\n</cell>\n<text>\nThe\
    \ function call:\nsorted_list_sum([\"aa\", \"a\", \"aaa\"])", "    array.sort_by_length\
    \ lst\nend\n    ", "  \n  # Your code here\n  \nend", "  lst.each do |word|\n\
    \    word.chars.each_with_index do |letter, i|\n      if i % 2 != 0\n        word.delete(letter)\n\
    \      else\n        word = word.sort\n      end\n    end\n  end\n  word\nend\n\
    </code>\nFor me that works. Hope it helps.\n<|/ a dscore=0 tags=string,arrays,ruby\
    \ |>\n<| a tags=string,arrays,ruby |>\n<code>", "  lst.sort.each do |i|\n    break\
    \ if i.length != i.to_s.split(//).length\n  end\n  lst\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nA `break` in a `sort` is very misleading. It breaks the sort and\
    \ doesn't sort, rather it returns the sorted array which happens to be the same\
    \ as the initial one.\n<|/ c |>\n<| c |>\nYes, `sort` does indeed return the sorted\
    \ array. That's not what I intended with the first comment. Sorry, it looks like\
    \ I didn't pay enough attention to the code when I answered. I will remove it.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  newlst = Array.new\n  lst.each do |x|\n\
    \    i = newlst.index(x)\n    newlst[i] = newlst[i..-1] if newlst.index(x)+1\n\
    \    newlst[i] += [x]\n  end\n  newlst.sort\nend", "  # Write your code below\
    \ this line\n  return lst\nend", "  l = lst.to_a\n  l.sort!\n  return l\nend\n\
    </cell>\n<text>\nSorting\nAs seen in the previous exercises, you can make use\
    \ of Ruby's sort method. In fact, there is already an instance method called sort\
    \ that can be used on arrays, but it's instance method can take blocks. One such\
    \ block is a comparison block. It will be called to compare two elements of the\
    \ array. The sort method will sort the array in place with the return value from\
    \ the block. The block returns the negative number if the first argument is less\
    \ than the second. The default block is as follows:", "  lst.map! { |x| x }\n\
    \  lst.sort! { |a,b| a.length <=> b.length }\n  lst.sort! { |a,b| a <=> b }\n\
    \  return lst\nend", "    sum = []\n    word_len = []\n    words = []\n    count\
    \ = {}\n    length = 1\n    for word in lst\n        if word != \"\"\n       \
    \     if length in count\n                count[length] += 1\n               \
    \ length += 1 # if exist one more word, increase length\n            else\n  \
    \              count[length] = 1\n                length += 1 # if exist one more\
    \ word, increase length\n            else\n                length += 1 # if exist\
    \ one more word, increase length\n            end\n        end\n    end\n    word_len\
    \ = count.values\n    word_len = word_len.sort\n    for word in word_len\n   \
    \     if word.odd?\n            sum << word\n        end\n    end\n    sum = sum.sort\n\
    \    sum.each do |word|\n        if words.include?(word)\n            words.delete\
    \ word\n        else\n            words << word\n        end\n    end\n    words\n\
    end\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nWhat if you were given an input\
    \ like `[\"aa\", \"ab\", \"cd\", \"a\"]`? Would you just sort the array and have\
    \ `[\"cd\", \"a\", \"ab\"]`? I think you misunderstood the question.\n<|/ c |>\n\
    <| c |>\nThat's not what the OP asked: *\"The function should return an array\
    \ of strings in sorted order\"*\n<|/ c |>\n<| c |>\nOh, I see; I misread the question.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| a tags=ruby,sorting |>\nHere is\
    \ my solution:\n<code>", "    arr = lst.to_a\n    arr.each { |x| arr.remove(x)\
    \ }\n    arr.sort!\n    arr\nend", "    sorted = []\n    sorted.concat(lst)\n\
    \    sorted.sort\n    sorted.delete_if\n    sorted.sort!\n    sorted\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a |>\n<code>", "  return lst.sort do |a, b|\n  \
    \  a1 = a\n    a2 = b\n    a1.length <=> a2.length <=> a.length > b.length ? -1\
    \ : 1\n    a1 <=> a2\n  end\nend", "  my_sorted = lst.sort\n  new_array = []\n\
    \  i = 0\n  while i < my_sorted.length\n    if my_sorted[i].length < 2\n     \
    \ i += 1\n    else\n      new_array << my_sorted[i]\n      i += 1\n    end\n \
    \ end\n  return new_array.sort\nend", "  lst.map! { |x| x.gsub(/[^a-z]+/, '')\
    \ } # Remove non-alphabetic characters\n  lst.delete_if { |x| x.length % 2 } #\
    \ Remove odd strings\n  lst.sort!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI dont get why this is so complicated when its only a few lines\
    \ of code. Is there some sort of ruby idiom i dont know about ?\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work correctly. You need to sort before filtering.\n<|/ c\
    \ |>\n<| c |>\nIt works as is, but you need to sort the list before filtering.\
    \ Otherwise you filter out all odd strings with an even length.\n<|/ c |>\n<|\
    \ c |>\nSorry, I missed that.\n<|/ c |>\n<| a dscore=2 |>\nJust add this to your\
    \ model\n<code>\n  def self.sorted_list\n    self.all.sort{ |a,b| a.size <=> b.size\
    \ }.map(&:downcase)\n  end\n</code>\nand you can call it with\n<code>\nMyModel.sorted_list\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis isn't the answer that\
    \ he wants. He wants words that appear once to be sorted at the top, even though\
    \ they might occur multiple times in an array.\n<|/ c |>\n<| c |>\nYeah, I missed\
    \ the sorting of duplicates. I'll have to fix my answer.\n<|/ c |>\n<| a |>\n\
    This was a fun challenge.  It's still an O(n^2) solution, but I thought I would\
    \ post it anyway.  I did this in two steps.  First I split all of the words into\
    \ letters, then I remove any duplicates that occur in the same letter group. \
    \ After that I sort the letters within each letter group alphabetically.  Finally,\
    \ I re-merge the letters back into words.\n<code>", "  lst.sort!\n  lst.delete_if\
    \ { |x| x.length % 2 == 1 }\n  lst\nend\n</code>\n<|/ a tags=string,ruby,sorting\
    \ dscore=1 |>\n<| a dscore=1 |>\nHere's another solution, using each_char:\n<code>\n\
    list = [\"ab\", \"a\", \"aaa\", \"cd\"]", "  lst.sort\n  lst.delete_if {|x| x.size\
    \ % 2 == 1}\n  lst\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYour second answer\
    \ is perfect and I thank you for your help. I edited my question to give a better\
    \ explanation of how I want to implement this function.\n<|/ c |>\n<| c |>\n,\
    \ you're welcome. I updated the answer accordingly. Please see the updated answer\
    \ with detailed comments.\n<|/ c |>\n<| c |>\nThank you very much for your help\
    \ and explanation. My question is do you know why when I use the solution from\
    \ your second answer I get this error `NameError: undefined local variable or\
    \ method `sorted_list_sum' for main:Object (NameError)`. My code is exactly the\
    \ same as you wrote in the second answer. I just put your first answer in my `list_sum`\
    \ function but I get this error.\n<|/ c |>\n<| c |>\n, you're welcome. Since your\
    \ `list_sum` function is actually a `class` method, you need to use `self.sorted_list_sum`.\
    \ Otherwise, the `self` won't be available and you need to use `list_sum.sorted_list_sum`.\
    \ See my updated answer with detailed comments.\n<|/ c |>\n<| c |>\nThank you\
    \ again for the help! I appreciate it. I tried your `self.sorted_list_sum` solution\
    \ and I received this error `NameError: undefined local variable or method `sorted_list_sum'\
    \ for main:Object (NameError)`. I checked my code and it looks like you wrote\
    \ the exact same thing as I did but I don't get why I keep getting this error.\n\
    <|/ c |>\n<| a dscore=0 tags=arrays,sorting,ruby,function |>\nI'm assuming you\
    \ want to implement the sort function of Array.  To do this, you can use the sort\
    \ method.  You can then use the delete_if method on that sorted array to remove\
    \ any items that meet a certain condition.  Finally, you can use sort again to\
    \ re-sort the array.\nThe method calls that you want to use are as follows:\n\
    <code>\narray.sort # will sort the array\narray.delete_if { |element| element.meets_condition\
    \ }", "  return lst.sort { |x, y| x.length <=> y.length || x.to_s cmp y.to_s }\n\
    end", "    # Write your solution\n    sorted = lst.sort\n    sorted.select{|x|\
    \ x.length == sorted.count}\nend\n</cell>\n<cell>", "    arr = lst.sort\n    arr.each\
    \ do |x|\n        x.delete_if {|y| y%2 == 1}\n    end\n    return arr\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=sorting,ruby |>\n<code>", "  new_lst = []\n  lst.each\
    \ do |item|\n    if item.count > 1\n      new_lst.push(item)\n    end\n  end\n\
    \  new_lst.sort_by! {|x| x.count}\n  new_lst.sort_by! {|x| x.downcase}\n  new_lst.each\
    \ do |item|\n    puts item\n  end\nend", "    l = lst.sort\n    a.each{ |el| el\
    \ =~ /\\w/; lst.delete(el) }\n    return lst.sort\nend\n</code>\nI used the sort_by\
    \ method and deleted to remove those elements from the original array.\nI then\
    \ sorted the array using the default sort method in ruby.\n<code>\na = [\"aa\"\
    , \"a\", \"aaa\"]\na.sort_by{|el| el =~ /\\w/}\n=> [\"aa\", \"a\", \"aaa\"]\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nthanks this is perfect to me. Can you explain\
    \ what each does? I see the symbol of each in ruby on rails but I'm not familiar\
    \ with that symbol yet (although it seems like it could be used for a lot more\
    \ than just ruby on rails).\n<|/ c |>\n<| c |>\neach_with_index is Ruby 1.9+ method.\
    \ See here for documentation http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-each_with_index\n\
    <|/ c |>\n<| c |>\neach_with_index will pass each element of an array with an\
    \ index, the index is an integer that goes from 0 to the size of the array minus\
    \ 1.", "  sorted = []\n  for i in lst\n    word = i.split\n    length =word.length\n\
    \    sorted.each do |element|\n      if element.length == length\n        element\
    \ << word\n      elsif element.length < length\n        sorted = sorted + [word]\n\
    \      end\n    end\n  end\n  sorted.sort\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a tags=ruby,arrays,sorting dscore=0 |>\nHere is a solution that avoids string\
    \ splitting. It uses regular expressions to extract the numbers and sorts the\
    \ results.\n<code>", "  lst.map {|x| x.split(\" \").map {|y| y.to_i}}.group_by\
    \ {|x| x.size}.map {|k,v| v.flatten.uniq.sort}.flatten\nend", "  lst.sort\n  lst.map\
    \ { |e| e[0..-2] }\nend", "  sorted = lst.sort do |a, b|\n    a.length <=> b.length\
    \ || a.downcase <=> b.downcase\n  end\n  sorted.map do |s| s.split('').sort.join('')\
    \ end\nend", "  # Write your code here\n  lst.sort!\n  lst.reject!{|x| x.length\
    \ % 2 == 1}\n  lst\nend\n</cell>\n<cell>\nsorted_list_sum([\"cd\", \"ab\", \"\
    ac\", \"ad\"])\n</cell>\n<text>\nWrite a function that receives two strings separated\
    \ by a space,\nand returns a string that is the concatenation of both strings,\n\
    but without spaces between them. If only one string has spaces between them,\n\
    the function should return a string with no spaces between them.\nYou should always\
    \ use + instead of puts because it returns the string\nwithout concatenating them.\n\
    Example:\n>>> concate_no_space(\"aa\", \"ab\")\n'aab'\n>>> concate_no_space(\"\
    aa\", \"a b\")\n'a b'\n>>> concate_no_space(\"a b\", \"a b\")\n'a b'", "  puts\
    \ \"lst.length = #{lst.length}\" if ENV['DEBUG']\n  return lst\nend", "    \n\
    \    arr=lst.sort\n    arr.reverse\n    \n    return arr\n    ", "  sums = []\n\
    \  sums.sort{|a,b| a.length <=> b.length}\n  sums.map {|word| lst.reject {|x|\
    \ x==word}}.sort.map{|word| word}.sort\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThanks so much for the help and explanations. That really helps!\n<|/ c\
    \ |>\n<| a tags=ruby |>\nYou can do it in one line:\n<code>\narr = [\"aaa\", \"\
    a\", \"bbb\", \"b\"]\narr.sort!.uniq!.sort!", "    \nend", "    arr = Array.new(lst.length)\
    \ { |i| lst[i] }\n    arr.sort!\n    return arr\nend", "    sorted = []\n    sorted\
    \ = sorted.concat(lst)\n    sorted = sorted.sort\n    return sorted\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,functional-programming |>\n<| a dscore=0 |>\n<code>",
  "  # Write your code here\n  arr = lst.sort\nend", "  sorted = []\n  sorted.push(lst[0])\n\
    \  for x in lst\n    if x.length != sorted.last.length\n      sorted.push(x)\n\
    \    else\n      sorted.push(sorted[sorted.length - 1] + x)\n  end\n  sorted.sort!\
    \ do |a, b|\n    b.length - a.length\n  end\n  sorted.map!{|x| x.to_s}\n  sorted\n\
    end", "  sorted_list = lst.sort\n  sorted_list.delete_if {|x| x.odd? }\n  sorted_list.sort\n\
    end\n</cell>\n<cell>", "  # Your code here\n  return lst\nend\n</cell>\n<cell>",
  "  puts \"Unsorted array:\"\n  puts lst\n  puts \"Array before sort:\"\n  puts lst",
  "  sorted = []\n  sorted.concat(lst.sort {|a, b| a.length <=> b.length || a <=>\
    \ b })\n  sorted.concat(lst.sort {|a, b| a.length <=> b.length || a.downcase <=>\
    \ b.downcase })\n  sorted.concat(lst.sort {|a, b| a.length <=> b.length || a.upcase\
    \ <=> b.upcase })\n  sorted\nend", "  lst.sort_by do |str|\n    str.to_s.split.sort_by\
    \ {|s| s.length }\n  end\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays,string\
    \ |>\n<| a tags=ruby,arrays,string |>\nIn case you still need this one,\nI wrote\
    \ a Ruby gem (named sorter) to help with this task. You can find it here on Github.\n\
    You can install it on Mac OS X using:\n<code>\nsudo gem install sorter\n</code>\n\
    Or Ubuntu:\n<code>\nsudo apt-get install rubygems\nsudo gem install sorter\n</code>\n\
    After installing sorter, you just need to do:\n<code>\nrequire 'sorter'", "\t\
    a=[]\n\tfor i in lst\n\t\ta.push(i)\n\tfor i in a\n\t\tif i.length%2==1\n\t\t\t\
    a.delete(i)\n\ta.sort\n\ta.push(\"\")\n\treturn a\n\tend\nend", "    # Your code\
    \ here\n    result = []\n    uniq_lst = uniq(lst)\n    uniq_lst.each do |uniq_word|\n\
    \        sorted_lst = []\n        uniq_lst.each do |word|\n            if uniq_word.length\
    \ == word.length\n                sorted_lst.push(word)\n            end\n   \
    \     end\n        result.push(sorted_lst.sort)\n    end\n    result\nend", " \
    \ # Your code here\nend", "  lst = lst.sort\n  \n  sorted_arr = []\n  i = 0\n\
    \  while i < lst.count\n    el = lst[i]\n    \n    i += 1\n    \n    if el.length\
    \ % 2 == 1\n      i += 1\n    end\n  end", "  lst.sort! do |a, b|\n    if a.length\
    \ < b.length\n      true\n    elsif a.length > b.length\n      false\n    else\n\
    \      a.upcase<=>b.upcase\n    end\n  end\n  lst\nend\n</code>\n<|/ a tags=ruby,functional-programming\
    \ |>\n<| a tags=ruby,functional-programming dscore=2 |>\n<code>", "    sums =\
    \ lst.map { |word| word.to_s.length }.uniq\n    sums.sort\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 |>\nThe first thing that jumps out at me is that you are using\
    \ lst.sort!. Try lst.sort instead, which will modify your original list.\n<|/\
    \ a tags=ruby |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post.\n<|/ c |>\n<| c |>\nWell it did the trick! Thanks for that :)\n<|/ c |>\n\
    <| a dscore=0 tags=ruby |>\n<code>", "    \n    # Write your code here\n    \n\
    \    # sort the list\n    \n    \n    # filter out the list with odd length\n\
    \    \n    \n    \n    # sort the list by the length\n    \n    \n    # sort the\
    \ list by the length again\n    \n    \n    # join the list by space\n    \n \
    \   \n    \n    return lst\n</cell>\n<cell>", "  sum_list = Array.new\n  for x\
    \ in lst\n    sum_list.push x.to_i\n  end\n  sum_list.sort_by {|s| s.to_i}\n \
    \ return sum_list\nend", "    arr.map {|x| x.delete('0'..'9').split('').sort}.flatten\n\
    end\n</cell>\n<text>\nTask\nWrite a function that accepts an array of numbers\
    \ (represented as strings containing only digits) and returns the sum of the numbers\
    \ in the array.", "  # TODO: your code here\nend", "  lst.sort!\n  lst.group_by{|word|\
    \ word.length}.sort{|a,b| a.length <=> b.length}.values\nend", "  lst.sort\n \
    \ lst.uniq\n  lst.sort\n  lst.sort\n  lst.sort\n  lst.sort\nend", "  result =\
    \ []\n  sorted = true\n  arr.each do |el|\n    if sorted = true\n      if el.length\
    \ % 2 == 1\n        sorted = false\n      end\n      el.length.times do |i|\n\
    \        result += [el[i]]\n      end\n    else\n      if el.length % 2 == 1\n\
    \        sorted = true\n      end\n      el.length.times do |i|\n        result\
    \ << el[i]\n      end\n    end\n  end\n  if sorted == true\n    result = result.sort_by\
    \ {|el| el}\n  end\n  return result\nend\n</code>\n<|/ a |>\n<| c |>\nThat code\
    \ does not work. It will just output the result from sorted list, not actually\
    \ remove elements from the original list.\n<|/ c |>\n<| c |>\nThanks for the comment\
    \ David. I've edited the code now. Have a look and let me know if it works.\n\
    <|/ c |>\n<| c |>\nThis code will not work as expected:", "  summed = []\n  for\
    \ i in lst\n    summed << i.split(//)\n  end\n  summed.map!(&:sort)\n  summed.uniq!\n\
    \  summed\nend", "    array.sort do |a, b|\n      length = [a.length, b.length].max\n\
    \      length == 0 ? length : a.length <=> b.length\n    end\n    lst\nend\n</code>\n\
    <|/ a tags=arrays,ruby,string dscore=3 |>\n<| a tags=arrays,ruby,string |>\n<code>\n\
    [a,b,c,d,e,f].map{|x| x.split(//).sort}.join(\"\")\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis looks like a better solution than the accepted answer, but doesn't\
    \ seem to work in Ruby 2.2.0\n<|/ c |>\n<| c |>\nI'm also curious if there's any\
    \ performance difference between the two methods provided here\n<|/ c |>\n<| c\
    \ |>\nThe accepted answer does work (tested on Ruby 2.2) and is shorter than the\
    \ one that uses .split and .sort.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nstr = \"\
    This is a string\"\nstr.gsub(/\\w+/) do |word|\n  word.downcase.split(//).sort\n\
    end\n</code>\n<|/ a tags=arrays,ruby,string |>\n<| a tags=arrays,ruby,string |>\n\
    <code>\nstr =  \"This is a string\"\nstr.gsub(/\\w+/) do |word|\n  word.downcase.split(//).sort\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't give the correct result.\
    \ Try it with `str = \"This is a string with words\"`.\n<|/ c |>\n<| a tags=arrays,ruby,string\
    \ |>\n<code>", "  sorted_list = lst\n  sorted_list = sorted_list.sort{|a,b| a.length<=>b.length\
    \ || a<=>b}\n  return sorted_list\nend\n</cell>\n<cell>", "    sort_by(lst, :length).sort_by(lst,\
    \ :first).map(&:last)\nend", "  new_list = []\n  array.sort_by { |word| word.to_s.length\
    \ }\n  list.each do |word|\n    new_list << word if word.to_s.length % 2 != 0\n\
    \  end\n  new_list.sort\nend", "    words=lst.to_a\n    sorted_array=[]\n    sorted_array.push(words[0..-2].sort)\n\
    \    sorted_array.push(words[-2..-1].sort)\n    sorted_array.push(words[0..-2].sort.reverse)\n\
    \    sorted_array.push(words[-2..-1].sort.reverse)\n    sorted_array.push(words[0..-2].sort.reverse)\n\
    \    sorted_array.push(words[-2..-1].sort.reverse)\n    return sorted_array\n\
    end\n</code>\n<|/ a |>\n<| c |>\nIt would be better to describe what the code\
    \ does and why rather than just \"writing code\".\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\nFor your problem, you can use the delete_if method to remove the strings\
    \ which have odd length:\n<code>", "  lst.sort! \n  arr.delete!{|i| i.length%2\
    \ == 1}\n  lst.sort!\nend", "  sum = 0\n  sorted = []\n  words = []\n  words.sort!\n\
    \  words.each do |word|\n    if word.length % 2 != 0\n      sorted.push(word)\n\
    \    end\n  end\n  return sorted\nend\n</cell>\n<code language=julia-1.6>", " \
    \ return lst.sort\nend\n</code>\n<|/ q tags=ruby |>\n<| a dscore=2 |>\nHere is\
    \ how I did it:\n<code>", "  lst.sort\n  return lst.sort\nend", "    sorted =\
    \ []\n    count = 0\n    i = 0\n    while i < lst.size\n        if lst[i] == \"\
    \\n\"\n            count += 1\n        else\n            if count == 0\n     \
    \           sorted << lst[i]\n            elsif count > 1\n                sorted\
    \ << lst[i]\n            elsif count == 1\n                i = i + 2\n       \
    \     end\n            count = 0\n        end\n    end\n    sorted.sort!\n   \
    \ return sorted\nend", "    array = lst.to_a\n    sorted_array = array.sort {|a,b|\
    \ a.length <=> b.length}\n    sorted_array.sort! {|a,b| a <=> b }\n    return\
    \ sorted_array\nend", "  lst.sort! do |a, b|\n    if a.length == b.length && a.length\
    \ <=> b.length == -1\n      a <=> b\n    else\n      a.length <=> b.length\n \
    \   end\n  end\n  lst\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,sorting,arrays,function\
    \ |>\nThe answers here are great, I just wanted to mention a different way to\
    \ approach the problem.\nYou could do something like\n<code>", "  lst.sort\n \
    \ lst.map {|e| e.to_s}\nend", "  sorted = []\n  sorted = sorted.concat(lst.sort\
    \ {|x,y| x.length <=> y.length })\n  sorted = sorted.concat(lst.sort {|x,y| x\
    \ <=> y })\n  sorted\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>", "  \
    \  arr = lst.sort.uniq.map do |w|\n        w\n    end\n    arr\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  sorted = []\n  i = 0\n  while i < lst.count\n \
    \   if lst[i].length\n      sorted << lst[i]\n      i += 1\n    else\n      i\
    \ += 1\n  end\n  sorted.sort! do |word1, word2|\n    if word2.length\n      word1\
    \ <=> word2\n    else\n      word1 < word2\n    end\n  end\n  sorted\nend", " \
    \   sums = []\n    i = 0\n    while i < lst.length\n        sum = 0\n        j\
    \ = i + 1\n        while j < lst.length\n            if lst[i].length > lst[j].length\n\
    \                sum += lst[j].length\n                j += 1\n            else\n\
    \                sum += lst[i].length\n                i += 1\n        end\n \
    \       sums << sum\n    end\n    sums.sort!\n    sums\nend", " sorted = []\n\
    \ sorted_sum = []\n sorted_sum.sort! do |a,b|\n a.length <=> b.length\n b.length\
    \ <=> a.length\n end\n lst.each do |string| \n sum = 0\n sorted_sum.each do |word|\n\
    \ sum += word.index(string).to_i\n end\n sorted << string if sum % 2 != 0\n end\n\
    \ return sorted\nend\n</code>\n<|/ a |>\n<| c |>\nThis is a little bit more complicated\
    \ than it needs to be. There are better ways to accomplish the same thing, like\
    \ `sums.inject(0) {|sum, a| sum + a.length}`.\n<|/ c |>\n<| c |>\n, this is an\
    \ instructor's assignment. I think he/she can learn how to use inject in the future.\
    \ Also, he will learn something from looking at the answers.\n<|/ c |>\n<| c |>\n\
    But I thought it was an instructor's assignment to write code without using loops\
    \ ;-)\n<|/ c |>\n<| a tags=ruby,arrays dscore=2 |>\n<code>", "\tlst.delete_if\
    \ { |a| a.length % 2 != 0 }\n\tlst.sort! { |a,b| a.length <=> b.length }\n\treturn\
    \ lst\nend", "  lst.map { |s| s.split(//).sort { |a, b| b <=> a } }\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nvar list = [ 'cat', 'dog', 'mouse',\
    \ 'pig', 'piglet', 'elephant', 'elephant' ];", "  lst.each do |word|\n    if word.to_s.length\
    \ % 2 == 1\n      lst.pop\n    else\n      lst.sort!\n    end\n  end\n  lst\n\
    end", "    sorted_list = nil\n    lst.each do |x|\n        if x.to_s.length %\
    \ 2 == 1\n            sorted_list << x\n        else\n            sorted_list\
    \ << x\n            sorted_list << x[1..-1]\n        end\n    end\n    sorted_list.sort!\n\
    \    return sorted_list\nend", "    # Write your code here\n    lst.sort{|x,y|\
    \ y.length <=> x.length }\n    lst\nend", "    sort = lst.sort { |a, b| b.length\
    \ <=> a.length || a.downcase <=> b.downcase }\n    sort.sort!\n    sort\nend",
  "    words = []\n    unique_words = []\n    count = 0\n    \n    unique_length =\
    \ []\n    for word in lst\n        unique_length.append(word.length)\n       \
    \ unique_words.push(word)\n    \n    unique_length.sort!\n    unique_words.sort!\n\
    \    \n    unique_length.each do |length|\n        words.push('')\n        unique_words.each\
    \ do |word|\n            if word.length == length\n                count +=1\n\
    \                words.push(word)\n            end\n        end\n    end\n   \
    \ \n    words.push(\"\")\n    words.sort!\n    \n    words\nend", "    return\
    \ lst.sort\nend", "    # Your code goes here\n  lst.sort.sort_by{|x| x.length}\n\
    end", "  lst.sort!\n  odd_sum = lst.reject { |str| str.count(' ') == 1 }\n  lst.map!\
    \ { |str| str.downcase.split(//).sort.join.strip }\n  odd_sum.map { |str| str.downcase.split(//).sort.join.strip\
    \ }\nend\n</code>\n<|/ a tags=ruby,arrays,string,sorting,arrays dscore=3 |>\n\
    <| a tags=ruby,arrays,string,sorting,arrays |>\n<code>", "    # Write your code\
    \ here\n    sorted = []\n    lst.each do |word|\n        sorted.push(word) unless\
    \ word.index(\"#\")\n    end\n    sorted.sort!\n    sorted.map!{ |word| word[1..-1]\
    \ }\n    sorted.uniq!\n    sorted\nend", "    # Write your sorting code here\n\
    \    sorted_list = lst\n    sorted_list.sort! do |a,b|\n        a.length <=> b.length\
    \ || a.to_i <=> b.to_i\n    end\n    return sorted_list\nend", "  lst.sort.reverse\n\
    end", "    sorted = []\n    sorted_by_length = []\n    sorted_by_length_names\
    \ = []\n    sorted_by_length_numbers = []\n    sorted_by_length_numbers_names\
    \ = []\n    sorted_by_length_names_names = []\n    sorted_by_length_numbers_names_names\
    \ = []\n    sorted_by_length_numbers_names_numbers = []\n    sorted_by_length_names_names_numbers\
    \ = []\n    sorted_by_length_numbers_names_names_numbers = []\n    sorted_by_length_numbers_names_names_numbers\
    \ = []\n    sorted_by_length_numbers_names_names_names_numbers = []\n    sorted_by_length_numbers_names_names_names_names_numbers\
    \ = []\n    sorted_by_length_numbers_names_names_names_names_names_numbers = []\n\
    \    sorted_by_length_numbers_names_names_names_names_names_names_numbers = []\n\
    \    sorted_by_length_numbers_names_names_names_names_names_names_names_numbers\
    \ = []\n    sorted_by_length_numbers_names_names_names_names_names_names_names_names_numbers\
    \ = []\n    sorted_by_length_numbers_names_names_names_names_names_names_names_names_names_names_numbers\
    \ = []", "\t\n\t# Initialize an empty list to store sorted words\n\tsorted_list\
    \ = []\n\t\n\t# Iterate through each element in the list\n\tfor word in lst\n\t\
    \t\n\t\t# If length of current word is odd, then add current word to the list\
    \ \n\t\tif word.length.odd?\n\t\t\tsorted_list << word\n\t\t\n\t\t# Else if the\
    \ length of the current word is even\n\t\telsif word.length.even?\n\t\t\t\n\t\t\
    \t# Iterate through the words in alphabetical order\n\t\t\tfor other_word in sorted_list\n\
    \t\t\t\t\n\t\t\t\t# If the current word is equal to the other word, \n\t\t\t\t\
    # then move on to the next word\n\t\t\t\tif word == other_word\n\t\t\t\t\tnext\n\
    \t\t\t\t\n\t\t\t\t# If the other word is equal to the current word,\n\t\t\t\t\
    # then move on to the next word\n\t\t\t\telsif other_word == word\n\t\t\t\t\t\
    next\n\t\t\t\t\n\t\t\t\t# Otherwise, if the current word is less than the other\
    \ word, \n\t\t\t\t# then swap the two words\n\t\t\t\telsif word.cmp(other_word)\
    \ < 0\n\t\t\t\t\t\n\t\t\t\t\t# Swap the words\n\t\t\t\t\tswap_word(word, other_word)\n\
    \t\t\t\t\t\n\t\t\t\t\t# Move on to the next word\n\t\t\t\t\tnext\n\t\t\t\t\n\t\
    \t\t\t# Otherwise, if the current word is more than the other word\n\t\t\t\telsif\
    \ word.cmp(other_word) > 0\n\t\t\t\t\t\n\t\t\t\t\t# Swap the words\n\t\t\t\t\t\
    swap_word(word, other_word)\n\t\t\t\t\t\n\t\t\t\t\t# Move on to the next word\n\
    \t\t\t\t\tnext\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\traise Exception.new(\"This should\
    \ never happen!\")\n\t\t\t\n\t\t\t# Add the current word to the sorted list after\
    \ all the words in sorted order\n\t\t\tsorted_list << word\n\t\tend\n\t\t\n\t\
    # Return the list with sorted words\n\treturn sorted_list\nend", "  lst.sort\n\
    \  result = []\n  i = 0\n  while i < lst.count\n    if lst[i].length > lst.count\n\
    \      result << lst[i]\n    else\n      result << lst[i+1]\n    end\n    i +=\
    \ 1\n  end\n  result\nend", "    sum = 0\n    sorted_lst = Array.new\n    i =\
    \ 0\n    while i < lst.length\n        sum += lst[i].length\n        if sum %\
    \ 2 == 1\n            sorted_lst.push lst[i]\n        end\n        i += 1\n  \
    \  end\n    return sorted_lst\nend", "  lst.sort\n  return lst\nend", "  sorted\
    \ = []\n  sorted = sorted.concat(lst.select{|word| word.length % 2 != 0}) # even\n\
    \  sorted = sorted.concat(lst.select{|word| word.length % 2 == 0}) # odd\n  sorted\
    \ = sorted.sort.uniq # remove duplicates\n  sorted = sorted.sort.join # put it\
    \ back together\n  return sorted\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThe last line could be `sorted = sorted.sort.join # put it back\
    \ together`, but otherwise this looks great. Just a small question: Does it work\
    \ for strings with odd length as well? I think it does, but just in case I wanna\
    \ double check.\n<|/ c |>\n<| c |>\nYes, it does. It sorts the strings alphabetically\
    \ with duplicates and strings with even lengths sorted by length, then it removes\
    \ the duplicates and joins it back together. Strings with odd lengths will always\
    \ be at the end of the sorted array.\n<|/ c |>\n<| c |>\nOh, I see. I was just\
    \ wondering if it would treat `\"abc\"` as `[\"a\", \"b\", \"c\"]`. Thanks for\
    \ clarifying.\n<|/ c |>\n<| c |>\nYes, it does. It sorts the strings alphabetically\
    \ with duplicates and strings with even lengths sorted by length, then it removes\
    \ the duplicates and joins it back together. Strings with odd lengths will always\
    \ be at the end of the sorted array.\n<|/ c |>\n<| c |>\nBy the way, I suggest\
    \ you to read up on Ruby Enumerable's methods like `select`, `sort`, `map`, `collect`,\
    \ `each`, `map!`, `inject`, `inject!`, `reduce`, `reduce!`, `find_all`, `reject`,\
    \ `reject!`, `find_index`, `find_all!`, `find_index!` etc.\n<|/ c |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>", "  lst.delete_if {|x| x.length&1 == 0}\n  lst.sort_by{|x| x.count}\n\
    \  lst\nend", "  return sort.call(lst.map {|item| item.split('').reject(&:odd?).join('').split('').sort})\n\
    end", "  my_list = lst.sort\nend", "  result = []\n  sorted_arr = lst\n  sorted_arr.each\
    \ do |elem|\n    elem.each_index do |i|\n      if i % 2 != 0\n        result.push(elem[i])\n\
    \      end\n    end\n  end\n  result = result.sort\n  result\nend", "    sorted\
    \ = []\n    sorted = lst.sort {|a,b| a.length <=> b.length }\n    sorted.each\
    \ {|word| sorted.delete_if{|word| word.length % 2 != 0}}\n    sorted.each {|word|\
    \ sorted.delete_if{|word| word.length == 0}}\n    sorted.sort {|a,b| a <=> b}\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    lst = lst.sort!\n\
    \    puts \"#{lst}\"\nend", "  lst.sort!\n  lst.uniq!\n  sorted_list = lst.sort\
    \ { |a, b| a.length <=> b.length } + [lst.sort]\nend", "  words = [word.to_s for\
    \ word in lst]\n  unique_words = Array.new(words.uniq).sort\n  unique_words +=\
    \ [words.length]\n  unique_words.map do |word|\n    words.find { |word| word.to_s\
    \ == word }\n  end\nend", "  sorted = []\n  sorted = lst.sort do |a,b|\n    a.length\
    \ <=> b.length\n  end\n  sorted.sort!\n  sorted\nend", "  sorted = []\n  sorted.concat(lst.sort\
    \ { |x,y| x.length <=> y.length })\n  sorted.concat(lst.sort { |x,y| x.capitalize\
    \ <=> y.capitalize })\n  sorted.concat(lst.sort { |x,y| x.upcase <=> y.upcase\
    \ })\n  sorted\nend", "  # Your code here!\nend\n</cell>\n<code language=julia-0.6>\n\
    sorted_list_sum(lst)\n</cell>\n<code language=julia-0.6>\n@assert sorted_list_sum([\"\
    aa\", \"a\", \"aaa\"]) == [\"aa\"]\n@assert sorted_list_sum([\"ab\", \"a\", \"\
    aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n@assert sorted_list_sum([\"c\"]) == [\"c\"\
    ]\n@assert sorted_list_sum([\"c\"]) == [\"c\"]\n@assert sorted_list_sum([\"c\"\
    ]) == [\"c\"]\n@assert sorted_list_sum([\"ab\", \"a\", \"cd\"]) == [\"ab\", \"\
    cd\"]\n@assert sorted_list_sum([\"a\"]) == [\"a\"]\n@assert sorted_list_sum([\"\
    a\"]) == [\"a\"]\n@assert sorted_list_sum([\"a\"]) == [\"a\"]\n@assert sorted_list_sum([\"\
    a\"]) == [\"a\"]\n@assert sorted_list_sum([\"a\"]) == [\"a\"]\n</cell>\n<code\
    \ language=julia-0.6>", "  lst.sort!\n  lst.delete_if { |word| word.length % 2\
    \ == 1 }\n  lst.sort! { |a,b| a.length > b.length ? 1 : -1 }\n  lst\nend", " \
    \ lst.sort do |a, b|\n    a.size<b.size\n  end\n  return lst\nend\n  ", "    sum\
    \ = 0\n    lst2 = []\n    lst3 = []\n    lst4.sort()\n    lst5.sort(key=lambda\
    \ x: int(x[0]) if x else sys.maxint)\n    \n    for i in lst:\n        lst3.append(i)\n\
    \    \n    for i in range(len(lst3)):\n        sum += lst3[i]\n        \n    \
    \    if sum%2 == 0:\n            lst2.append(lst3[i])\n    \n    for i in range(len(lst2)):\n\
    \        lst2.append(lst2[i])\n        \n    return lst2\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\
    print(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(sorted_list_sum([1, 2, 3, 4, 5, 6, 7, 8, ",
  "  sorted = []\n  sorted = sort.call(lst, sort_by)\nend", "  # Your code here\n\
    end\n</cell>\n<code language=julia-1.6>\nsorted_list_sum([\"a\", \"b\", \"c\"\
    , \"a\", \"c\"])\n</cell>\n<code language=julia-1.6>\nfunction sorted_list_sum(lst)\n\
    \    map(w -> length(w)==1 ? w : w[1], sort(lst))\nend\n</cell>\n<text>\nPart\
    \ 2\nWrite a function that accepts a number as a parameter,\nand returns the factorial\
    \ of it,\nin base 10 (that is, x factorial)\nThe function should return the result\
    \ as a number not a string\nThe function will accept negative numbers as well\n\
    For Example:\n>>> factorial(7)\n5040\n>>> factorial(10)\n3628800\n>>> factorial(14)\n\
    130767436800\n>>> factorial(-8)\n-120\n>>> factorial(4.4)\n0.0\n>>> factorial(-1)\n\
    1", "    sorted_list = []\n    sorted_list.sort!", "    arr = lst.sort\n    puts\
    \ \"Sorted Array is: \" + arr.join(\", \")\nend", "  lst.sort\nend\n</code>\n\
    I didn't write this because it is a lot of work, but it does require you to write\
    \ functions in a language you understand, which is no fun at all.\nThis problem\
    \ will almost certainly be solved better with more sophisticated methods than\
    \ sorting, but that is a different story.  I spent a lot of time thinking about\
    \ this question, and it became apparent that sorting is probably not the right\
    \ way to solve this problem (although it does seem like your teacher wants you\
    \ to sort the array by length for some reason).\n<|/ a tags=sorting,ruby,arrays,algorithm\
    \ dscore=1 |>\n<| c |>\nSorry, I only realised this now after looking more closely\
    \ at the sample problem - I missed your \"may contain duplicates\". It would help\
    \ if you stated that in the problem description.\n<|/ c |>\n<| c |>\n- I edited\
    \ my answer (I believe) to reflect your addition.\n<|/ c |>\n<| c |>\n- Oh well,\
    \ sorry.  I think I should delete my answer (now deleted), but I think I like\
    \ it.\n<|/ c |>\n<| a tags=sorting,ruby,arrays,algorithm |>\nThis should be fairly\
    \ straightforward using Ruby's Enumerable#group_by:\n<code>\nwords = [\"I\", \"\
    love\", \"Ruby\", \"and\", \"Python\"]\nwords.group_by { |word| word.size }",
  "  list2 = []\n  list1 = []\n  for i in lst\n    if i[6] == i[6].to_f\n      list2.push(i)\n\
    \    else\n      list1.push(i)\n    end\n  end\n  list2.sort!\n  list2.sort!\n\
    \  return list1 + list2\nend", "  lst.sort!\n  result = lst.dup\n  result.sort!\n\
    \  return result\nend", "  lst.sort!\n  lst.group_by{|x| x}.map{|_, v| v.sort}.flatten\n\
    end", "  lst.sort.sort!\n  lst\nend", "  return lst.sort{|a,b|a.size<b.size?-1:a.size<b.size?1:a[0]<b[0]?-1:a[0]<b[0]?1:a[1]<b[1]?-1:a[1]<b[1]?1:a[2]<b[2]?-1:a[2]<b[2]?1:a<=>b}\n\
    end", "  lst.sort_by{ |x| x } # sort by ascending length of words\n  lst.uniq{\
    \ |x| x.length % 2 } # remove duplicate strings\nend\n</code>\n<|/ a tags=sorting,arrays,ruby,string\
    \ |>\n<| a dscore=1 |>\nIf your goal is to delete all strings which contain odd\
    \ number of characters, this would suffice:\n<code>\narray = ['aa', 'aaaa', 'aaa',\
    \ 'ab', 'ac', 'cd', 'aaaac', 'acd', 'aacd', 'aad', 'abcd']\narray.delete_if{ |s|\
    \ s.count % 2 == 1 }\n</code>\n<|/ a tags=sorting,arrays,ruby,string |>\n<| a\
    \ tags=sorting,arrays,ruby,string dscore=1 |>\nYou can use delete_if with each_char\
    \ and then use downcase to get case insensitive unique values from an array:\n\
    <code>\narr.delete_if{ |x| x.downcase.each_char.uniq.size <= 2 }\n</code>\n<|/\
    \ a |>\n<| a tags=sorting,arrays,ruby,string |>\n<code>\narr.uniq.sort\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's an example with 2 solutions for both\
    \ of the problems:\n<code>\narray = ['aa', 'aaaa', 'aaa', 'ab', 'ac', 'cd', 'aaaac',\
    \ 'acd', 'aacd', 'aad', 'abcd']", "  result = {}\n  lst.each do |string|\n   \
    \ result[string] ||= 0\n    result[string] += 1\n  end\n  result.sort.sort_by{|k,\
    \ v| v}\nend", "  sorted_list = []\n  sorted_list.sort!\n  lst.reverse.each_with_index\
    \ do |word, index|\n    word = word.downcase\n    word_length = word.length\n\
    \    if word_length % 2 != 0\n      sorted_list.push(word)\n      lst[index] =\
    \ \"\"\n    end\n  end\n  sorted_list\nend\n</code>\n<code>\nsorted_list_sum([\"\
    abc\", \"ab\", \"abcd\", \"def\", \"ef\"])", "  lst = lst.sort\n  lst.sort!\n\
    \  list\nend", "  new_lst = []\n  lst.sort_by {|word| word.length}\n  lst.uniq\
    \ {|word| word.length}\n  new_lst = lst.sort_by {|word| word}\n  new_lst\nend",
  "  if lst.empty?\n    []\n  else\n    sorted_list = lst.sort\n    sorted_list.each_with_index\
    \ do |w, i|\n      if w.length > sorted_list[i + 1].length\n        sorted_list[i\
    \ + 1] = w\n      end\n    end\n    sorted_list\n  end\nend", "    sorted = []\n\
    \    sorted_count = 0\n    temp_total = 0\n    words = lst.split(//)", "  sorted\
    \ = []\n  sorted = sorted.concat(sorted.zip(lst.sort{|a,b| a.length <=> b.length}))\n\
    \  sorted = sorted.concat(sorted.zip(lst.sort{|a,b| a <=> b}))\n  sorted = sorted.sort{|a,b|\
    \ a <=> b}\n  sorted\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm dscore=0\
    \ |>\n<| a |>\nFor this solution I assume that every string is separated with\
    \ whitespace or punctuation marks.\n<code>", "    sorted_list = []\n    sorted_list.sort!\n\
    \    sorted_list.uniq!\n    sorted_list.sort!\n    sorted_list.each {|x| sorted_list\
    \ << x.split(\" \").sort!.uniq.join.strip}\n    sorted_list\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nGood answer! But you forgot to add how to sort the array\n<|/\
    \ c |>\n<| c |>\nthank you for the feedback. i think i already answered that.\
    \ my answer was not complete. i'll try to fix it tonight when I get to my laptop.\n\
    <|/ c |>\n<| c |>\nThanks for providing the detailed explanation as to how you\
    \ arrived at this solution.\n<|/ c |>\n<| c |>\nI added the explanation at the\
    \ end\n<|/ c |>\n<| a tags=sorting,arrays,ruby dscore=3 |>\nThe simplest answer:\n\
    <code>", "  l = lst.to_a\n  l.sort! { |a, b| a.length <=> b.length }\n  l.sort!\
    \ { |a, b| a <=> b }\n  l\nend", "  sorted_list = []\n  sorted_list.push(*lst).sort!\n\
    \  return sorted_list\nend", "  sorted_list = lst.sort\n  unique = sorted_list.uniq\n\
    \  array = unique.map{ |s| s.split(//) }\n  sorted_array.map{|a| a.sort}\nend",
  "  sorted_list = []\n  l = lst.length\n  for i in 0..l-1\n    if lst[i].length %\
    \ 2 == 1\n      sorted_list << lst[i]\n    else\n      a = lst[i].split(\"\")\n\
    \      sorted_list << a[0].to_i + a[1].to_i + a[2].to_i\n    end\n  end\n  return\
    \ sorted_list.sort_by { |word| -word.length }\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I really appreciate your effort, but this isn't what I was looking for. I was\
    \ trying to understand how to solve this with loops and arrays. Also the function\
    \ I wrote was written for only a certain kind of arrays, where all the arrays\
    \ were already sorted. I just wanna understand how to solve the question with\
    \ a loop and arrays. Thanks for your effort, though!\n<|/ c |>\n<| a |>\nThe question\
    \ asks you to write a function called remove_odd_words that, given an array of\
    \ strings, removes all the strings in that array whose lengths are odd. Once you\
    \ do that, you are left with an array of strings of even lengths. You would like\
    \ to create a new array of strings from this new array of strings that contains\
    \ all the strings in the original array that have odd lengths. \nThe function\
    \ remove_odd_words is given an array of strings. To get the odd lengths, you want\
    \ to use the length method, which is provided by Ruby. Then, to create a new array\
    \ out of the odd strings, you want to use the select method. \n<code>", "  return\
    \ lst.sort{|a,b| a.length <=> b.length || a.downcase <=> b.downcase}\nend", " \
    \ res=[]\n  for x in lst\n    word=x.split(\" \")\n    word=word[0]\n    word=word.to_i\n\
    \    if word.length%2==1\n      res<<word\n    else \n      if word < res\n  \
    \      res<<word\n      else\n        if word > res\n          res<<word\n   \
    \   end\n    end\n  end\n  res=res.sort\n  return res\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
