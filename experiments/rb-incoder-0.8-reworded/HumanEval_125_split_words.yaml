name: HumanEval_125_split_words
language: rb
prompt: "# Given a string of words, return an array of words split on whitespace,\
  \ if no whitespaces exists in the text you\n# should split on commas ',' if no commas\
  \ exists you should return the number of lower-case letters with odd order in the\n\
  # alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n# Examples\n# >>> split_words.call(\"\
  Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\"\
  )\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n\
  \    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"],\
  \ candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"\
  Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello\
  \ world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"\
  Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2,\
  \ candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n \
  \   assert_equal(0, candidate.call(\"\"))\n  end\nend\n"
completions: ["    words = txt.split(' ')\n    words.each do |word|\n        word.gsub!(',',\
    \ '') unless word.length > 0\n        word.gsub!(' ', '') unless word.length >\
    \ 0\n        word.gsub!('!', '') unless word.length > 0\n    end\n    return words.count\
    \ { |word| word.gsub(/[^a-z]/, '').length == word.size }\nend", "  words = txt.split(\"\
    \ \") || txt.split(\",\")\n  words.map { |w| w.downcase }\nend", '  return txt
    unless txt.is_a? String', "  txt.split(\" \").map! { |word| word.split(\",\").select\
    \ { |x| x != \"\" }.count { |x| x.downcase % 2 != 0 } ? word : word.split(\",\"\
    ).count { |x| x.downcase % 2 == 0 } ? word.split(\",\").map{ |x| x.downcase }\
    \ : word.split(\"-\").count { |x| x.downcase % 2 == 0 } ? word.split(\"-\").map{\
    \ |x| x.downcase } : word.split(\" \").count { |x| x.downcase % 2 == 0 } ? word.split(\"\
    \ \").map{ |x| x.downcase } : word}\nend", "  words = txt.split(\" \") unless\
    \ txt.include?(\" \")\n  words ||= txt.split(\",\") unless txt.include?(\",\"\
    )\n  words.count(\",\")\nend", "    words = txt.split(/,/)\n    letters = []\n\
    \    letters_count = 0\n    \n    # loop to go through all the letters and see\
    \ if the letter count is odd or even\n    # odd letters are lower case letters\
    \ with an odd order in the alphabet\n    words.each do |word|\n        letters_count\
    \ += word.count(?[a-z])\n    end\n    \n    # if there are no commas in the text\
    \ return even\n    if words.count != letters_count\n        letters_count\n  \
    \  else # otherwise return odd\n        letters_count % 2\n    end\nend", "  new_words\
    \ = Array.new(txt.length, [])\n  \n  i = 0\n  while i < txt.length\n    word =\
    \ \"\"\n    \n    # find the first non-whitespace\n    char = txt.charat(i)\n\
    \    \n    while char == \" \" || char == \"\\n\"\n      i += 1\n      char =\
    \ txt.charat(i)\n    end\n    \n    word << txt[i, txt.length - i - 1]\n    new_words\
    \ << word\n    \n    i += 1\n  end\n  \n  new_words.join\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI'm getting an error: undefined method 'split' for #<String:0x00000101bc25d0>\
    \ for the first solution. Your first solutions works fine when there are no spaces.\
    \ However, when there are spaces I got an error: undefined method 'split' for\
    \ \"HelloWorld!\":String\n<|/ c |>\n<| c |>\nUpdated my answer. Let me know if\
    \ it helps.\n<|/ c |>\n<| c |>\nI got a new error: undefined method 'charat' for\
    \ #<String:0x00000101bc25d0>\n<|/ c |>\n<| c |>\nUpdated my answer. There was\
    \ a mistake in my code. Fixed it.\n<|/ c |>\n<| a dscore=0 |>\nI got this working\
    \ this way:\n<code>", "  result = \"\"\n  letter = \"\"", "  arr = txt.split('\
    \ ')\n  return arr.join(',') if arr.join(',') != txt and arr.join(',').split(',').length\
    \ > 3 else arr.join(',').split(',').count('a') + arr.join(',').split(',').count('b').to_i\
    \ + arr.join(',').split(',').count('c').to_i + arr.join(',').split(',').count('d').to_i\
    \ + arr.join(',').split(',').count('e').to_i + arr.join(',').split(',').count('f').to_i\n\
    end", "  txt.gsub!(/\\s+/, \"\") if txt.include?(\" \")\n  txt.gsub!(/,/, \"\\\
    n\") if txt.include?(\",\")\n  txt.downcase.split.uniq.count\nend", "  words =\
    \ txt.split(\" \") # Split on spaces\n  letters = txt.split(\",\").length # Split\
    \ on commas if they exist\n  return words.map { |word| word.length > 0 ? word.downcase.delete(',')\
    \ : word }\nend", "  # create an array of the split\n  txt.split(\" \").each do\
    \ |word|\n    # only add word to array if it has a length\n    word.downcase!\n\
    \    if word.count(\",\") == 0\n      split_words << word\n    end\n  end\n  split_words.count(\"\
    ,\") > 0\nend", "  return txt.split() if txt.count ? txt.split(/,/).count : txt.split(//).count\
    \ : txt.split(//).map{|c| c.downcase.length if c.downcase =~ /[a-z]/i ? c.downcase.length\
    \ : 0}.max\nend", "  words = []\n  space_idx = 0\n  word = ''\n  words = txt.downcase.split(/\
    \ /)\n  txt.split(/ /).each do |word|\n    word.downcase.each do |character|\n\
    \      word = word + character\n      if ((word.count > space_idx) && (space_idx\
    \ < (word.count - 1))) then\n        words.push(word)\n      end\n      space_idx\
    \ = space_idx + 1\n    end\n  end\n  return words.uniq.size\nend", "  txt = txt.upcase\n\
    \  txt = txt.gsub(',',', ')\n  words = txt.split(' ')\n  words.delete_if{|w| w.empty?}\n\
    \  words[0,words.size / 2].sort.uniq.each_with_index {|w, i| if words[i] =~ /[a-z]/\n\
    \    words[i] = \"#{words[i].gsub(/[a-z]/, '')}\"\n  end\n  return words[0..words.size\
    \ / 2].count\nend", "  return txt.split(/\\s*,\\s*|\\s+/).map do |s|\n    s.split(/(.)/).map\
    \ { |word| word.downcase }\n  end\nend", "  words = txt.split(' ')\n  return words.size\
    \ if words.size > 1 && !words.include?('') else words.size + words.count{ |w|\
    \ w.split(',').size % 2 }\nend", "  txt.split(\" \") unless txt.include?(\" \"\
    )\nend", "  words = txt.split(' ')\n  words.reverse!\n  word_count = 1\n  while\
    \ words.any? do\n    words.shift\n    word_count += 1\n  end\n  words.reverse!\n\
    \  words.count! {|word| word.size == 1}\n  words.shift\n  words.map {|word| word\
    \ =~ /[a-z]/i}.count\nend", "  words = txt.split(\" \")\n  words.each_with_index\
    \ { |word, i| words[i] = word if word.to_s.length < words[i].to_s.length }\n \
    \ if words.count < 1 then\n    words = words.collect { |w| w.downcase }\n    if\
    \ words.count < 1 then\n      words = words.collect { |w| w.count }\n      words.sort!\
    \ { |a, b| a <=> b }\n      words = words[0...(words.count % 2)].inject(:+)\n\
    \    end\n  end\n  return words\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post.\n<|/ c |>\n<| c |>\nYeah it\
    \ does. He asked for help to write a method that would return an array of words\
    \ split on whitespace and commas, with spaces being added if they don't already\
    \ exist. I provided the code to do that which he could just copy/paste into his\
    \ code.\n<|/ c |>\n<| c |>\nIf `split_words.call(\"abc   def\")` were called,\
    \ would the result be `[\"abc\", \"def\"]`?\n<|/ c |>\n<| c |>\nNope, that would\
    \ be `[\"abc\", \"def\"]`. I think it's pretty clear what he wants to do in that\
    \ case, just not how to do it.  Plus I added comments to his code to explain what\
    \ his code is doing.\n<|/ c |>\n<| c |>\nYeah I know. I was just thinking if people\
    \ really don't understand the question, then they may miss that.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  words = txt.split(' ')\n  words.each do |word|\n\
    \    if /\\s/.match(word)\n      words.delete(word)\n    end\n  end\n  words.count('a'..'z').odd?\n\
    end", "  words = txt.split(' ')\n  words.delete_if { |s| s.empty? }\n  words.delete_if\
    \ { |s| s == '' }\n  words.delete_if { |s| s.start_with?(',') }\n  words.delete_if\
    \ { |s| s.include?(\",\") }\n  words.delete_if { |s| s.upcase == 'A' || s.upcase\
    \ == 'B' || s.upcase == 'C' || s.upcase == 'D' || s.upcase == 'E' || s.upcase\
    \ == 'F' || s.upcase == 'G' || s.upcase == 'H' || s.upcase == 'I' || s.upcase\
    \ == 'J' || s.upcase == 'K' || s.upcase == 'L' || s.upcase == 'M' || s.upcase\
    \ == 'N' || s.upcase == 'O' || s.upcase == 'P' || s.upcase == 'Q' || s.upcase\
    \ == 'R' || s.upcase == 'S' || s.upcase == 'T' || s.upcase == 'U' || s.upcase\
    \ == 'V' || s.upcase == 'W' || s.upcase == 'X' || s.upcase == 'Y' || s.upcase\
    \ == 'Z' }\n  words.count { |s| s.include?(\",\") }\nend", "    words = txt.split('\
    \ ')\n    odd_letters = txt.chars.with_index.with_object([])", "  return txt.split.map\
    \ {|i| i}.join(', ').scan(/./).reject(&:empty?).uniq.sort {|a,b| a.length <=>\
    \ b.length }.reverse\nend", "  txt.split(/ +/)\nend", "  return txt.split(' ')\
    \ unless txt.empty?\n  return 0 if txt.chars.uniq.size == 1\n  txt.chars.uniq.sort.each_with_index\
    \ { |letter, index|\n    return 0 if letter >= 'a' and letter <= 'z'\n    return\
    \ 1 if letter >= 'A' and letter <= 'Z'\n    return 2 if letter >= '0' and letter\
    \ <= '9'\n  }\n  raise \"Invalid word count #{txt.chars.uniq.size}\"\nend\n</code>\n\
    Here we see that we can also use the split method on a String and have it split\
    \ on multiple characters, so the following will split on both, whitespace and\
    \ commas\n<code>\n'Hello world!'.split(' ,')\n</code>\nWe need to make some adjustments\
    \ to the code in the question. First, we need to split the text to an array of\
    \ Strings, one for each word. This can be accomplished using the split method\
    \ on String\n<code>\ntxt.split(' ')\n</code>\nThen, we can check each of those\
    \ words to make sure it is all lower case letters. We can do that by getting the\
    \ ascii value of the character in question using the chars method, which will\
    \ give us the character array, which we can then get the uniq method on, which\
    \ will get us an array of unique characters.\n<code>\ntxt.chars.uniq.sort.each_with_index\
    \ { |letter, index|\n  case letter\n  when 'a'..'z'\n    return 0 if index ==\
    \ 0\n  when 'A'..'Z'\n    return 1 if index == 0\n  when '0'..'9'\n    return\
    \ 2 if index == 0\n  end\n}\n</code>\nThat last bit of code is probably a bit\
    \ confusing, but I tried to explain it best. First, I check if the current letter\
    \ is a lower case letter, and then check what number that letter is in. Since\
    \ letters count in order, we can just check those letters for which letters are\
    \ the first (index 0) letter in each word. If those letters are the letters in\
    \ the word and are in the correct order, we can return 0. If they are in the wrong\
    \ order, or not in the word, then we can return 1 or 2.\n<code>\ntxt.chars.uniq.sort.each_with_index\
    \ { |letter, index|\n  return 0 if letter >= 'a' and letter <= 'z'\n  return 1\
    \ if letter >= 'A' and letter <= 'Z'\n  return 2 if letter >= '0' and letter <=\
    \ '9'\n}\n</code>\nSo let's break it down a bit more. We start with the txt.chars.uniq.sort\
    \ method, which will give us the unique characters in our String. We then use\
    \ the each_with_index ", "  words = txt.split\n  words.length ? (words[0..-2]\
    \ + [words.last][0..-2] + words.last.split(',')[0..-2]) : (words.split(',').map\
    \ { |w| w.length % 2 == 0 ? (w.to_s + w.to_s.reverse) : 'a,' + w })\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nIt's not my homework, I'm doing a project\
    \ for my CS final project and I need this in Ruby.\n<|/ c |>\n<| c |>\nYou can\
    \ take what you've got, and do some Ruby magic to make it work. Don't forget to\
    \ accept an answer if you think it has helped you!\n<|/ c |>\n<| a dscore=1 tags=ruby\
    \ |>\nHere's a solution in Ruby, using regular expressions:\n<code>\nwords = %w[a\
    \ b c d e f g].map do |w|\n  w = w.gsub(/[^a-zA-Z]/, ' ').strip\n  w =~ /^([a-z])\\\
    1/ ? [w.to_s.reverse].join : w\nend", "  words = txt.split(\" \") # split(\" \"\
    ) splits on any whitespace.\n  return words if words.size != 0 && !words.empty?\
    \ # If the array is empty we should return an empty array.\n  words.length <=\
    \ 1 && words.inject(0) do |num_words, word|\n    word_letters = word.chars.to_a.size\
    \ # Get an array of all letters in the word so we can count how often they are\
    \ in alphabetical order.\n    if word_letters > num_words # If the word is bigger\
    \ than the previous words we increment the number of words by 1.\n      num_words\
    \ += 1 # We increment the variable by one because we do not want to count the\
    \ initial word \"Hello\".\n    end\n    word_letters\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis would work great if I was trying to find the number\
    \ of letters in the string, but I need to find the number of lower-case letters\
    \ in the string. Thanks for your help!\n<|/ c |>\n<| c |>\nSorry I missed that.\
    \ I've updated my answer with the solution for your problem.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,split |>\n<code>\n\"Hello world\".split.map(&:downcase).inject(0)\
    \ { |total, x| total + x.size}", "  word_list = txt.split(/\\s+/)\n  return word_list.empty?\
    \ ? word_list.join(\",\") : word_list\nend", "    txt.split(//)\nend", "    words\
    \ = txt.split(' ')\n    return words if words.count != words.join.length \n  \
    \      words.length\n        words.join.split(//)\n        words.join.split(',')\n\
    end", "  txt = txt.split(\"\\n\")\n  txt.each do |word|\n    word.gsub!(/\\s+/,\
    \ \"\") # remove all whitespace if any\n    word.gsub!(/,/, \"|\") # replace commas\
    \ with pipe delimiters if any\n  end\n  txt = txt.map{|word| word.downcase.gsub(/[a-b]/,\
    \ ord('A')..ord('Z').to_a).join}\n  return txt.length if txt.length.even?\n  txt\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby |>\nYou don't need to\
    \ split the string twice:\n<code>", "  if txt.strip.empty?\n    []\n  else\n \
    \   words = txt.split.map(&:strip)\n    words.flatten.map(&:downcase).each_cons(2).sum\
    \ do |a, b|\n      a + b.index(b.first).nonzero? || a.index(b.last).nonzero?\n\
    \    end\n  end\nend", "  words = txt.split.to_a\n  words.compact.each do |word|\n\
    \    word.gsub!(/[,.!]/, \"\")\n  end\n  words.uniq.count\nend", "  txt.scan(/[a-z]+/).collect\
    \ do |word|\n    word.present? ? word : ','\n  end\nend", "  txt.downcase!\n \
    \ word_list = [txt]\n  while txt.length > 0\n    if txt =~ /[a-z]/i\n      txt.slice!(0,1)\n\
    \      word_list << txt\n    elsif txt =~ /[a-z]\\z/i\n      txt.slice!(0,-1)\n\
    \      word_list << txt\n    else\n      word_list << txt.slice!(0,2)\n    end\n\
    \  end\n  return word_list\nend\n</cell>\n<cell>\nsplit_words.call('Hello world!')\n\
    </cell>\n<cell>\nsplit_words.call('Hello,world!')\n</cell>\n<cell>\nsplit_words.call('abcdef')\n\
    </cell>\n<cell>\nsplit_words.call('abcdefg')\n</cell>\n<cell>\nsplit_words.call('abcd,efgh')\n\
    </cell>\n<cell>\nsplit_words.call('abcd,efghi')\n</cell>\n<cell>\nsplit_words.call('')\n\
    </cell>\n<cell>\nsplit_words.call(' ')\n</cell>\n<cell>\nsplit_words.call('Hello')\n\
    </cell>\n<cell>\nsplit_words.call('Hello ')\n</cell>\n<cell>\nsplit_words.call('\
    \ Hello ')\n</cell>\n<cell>\nsplit_words.call(' Hello ,world!')\n</cell>\n<cell>\n\
    split_words.call(' Hello ,world! ')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world!\
    \ ')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world! ,')\n</cell>\n<cell>\n\
    split_words.call(' Hello,,world! ,d')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world!\
    \ ,d')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world! ,d')\n</cell>\n<cell>\n\
    split_words.call(' Hello,,world! ,d')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world!\
    \ ,d')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world! ,d')\n</cell>\n<cell>\n\
    split_words.call(' Hello,,world! ,d')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world!\
    \ ,d')\n</cell>\n<cell>\nsplit_words.call(' Hello,,world! ,d')\n</cell>\n<cell>\n\
    split_words.call(' ", "  words = txt.split(\" \") # splits words into an array\n\
    \  words.delete_if{ |word| word == \"\" }\n  if words.empty? # returns empty string\
    \ if all words empty\n    return []\n  else # returns only words that are not\
    \ empty\n    words.delete_if{ |word| word == \",\" }\n    words.delete_if{ |word|\
    \ word == \"-\" }\n    words.delete_if{ |word| word == \".\" }\n    words.delete_if{\
    \ |word| word == \"!\" }\n    words.delete_if{ |word| word == \"?\" }\n    words.delete_if{\
    \ |word| word == \"'\" }\n    words.delete_if{ |word| word == \".\" }\n    words.delete_if{\
    \ |word| word == \"-\" }\n    words.delete_if{ |word| word == \"/\" }\n    words.delete_if{\
    \ |word| word == \"\\\\\" }\n    words.delete_if{ |word| word == \"#\" }\n   \
    \ words.delete_if{ |word| word == \"@\" }\n    words.delete_if{ |word| word ==\
    \ \"$\" }\n    words.delete_if{ |word| word == \"%\" }\n    words.delete_if{ |word|\
    \ word == \"^\" }\n    words.delete_if{ |word| word == \"&\" }\n    words.delete_if{\
    \ |word| word == \"*\" }\n    words.delete_if{ |word| word == \"(\" }\n    words.delete_if{\
    \ |word| word == \")\" }\n    words.delete_if{ |word| word == \"|\" }\n    words.delete_if{\
    \ |word| word == \"~\" }\n    words.delete_if{ |word| word == \":\" }\n    words.delete_if{\
    \ |word| word == \"?\" }\n    words.delete_if{ |word| word == \"!\" }\n    words.delete_if{\
    \ |word| word == \"<\" }\n    words.delete_if{ |word| word == \">\" }\n    words.delete_if{\
    \ |word| word == \"'\" }\n    words.delete_if{ |word| word == \"'\" }\n    words.delete_if{\
    \ |word| word == \"|\" }\n    words.delete_if{ |word| word == \"}\" }\n    words.delete_if{\
    \ |word| word == \"[\" }\n    words.delete_if{ |word| word == \"]\" }\n    words.delete_if{\
    \ |word| word == \"}\" }\n    words.delete_if{ |word| word == \"%\" }\n    words.delete_if{\
    \ |word| word == \"^\" }\n    words.delete_", "  words = txt.split(',')\n  words[0]\
    \ = words[0][0].downcase\n  if words.count == 1\n    words = words[0]\n  words.drop(1)\n\
    \  words.map!{|w| w.strip.downcase}\n  return words\nend", "  words = []\n  word\
    \ = \"\"\n  splits = 0\n  \n  # Split the string into words using \\s character\
    \ class (any white space)\n  txt_split = txt.split(/\\s/)\n  \n  # Iterate through\
    \ all the words in the text\n  txt_split.each do |word|\n    # Add the word if\
    \ it doesn't exist in the words array already\n    words << word unless words.include?\
    \ word\n    \n    # Check to see if the word has two letters or more, if so split\
    \ it, otherwise add it to the words array unchanged\n    word = word.split('')\n\
    \    \n    # If a word has two letters, add it to the words array with the first\
    \ letter of the word capitalized\n    if word.length == 2\n      words << word[0].capitalize\
    \ << word[1]\n    else\n      words << word.join(' ')\n    end\n  end\n  \n  #\
    \ Return the number of unique words we found and split the text into words\n \
    \ return words.length, words\nend", "  words = txt.split\n  return words if txt.split.blank?\
    \ else words.gsub!(\"[\\\\s,]+\", \",\")\nend\n</code>\n3. Write a method that\
    \ takes a string and returns the number of characters in the string in lower-case\
    \ letters with odd order in the alphabet.\n<code>", "    words = txt.split.to_s\n\
    \    words = words.split(\",\")\n    words = words.map(&:downcase)\n    words\
    \ = words.select { |word| !word.empty? }\n    words = words.select { |word| word.include?(\"\
    \ \") }\n    words = words.select { |word| word.length % 2 != 0 }\n    words.count\n\
    end", "  a = txt.split\n  (a.size==0)? a.call : a\nend", "    words = txt.split('\
    \ ')\n    words.pop() if words.empty? \n    words.uniq!\n    words.map! {|word|\
    \ word.downcase}\n    words.select {|word| word =~ /^[a-z]/}.count\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,regex |>\nI haven't done a lot of Ruby but here is an\
    \ idea to solve this.\nI assume that in ruby there is a method called String.split.\
    \ \nWhat you can do is\n<code>\nstring.split(' ') //Split on space\n</code>\n\
    And then you can take out all the white spaces \n<code>\nstring.split(' ').map!\
    \ &:strip\n</code>\nAnd now you have an Array of words in which you can use the\
    \ filter method on it to remove all the non alphabetic characters from it \n<code>\n\
    string.split(' ').map! &:strip\nstring.split(' ').filter { |w| !w.match(/[a-z]/)\
    \ }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nAvoid `&:strip` it can be replaced with\
    \ `&:strip!`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  txt.downcase!\n  words\
    \ = txt.split(/\\W+/)\n  if txt.include?(\" \") && words.size > 1\n    words.delete_at(words.size\
    \ - 1)\n  else\n    words.delete_at(words.size - 2)\n  end\n  words.delete_at(words.size\
    \ - 1)\n  return words\nend", "  words = txt.split(' ')\n  words[1, words.size]\
    \ = [words[1, words.size].join('')]\n  return words\nend", "\ttxt = txt.downcase\n\
    \twords = txt.split(' ')\n\twords.reject { |word| word.empty? }\n\twords.reject\
    \ { |word| word =~ /\\s/ }\n\twords.count { |word| word.start_with?('a') && (word\
    \ =~ /[ab]/) ? word.size % 2 : 1 }\nend", "  txt.split(//).map(&:strip)\nend",
  "  # TODO: Write your code here\n  return txt.scan(/[[:alpha:]]/).reduce(:+).to_a.uniq.sort_by\
    \ { |w| w.ord.to_s }\nend", "  txt.split(\" \") # Split on spaces first\n    .map\
    \ { |w| w.split(\",\") # Split on commas\n        .map { |w| w.split(\".\") #\
    \ Split on periods\n            .map { |w| w.split(\"!\") # Split on exclamation\
    \ points\n                .map { |w| w.split(\"?\") # Split on question marks\n\
    \                    .map { |w| w.split('\"') # Split on double quotes\n     \
    \                 .map { |w| w.gsub(/[^a-z]/, '') } # Remove all non letters from\
    \ words\n                      .sort { |a, b| b.length <=> a.length } # Sort words\
    \ by length\n                    } # Sort each word lexicographically\n      \
    \            } # Sort each word lexicographically\n              } # Sort each\
    \ word lexicographically\n          } # Sort each word lexicographically\n   \
    \   } # Sort each word lexicographically\n    } # Sort each word lexicographically\n\
    \    .each { |w| w.downcase! # Make all words lower case\n    } # Make all words\
    \ lower case\n    .sort { |a, b| a.length <=> b.length } # Sort words by length\n\
    end", "  if txt.empty?\n    []\n  elsif txt.include?(',')\n    txt.split(',')\n\
    \  elsif txt.include?(' ')\n    txt.split(' ')\n  else\n    letters = txt.chars.map(&:ord).sort.map\
    \ { |x| x % 26 }\n    letters.select { |x| x % 2 != 0 }\n  end\nend", "  return\
    \ txt.split(/\\s+/) unless txt.include?(' ')\n  txt.split(',').map(&:downcase).count('a')\
    \ % 2 == 0 ? (txt.split(',').map(&:downcase).count('a') + 1) : (txt.split(',').map(&:downcase).count('b')\
    \ + (txt.split(',').map(&:downcase).count('z') - txt.split(',').map(&:downcase).count('a')))\n\
    end", "  if txt.split.empty?\n    txt.split.to_s.split.map{|x| x.strip}.uniq.map{|x|\
    \ x.downcase}.reduce(0,:+).odd?\n  else\n    txt.split.to_s.split.map{|x| x.strip}.uniq.map{|x|\
    \ x.downcase}.reduce(:+).odd?\n  end\nend", "  txt.split.to_s\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby dscore=3 |>\n<code>\nputs str.split(\"\").uniq.sort.map(&:ord).map(&:chr).join(\"\
    \\n\")\n</code>\n<|/ a |>\n<| a dscore=3 |>\nA slight variation on James Carpenter,\
    \ that doesn't sort the characters but is slightly faster since it only sorts\
    \ the letters once (at the start of the program).\n<code>", "  words = txt.split('\
    \ ')\n  words.join(',')\nend", "    words = txt.split(\" \")\n    split_words\
    \ = words.clone\n    split_words[0] = split_words[0].strip\n    if words.size\
    \ != split_words.size - 1 then\n        split_words[split_words.size - 1] = split_words[split_words.size\
    \ - 1].strip\n    end\n    split_words.reverse!\n    split_words.select! {|s|\
    \ s.empty? }\n    split_words[split_words.find_index {|s| !s.empty? }] += 1\n\
    \    split_words.uniq!\n    return split_words[0...-1] if split_words.size % 2\
    \ == 1\n    return split_words[0...split_words.size % 2]\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "  words = txt.split(' ')\n  words.delete('')\n\
    \  return words\nend", "    words = txt.split.map(&:downcase)\n    words.compact!\n\
    \    return words.length.even? ? words : words.map(&:split(\",\").map(&:downcase).uniq)\n\
    end", "  \n  words = txt.split(//)\n  \n  word.each_with_index do |word, index|\n\
    \    word.downcase!\n    if word == nil\n      words[index] = nil\n    elsif word\
    \ != word.to_s\n      words[index] = word\n    end\n  end\n  \n  words.compact!\n\
    \  \n  return words.length\nend", "  words = txt.split(//, 2)\n  words = words.inject([])\
    \ {|arr,str| arr << str }.uniq.map { |word| word[0].chr.downcase + word[1..-1]\
    \ }\n  return words.length if words.length < txt.length\n  words.reverse.length\n\
    end", "  words = txt.split(' ')\n  words.count { |word| word.match(/[a-z]/i) }\n\
    end", "  txt.split(\"\\s+\").map {|w| w.split(\",\").map {|s| s.downcase}.flatten}\n\
    end", "  txt.gsub(/(\\s)|(,)/, ' ').downcase.split(' ').select { |w| w =~ /[A-Za-z]/i\
    \ }.count\nend", "  words = txt.split(' ')\n  words.map do |word|\n    word.empty?\
    \ ? word : word.gsub(/[^a-z0-9]/, \"\")\n  end\nend", "  result = \"\"\n  words\
    \ = txt.split(' ')\n  words[1..-1].each do |word|\n    result << \"#{word}, \"\
    \n  end\n  return result.chop if result =~ /,/\n  return result.count.to_i\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\n`chop` would be better, since `chop!` would\
    \ mutate the string.\n<|/ c |>\n<| a tags=ruby |>\nI did this:\n<code>", "  words\
    \ = txt.split(' ')\n  if words.include?(\",\")\n    words = words.join(',')\n\
    \  else\n    words = words.join('')\n  end\n  \n  words = words.split('')\n  \n\
    \  words.select!{|x| x.downcase > 'z'}\n  words.select!{|x| x.downcase < 'a'}\n\
    \  \n  return words.count('a') + words.count('b')\nend", "  return txt.split(/[,|\\\
    s+]/).size % 2 ? txt.split(/[,|\\s+]/) : txt.split(/[,|\\s+]/).size - 1\nend",
  "  txt.split(/,|\\s+/)\nend", "  if txt.strip =~ /\\s/\n    # split on whitespace\
    \ if no whitespace exists in the txt\n    txt.split(\" \").collect {|x| x.downcase}\n\
    \  elsif txt.strip =~ /,/\n    # split on commas if no commas exists in the txt\n\
    \    txt.split(\",\").collect {|x| x.downcase}\n  else\n    # split on lower-case\
    \ letters with odd order in the alphabet\n    txt.downcase.split(//).collect {|x|\
    \ x.to_i % 2 == 1 ? (\"#{x}\") : x.chr}.length.to_i\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,nokogiri |>\n<| c |>\nthanks , can you please explain\
    \ me this `txt.downcase.split(//).collect {|x| x.to_i % 2 == 1 ? (\"#{x}\") :\
    \ x.chr}.length.to_i`\n<|/ c |>\n<| c |>\n`txt.downcase.split(//)` splits the\
    \ string into words based on the whitespace.\n<|/ c |>\n<| c |>\nIf it helps you\
    \ understand how it works `txt.downcase.split(//).collect {|x| x.to_i % 2 == 1\
    \ ? (\"#{x}\") : x.chr}.length.to_i` will first convert the input into an array\
    \ of strings, then split these strings at whitespace and each word is then converted\
    \ into a boolean by doing `to_i % 2 == 1` and if it returns `true` then append\
    \ the word into a new string. Finally we get the length of this new string and\
    \ convert it into `int`.\n<|/ c |>\n<| a |>\nFirst of all, you should probably\
    \ look into using something like Nokogiri if you're going to be parsing HTML.\
    \ \nBut to your question, your approach of looping over the entire document seems\
    \ like a good one. But instead of doing it in the view I would recommend doing\
    \ it in the controller and returning a hash with your words as keys and the count\
    \ of how many times it shows up as a value with each key being the word you're\
    \ counting. It would look something like this:\n<code>", "  return txt if txt.empty?\
    \ || (txt.split(\" \").length == 1) || (txt.split(\",\").length == 1) || (txt.split(\"\
    \ \").length + txt.split(\",\").length == 1) else (txt.split(\" \").length + txt.split(\"\
    ,\").length) - (txt.split(\",\").length * txt.split(\" \").length)\nend", "  result\
    \ = []\n  txt.split(\" \").each do |word|\n    result += [word] if word.include?(\"\
    ,\")\n    result += [word] if word.include?(\",\")\n    result += [word] if word.include?(\"\
    ,\")\n  end\n  result.sort!", "  txt = txt.split(\" \") unless txt == \"\"\n \
    \ txt.collect{|word| word if word !~ /[a-zA-Z0-9]/}.count{|word| word > 0 ? true\
    \ : false}\nend", "\ttxt.gsub(/\\s+/, ' ').gsub(/([^A-Za-z])([A-Z])/, '\\1\\2').gsub(/([A-Za-z])([^A-Z])/,\
    \ '\\1\\2').gsub(/([A-Z])([A-Z])/, '\\1\\2').split.size\nend", "  return txt.split('\
    \ ').map(&:downcase).reject(&:empty?)\nend", "  words = txt.downcase.split\n \
    \ words.delete_if do |word|\n    word.include?(' ')\n  end\n  words.delete_if\
    \ do |word|\n    word.include?(',')\n  end\n  words.delete_if do |word|\n    word.include?('a')\n\
    \  end\n  words.delete_if do |word|\n    word.include?('z')\n  end\n  words.count\n\
    end", "    \n    letters = Array.new\n    array = txt.split(' ')\n    \n    array.each\
    \ do |word|\n        if word.include? ','\n            letters << word\n     \
    \   else\n            letters << word.split(',').count\n        end\n    end\n\
    \    \n    letters.sort.last.odd? ? letters.count : letters.last\nend\n</cell>\n\
    <text>\nProblem 2\nUse a regular expression to identify and remove any instances\
    \ of non-alphanumeric characters from each word in the text of test strings in\
    \ Problem 1.", "  words = []\n  text = txt.downcase\n  \n  # Find out how many\
    \ commas\n  if text.count(\",\") > 0\n    comma = text.index(\",\")\n  else\n\
    \    comma = text.size\n  end\n  \n  char_count = text.size\n  \n  # Find out\
    \ how many lower-case letters\n  if char_count\n    lower = char_count.downto(0)\n\
    \  else\n    lower = 0\n  end\n  \n  # Get the odd number of lower-case letters\n\
    \  odd_count = lower - odd_count(lower)\n  \n  words.concat(text.split)\n  \n\
    \  if comma\n    words.concat(text.split(\",\") + text.split(\",\").map{|w| w.strip}).take(comma)\n\
    \  else\n    words.concat(text.split).take(lower)\n  end\n  \n  if odd_count\n\
    \    words.concat(text.split.map{|w| w.downcase})\n  end\n  \n  words\nend", " \
    \ word = txt.split(/\\s+/)\n  return word if word.empty? || word.count { |word|\
    \ word =~ /\\s/ }.zero? ? 0 : word.count { |word| word =~ /[a-z]/ } % 2 == 1 ?\
    \ word.select { |word| word =~ /[a-z]/} : word.count { |word| word =~ /[a-z]/}\
    \ + 1 end\nend", "  txt.split(\" \") || [txt, txt.split(\",\")]\nend", "  new_words\
    \ = nil\n  if txt.length > 0\n    if txt.scan(/\\s{2,}/).count > 0\n      new_words\
    \ = txt.scan(/[a-z]|\\s/)\n      new_words.flatten!\n    else\n      new_words\
    \ = txt.scan(/[a-z]/)\n      new_words.flatten!\n    end\n  end\n  return new_words\n\
    end", "  words = txt.split\n  return words.call(/,/) if words && words.length\n\
    \  words.call([ :upcase, :downcase ].compact.uniq)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,string,split\
    \ dscore=2 |>\n<| c |>\nYour first solution gives me the error:", "  return split(txt.strip)\
    \ unless txt.strip.empty?\n  comma_count = txt.scan(/,/).size\n  space_count =\
    \ txt.scan(/\\s+/).size\n  space_count = txt.scan(/\\s+/).size if space_count\
    \ < comma_count\n  txt.scan(/[a-z]/i).size - 1 if space_count > comma_count\n\
    end", "    words = txt.split(\" \")\n    return words\nend", "    chars = string.split(txt,\
    \ \" \")\n    \n    if chars == nil or chars.length == 0\n        puts \"Please\
    \ enter some text!\"\n        return nil\n    end", "  # Write your solution here\n\
    \  return txt.count(\",\".to_sym) if txt.include?(\",\".to_sym)\n  txt.downcase.split(\"\
    \ \").count(\"a\".ord) - txt.count(\"a\".ord).to_i\nend", "  words = txt.split(\"\
    \ \").map{|x| x.split(\",\")}\n  words.flatten!\n  words.map!{|x| x.select{|w|\
    \ w != \"\" }}\n  words.compact!\n  words.map!{|w| w.select{|w| w.size == w.to_s.length}}\n\
    \  words.flatten!\n  words.map!{|w| w[w.length - 1]}\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThe answer here uses Ruby 2.4, but that's an outdated version of Ruby\
    \ nowadays. I'd suggest to use the latest version (2.5.x), and use [`slice_before`](http://ruby-doc.org/core-2.5.1/String.html#method-i-slice_before)\
    \ or [`slice_after`](http://ruby-doc.org/core-2.5.1/String.html#method-i-slice_after)\
    \ to achieve the same results.\n<|/ c |>\n<| a |>\nUsing only regular expression\
    \ (without Ruby's enumerable methods, like map, each etc.):\n<code>", "  txt =\
    \ txt.split.join(\"\") # change to join method\n  words = txt.split(/[\\s,\\.]/)\n\
    \  if words.empty?\n    words\n  else\n    words.map! { |word| word.strip }\n\
    \  end\nend", "  return txt.split(' ').join(',') if txt.include?(' ') && txt.split('\
    \ ').join(',').split('').map(&:downcase).count(&:odd).zero? else txt.split(',').map(&:downcase).count\n\
    end", "  # Remove whitespaces and commas\n  words = txt.gsub(/[,!\\s]+/, \"\"\
    ).downcase\n  # Count occurence of lowercase\n  counts = words.scan(/[a-z]+/).flatten\n\
    \  \n  return counts[1] if counts[1] % 2 == 1 \n  \nend\n</code>\nNow we create\
    \ a helper function which will return the index of the word we want, and we can\
    \ test this against the count of the word in our wordlist, which contains all\
    \ our words\n<code>", "  words =[]\n  word = nil\n  splitted = false\n  txt.downcase!",
  "  txt = txt.downcase\n  words = txt.split(' ')\n  words.delete_if {|s| s.strip.empty?}\n\
    \  words.delete_if {|s| s.strip.length < 1}\n  words.delete_if {|s| s.split(',').length\
    \ < 1}\n  return words.count {|s| s.strip.length < 2 }\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThe test `words.delete_if {|s| s.strip.length < 1}` is redundant, since\
    \ `strip` will already remove any empty strings. `words.count{|s| s.strip.length\
    \ < 2}` has the same effect, but since `delete` removes all matching elements,\
    \ it can be shortened to `words.count{|s| s.strip.length % 2 == 1}`.\n<|/ c |>\n\
    <| c |>\nYou're right. I'm still a newbie. Thank you for pointing that out.\n\
    <|/ c |>\n<| a dscore=0 |>\nA Ruby version of the Kata problem #1 is:\n<code>",
  "  txt.split.to_a\nend", "  result = []\n  tmp = ''\n  words.each do |word|\n  \
    \  if word.include?(',')\n      result += word.split(\", \")\n      next\n   \
    \ end", "  return txt.split(' ').map do |word|\n    word.ljust(26)\n  end.reject\
    \ do |word|\n    word.include?(',')\n  end\nend", "  arr = txt.split(' ')\n  arr.each\
    \ do |word|\n    word.gsub!(',', '') unless word.length == 0\n  end\n  arr.each\
    \ do |word|\n    if word.chars.uniq.count > 26\n      word.length = 26 - word.chars.uniq.count\n\
    \    end\n  end\n  return arr\nend", "  txt.downcase!\n  words = txt.split(' ')\n\
    \  words = words.reject { |word| word =~ /\\A[!,.;:?]+\\Z/ } if words.present?\n\
    \  words.present? ? words.split(',') : nil\nend", "  # Split words on whitespace\
    \ and commas (',')\n  words = txt.split(' , ')\n  # If commas (',') exists in\
    \ the text, split on commas\n  if /,/ in txt\n    words = txt.split(',')\n  else\n\
    \    words = txt.split(' ')\n  end\n  \n  # Return the number of words that contains\
    \ all lowercase letters.\n  # Example: \n  # >>> split_words.call(\"Hello world!\"\
    )\n  # 3\n  # >>> split_words.call(\"Hello, world!\")\n  # 2\n  # >>> split_words.call(\"\
    abcdef\")\n  # 3\n  words.select{|word| word.downcase.count ('a'..'z').odd? }.size\n\
    end", "  words = txt.downcase.split(' ')\n  if words.length != 0 && !(words.length\
    \ == 1 && (words[0].length == 0 ||\n    words[0].length == 1 && (words[0][0].ord\
    \ < ord('a') || ord('z') < words[0][0].ord)))\n    words = words.join(', ')\n\
    \  end\n  return words\nend", "  words = txt.split(\" \").map(&:strip)\n  words.delete_if\
    \ { |word| word.blank? }\n  words.delete_if { |word| word == \"nil\" }\n  words.delete_if\
    \ { |word| word.include?(\",\") }\n  words.delete_if { |word| word.include?(\"\
    .\") }\n  words.delete_if { |word| word.downcase =~ /[a-z]/i }\n  words.delete_if\
    \ { |word| word.downcase =~ /[A-Z]/i }\n  words.delete_if { |word| word.downcase\
    \ =~ /\\d+/i }\n  words.count\nend\n</code>\n<|/ a tags=ruby,arrays,loops |>\n\
    <| c |>\nThank you so much ! I have learned a lot from your code. Also thanks\
    \ for the other suggestions. I appreciate it!\n<|/ c |>\n<| a tags=ruby,arrays,loops\
    \ dscore=0 |>\nIt looks like the question requires us to count the number of letters\
    \ used in a text, and I assume that the text has non-alphanumeric characters like\
    \ periods or commas present (and possibly spaces/tabs). The following code does\
    \ that for you:\n<code>\ntext = \"A. B. C.,D. E. F., G. H. I. J.,K. L. M.\"\n\
    text.gsub(/[^a-zA-Z ]/, '').gsub(/ /, '').tr(\" \", \"  \").tr(\",\", \"\\n\"\
    ).count(\"\\n\")\n</code>\nThe first gsub turns text into one string with only\
    \ alphanumeric characters. The second gsub removes any spaces and commas, and\
    \ the third gsub replaces spaces with two spaces, and commas with newlines.\n\
    The third gsub replaces all newlines with spaces. The last gsub counts the number\
    \ of spaces.\n<|/ a |>\n<| c |>\nThis assumes that the input has any amount of\
    \ spaces or other whitespace characters.\n<|/ c |>\n<| a tags=ruby,arrays,loops\
    \ |>\nI guess you are new to ruby. Don't be discouraged by the length of the answers\
    \ given already. There are many ways to do this. This answer might help.\n<code>",
  "  txt = txt.downcase\n  if txt.length == 0 || txt.include?(\" \")\n    txt = txt.strip.downcase\n\
    \    txt = txt.gsub(/[,\\s]+/,\" \")\n    txt = txt.split(\"\\\\s+\")\n  end",
  "    words = []\n    words = txt.split(\" \") unless txt.include?(' ')\n    words\
    \ = words.join(\",\") unless words.include?(',')\n    \n    if words.include?(\"\
    ,\")\n        words = words.split(\",\")\n        words.delete_if {|item| item.empty?}\n\
    \    end\n    \n    words.length\nend", "  words = txt.split.to_a\n  return words.size>1\
    \ ? words : words.first ? words.first.split.to_a : 1\nend", "  s = ''\n  words\
    \ = txt.split(' ')\n  words.each do |word|\n    word = word.downcase\n    s <<\
    \ word\n  end", "  splitted = []\n  words = txt.split(\"\\n\")\n  words.each do\
    \ |word|\n    splitted << word.split(' ')\n  end\n  splitted.flatten\nend", " \
    \ arr = txt.split(/\\W+/)\n  if arr.blank?\n    arr.push(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    arr.delete_if { |x| x == ',' }\n    arr.delete_if { |x| x == '.' }\n  \
    \  arr.delete_if { |x| x == '!' }\n    arr.delete_if { |x| x == '?' }\n    arr.delete_if\
    \ { |x| x == '\\'' }\n    arr.delete_if { |x| x == '!' }\n    arr.delete_if {\
    \ |x| x == '?' }\n    arr.delete_if { |x| x == '.' }\n    arr.delete_if { |x|\
    \ x == '\\'' }\n  end\n  return arr\nend", "  txt.chars.map.with_index.select{|c,i|\
    \ c.to_i %2 == 1}.sort{|a,b| b.ord.chr -a.ord.chr}.uniq.compact\nend\n</code>\n\
    I hope this helps you understand what I am trying to do!\n<|/ a tags=ruby |>\n\
    <| c |>\nAwesome answer! Although it does require the OP to reinvent a lot of\
    \ their own methods/libraries, I like it. I think it could be improved by adding\
    \ `.map` to `split`. That would allow `split_words` to take an optional argument,\
    \ like `split_words(txt, sep: ',')`.\n<|/ c |>\n<| c |>\nThanks for your input!\
    \ I definitely think your method is more elegant. I've changed my example and\
    \ used `.chars.map.with_index.select{|c,i| c.to_i %2 == 1}.sort{|a,b| b.ord.chr\
    \ -a.ord.chr}.uniq.compact`\n<|/ c |>\n<| a dscore=0 |>\nAnother option:\n<code>",
  "  txt.scan(/./)\n  return txt.split(' ') if txt.include?(' ') \n  txt.scan(/./).count{|x|\
    \ x.downcase > 'a'}\nend\n</cell>\n<cell>\nsplit_words.call(\"Hello world!\")\n\
    </cell>\n<cell>\nsplit_words.call(\"Hello,world!\")\n</cell>\n<cell>\nsplit_words.call(\"\
    abcdef\")\n</cell>\n<text>\nRemoving a character from a string\nLet's make a function\
    \ that takes a string and removes a character from it.", "  words = txt.split(?!,\
    \ ?!)\n  words.inject('') do |m, w|\n    m.sub!(/\\W+/, \"#{w}\".downcase) if\
    \ w.downcase != ''\n    m\n  end\n  return words.size\nend", "  txt.scan(/[^,]+/).map\
    \ {|x| x.strip.split }\nend", "  return txt.split(\" \") unless txt.include?(',')\n\
    \  txt.split(',').count{|e| !e.strip.empty? }.odd? ? txt.split(',').count : txt.split('').map.with_index\
    \ { |e,i| e.size == 1 ? i.to_i : e.size }.max + 1\nend", "  words = txt.split(\"\
    \ \") # split on spaces\n  words.delete_if { |w| w !~ /[,\\.]/ } # remove split\
    \ words that dont have '.' or ','\n  words.delete_if { |w| w !~ /[']/ } # remove\
    \ split words that dont have '\n  return words.size if words.size == words.to_a.count\
    \ # return length if no commas, commas otherwise\n  return words.size + 1 # return\
    \ length if commas exist, number of lower case letters with odd order otherwise\n\
    end", "  txt.downcase!\n  txt.gsub!(/,/, '') if txt.include?(',')\n  txt.gsub!(/\\\
    s+/, ' ') if txt.include?(' ')\n  words = txt.split.map(&:downcase)\n  words.reduce(:+).to_i\n\
    end", "  words = txt.split() if txt.include?(',') ? txt.split(',') : txt.split().map\
    \ &:downcase\n  words.count { |word| word.include?(' ') } ? words : words.count{\
    \ |word| word.to_s.downcase.include?('z') ? word.to_s.downcase.count('z') : word.to_s.downcase.count('a')\
    \ }\nend", "  return txt.downcase.gsub(/\\W+/, '').split(',').length if txt =~\
    \ /\\S/\n  text.chars.to_a.group_by { |x| x.ord }.map { |x, arr| arr.size if arr.size\
    \ > 0 }.max || 0\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is a solution\
    \ that uses the Enumerator module to break down strings into words and then groups\
    \ the words according to their order:\n<code>", "  txt.split(//) do |s|\n    s.split(',').select\
    \ do |s| \n      s.strip.empty? || s.include?(' ')\n    end.count(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ).odd?\n  end\nend\n</code>\n<|/ a tags=arrays,ruby dscore=0 |>\n<| c |>\nThanks\
    \ for your response. Your solution works but it seems to me that the other solution\
    \ is better since it's more elegant and I don't need to reinvent the wheel.\n\
    <|/ c |>\n<| c |>\nyeah my bad, my solution was a bit more concise\n<|/ c |>\n\
    <| a |>\nIf by \"words\" you mean \"words with punctuation\" then this may do\
    \ the trick:\n<code>", "  txt.downcase!\n  split_words = txt.split.map do |word|\n\
    \    if word.length > 0\n      word\n    else\n      word.split(\",\")\n    end\n\
    \  end\n  split_words.flatten!\n  split_words.compact!\n  split_words.length\n\
    end", "  txt.split() if txt.count(' ') == 0 || txt.count(',') == 0\n  txt.split()\
    \ if txt.count(' ') == 1 || txt.count(',') == 1\n  txt.split() if txt.count('\
    \ ') == 2 || txt.count(',') == 2\n  txt.split() if txt.count(' ') == 3 || txt.count(',')\
    \ == 3\n  txt.split() if txt.count(' ') == 4 || txt.count(',') == 4\n  txt.split()\
    \ if txt.count(' ') == 5 || txt.count(',') == 5\n  txt.split() if txt.count('\
    \ ') == 6 || txt.count(',') == 6\n  txt.split() if txt.count(' ') == 7 || txt.count(',')\
    \ == 7\n  txt.split() if txt.count(' ') == 8 || txt.count(',') == 8\n  txt.split()\
    \ if txt.count(' ') == 9 || txt.count(',') == 9\n  txt.split() if txt.count('\
    \ ') == 10 || txt.count(',') == 10\n  txt.split() if txt.count(' ') == 11 || txt.count(',')\
    \ == 11\n  txt.split() if txt.count(' ') == 12 || txt.count(',') == 12\n  txt.split()\
    \ if txt.count(' ') == 13 || txt.count(',') == 13\n  txt.split() if txt.count('\
    \ ') == 14 || txt.count(',') == 14\n  txt.split() if txt.count(' ') == 15 || txt.count(',')\
    \ == 15\n  txt.split() if txt.count(' ') == 16 || txt.count(',') == 16\n  txt.split()\
    \ if txt.count(' ') == 17 || txt.count(',') == 17\n  txt.split() if txt.count('\
    \ ') == 18 || txt.count(',') == 18\n  txt.split() if txt.count(' ') == 19 || txt.count(',')\
    \ == 19\n  txt.split() if txt.count(' ') == 20 || txt.count(',') == 20\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby-on-rails,ruby |>\nThis is\
    \ a way to do this without using regex, and without having to specify the word\
    \ length for each word. I'm sure there's a better way, but it works for me on\
    \ ruby 2.5.1 :\n<code>", "  words = txt.split(' ')\n  return words.size > 1 ?\
    \ words : words.inject([], :<<)\nend", "  return txt.split(' ') if txt.present?\
    \ and txt.split?\n  txt.split(',') if txt.present? and txt.split?\n  txt.chars.count{\
    \ |c| c.downcase == c.downcase.ord }.odd?\nend", "  txt.scan(/\\w/).map { |w|\
    \ w.downcase.split }\nend\n</cell>\n<text>\nWrite a function which takes a string\
    \ of words, splits it at commas, then returns the number of words in your string\n\
    (including empty words).", "  return txt.split(/[,|\\s+]/).map(&:downcase)\nend\n\
    </code>\nFinally, here is the Ruby one-liner:\n<code>\n\"Hello,world!\".split.map\
    \ {|word| word.downcase}.reject {|word| word == ''}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nIt should be noted that in the code above, the argument to `reject` should\
    \ have been `&:downcase` instead, otherwise it will just be the string itself.\n\
    <|/ c |>\n<| c |>\nAlso note that splitting the string on `,` or `\\W` is _not_\
    \ the same as splitting on `\\s+`, which is the same as splitting on whitespace.\n\
    <|/ c |>\n<| c |>\nI like to use `!` instead of `!==`\n<|/ c |>\n<| c |>\nThe\
    \ '!' at the end isn't a typo, it's an idiom for \"negate\" and is commonly used\
    \ to indicate that `!expression` is true whereas `expression != true` is false\
    \ (it would be more idiomatic to use `!!expression`). The '!==' is a direct copy\
    \ from Ruby's '!' operator, where you can also negate it with '!==', but it is\
    \ typically reserved for strings and numbers, whereas '!' will work for booleans\
    \ and objects, whereas '!==' will work for numbers and booleans. In any case,\
    \ the '!' operator is more commonly used.\n<|/ c |>\n<| c |>\nYes, of course it\
    \ is. But `!` has a different semantics than `!=`. `!` doesn't do type conversions,\
    \ so if you compare against `false` (or anything truthy), you get the same result\
    \ as `!=` would. However, if you compare against anything that isn't false (e.g.\
    \ `nil`, `0`, `\"\"`), you get `!==`. And `!==` is much more common than `!=`,\
    \ so why not use `!==` instead of `!=`? It's a little less typing and less opaque\
    \ for Ruby newcomers.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  words = txt.split(\"\
    \ \") # Split the text on whitespace\n  words_without_whitespace = words.map {|w|\
    \ w.tr(\"a-z\", \" \") } # Remove all non alphanumeric characters \n  words_without_comma\
    \ = words_without_whitespace.map { |w| w.tr(\",\", \"\") } # Remove all commas\n\
    \  words_with_odd_order = words_without_comma.reduce(:+).to_s.length # Count each\
    \ letter with odd order in the alphabet\n  return words_with_odd_order\nend",
  "    split_words = txt.split(' ')\n    if split_words.length > 0\n    split_words.each\
    \ do |word|\n        split_words.delete(word)\n    end\n    split_words.join(',')\n\
    end", "  words = txt.split(/,|\\s+/)\n  words.delete_if { |w| w.empty? }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| w.include?(\",\") }\n  words.delete_if { |w| w.include?(\",\") }\n  words.delete_if\
    \ { |w| ", "  splits = txt.split(\" \").map{|word| word.split(',') }\n  splits\
    \ = splits.flatten.compact.count{|a| a.include?(ord('a'))}.odd?\n  splits = splits\
    \ ? splits : txt.length\n  txt.split(\",\").count{|word| word.include?(ord('a'))}.odd?\n\
    end", "  return txt.split(' ').map do |word|\n    word.count(',').zero? ? word\
    \ : word.count(',').zero? ? word.downcase : word.split.map(&:downcase).join\n\
    \  end\nend", "  txt = txt.split if txt.is_a? String else txt.to_s\n  words =\
    \ txt.split(nil) if txt.include?(' ')\n  words.select { |w| w =~ /^[a-z]+$/ &&\
    \ !w.include?(',') && !w.include?(' ') }.size\nend", "  return txt.split(' ')\n\
    end", "  return txt.split(' ').to_a + txt.scan(/[a-z]/).map(&:to_a).flatten.sort.take(txt.size)\n\
    end", "  return txt.split(/,/) if txt.include?(/\\s+/) \n  return txt.split(//).reject(&:empty?).count{|s|\
    \ s.size == 1}\nend", "  words = txt.split \" \"\n  if words.size == 1\n    words\
    \ = txt.split \",\"\n  end\n  words.map! { |w| w.downcase }\n  words.select {\
    \ |w| w =~ /[a-z]/i }\nend\n</code></pre>\n<p>Your task is to redefine the <code>count_words</code>\
    \ method to make it return an array with all the words and their\ncounts (like\
    \ in the previous challenges)</p>\n<pre class=\"ruby\"><code># Given a string\
    \ of words, return an array of word counts (like in the previous challenges)",
  "  words = txt.split\n  words.each do |word|\n    word.empty? ? word = word.split(',')\
    \ : word\n  end\nend\n</code>\nAs pointed out by others, your code is too much\
    \ repetition. I would suggest you use the following (I haven't tested it though):\n\
    <code>", "  words = txt.split(%r{\\s|,})\n  words.reject!{|e| e.empty?}\n  words.reject!{|e|\
    \ e.start_with?(\"&\")}\n  words.reject!{|e| e.start_with?(\";\")}\n  words.reject!{|e|\
    \ e.start_with?(\"?\")}\n  words.reject!{|e| e.start_with?(\"!\")}\n  words.reject!{|e|\
    \ e.start_with?(\":\")}\n  words.reject!{|e| e.start_with?(\"'\")}\n  words.reject!{|e|\
    \ e.start_with?(\"\\\\\")}\n  words.reject!{|e| e.start_with?(\"*\")}\n  words.reject!{|e|\
    \ e.start_with?(\"(\")}\n  words.reject!{|e| e.start_with?(\")\")}\n  words.reject!{|e|\
    \ e.start_with?(\"'\")}\n  words.reject!{|e| e.start_with?(\"'(\")}\n  words.reject!{|e|\
    \ e.start_with?(\"'&\")}\n  words.reject!{|e| e.start_with?(\"'?\")}\n  words.reject!{|e|\
    \ e.start_with?(\"'!\")}\n  words.reject!{|e| e.start_with?(\"'\\\\\")}\n  words.reject!{|e|\
    \ e.start_with?(\"'*\")}\n  words.reject!{|e| e.start_with?(\"*(\")}\n  words.reject!{|e|\
    \ e.start_with?(\"*&\")}\n  words.reject!{|e| e.start_with?(\"*?\")}\n  words.reject!{|e|\
    \ e.start_with?(\"*!\")}\n  words.reject!{|e| e.start_with?(\"'*\\\\\")}\n  words.reject!{|e|\
    \ e.start_with?(\"*(\")}\n  words.reject!{|e| e.start_with?(\"*&\")}\n  words.reject!{|e|\
    \ e.start_with?(\"*?\")}\n  words.reject!{|e| e.start_with?(\"*!\")}\n  words.reject!{|e|\
    \ e.start_with?(\"'(\")}\n  words.reject!{|e| e.start_with?(\"'&\")}\n  words.reject!{|e|\
    \ e.start_with?(\"", "  # Your code here\n  words = txt.split(' ')\n  new_words\
    \ = []\n  words.each do |word|\n    if word.include?(',')\n      new_words +=\
    \ word.split(', ')\n    else\n      new_words << word\n    end\n  end\n  new_words.map!{|word|\
    \ word.downcase.count(\"a\") % 2 == 1 ? word.downcase.chop.downcase : word.downcase\
    \ }\n  new_words.count\nend\n</cell>\n<code language=julia-0.5>", "  words = txt.split(\"\
    \\s\")\n  words.delete(\"\")\n  return words\nend", "  txt.split(\" \").each do\
    \ |word|\n    word == \"\" ? words : words.push(word)\n  end\n  words.count(\"\
    ,\")\nend", "  txt = txt.downcase\n  txt = txt.tr(\"!?\".to_a, \"-\")\n  txt =\
    \ txt.split(/\\W+/)\n  txt = txt.select {|x| x.length != 0}\n  txt.inject(0) {|sum,\
    \ word| sum + word.count}\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  words\
    \ = txt.split\n  words.each do |word|\n    word.gsub!(/\\s+/, \" \")\n  end\n\
    \  words.each do |word|\n    word.gsub!(/,/, \" \")\n  end\n  words.count('a')\n\
    end", "  result = []\n  txt.split.each do |word|\n    result += [word] if word.include?('\
    \ ')\n  end\n  result.uniq.uniq.uniq.uniq.uniq.uniq.uniq\nend", "  txt.split(\"\
    \ \").collect{|w| w.split(\",\").collect{|s| s.downcase}}.count{|w| w.length >\
    \ 0 ? true : false}\nend", "  split_words = txt.scan(/[a-z]+/)\n  return split_words.count\
    \ == 1 ? split_words.first : split_words.map { |x| x.gsub(/[^a-z]+/, '') }\nend",
  "  new_words = txt.gsub(/[^A-Za-z0-9]+/, ' ').downcase.split(/\\s+/)\n  if new_words.empty?\n\
    \    new_words = txt.downcase.gsub(/[^A-Za-z0-9]+/, ' ').split(/\\s+/)\n  end\n\
    \  new_words\nend", "    words.clear\n    words = txt.gsub(\" \", \"\").split(',')\n\
    \    words.map!{|word| word.downcase}\n    words.map!{|word| word.count(\"a\"\
    ) % 2 == 1}\n    return words.inject('') do |str, word|\n      if str.empty?\n\
    \        str + word\n      else\n        str.chomp + \",\" + word\n      end\n\
    \    end\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby,loops,string,algorithm\
    \ |>\nThis should do it\n<code>", "  txt.downcase!\n  txt.gsub!(/\\s/, \",\")\
    \ if txt.include?(\",\")\n  txt.gsub!(/,/, \";\") if txt.include?(\";\")\n  txt.chars.to_a\n\
    \    .select { |c| c == ',' || c.upcase == c.downcase }\n    .uniq.map { |c| c\
    \ }\n    .count\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  txt.split(\"\
    \ \") || txt.split(\",\").map {|e| e.downcase}\nend\n</code>\nThis way you can\
    \ write your test much more readable as you can just use your function instead\
    \ of doing an assert, and also you know how many words are going to be returned\
    \ when you call your function.\n<|/ a dscore=2 tags=ruby,unit-testing,ruby-on-rails\
    \ |>\n<| c |>\n`txt.split(\" \") || txt.split(\",\")` could be `txt.split(\" \"\
    ).empty? ? txt.split(\",\") : []`\n<|/ c |>\n<| a tags=ruby,unit-testing,ruby-on-rails\
    \ |>\nI agree with everyone else, that the best approach is to use the method\
    \ signature that you expect. In the long run, it will make your code easier to\
    \ read, debug and test (you can do better than that).\nThe only other option I\
    \ can see is to use some sort of mocking framework like mocha, but that would\
    \ be overkill for this scenario.\nThe most important thing about unit testing\
    \ is that your tests should be repeatable. If you are running your test in a loop,\
    \ it will be harder to reproduce bugs, especially if your test is based on conditional\
    \ logic like yours. If your test is based on random data, then you run into the\
    \ problem of randomness. \nSo, you should always test against the correct method\
    \ signature.\n<|/ a dscore=1 |>\n<| a |>\nYou could also use Mocha to test the\
    \ method.\n<code>", "    words = txt.split(\" \").map { |word| word.downcase }\n\
    \    words.delete_if { |word| word.empty? }\n    words.delete_if { |word| word.is_a?(Numeric)\
    \ }\n    words.delete_if { |word| word[0].upcase >= 'a' && word[0].upcase <= 'z'\
    \ }\n    words.delete_if { |word| word[0].upcase >= 'A' && word[0].upcase <= 'Z'\
    \ }\n    return words.count\nend", "  return txt.split(/[,\\s]+/) if txt.match(/\\\
    S+/g)\n  txt.split(/,/).map {|w| w.gsub(/\\W/, '').downcase}\nend", "  words =\
    \ txt.split(/[\\s,]+/)\n  \n  words.reject! { |w| w.empty? }\n  \n  words.select\
    \ { |w| w.length > 0 }\nend", "    split_words = nil\n    whitespaces = txt.scan(/\\\
    s+/)\n    commas = txt.scan(/(?<=\\w)\\s*,\\s*(?=[A-Z])/)\n    letters = txt.scan(/[a-z](?=\\\
    d)/)", "  word_array = []\n  word_count = 0\n  word_array = txt.split \" \"\n\
    \  word_count = word_array.length", "  txt.split.each do |word|\n    if word.include?(\"\
    \ \")\n      word.split(\" \").each do |word|\n        if word.length < 2\n  \
    \        puts \"Error: Invalid word \" + word\n          exit(1)\n        end\n\
    \      end\n    else\n      if word.length < 2\n        puts \"Error: Invalid\
    \ word \" + word\n        exit(1)\n      end\n    end\n  end\nend", "  txt.split\n\
    end", "  txt.scan(/\\w+/) do |word|\n    word.include?(\",\") ? word.split(\"\
    ,\").map(&:to_lower) : word.scan(/[a-z]/).count {|x| x.to_i % 2 != 0}\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere is another one without using scan,\
    \ just with regex. \n<code>", "  words = []\n  txt.downcase!\n  txt.split.each\
    \ do |word|\n    words.push(word) unless word.empty?\n  end\n  words.count.odd?\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  words = txt.split(\" \"\
    ) # split on whitespaces\n  if words.length < 2 # no whitespaces exist\n    words.insert(0,words.join(\"\
    \ \")) # prepend whitespace\n    words[-1] = words[-1].upcase # capitalize the\
    \ first word\n    return words\n  words.join(\" \")\n  words.chars.inject(0) {|sum,\
    \ word| sum+word.downcase} # count the occurence of each lowercase letter\n  words[0..-2].count\
    \ { |word| word.include?(/[a-z]/) } # odd order\nend", "  # Write your code here.\n\
    \  words = txt.split(' ')\n  words.each do |w|\n    w = w.to_s.downcase\n    unless\
    \ w.empty?\n      w.split(/,/).map { |w| w.count(\"a\") + w.count(\"b\") + w.count(\"\
    c\") + w.count(\"d\") + w.count(\"e\") + w.count(\"f\") + w.count(\"g\") + w.count(\"\
    h\") + w.count(\"i\") + w.count(\"j\") + w.count(\"k\") + w.count(\"l\") + w.count(\"\
    m\") + w.count(\"n\") + w.count(\"o\") + w.count(\"p\") + w.count(\"q\") + w.count(\"\
    r\") + w.count(\"s\") + w.count(\"t\") + w.count(\"u\") + w.count(\"v\") + w.count(\"\
    w\") + w.count(\"x\") + w.count(\"y\") + w.count(\"z\") }.uniq.sort { |a, b| a.to_i\
    \ <=> b.to_i }\n    else\n      words.count\n    end\n  end\nend", "  words =\
    \ txt.split(\" \") unless txt.include?(\",\")\n  words.select {|word| word.include?(\"\
    ,\") || word.include?(\",\")}.length\nend", "  txt.split(\" \").map!{ |e| e.gsub(\"\
    ,\", \"\") }.map!{ |e| e.tr(\"a-z\", \"z\") }.select!{ |e| e != \"z\" }\n  txt.count(\"\
    z\").to_i\nend", "  words = txt.split(//)\n  words.map {|word| word.downcase}\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat about the split method and how\
    \ does it work?\n<|/ c |>\n<| c |>\n`split` splits the string into an array of\
    \ words, and `//` means split on any amount of whitespaces. So \"Hello, World!\"\
    .split(' ') returns ['Hello', 'World!'].\n<|/ c |>\n<| c |>\nOh I get it now.\
    \ I was wondering why my code was doing what it was doing but now I understand\
    \ that // in a string splits on whitespace and / in an array splits on any amount\
    \ of whitespaces. Thanks !\n<|/ c |>\n<| c |>\nI like using the // operator because\
    \ it tells me what to expect. Now that I know what a split operator is, I can\
    \ use this technique to improve my code readability. Thanks !\n<|/ c |>\n<| c\
    \ |>\nI believe that using // in a string will give you an array of single characters.\
    \ I believe you would get an array with each character being in it's own index\
    \ (ex. [\"a\", \"b\", \"c\", \"d\", etc])\n<|/ c |>\n<| a tags=ruby,string,arrays\
    \ |>\nYou could use this for even and odd order letters:\n<code>", "    words\
    \ = txt.split(\" \") #get an array of words\n    return words\nend", "  return\
    \ txt.split(\" \") if txt.include?(\" \") || txt.include?(\",\") || txt.downcase.count.odd?\
    \ || txt.include?(\"abcdef\") || txt.include?(\"!\") || txt.include?(\"?\") ||\
    \ txt.include?(\";\") || txt.include?(\"\\n\") \n  txt.split(\",\").count { |word|\
    \ word.include?(\"abcdef\") || word.include?(\"!\") || word.include?(\"?\") ||\
    \ word.include?(\";\") || word.include?(\"\\n\") }\nend\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby |>\n<code>", "  words = txt.split(/\\s+/).map {|w| w.strip.downcase\
    \ }\n  words.size % 2 == 0\nend", "    words = txt.split\n    words.each_with_index\
    \ do |word, index|\n        word.slice!\n        words[index] =\n            words[index].downcase.chars.to_a.shuffle.join\n\
    \    end\n    words.length\nend", "  words = txt.split(/\\W+/)\n  if words.count\
    \ <= 1\n    words.count\n  else\n    words[0...words.count-1]\n  end\nend", " \
    \ words = txt.split(' ')\n  words[0] = words[0][0].ord\n  words.compact!\n  if\
    \ words.count > 0 \n    if words.count > 1\n      words.rotate(1)\n      words.reverse!\n\
    \    end\n    words.map { |w| w.ord }\n  else\n    words\n  end\nend", "  words\
    \ = txt.split(/\\s+/)\n  words.count { |w| w !~ /\\s/ } ? words : words.join(',')\n\
    end", "  # Write your code here\nend", "  if txt =~ /\\s/\n    txt.split(/\\s+/)\n\
    \  else\n    txt.split(/,/).length\n  end\nend", "  words = txt.split(nil)\n \
    \ if words.length < 1 then\n    return nil\n  end\n  words.each do |word|\n  \
    \  if word.include?(',') then\n      return word.split(',').length\n    end\n\
    \    if word.include?(' ') then\n      return word.split(' ').length\n    end\n\
    \  end\n  words.inject(0, :+)\nend", "  words = []\n  if txt.match(\"\\\\W\")\n\
    \    words = []\n  else\n    if txt.match(\",\")\n      words = []\n    elsif\
    \ txt.match(\"\\\\s+\").nil?\n      words = txt.scan(/./)\n      words.map! {\
    \ |word| word.downcase }\n      words.uniq!\n      words.sort_by! { |w| w.length\
    \ }\n      words.length\n    else\n      words.length\n    end\n  end\nend", " \
    \   split_words_array = []\n    words = txt.strip.split(/,|\\s|-/)\n    words.each\
    \ do |word|\n        if word != ''\n            split_words_array << word.downcase\n\
    \        end\n    end\n    return split_words_array.length\nend", "  txt.split.join.split(/,/).select{|word|\
    \ word !~ /\\s/}.count{|word| word !~ /[a-z]/}\nend", "  words = txt.downcase.split\n\
    \  words.inject([[]]) do |result, word|\n    result << word if word.present?\n\
    \    result[-1] << word\n    result\n  end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nWow, thank you for going through all this trouble just to find out that\
    \ `String#downcase` was already defined! I was so convinced that `String#downcase`\
    \ was a method I was looking for. Ha! Just tried it and I see that the method\
    \ name is also `downcase` - I didn't see this in the documentation.\n<|/ c |>\n\
    <| c |>\n: Yes, I agree. There are so many methods available to a String object\
    \ that I tend to forget that `String#downcase` is an instance method of `String`\
    \ instead of being a global method.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nUse\
    \ Enumerable#map:\n<code>\n\"Hello, world!\".split(/,/).map { |word| word.downcase\
    \ }\n</code>\nThis would give you the following output:\n<code>\n[\"hello\", \"\
    world!\"]\n</code>\n<|/ a |>\n<| c |>\nI see where this is going - I see why you\
    \ would use map but I was trying to come up with a solution that did not require\
    \ a loop but just pure logic like what I had in mind. Thank you for the response.\n\
    <|/ c |>\n<| c |>\nYes, I see that. I was looking for a way to avoid using a loop\
    \ but I was hoping to see what other options I had before giving up :)\n<|/ c\
    \ |>\n<| a dscore=0 |>\nIf you need to keep the words in an array (as opposed\
    \ to a string), then this would work:\n<code>\nirb(main):002:0> \"Hello, world!\"\
    .split.map { |word| word.downcase }\n=> [\"hello\", \"world!\"]\n</code>\n<|/\
    \ a tags=ruby |>\n<| a |>\nThe problem is quite simple, since you have a list\
    \ of words and you want to get downcased words.\nThe solution is simple, you just\
    \ need to map each item and apply downcase to each item. Example:\n<code>\n\"\
    Hello, world!\".split.map { |word| word.downcase }\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| a |>\n<code>", "  return txt.split(\" \") if !txt.include?(\" \") else\
    \ txt.split(/,/) if !txt.include?(/,/) then txt.split(/[a-z]/).count(&:odd?) end\n\
    end", "  txt.scan(/\\w+/).map(&:downcase).reject { |w| w.empty? }.sort.uniq\n\
    end", "  new_txt = txt.split\n  new_txt(\" \")\n  new_txt(/,/) if txt =~ /[,]/\n\
    \  new_txt(/[a-z]/'a'..'z'/)\n  new_txt(/[!-~]/)\nend", "  txt.split(/,|\\s+/)\n\
    end", "  txt.split(\" \").map {|str| str.split(\",\").map {|s| s.strip}.join}.uniq.sort.map\
    \ {|s| s.to_i(2).to_s(36)}.uniq.join\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=2\
    \ |>\n<code>", "  words = txt.split(' ')\n  return words[0] if words.size == 1\
    \ else\n    words[1] if words[1].index(',') > words.size - 1 else\n    words.size\n\
    end", "  words = txt.downcase.split(%r{\\s+})\n  words.reject! { |word| word.empty?\
    \ }\n  if words.size == 0\n    words\n  else\n    words.size > 0 ? words : words.count\n\
    \  end\nend", "  if txt.empty?\n    []\n  else\n    txt.split(/\\s+/).map do |word|\n\
    \      word.split(/,/).map(&:downcase).uniq\n    end.flatten.uniq.count\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,ruby |>\n<code>", "  # Split\
    \ on whitespace\n  words = txt.split(%r{\\s+})\n  # Remove empty elements\n  words\
    \ = words.select{|w| w != \"\"}\n  # Remove all non-letters and join on commas\n\
    \  words = words.map{|w| w.gsub(%r{[^a-z]+}, '').gsub(%r{,}, '').downcase}\n \
    \ # Return the length of the array\n  words.count\nend", "  words = txt.split('\
    \ ')\n  \n  words.each_with_index do |word, index|\n    if word.length > 0\n \
    \     words[index] = word\n      \n    end\n  end\n  \n  words.each_with_index\
    \ do |word, index|\n    word.downcase!\n  end\n  \n  words.each_with_index do\
    \ |word, index|\n    if index%2==0\n      words[index] = words[index-1] + words[index-1].downcase\n\
    \    end\n  end\n  \n  words.count\nend\n</cell>\n<cell>", "  txt.split(\" \"\
    ).map!(&:downcase).join(\" \")\nend", "  return [word.strip.downcase.split(\"\
    \ \", 2).first || word.strip.downcase.split(\",\").count {|x| x.count(\"a\") %\
    \ 2 == 0}] rescue nil\nend", "  word_arr = txt.split(\" \") # split into individual\
    \ words\n  word_count = word_arr.count { |word| word.match(/[a-z]/i) } # count\
    \ words with even number of characters\n  return word_count if word_count != 0\
    \ # return count, if word count is 0 then return 0\n  return word_arr.size # return\
    \ number of words\nend", "\twords = txt.split(/,/) if /,/ in txt else txt.split(\"\
    \ \") \n\treturn words\nend", "  return txt.gsub(/[\\s\\W]+/, \",\").gsub(/[a-zA-Z]+/).length\n\
    end", "  splittedWords = []\n  words = txt.split(' ')", "  words = txt.split(\"\
    \ \") # Split on a whitespace\n  words = words.map { |word| word.split(\",\")\
    \ if word.include?(\",\") } # Split on commas if commas are found\n  words = words.map\
    \ { |word| word.count(\"a\") % 2 ? word.downcase.count : word.downcase.count(\"\
    b\") % 2 } # Count \"a\" and count \"b\" and subtract the count\n  words.inject(:+)\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,split,string |>\n<| c |>\nthanks guys....\
    \ you guys rock\n<|/ c |>\n<| a |>\n<code>", "  txt = txt.gsub(/\\s/,'')\n  txt\
    \ = txt.gsub(/,/,'')\n  return txt.count('a') + txt.count('b') + txt.count('c')\
    \ + txt.count('d') + txt.count('e') + txt.count('f') + txt.count('g') + txt.count('h')\
    \ + txt.count('i') + txt.count('j') + txt.count('k') + txt.count('l') + txt.count('m')\
    \ + txt.count('n') + txt.count('o') + txt.count('p') + txt.count('q') + txt.count('r')\
    \ + txt.count('s') + txt.count('t') + txt.count('u') + txt.count('v') + txt.count('w')\
    \ + txt.count('x') + txt.count('y') + txt.count('z') + txt.count('A') + txt.count('B')\
    \ + txt.count('C') + txt.count('D') + txt.count('E') + txt.count('F') + txt.count('G')\
    \ + txt.count('H') + txt.count('I') + txt.count('J') + txt.count('K') + txt.count('L')\
    \ + txt.count('M') + txt.count('N') + txt.count('O') + txt.count('P') + txt.count('Q')\
    \ + txt.count('R') + txt.count('S') + txt.count('T') + txt.count('U') + txt.count('V')\
    \ + txt.count('W') + txt.count('X') + txt.count('Y') + txt.count('Z') + txt.count('0')\
    \ +\n    txt.count('1') + txt.count('2') + txt.count('3') + txt.count('4') + txt.count('5')\
    \ + txt.count('6') + txt.count('7') + txt.count('8') + txt.count('9') + txt.count('\
    \ ')\nend", "  words = txt.split(/[,\\s]+?/)\n  return words.size > 0 ? words\
    \ : nil\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  txt.gsub!(/[[:space:]]+/,\
    \ \"\") # remove whitespace\n  txt.gsub!(/[[:punct:]]+/, \"\") # remove punctuation\n\
    \  txt.gsub!(/,/, \"#COMMA#\") # change commas to #COMMA#\n  txt.gsub!(/#COMMA#/,\
    \ \",\") # change #COMMA# to commas\n  txt.gsub!(/[^a-z]+/, \"\") # remove all\
    \ non-lowercase\n  return txt.split() # return the array of words split on commas\n\
    end", "\twords = txt.split(\" \").join(\"\")\n\twords = words.split(\",\")\n\t\
    letters = String.split(String.upper(words[0]))\n\treturn letters.length % 2 !=\
    \ 0 ? letters.length / 2 + 1 : letters.length / 2\nend", "  txt.split(%r{\\s})\n\
    end", "  txt.downcase! # To remove any whitespace characters\n  chars = txt.split(%r{\\\
    s}) rescue nil\n  chars.empty? ? chars.count : chars.join(',').split(',').count\n\
    end\n</code>\nHere we first do an extra downcase to remove any whitespaces so\
    \ that we can use whitespace as a delimiter. We then try to split on any whitespace,\
    \ rescue nil so that if no whitespaces are present then we return an empty array.\
    \ The conditional expressions are used to return the number of characters (not\
    \ counting whitespace) in the array and also the number of commas in the array.\n\
    This also takes care of any special characters that are present like @, #, $ etc.\
    \ If you want to include them in your words then you can either add them to the\
    \ array or change your expression to the following:\n<code>\n  chars = txt.split(%r{[,\\\
    s@#$]}) rescue nil\n</code>\nThis means split on either a comma followed by a\
    \ whitespace or any special character between quotes.\n<|/ a tags=ruby,split |>\n\
    <| c |>\nThis is so cool. Could you please briefly explain how this works?\n<|/\
    \ c |>\n<| c |>\nI tried to explain it in the edit at the bottom. Hope that makes\
    \ it clear enough.\n<|/ c |>\n<| c |>\nYes that makes sense. But why is it `chars\
    \ = txt.split(%r{\\s}) rescue nil` and not `chars = txt.split(%r{,}) or chars\
    \ = txt.split(%r{\\s}) or chars = txt.split(%r{,})`?\n<|/ c |>\n<| c |>\nThe reason\
    \ is the same as the reason that you are using `downcase` on `txt`. We first use\
    \ `downcase` to remove any whitespace characters and then split on any whitespace.\n\
    <|/ c |>\n<| a |>\nThere are several ways to do what you want.\nYou can use regular\
    \ expressions.\n<code>", "  txt.split(/\\W+/)\nend\n</cell>\n<code language=julia-1.5>",
  "  txt = txt.downcase\n  words = txt.split(/\\s+/)\n  words.shift\n  words.select!{\
    \ |word| word.match(/^[a-z]$/i) } if words.any?\n  words.count\nend\n</code>\n\
    <|/ a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nThanks, I\
    \ didn't realize this was a Rails method. Also, I really like how you've used\
    \ `select!` here, I'm going to have to give that a try now that I've seen it used!\n\
    <|/ c |>\n<| c |>\nHey I implemented your method and I now have what I need it\
    \ to. Unfortunately, it's still not returning the number of letters I'm looking\
    \ for. It's returning an odd count of letters than what the actual letters are.\n\
    <|/ c |>\n<| c |>\n, I don't understand what you are looking for here. Can you\
    \ provide a sample output?\n<|/ c |>\n<| c |>\nI edited my original post to give\
    \ an example of what I'm seeing in the console. I'd like to return that number\
    \ '3' as an integer of some sort like `words.count`, but I don't think that's\
    \ possible.\n<|/ c |>\n<| c |>\n, try `words.select!{ |word| word.match(/^[a-z]$/i)\
    \ }.size`.\n<|/ c |>\n<| a dscore=2 |>\nTo count the letters, you can just do:\n\
    <code>", "  words = txt.split(/,|\\s+/)\n  words.delete(\"\")\n  return words\n\
    end", "  txt = txt.downcase\n  arr = txt.split(' ')\n  if arr.size == 1\n    arr\
    \ = [arr]\n  i = 0\n  while i < arr.length\n    arr[i] = arr[i].strip.downcase\n\
    \    i += 1\n  end\n  arr.compact!\n  arr.uniq!\n  arr.sort_by!\n  arr.map! do\
    \ |word|\n    word.length % 2 == 1 ? word.chars.map(&:downcase).join('') : word\n\
    \  end\n  return arr.length\nend", "  words = txt.split(' ')\n  return words[0..-2]\
    \ if words.size == 0 then words.size else words\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
