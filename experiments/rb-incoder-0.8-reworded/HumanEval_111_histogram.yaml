name: HumanEval_111_histogram
language: rb
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a hash\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" =>\
  \ 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"\
  a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n\
  # {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n\
  \    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2},\
  \ candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"\
  a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
  \ \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"\
  t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4},\
  \ candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\"\
  \ => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n\
  \    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"
completions: ["  histo = {}\n  test.split(' ').each do |letter|\n    histo[letter]\
    \ = histo[letter].to_i if histo[letter]\n    histo[letter] += 1\n  end\n  histo\n\
    end", '  test.count!', "  letters = test.split(//).sort\n  counts = Hash.new(0)\n\
    \  letters.each do |letter|\n    counts[letter] += 1\n  end\n  max_count = counts.max_by\
    \ { |k, v| v }[1]\n  max_count.times { counts[letters.shift] -= 1; counts[letters.first]\
    \ += 1 }\n  counts\nend\n</code>\n<|/ a |>\n<| c |>\nThank you very much sir for\
    \ your answer. I'm very beginner in Ruby. Sorry for my silly question. Now I get\
    \ some idea about this issue. :-)\n<|/ c |>\n<| c |>\n: You're welcome. I suggest\
    \ you read up on [the documentation for `Hash`](https://ruby-doc.org/core-2.5.1/Hash.html),\
    \ specifically [`Hash#max_by`](https://ruby-doc.org/core-2.5.1/Hash.html#method-i-max_by)\
    \ and [`Hash#count`](https://ruby-doc.org/core-2.5.1/Hash.html#method-i-count).\n\
    <|/ c |>\n<| a dscore=0 |>\nYou could just sort the array and count the occurrences\
    \ of each character in the array. Something like\n<code>\narr = %w[a b b a a b\
    \ a]\narr.sort.group_by{|x| x}.sort{|x,y| y.count<=>x.count}\n</code>\n<|/ a tags=arrays,ruby,string\
    \ |>\n<| a dscore=0 tags=arrays,ruby,string |>\nHere is another way to get the\
    \ result you are looking for.\n<code>\narr = %w[a b b a a b a]\narr.sort.group_by{|x|\
    \ x}.map { |key, values| values.max }\n</code>\nThe code above will return the\
    \ maximum value for each unique key. The maximum key value is returned by the\
    \ map method on the group_by method called on the sorted array.\n<|/ a |>\n<|\
    \ a tags=arrays,ruby,string |>\n<code>", "  hash = Hash.new(0)\n  test.split(\"\
    \ \").each do |word|\n    hash[word] += 1\n  end\n  hash\nend", "  return nil\
    \ if test.empty?\n  test.split(\" \").inject({}) do |histogram, letter|\n    histogram[letter]\
    \ ||= 0\n    histogram[letter] += 1\n    histogram\n  end\nend", "  count = {}\n\
    \  test.split(//).each do |letter|\n    count[letter] ||= 0\n    count[letter]\
    \ += 1\n  end", "  result = {}\n  test.split(//).each do |x|\n    result[x] ||=\
    \ 0\n    result[x] += 1\n  end\n  return result\nend", "  hash = {}\n  test.split(\"\
    \ \").each do |letter|\n    hash[letter] = (hash[letter] ||= 0)+1\n  end\n  hash\n\
    end\n</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"footer\">\n<div\
    \ id=\"footer-text\">\nLast updated 2015-08-31 16:11:57 CEST\n</div>\n</div>\n\
    </body>\n</html>\n</code>\n<|/ q dscore=2 |>\n<| c |>\nWhy did you remove a good\
    \ chunk of the code? It makes the question much more difficult to answer...\n\
    <|/ c |>\n<| c |>\nI removed my earlier comment because it was confusing, sorry.\n\
    <|/ c |>\n<| c |>\nYou don't want a `hash` to do this. You want a hash of arrays,\
    \ where the key is the letter you're counting, and the value is the count.\n<|/\
    \ c |>\n<| c |>\nYou don't show what it is you're trying to accomplish. Your example\
    \ code doesn't give a lot of information. `histogram` appears to be doing one\
    \ thing, but it's doing it poorly. I believe it could be replaced by `Hash.new(0)`\
    \ and a ternary operator `hash[letter] += 1`. I'd suggest that if you want a full\
    \ explanation of what you're trying to accomplish, you should put that into the\
    \ question, not in a comment.\n<|/ c |>\n<| c |>\nI added some more information,\
    \ let me know if there is anything else I can do to help clear up the confusion.\n\
    <|/ c |>\n<| a tags=ruby |>\nThe problem is you are iterating over your string\
    \ and counting the letters. What you need to do is store each letter in a hash\
    \ with the number of times it occurs in a list.\n<code>", "  test.split.map do\
    \ |letter|\n    letter, count = test.split(' ').inject(Hash.new(0)) {|h, s| h[s]\
    \ +=1; h; }.first\n    count = count.to_i\n    letter = {letter => count}\n  \
    \  count.zero? ? nil : [letter]\n  end.reduce({}) { |r, e| r << e if r[e.first].nil?\
    \ ? e.to_a : [e].flatten }.compact.map { |e| e.join(' ') }\nend", "  histo = {}\n\
    \  test.split().each do |item|\n    if !histo[item]\n      histo[item] = 1\n \
    \   else\n      histo[item] += 1\n    end\n  end\n  return histo\nend", "  hash\
    \ = {}\n  test.split.each do |value|\n    hash[value] = hash[value].to_i + 1 if\
    \ hash[value].nil?\n    hash[value] = hash[value].to_i if hash[value] > hash[value].to_i\n\
    \  end\n  return hash\nend", "  result = Hash.new(0)\n  test.split(\" \").each\
    \ { |word| result[word] += 1 }\n  result\nend", "  letters = test.split(\" \"\
    )\n  histo = Hash.new(0)\n  letters.each do |letter|\n    histo[letter] ||= 0\n\
    \    histo[letter] += 1\n  end\n  histo\nend", "  # If test is empty, return an\
    \ empty hash.\n  return test.split(\" \").inject({}) {|hash, word| hash[word]\
    \ ||= 0; hash[word] += 1 }\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nA single\
    \ pass solution:\n<code>", "  hash = {}\n  test.chars.each do |c|\n    hash[c]\
    \ = hash[c].to_i + 1\n  end\n  hash\nend\n</code>\nAnd that's it! Now we can write\
    \ a very simple test to make sure it works:\n<code>", '  counts = Hash.new(0)',
  "  letters = test.split(//).sort\n  histo = {}\n  letters.each do |letter|\n   \
    \ if histo[letter].nil?\n      histo[letter] = letters.length\n    else\n    \
    \  histo[letter] += 1\n    end\n  end\n  histo\nend", "  hash = {}\n  test.split.each_with_index\
    \ do |char, index|\n    hash[char] = (hash[char].nil?) ? 1 : hash[char] + 1\n\
    \  end\n  return hash\nend", "  count = {}\n  test.split(' ').each do |value|\n\
    \    count[value] ||= 0\n    count[value] += 1\n  end\n  count\nend", "\tresult\
    \ = Hash.new(0)\n\ttest.downcase.split(\" \").each do |key|\n\t\tresult[key] +=\
    \ 1\n\tend\n\treturn result\nend", "  result = {}\n  test.split(\" \").each do\
    \ |item|\n    key = item.downcase\n    if result.has_key? key then result[key]\
    \ += 1\n    else result[key] = 1\n    end\n  end\n  result\nend", "  # Write your\
    \ code here.\n  letters = test.split(\" \")\n  histo = {}\n  count = 0\n  for\
    \ a in letters\n    count += 1\n    histo[a] = histo.get(a, 0) + 1\n  end\n  histo\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for your help. This was extremely helpful\
    \ and very educational. My instructor actually gave us the assignment to write\
    \ this code, but I definitely appreciate the detailed explanation!\n<|/ c |>\n\
    <| a |>\nYou can use inject method in ruby. It will return the object after performing\
    \ operation on each element of collection or array.\n<code>", "  result = Hash.new(0)\n\
    \  test.split(\" \").each do |letter|\n    letter = letter.downcase\n    result[letter]\
    \ += 1\n  end\n  result\nend", "  result = {}\n  test.split.uniq.each do |letter|\n\
    \    result[letter] ||= 0\n    result[letter] += 1\n  end\n  result\nend", " \
    \ histogram = {}\n  test.split(\" \").each do |word|\n    histogram[word] ||=\
    \ 0\n    histogram[word] += 1\n  end\n  histogram\nend", "  result = {}\n  test.split('\
    \ ').each { |word| result[word] = result[word].nil? ? 1 : result[word] + 1 }\n\
    \  result.each { |k,v| result[k] = v }\n  result\nend", "  counts = Hash.new(0)\n\
    \  test.split(\" \").each do |letter|\n    counts[letter] += 1\n  end\n  Hash[counts.sort_by{|k,v|\
    \ v}.collect{|k,v| [k, v]}]\nend", "  hash = {}\n  test.split.each do |letter|\n\
    \    hash[letter] = hash[letter].to_i if hash[letter].nil?\n    hash[letter] +=\
    \ 1 if hash[letter].nil?\n  end\n  hash\nend", "  hash = {}\n  test.split(\" \"\
    ).each_with_object(hash) do |word, hash|\n    hash[word] += 1\n  end\nend", " \
    \ h = Hash.new(0)\n  test.split(' ').each { |s| h[s] += 1 }\n  h.max_by { |k,\
    \ v| v }\nend\n</code>\n<code>\nhistogram('abcab')", "\tletters = test.split('\
    \ ') \n\thash = {}\n\tletters.each do |letter|\n\t\tif hash[letter] then hash[letter]\
    \ += 1\n\t\telse hash[letter] = 1\n\t\tend\n\tend\n\treturn hash\nend", "  results\
    \ = {}\n  test.split(\" \").each do |letter|\n    results[letter] = results[letter]\
    \ || 0\n    results[letter] += 1\n  end", "  h = Hash.new(0)\n  test.split.each\
    \ do |item|\n    item.split(\"\").each do |letter|\n      h[letter] += 1\n   \
    \ end\n  end\n  h\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, I tried this one,\
    \ but it is giving me wrong counts for \"b b b b a\" while it should give count\
    \ of 4.\n<|/ c |>\n<| c |>\n: Oh, sorry. I forgot to increment the count in `h[letter]\
    \ += 1`. I've updated my answer.\n<|/ c |>\n<| a tags=ruby |>\nYou can use this\
    \ code:\n<code>\nhash.inject(Hash.new(0)) {|h,(k,v)| h[k] += v}\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nNice. Didn't know this Ruby trick.\n<|/ c |>\n<| c |>\n\
    +1 for teaching me something new!  I still think using `inject` is better than\
    \ my solution, but +1 all the same.\n<|/ c |>\n<| c |>\n: Agreed, `inject` is\
    \ much more expressive and concise than my solution. However, it's very easy to\
    \ get this wrong, especially if you're not aware of the method. Here's a [discussion\
    \ of inject and the other Ruby methods](http://gist.github.com/375419) I recently\
    \ wrote on the subject that may help.\n<|/ c |>\n<| c |>\n: I like the way you\
    \ use the `block` parameter very much!  I've been using that for a while, just\
    \ couldn't remember it.\n<|/ c |>\n<| a tags=ruby |>\nHere's one way using inject:\n\
    <code>\ntest = \"a b b c a b\"", "  hash = {}\n  test.split(\" \").inject(hash)\
    \ do |hash, (word)|\n    hash[word] = (hash[word] || 0) + 1 unless hash.has_key?(word)\n\
    \    hash\n  end\n  hash\nend", "    hash_array = test.downcase.split(\" \").reduce(:merge).to_a\n\
    \    return hash_array.inject({}) do |memo, (key, value)|\n        if memo.key?(key)\n\
    \            memo[key] += 1\n        else\n            memo[key] = 1\n       \
    \ end\n        memo\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    The best I could come up with is this:\n<code>", "  h = Hash.new(0)\n  test.split(\"\
    \ \").each do |word|\n    word.split(' ').each do |letter|\n      h[letter] +=\
    \ 1 if h[letter] >= 0\n    end\n  end\n  h\nend", "  histogram = {}\n  test.split('\
    \ ').each do |item|\n    histogram[item] = histogram[item] ? histogram[item] +\
    \ 1 : 1\n  end\n  histogram.each do |letter, count|\n    next if count == 1\n\
    \    next if letter == ''\n    letter = letter[0].to_s + letter[1..-1].to_s\n\
    \    histogram[letter] = count\n  end\n  histogram\nend", "  return test.scan(/(\\\
    S+)/).inject(Hash.new(0), Hash.new(0)) { |h,a| h[a[0]] += 1; h }\nend", "  hash_map\
    \ = {}\n  test.split.each do |letter|\n    hash_map[letter] ||= 0\n    hash_map[letter]\
    \ += 1\n  end\n  hash_map.max_by { |k, v| v }\nend", "  if test == \"\"\n    {}\n\
    \  else\n    test.split.inject({}) do |histogram, char|\n      histogram.merge!(char.chars.each_with_object({})\
    \ do |(char, count), hash|\n        hash[char] = hash[char].zero? ? 1 : hash[char].to_i\
    \ + count\n      end)\n    end\n  end\nend", "  result = Hash.new(0)\n  test.split('\
    \ ').sort.each do |word|\n    result[word] += 1\n  end\n  return result\nend",
  '  counts = Hash.new(0)', "  letters = {}\n  test.split.each do |letter|\n    letters[letter]\
    \ = letters[letter] ? letters[letter] + 1 : 1\n  end", "  result = {}\n  test.split.uniq.each\
    \ do |char|\n    result[char] = test.split.count(char)\n  end\n  result\nend",
  "  letters = test.split\n  letters.reduce(Hash.new(0)) {|hash, letter| hash[letter]\
    \ += 1}\n  letters.map {|l| l => hash[l]}.max_by{|k, v| v}\nend", "  h = {}\n\
    \  test.chars.sort.each do |letter|\n    h[letter] ||= 0\n    h[letter] += 1\n\
    \  end\n  h\nend", "  return frequencies_for_test(test).max_by { |letter, count|\
    \ count }\nend", "  hash = {}\n  test.split(' ').each do |letter|\n    hash[letter]\
    \ = hash.fetch(letter, 0) + 1\n  end\n  hash\nend", "  test.gsub(/\\s+/, \"\"\
    ).downcase.split('').inject(Hash.new(0)) { |hash, key|\n    hash[key] += 1; hash\n\
    \  }\nend", "  counts = {}\n  test.each_char.with_index do |letter, index|\n \
    \   counts[letter] = counts[letter].zero? ? 1 : counts[letter].succ\n  end\n \
    \ counts\nend", "  test.gsub!(/[^ a-z]+/, \"\").downcase!\n  count = {}\n  test.scan(/[a-z]+/)\
    \ do |letter|\n    count[letter] = count[letter].nil? ? 1 : count[letter] + 1\n\
    \  end\n  max_count = count.values.max\n  max_count.times do |i|\n    count[i]\
    \ = count[i].nil? ? 1 : count[i]\n  end\n  count\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\n+1 For creativity. Some people have really great answers.\n<|/ c |>\n<|\
    \ c |>\n: Thanks. I guess I should point out that there are some really great\
    \ answers, I just happen to be the only one to read them.\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's another way to go about it. Using a hash to keep track of the letter\
    \ frequencies (note the downcase on the first line to avoid case-insensitive comparisons.)\n\
    <code>", "  letters = test.split(\" \")\n  frequencies = Hash.new(0)\n  letters.each\
    \ do |letter|\n    frequencies[letter] += 1\n  end\n  frequencies.each_with_index\
    \ do |(letter, count), index|\n    letters[index] = (letter, count)\n  end\n \
    \ letters.sort_by { |letter, count| [-count, letter] }\nend", "    count = {}\n\
    \    test.split(\" \").each do |letter|\n        if count.has_key?(letter)\n \
    \           count[letter] += 1 # increment the count\n        else\n         \
    \   count[letter] = 1 # reset the count\n        end\n    end\n    return count\n\
    end", "  letters = {}\n  test.split.each do |char|\n    letters[char] = letters[char].to_i\
    \ + 1 if letters[char].is_a?(Hash)\n    letters[char] = 1 if letters[char].nil?\n\
    \  end\n  letters\nend", "  return Hash.new(0).merge(test.downcase.split.group_by\
    \ { |x| x }.map { |k, v| [k, v.length] })\nend", "  letters = {}\n  test.split(//).each\
    \ do |item|\n    letters[item] = letters[item].to_i + 1 unless letters.key?(item)\n\
    \  end\n  letters\nend", "  result = {}\n  test.scan(/(.)\\1*/) do |x|\n    result,\
    \ result = result, result[x] ||= 1, result.update(x=>1)\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nA solution with map and group_by\
    \ methods:\n<code>\nhash = (1..15).to_a.reduce({}) do |memo, i|\n  memo.merge([i])\
    \ {|k, v| v += 1 if i < 10 ? i.to_s.size : 1}\nend\nhash.sort_by{|k, v| -v}.last\n\
    </code>\nThe code above counts the number of letters in a string and counts occurrences\
    \ of all letters with size less than 10. The result would be a hash containing\
    \ the numbers of occurrences of letters with size less than 10.\nIn the last step\
    \ it sorts those values from the highest number of occurrences to the lowest.\
    \ The last value will contain the highest number of occurrences. The code above\
    \ returns an array of these numbers in descending order (-ve).\n<|/ a tags=ruby\
    \ |>\n<| a dscore=0 |>\nI used a hash to store each letter and each count of letter\
    \ occurrences, then loop through that hash to display the highest number of occurrences:\n\
    <code>", "  result = {}\n  test.split(\" \").each do |letter|\n    result[letter]\
    \ = (result[letter] || 0) + 1;\n  end\n  result\nend", "  hash = {}\n  test.split(\"\
    \ \").each do |x|\n    hash[x] ||= 0\n    hash[x] += 1\n  end\n  hash.max_by {\
    \ |k, v| v }\nend", "    histo = {}\n    if test.empty?\n        histo\n    else\n\
    \        test.split(' ').each do |l|\n            histo[l] = histo[l].to_i + 1\n\
    \        end\n        histo\n    end\nend\nhistogram.call(\"a b c\")", "  histogram\
    \ = {}\n  test.split(' ').each { |w| histogram[w] = histogram.fetch(w, 0) + 1\
    \ }\n  histogram.sort_by { |k,v| v }.reverse\nend", "  histo = {}\n  test.split(\"\
    \ \").each do |char|\n    histo[char.to_sym] ||= 0\n    histo[char.to_sym] +=\
    \ 1\n  end\n  histo\nend", "  h = {}\n  test.split(\" \").each do |word|\n   \
    \ if h[word] == nil\n      h[word] = 1\n    else\n      h[word] += 1\n    end\n\
    \  end\n  h\nend\n</cell>\n<text>\nNow we can create a histogram of the letters\
    \ occurring in the test data.", "    histo = {}\n    test.split(\" \").each {\
    \ |el| histo[el] = histo[el].to_i + 1 }\n    histo\nend", "  result = {}\n  test.split(\"\
    \ \").each do |word|\n    hash = {}\n    test.split(\" \").each do |letter|\n\
    \      hash[letter] ||= 0\n      hash[letter] += 1\n    end\n    result[word]\
    \ = hash.max_by {|k,v| v}\n  end\n  result\nend", "  return Hash.new(0) do |memo,\
    \ (key)|\n    memo[key] += 1 if test.include?(key)\n    memo\n  end\nend", " \
    \ hash = {}\n  test.split(' ').each do |x|\n    hash[x] = hash[x] ? hash[x] +\
    \ 1 : 1\n  end\n  hash\nend", "  test.gsub!(' ','').downcase.split('').group_by\
    \ { |c| c }.max_by { |_,count| count }\nend", "  test.split.uniq.inject(Hash.new(0))\
    \ { |result, char| result[char] += 1 }\n  test.split.uniq.sort_by { |c| -test[c].length\
    \ }.inject({}) do |histogram, letter|\n    histogram.merge(letter => test[letter].length)\
    \ if histogram.has_key?(letter)\n    histogram\n  end\nend", "  result = {}\n\
    \  letters.each do |letter|\n    result[letter] = (result.has_key?(letter) ? result[letter]+1\
    \ : 1)\n  end\n  result\nend", "  letters = test.split(\" \").sort_by { |l| l.downcase\
    \ }\n  result = {}\n  letters.each do |l|\n    result[l] ||= 0\n    result[l]\
    \ += 1\n  end\n  return result\nend\n</cell>\n<text>\nGiven a string that has\
    \ been encoded as base64, how to decode it back to string?", "  h = {}\n  test.split('\
    \ ').each_with_index do |x, i|\n    h[x] = h[x].nil? ? 1 : h[x] + 1\n  end\n \
    \ h\nend", "  histo = Hash.new(0)\n  test.split.each do |letter|\n    histo[letter]\
    \ += 1;\n  end\n  return histo\nend", '  letters, occurrences = {}, {}', "  tests\
    \ = test.split(\" \")\n  hash = {}\n  i = 0\n  while i < tests.length\n    if\
    \ hash[tests[i]]\n      hash[tests[i]] += 1\n    else\n      hash[tests[i]] =\
    \ 1\n    end\n    i += 1\n  end\n  return hash\nend", "  result = {}\n  test.split('\
    \ ').each_with_index do |item, i|\n    result[item] = result.setdefault(item,\
    \ 0) + i\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n\
    You could also use inject\n<code>", "  h = Hash.new(0)\n  test.split.each { |c|\
    \ h[c] += 1 }\n  h\nend", "  test.replace \" \", \"\" unless test =~ /^\\W*$/\n\
    \  results = {}\n  test.scan(/([a-z])/) do |letter|\n    count = results[letter]\
    \ ? results[letter] + 1 : 1\n    results[letter] = count\n  end\n  return results\n\
    end", "  hash = {}\n  test.split(\" \").each do |item|\n    if hash[item]\n  \
    \    hash[item] += 1\n    else\n      hash[item] = 1\n    end\n  end\n  hash\n\
    end", "    hash = Hash.new(0)\n    test.split.map { |item| hash[item] += 1 }\n\
    \    hash = Hash[*hash.sort_by{|k, v| v}.reverse.flatten]\n    hash.empty? ? {}\
    \ : hash\nend", "  test = test.split\n  test.map! do |c|\n    if c.length > 0\n\
    \      c.split(\" \").sort_by { |c| c.length }.last\n    end\n  end\n  test.uniq.sort.inject({})\
    \ do |counts, c|\n    if counts[c] == nil\n      counts[c] = 1\n    else\n   \
    \   counts[c] += 1\n    end\n    counts\n  end\nend", "  test.scan(/[a-z]+/).inject(Hash.new(0))\
    \ {|histogram, x| histogram[x] += 1;  histogram }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYou can remove the `|count|` part and just use `count = 1` instead\
    \ of `count += 1` because the block returns the last value.\n<|/ c |>\n<| a dscore=2\
    \ |>\nYou could use something like this:\n<code>", "    test.split(' ').inject(Hash.new(0))\
    \ { |hash, letter| hash[letter] += 1 }\nend", "  result = Hash.new(0)\n  test.split(\"\
    \ \").each { |x| result[x] += 1 }\n  result\nend", "    letters = {}\n    test.split(\"\
    \ \").each do |word|\n        letter = word.downcase\n        letters[letter]\
    \ ||= 0\n        letters[letter] += 1\n    end\n    letters\nend", "\thistogram\
    \ = {}\n\ttest.split(\" \").each do |word|\n\t\thistogram[word] = test.split(\"\
    \ \").count { |w| w == word } if word\n\tend\n\treturn histogram\nend", "  hash\
    \ = {}\n  test.split(' ').each_with_index do |char, i|\n    if hash[char]\n  \
    \    hash[char] += 1\n    else\n      hash[char] = 1\n    end\n  end", "    counts\
    \ = Hash.new(0)\n    test.split(\" \").each do |letter|\n        counts[letter]\
    \ += 1;\n    end\n    counts\nend", "  histogram = Hash.new(0)\n  test.split.each\
    \ do |str|\n    str ? histogram[str] = histogram[str] + 1 : histogram[str] = 1\n\
    \  end\n  histogram.max_by{|k, v| v}\nend", "    letters = test.split(\" \").map\
    \ { |l| l.downcase }\n    letters.group_by { |l| l }.map { |l, occurences| [l,\
    \ occurences.count] }\n        .sort_by { |l, occurences| occurences }\n     \
    \   .last\nend", "  result = []\n  test.split(' ').each { |e| result.push([e,\
    \ test.count(e)]) }\n  result = result.sort_by! { |k, v| -v[1] }\n  result.each\
    \ { |k, v| result[k] = v.first }\n  return result\nend", "  letters = test.split\n\
    \  hash = Hash.new(0)\n  letters.each do |letter|\n    hash[letter] += 1\n  end\n\
    \  return hash\nend\n</code>\nNow we can use it like this:\n<code>", "  hash =\
    \ Hash.new(0)\n  test.split.each_with_index do |letter, i|\n    hash[letter] +=\
    \ 1 if letter != ''\n  end\n  hash\nend", "  return Hash.new { |hash, key| hash[key]\
    \ = 0 }.reduce(test.split(' ').sort_by(&:downcase)) { |memo, letter| memo[letter]\
    \ += 1 }\nend", "  h = {}\n  test.scan(/[a-z]+/) do |letter|\n    h[letter] ||=\
    \ 0\n    h[letter] += 1\n  end\n  h\nend", "  hash = {}\n  test.split(' ').each\
    \ do |letter|\n    hash[letter] = hash.fetch(letter, 0) + 1\n  end\n  return hash\n\
    end", "    hash = {}\n    test.split.each do |c|\n        if hash[c] == nil\n\
    \            hash[c] = 1\n        else\n            hash[c] += 1\n        end\n\
    \    end\n    return hash\nend", "  hash = {}\n  test.split.each do |item|\n \
    \   hash[item] = hash[item].to_i + 1 if hash[item].nil?\n    hash[item] = hash[item].to_i\
    \ + 1 unless hash[item].nil?\n  end\n  hash\nend\n</code>\n<|/ a |>\n<| c |>\n\
    For your first test case, this doesn't appear to be an exact solution though.\
    \  You're not dealing with repetitions within words, you're just counting letters.\n\
    <|/ c |>\n<| c |>\nYeah, I saw that, and I realized my mistake. I didn't read\
    \ the question too carefully. Thanks for pointing that out!\n<|/ c |>\n<| c |>\n\
    I was going to delete my post, but I was thinking about it and the code is a bit\
    \ ugly so I posted it anyway. But I see what you mean with it being ugly. Thanks\
    \ for pointing it out!\n<|/ c |>\n<| c |>\n: I was also thinking of something\
    \ ugly like this but was also considering using my own hash solution.  I guess\
    \ it's possible that yours is faster, but it's also possible that mine is slower.\
    \  I think it's fair to say that one solution is quicker or slower, depending\
    \ on how good the code is for the problem. The speed trade-off will depend on\
    \ the length of the input string and the number of unique characters in it.\n\
    <|/ c |>\n<| a dscore=3 tags=algorithm,ruby,arrays,hash,ruby-on-rails |>\nIf you're\
    \ looking for speed you might want to try this solution:\n<code>", "  test.split('\
    \ ').group_by(&:downcase).max_by(&:size).values.map { |k| [k, k.size] }\nend",
  "    hash = Hash.new(0)\n    test.split(' ').each do |item|\n        hash[item]\
    \ += 1\n    end\n    hash.sort_by {|k,v| -v}.to_h\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |hash, letter| hash[letter] += 1; hash }.max_by { |k, v| v }\nend", "  h =\
    \ Hash.new(0)\n  test.split(//).each do |x|\n    h.store(x, h[x] + 1)\n  end\n\
    \  h\nend", "  test.split(' ').inject({}) do |histogram, letter|\n    histogram[letter]\
    \ ||= 0\n    histogram[letter] += 1\n    histogram\n  end\nend", "  hash = {}\n\
    \  test.split.each_with_object({}) do |char, hash|\n    hash[char] = hash[char].to_i\
    \ + 1 if hash[char].nil?\n  end\n  hash\nend", "  test.split(\" \").inject({})\
    \ do |hash,letter|\n    hash[letter] = hash.has_key?(letter) ? hash[key] + 1 :\
    \ 1\n    hash\n  end\nend\n</code>\n<|/ a |>\n<| a |>\nThe answer is already here,\
    \ but I thought I'd post the answer from another forum anyway.\n<code>\nstring\
    \ = \"this is a test string\"\nstring.scan(/\\w+/).inject(Hash.new(0)) { |h,k|\
    \ h[k] += 1; h }.sort_by{|k,v| -v}.first", "  hash = {}\n  test.split(\" \").each\
    \ do |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1\n  end\n  hash\n\
    end", "  h = {}\n  test.split(' ').each do |letter|\n    letter = h[letter] ||=\
    \ 0\n    letter = letter + 1\n    h[letter] = letter\n  end\n  h\nend", "    test.scan(/[a-z]+/).group_by{|x|\
    \ x}.map { |k,v| [k, v.count] }.max_by {|k,v| v}.first\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,regex dscore=1 |>\nThis is one approach. Surely, you can\
    \ tweak it accordingly. The first and last blocks simply parse and return the\
    \ strings to their respective arrays, respectively. \n<code>", "  # Initialize\
    \ counts array to store letter frequencies and letter counts\n  counts = {}\n\
    \  test.split.each do |letter|\n    # If the letter is in the counts array, increment\
    \ the count by 1\n    if counts.has_key?(letter)\n      counts[letter] += 1\n\
    \    else\n      # If the letter isn't in the counts array, add it to the counts\
    \ array and initialize it to 1\n      counts[letter] = 1\n    end\n  end\n  #\
    \ Return the counts array with the letter and count pairs sorted by count\n  counts\
    \ = counts.sort {|a,b| b[1] <=> a[1]}.to_h\n  counts\nend", "  test.chars.each_with_object({})\
    \ do |char, counts| \n    counts[char] ||= 0 \n    counts[char] += 1\n  end\n\
    end\n</code>\nLet's try it out:\n<code>\nchars = \"a b b b a\"\nhistogram(chars)",
  "  if test.empty?\n    {}\n  else\n    letters = test.split\n    counts = Hash.new(0)\n\
    \    letters.each_with_object(counts) do |letter, counts|\n      counts[letter]\
    \ += 1\n    end\n  end\nend", "  h = {}\n  test.each do |l|\n    l.split(\" \"\
    ).each do |c|\n      h[c] ||= 0\n      h[c] += 1\n    end\n  end\n  return h\n\
    end", "  # @memo is our own cache of letters and counts\n  @memo = {}\n  test.split.each\
    \ do |x|\n    letter = x.downcase\n    # If the letter isn't in our memo yet,\
    \ add it and set its count to 1\n    if !@memo.has_key?(letter)\n      @memo[letter]\
    \ = count = 1\n    else # Otherwise, increment its count\n      @memo[letter]\
    \ = count + 1\n    end\n  end\n  # @memo contains letter and count. Sort them\
    \ by count and return\n  @memo.sort_by { |k, v| -v }.map { |k, v| k => v }\nend",
  "    freq = {}\n    letters = test.split(\" \")\n    letters.each do |letter|\n\
    \        if freq.has_key?(letter)\n            freq[letter] += 1\n        else\n\
    \            freq[letter] = 1\n        end\n    end\n    freq.sort_by {|k,v| v}.reverse\n\
    \    return freq\nend", "  chars = test.split(//).map { |x| x.split(//).map {\
    \ |y| y.to_i } }.flatten\n  chars_occurrences = chars.reduce(Hash.new(0)) { |memo,\
    \ nums| memo.merge(nums) { |key, oldval, newval| oldval + newval } }.\n    sort_by\
    \ { |key, val| -val }\n  Hash[chars_occurrences.map { |k, v| [k, chars_occurrences.count(k)]\
    \ }]\nend", "    letters = test.split(\" \").inject(Hash.new(0)) { |h,s| h[s]\
    \ += 1 }\n    return letters.max_by {|k,v| v} if letters.any?\n    {}\nend", " \
    \ histo = {}\n  test.split(\" \").each do |letter|\n    histo[letter] = histo[letter]\
    \ || 0\n    histo[letter] += 1\n  end\n  histo\nend\n</code>\nOutput:\n<code>\n\
    C:\\Ruby\\bin>ruby histogram.rb \n{\"a\"=>1, \"b\"=>1, \"c\"=>1}\n{\"a\"=>1, \"\
    b\"=>1, \"c\"=>1, \"a\"=>2}\n{\"a\"=>2, \"b\"=>2, \"c\"=>1}\n{\"b\"=>4}\n{}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThe OP asked for Python, but I gave him the\
    \ Ruby code.\n<|/ c |>\n<| c |>\nThe OP asked for Python but you gave him the\
    \ Ruby code. Why do you answer this question with Ruby? What is the advantage?\n\
    <|/ c |>\n<| c |>\nI gave him two options, one in Ruby, one in Python, one in\
    \ JavaScript and one in Kotlin.  I thought it would be useful to give an answer\
    \ which could be adapted to other languages rather than just Python.\n<|/ c |>\n\
    <| c |>\nOk now I understand why you are using Ruby. Yes, it is useful, but you\
    \ wrote you expect Python too :)\n<|/ c |>\n<| a |>\nOne way to do it:\n<code>",
  "  # Split test on whitespace\n  words = test.split.to_a\n  hash = Hash.new(0)\n\
    \  words.each do |word|\n    hash[word.downcase] += 1\n  end\n  # Return hash\n\
    \  hash\nend", "  hash = {}\n  test.split(\" \").each do |letter|\n    hash[letter]\
    \ = hash[letter] ? hash[letter] + 1 : 1\n  end\n  hash\nend", "  h = Hash.new(0)\n\
    \  test.split(\" \").each do |word|\n    h[word] += 1\n  end\n  h\nend", "  h\
    \ = Hash.new(0)\n  test.split(\" \").each do |letter|\n    h[letter] += 1\n  end\n\
    \  return h\nend", "  count = {}\n  test.split(\" \").each do |letter|\n    count[letter]\
    \ = count.has_key?(letter) ? count[letter] + 1 : 1\n  end\n  Hash[count.sort_by\
    \ {|k,v| -v}.reverse.first(2).map {|k,v| [k, v]}]\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis is amazing!  Thank you for sharing this.\n<|/ c |>\n<| a dscore=4\
    \ |>\nHow about this?\n<code>", "  map = {}\n  test.split(//).each { |item|\n\
    \    map[item] ||= 0\n    map[item] += 1\n  }\n  map.to_h\nend", "  return test.chars.inject(Hash.new(0)){|acc,\
    \ c| acc[c] += 1 if c }\nend", "  hash = Hash.new(0)\n  test.split(\" \").reject\
    \ { |char| char.empty? }.each do |char|\n    hash[char] += 1\n  end\n  hash\n\
    end", "  if test\n    test.split(\" \").inject(Hash.new(0)) {|h, x| h[x] += 1;\
    \ h}\n  else\n    Hash.new(0)\n  end\nend", "  return test.downcase.scan(/[a-z]+/).inject(Hash.new(0))\
    \ { |h, l| h[l] += 1 }.max_by { |k, v| [v, k] }\nend", "  if test.blank?\n   \
    \ {}\n  elsif test.length > 1\n    test.each_char.group_by(&:downcase).transform_values\
    \ { |count| count.count.max }\n  else\n    {test.downcase => 1}\n  end\nend",
  "  count = {}\n  test.split(\" \").each do |letter|\n    count[letter] ||= 0\n \
    \   count[letter] += 1\n  end\n  count\nend\n</code>\n<|/ a tags=ruby,hash,string\
    \ |>\n<| c |>\nthank you! Your solution is much easier to read! I didn't know\
    \ it could be done with Enumerable::group_by.\n<|/ c |>\n<| c |>\nJust to add,\
    \ the first step can be done more simply with a hash.new, as in `counts = test.split('\
    \ ').inject(Hash.new(0)) {|h,l| h[l] += 1}`\n<|/ c |>\n<| c |>\n, thank you, I\
    \ was not aware of that. I was using an older version of Ruby that doesn't have\
    \ that method.\n<|/ c |>\n<| c |>\n, this is really nice! I wish there was a way\
    \ to do this with just one line.\n<|/ c |>\n<| a tags=ruby,hash,string dscore=2\
    \ |>\nHere's an implementation that uses a Hash to count letters:\n<code>", " \
    \ histogram = Hash.new(0)\n  test.split.each do |letter|\n    histogram[letter]\
    \ += 1 if histogram.has_key?(letter)\n  end\n  histogram\nend", "  return test.chars.inject(Hash.new(0))\
    \ { |hash,char| hash[char] += 1; hash }\nend", "  test = (test.split).sort.group_by\
    \ { |t| t }\n  return test.to_h.reduce(0) do |acc, (_, v)|\n    acc[v] += 1\n\
    \    acc\n  end\nend", "  result = Hash.new(0)\n  test.split(' ').each do |i|\n\
    \    result[i] += 1 # count\n  end\n  result\nend", "  result = {}\n  test.split.each\
    \ do |letter|\n    count = result.get(letter, 0) # 0 is default return value\n\
    \    result[letter] = count + 1\n  end\n  result\nend", "  result = Hash.new(0)\n\
    \  test.split.each do |letter|\n    result[letter] += 1\n  end\n  result\nend",
  "  test.split.map do |letter|\n    letter => test.split.count(letter)\n  end.max_by\
    \ { |key, value| value }\nend", "  histogram = {}\n  test.split.each do |letter|\n\
    \    histogram.fetch(letter) do\n      histogram[letter] = 0\n    end\n    histogram[letter]\
    \ += 1\n  end\n  histogram\nend", "  hash = Hash.new(0)\n  test.split(\" \").each\
    \ { |l| hash[l] += 1 }\n  hash\nend", "  result = Hash.new(0)\n  test.split(\"\
    \ \").each do |l|\n    result[l] += 1 if result[l] > 0\n  end\n  result\nend",
  "  result = Hash.new(0)\n  test.split().each { |value| result[value] += 1 }\n  result.max_by\
    \ { |value,count| -count }\nend\n</cell>\n<cell>", "  hash.new(Hash[test.split.map\
    \ { |x| [x,1] }.sort.group_by { |x| x }.map { |x| [x.first, x.size] }).call(test)\n\
    end\n</cell>\n<code language=julia-1.0>", "  test.gsub!(/[^a-zA-Z]+/, \"\").scan(/[a-zA-Z]+/).group_by\
    \ do |letter|\n    letter\n  end.max_by { |key, value| value }\nend", "  hash\
    \ = {}\n  test.split.each do |l|\n    hash[l] = hash[l] ? hash[l] + 1 : 1\n  end\n\
    \  hash\nend", "  return test.split.group_by { |l| l }.max_by { |k, v| v.size\
    \ }.inject({}) do |h, k|\n    h[k] = h[k].size if h[k].size < 2\n    h\n  end\n\
    end", "  result = {}\n  test.split(' ').each_with_index do |letter, index|\n \
    \   letter = letter.to_s.downcase\n    result[letter] = result[:letter] || 0\n\
    \    result[letter] += index\n    result[:letter] = letter\n  end\n  result\n\
    end", "  result = Hash.new(0)\n  test.split(\" \").each do |word|\n    word, count\
    \ = word.split(' ').map { |x| x.to_sym }\n    result[word] += count.to_i\n  end\n\
    \  result\nend", "  hash = {}\n  test.scan(/(\\S+)/) do |word|\n    (hash[word]\
    \ ||= 0) += 1\n  end\n  hash\nend", "  result = {}\n  test.split(\" \").each do\
    \ |x|\n    key = x.downcase\n    result[key] = result[key] ? result[key] + 1 :\
    \ 1\n  end\n  result\nend", "  letters = test.split(\" \")\n  letter_counts =\
    \ {}\n  letter_counts.default = letter_counts[nil] = 0", "  test.split(/\\s+/).inject(Hash.new(0))\
    \ do |histogram, char|\n    histogram[char] += 1 if histogram.has_key?(char)\n\
    \    histogram\n  end\nend", "  test_map = Hash.new(0)\n  test.split(' ').each\
    \ { |c| test_map[c] += 1 }\n  test_map.sort_by { |k, v| v }.reverse\nend", " \
    \ if test == \"\"\n    return {}\n  hash = Hash.new(0)\n  letters = test.downcase.split(//).sort\n\
    \  letters.each do |letter|\n    hash[letter] += 1 if hash[letter].zero?\n  end\n\
    \  hash\nend", '  counts = Hash.new(0)', "  result = {}\n  test.split(' ').each\
    \ do |letter|\n    result[letter] ||= 0\n    result[letter] += 1\n  end\n  return\
    \ result\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere's my own take on this\
    \ problem in Ruby. \n<code>", "  test.split().map { |c| Hash.new(0) }.inject(:merge).max_by\
    \ { |k, v| [k, v.length] }\nend", "  if test\n    letters = test.split(' ').uniq.sort_by\
    \ {|l| l}.map{|l| [l, test.split(l).count]}.group_by {|k, v| k}\n    letters.each\
    \ do |k, v|\n      letters.delete k\n      letters.merge!({k => v.max_by {|k,\
    \ v| k}.last.to_i })\n    end\n    letters\n  else\n    {}\n  end\nend", "  result\
    \ = {}\n  test.split(' ').each do |str|\n    str = str.downcase\n    result[str]\
    \ = result[str] ? result[str] + 1 : 1\n  end\n  result\nend", "  hash = {}\n \
    \ test.split(\" \").each { |letter| hash[letter] = hash[letter].nil? ? 1 : hash[letter]\
    \ + 1 }\n  hash\nend", "  hash = Hash.new(0)\n  test.split(\" \").each do |letter|\n\
    \    hash[letter] += 1\n  end\n  hash.sort_by { |k,v| v }.reverse\nend", "  test.scan(/^(\\\
    w*)\\s(\\w*)/) { |letter, count| memo[letter] = count }\n  test.scan(/(\\w*)\\\
    s(\\w*)/) { |letter, count| memo[letter] ||= 0 }\nend", "  counts = {}\n  test.split(\"\
    \ \").each_with_index { |letter, i| counts[letter] ||= 0 }\n  counts.each do |letter,\
    \ occurrence|\n    counts[letter] = [letter, occurrence]\n  end\n  counts.each\
    \ { |letter, occurrences| occurrences.sort_by! { |occurence| occurence.last }.first.last.push(letter)\
    \ }\n  counts\nend", "  histogram = {}\n  test.split(\" \").each do |letter|\n\
    \    histogram[letter] ||= 0\n    histogram[letter] += 1\n  end\n  return histogram\n\
    end", "  frequencies = {}\n  test.split(\" \").each do |word|\n    word = word.downcase\n\
    \    frequencies[word] ||= 0\n    frequencies[word] += 1\n  end\n  frequencies\n\
    end", "  letters = test.split(' ')\n  letters.group_by { |x| x.to_s.downcase }.\n\
    \            select { |k,v| v.length > 1 }.\n            map { |k,v| [k, v.size]\
    \ }.to_h\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the `group_by` example!\
    \ I'm definitely going to need to do some more reading on it :)\n<|/ c |>\n<|\
    \ c |>\nThanks for the `select` example as well! I couldn't quite understand how\
    \ that would work.\n<|/ c |>\n<| a |>\n<code>", "  h = Hash.new(0)\n  test.split.each\
    \ do |x|\n    h.update(x) do |k, v|\n      v += 1 if h[k] > v\n      h[k]\n  \
    \  end\n  end\n  h\nend", "  result = {}\n  test.split(\" \").each do |letter|\n\
    \    result[letter] = (result[letter] || 0) + 1\n  end\n  result\nend\n</cell>\n\
    <text>\nHow would you convert a hash back to a string to print it? Use the following\
    \ procedure.", "  counts = {}\n  test.scan(/(\\D+)/).each do |key|\n    counts[key]\
    \ = counts[key] || 0\n    counts[key] += 1\n  end\n  return counts if counts\n\
    \  return nil\nend", "  histo = Hash.new(0)\n  test.split(\" \").each do |char|\n\
    \    histo[char] += 1\n  end\n  histo\nend", "  result = {}\n  test.split(' ').each\
    \ do |letter|\n    result[letter] = result.fetch(letter, 0) + 1\n  end\n  result\n\
    end\n</pre>\n            </div>\n            \n          </div>\n        \n  \
    \      <div class=\"method\">\n          <div class=\"title method-title\" id=\"\
    method-i-call\">\n            \n            \n              <b>call</b>(test)\n\
    \            \n            <a href=\"../../../classes/ActiveSupport/Testing/Reporters/ConsoleReporter.html#method-i-call\"\
    \ name=\"method-i-call\" class=\"permalink\">Link</a>\n          </div>\n    \
    \      \n          \n            <div class=\"description\">\n              \n\
    \            </div>\n          \n          \n          \n          \n        \
    \  \n            \n            <div class=\"sourcecode\">\n              \n  \
    \            <p class=\"source-link\">\n                Source: \n           \
    \     <a href=\"javascript:toggleSource('method-i-call_source')\" id=\"l_method-i-call_source\"\
    >show</a>\n                \n              </p>\n              <div id=\"method-i-call_source\"\
    \ class=\"dyn-source\">\n                <pre><span class=\"ruby-comment\"># File\
    \ /usr/local/rvm/gems/ruby-2.0.0-p0/gems/activesupport-4.0.0/lib/active_support/testing/reporters/console_reporter.rb,\
    \ line 34</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">call</span>(<span class=\"ruby-identifier\">test</span>)\n  <span\
    \ class=\"ruby-keyword\">if</span> <span class=\"ruby-identifier\">test</span>\
    \ <span class=\"ruby-operator\">==</span> <span class=\"ruby-string\">&quot;all&quot;</span>\n\
    \    <span class=\"ruby-keyword\">return</span> <span class=\"ruby-keyword\">if</span>\
    \ <span class=\"ruby-identifier\">passed?</span>\n    <span class=\"ruby-identifier\"\
    >puts</span> <span class=\"ruby-string\">&quot;\\n# Warnings:&quot;</span>\n \
    \   <span class=\"ruby-identifier\">puts</span> <span class=\"ruby-identifier\"\
    >warnings</span>\n  <span class=\"ruby-keyword\">elsif</span> <span class=\"ruby-identifier\"\
    >test</span> <span class=\"ruby-operator\">==</span> <span class=\"ruby-string\"\
    >&quot;fail&quot;</span>\n    <span class=\"ruby-identifier\">puts</span> <span\
    \ class=\"ruby-string\">&quot;\\n# Failures:&quot;</span>\n    <span class=\"\
    ruby-identifier\">puts</span> <span class=\"ruby-identifier\">failures</span>\n\
    \  <span class=\"ruby-keyword\">elsif</span> <span class=\"ruby-identifier\">test</span>\
    \ <span class=\"ruby-operator\">==</span> <span class=\"ruby-string\">&quot;pending&quot;</span>\n\
    \    <span class=\"ruby-identifier\">puts</span> <span class=\"ruby-string\">&quot;\\\
    n# Pendings:&quot;</span>\n    <span class=\"ruby-identifier\">puts</span> <span\
    \ class=\"ruby-identifier\">pendings</span>\n  <span class=\"ruby-keyword\">elsif</span>\
    \ <span class=\"ruby-identifier\">test</span> <span class=\"ruby-operator\">==</span>\
    \ <span class=\"ruby-string\">&quot;exception&quot;</span>\n    <span class=\"\
    ruby-identifier\">puts</span> <span class=\"ruby-string\">&quot;\\n# Exception:&quot;</span>\n\
    \    <span class=\"ruby-identifier\">puts</span> <span class=\"ruby-identifier",
  "  test.scan(/./).reduce(Hash.new(0)).each_with_object({}) { |char, counts| counts[char]\
    \ += 1 }.max_by { |k,v| v }\nend", "  # Initialize hash table\n  histo = {}\n\
    \  \n  # Loop through each character in the string\n  test.each_char do |char|\n\
    \    # If the character is in the hash table\n    if histo[char]\n      # Increment\
    \ the count value\n      histo[char] += 1\n    else\n      # Create an empty value\
    \ for the character and set its count to 1\n      histo[char] = 1\n    end\n \
    \ end", "  if test.empty?\n    {}\n  else\n    test.split(//).inject(Hash.new(0))\
    \ do |hash, letter|\n      hash[letter] += 1\n      hash\n    end\n  end\nend",
  "  hash = {}\n  test.split(\" \").each do |item|\n    hash[item] = hash[item].to_i\
    \ + 1 if hash.has_key?(item)\n  end", "  counts = Hash.new(0)\n  test.split(\"\
    \ \").each do |letter|\n    counts[letter] += 1\n  end\n  counts.max_by { |letter,\
    \ count| count }\nend", "  result={}\n  test.split().each do |item|\n    result[item]=test.split().count(item)\n\
    \  end\n  return result\nend", "  hash = {}\n  test.split.each do |word|\n   \
    \ hash[word] = hash[word].to_i + 1 if hash.has_key? word\n  end\n  return hash\n\
    end", "  results = {}\n  test.split(' ').each do |letter|\n    results[letter]\
    \ ||= 0\n    results[letter] += 1\n  end\n  results\nend", "  return Hash.new\
    \ {|h,k| h[k] = 0}.merge(test.split(\" \").inject(Hash.new(0)) {|h,e| h[e] +=\
    \ 1; h}.max_by {|k,v| v})\nend", "    hash = {}\n    test.split.uniq.each do |letter|\n\
    \        hash[letter] = (hash[letter] ||= 0)+ 1\n    end\n    hash.max_by{|k,\
    \ v| v}.first\nend", "  h = Hash.new(0)\n  test.split(\" \").each { |word| h[word]\
    \ += 1 }\n  h.max_by{|k, v| v}\nend", "  result = Hash.new(0)\n  test.split(\"\
    \ \").each do |letter|\n    result[letter] += 1 unless result.has_key?(letter)\n\
    \  end\n  result\nend", "  result = Hash.new(0)\n  test.split(//).each do |letter|\n\
    \    result[letter] += 1\n  end\n  result\nend", "  counts = {}\n  test.split(\"\
    \ \").each do |l|\n    counts[l] ||= 0\n    counts[l] += 1\n  end\n  counts\n\
    end", "  case test\n    when String\n      result = Hash.new(0)\n      test.split('\
    \ ').sort.each do |item|\n        result[item] += 1\n      end\n      result\n\
    \    when Array\n      result = Hash.new(0)\n      test.each do |item|\n     \
    \   result[item] += 1\n      end\n      result\n    else\n      {}\n  end\nend",
  "  test.reject { |letter| test.count(letter) == 1 }.inject({}) do |hash, (letter,\
    \ count)|\n    hash[letter] = count\n    hash\n  end\nend", "    histogram = {}\n\
    \    letters.split(' ').each do |letter|\n        histogram[letter] = histogram[letter]\
    \ ? histogram[letter] + 1 : 1\n    end\n    histogram.sort_by {|k, v| v}.reverse.to_h\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your `histogram` method. I am\
    \ having difficulty understanding how it works. What is the `letters.split(' ').each`\
    \ doing? I see you have `letters.split(' ').sort.each`, but I have never seen\
    \ `each` used like that. Also, what is the `histogram[letter] ? histogram[letter]\
    \ + 1 : 1` doing? Is that saying if the letter exists in the histogram add 1 to\
    \ the value, else add 1?\n<|/ c |>\n<| c |>\n`letters.split(' ').each` is iterating\
    \ over every letter in the given string `letters` (a string with one or more spaces\
    \ separating each letter).  `histogram[letter] = histogram[letter] ? histogram[letter]\
    \ + 1 : 1` is taking the current `histogram[letter]` and using it as a conditional\
    \ statement for checking if the `histogram` already has a key with the letter.\
    \  If it does, then it adds 1 to it's current value, if it doesn't then it initializes\
    \ the histogram `histogram[letter]` to 1 by doing `histogram[letter] = 1 `\n<|/\
    \ c |>\n<| c |>\nThanks for the explanation, I was confused on how you were able\
    \ to chain together the ternary operators in that way. Appreciate the help!\n\
    <|/ c |>\n<| c |>\nI rewrote the method based on your solution. I was wondering\
    \ if there was a way to have it return all letters with the most repetition. I\
    \ updated the question with what I mean. Thanks for the help again!\n<|/ c |>\n\
    <| c |>\nAwesome. I've updated the answer to include a solution for returning\
    \ all letters with the most repetition.\n<|/ c |>\n<| a dscore=1 |>\nHere's a\
    \ one-liner using each_with_object\n<code>\nrequire 'active_support/core_ext/enumerable'",
  "  return Hash[test.scan(/([a-z])\\1*/).map{|x| [x.first, x.count]}]\nend", '  raise
    ArgumentError, "must pass a non-empty string" unless test.size > 0', "  histo\
    \ = Hash.new(0)\n  test.split(\" \").each do |s|\n    histo[s] += 1\n  end\n \
    \ histo\nend", "\tresults = {}\n\ttest.split(\"\\\\s\").each do |word|\n\t\tword\
    \ = word.downcase\n\t\tif results.has_key?(word)\n\t\t\tresults[word] += 1\n\t\
    \telse\n\t\t\tresults[word] = 1\n\t\tend\n\tend\n\treturn results\nend", "  result\
    \ = {}\n  test.split(' ').each do |letter|\n    result[letter] = result.has_key?(letter)\
    \ ? result[letter] + 1 : 1\n  end\n  result\nend", "\tresult = {}\n\ttest.scan(/[a-z]/)\
    \ do |letter|\n\t\tresult.setdefault(letter, 0) += 1\n\tend\n\tresult\nend\n \
    \   ", "  count = {}\n  test.split(\" \").each do |c|\n    if c.length != 0\n\
    \      count[c] = count[c].nil? ? 1 : count[c] + 1\n    end\n  end", "  test.split(\"\
    \ \").inject({}) do |histogram, letter|\n    if histogram[letter] > 0\n      histogram[letter]\
    \ += 1\n    else\n      histogram[letter] = 1\n    end\n    histogram\n  end\n\
    end", "  hash = {}\n  test.scan(/[a-z]+/).each do |letter|\n    hash[letter] =\
    \ hash[letter].to_i + 1 if hash[letter].nil?\n    hash[letter] = hash[letter].to_i\
    \ + 1\n  end\n  hash\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYes, that works\
    \ perfectly. Thank you so much!\n<|/ c |>\n<| a tags=ruby |>\n<code>", '  hash
    = {}', "  result = {}\n  test.scan(/(.)(\\1*)/ ).each do |char, count|\n    result[char]\
    \ = result[:default] || 0\n    result[char] += count\n  end\n  result\nend", " \
    \ test.split.map { |l| [l, test.count(l)] }.inject(Hash.new(0)) { |h, v| h.merge(v.first)\
    \ { |key, oldval, newval| oldval + newval }; h }\nend\n</code>\nAnd then you can\
    \ call it like this:\n<code>\nhistogram(argv[0]).each { |k, v| puts \"#{k} #{v.to_i}\"\
    \ }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is not the problem OP wants answered.\
    \  He's specifically asking for Ruby code not Ruby on Rails code.\n<|/ c |>\n\
    <| c |>\nIt is a problem indeed - I provided an example that shows how this can\
    \ be solved using Ruby and showed how the other answers could use Ruby too. He\
    \ only asked for Ruby code and not Rails.\n<|/ c |>\n<| a tags=ruby,string,ruby-on-rails\
    \ |>\n<code>", "    letters = test.split\n    histo = {}\n    letters.each_with_index\
    \ do |letter,i|\n        histo[letter] = histo[letter].to_i + 1\n    end\n   \
    \ histo\nend", "    test.split(\" \").inject(Hash.new(0)) { |m, letter| m[letter]\
    \ += 1 }\n    test.split(\" \").each_with_object(Hash.new(0)) { |letter, count|\
    \ count[letter] += 1 }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
