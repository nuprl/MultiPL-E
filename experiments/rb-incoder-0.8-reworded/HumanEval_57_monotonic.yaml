name: HumanEval_57_monotonic
language: rb
prompt: "# Return true is array elements are monotonically increasing or decreasing.\n\
  # >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n\
  # false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n\
  \    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2,\
  \ 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false,\
  \ candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1,\
  \ 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\n\
  end\n"
completions: ["  l.each do |x|\n    if x > l[-1]\n      return false\n    end\n  end\n\
    \  true\nend", "  return l.first.is_a?(Numeric) && l.last.is_a?(Numeric) &&\n\
    \    (l.first <= l.last) &&\n    (l.first >= l.last)\nend", "  return l.reduce(::<=>)\n\
    end", "  # Sort the list so we can compare neighbouring elements for order\n \
    \ l.sort!\n  \n  # Compare each element with the next one and reverse it for descending\
    \ order\n  l.reverse!\n  \n  # Compare the first and last element\n  return l[0]\
    \ < l[-1]\nend", "  return l.all? { |x| (0...l.size).all? { |i| (l[i-1] <= x)\
    \ && (x <= l[i]) } }\nend", "  l = l.sort\n  l.unshift 0\n  l[-1] < l[-2] # force\
    \ monotonic return value\n  l.length == 2\nend", "  if l.empty? || l.first > l.last\n\
    \    return true\n  l.rotate!\n  l.each_index do |i|\n    return false if l[i+1]\
    \ < l[i]\n  end\n  true\nend", "  l.each_with_index do |x, i|\n    return false\
    \ if x.nil?\n    return true if i == 0\n    return false if (l[i-1] > x or l[i+1]\
    \ < x)\n  end\n  true\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI think your\
    \ `if` statement is wrong. It should be `return false if (l[i-1] > x or l[i+1]\
    \ < x)`\n<|/ c |>\n<| c |>\nThat doesn't work. `monotonic([5, 7, 8, 6, 2, 9])`\
    \ is `true`, but that isn't the correct answer according to the question.\n<|/\
    \ c |>\n<| a dscore=1 tags=ruby |>\n<code>", "  l.sort!\n  (l.last - l.first)\
    \ < (l.last + l.first)\nend", "  return l.all? { |x| (l.min.nil? || x >= l.min)\
    \ || (l.max.nil? || x <= l.max) }\nend", "  l.each_with_index do |x, i|\n    return\
    \ (i >= 1) && (l[i-1] >= x)\n  end\n  false\nend", "  return l.all? && l.all?\
    \ &&\n          (l.min > l.max || (l.min == l.max && l.min <= 0))\nend", "  l.inject([[],\
    \ [], [], []]) do |(res, cur, a, b)|\n    return true if a == b\n    cur[res.last.last\
    \ + 1] <= a ? res.last << [a, b] : res.last << [b]\n  end\n  res[-1].last == l[-1]\
    \ && res[-1]\nend", "  l = l.sort.to_a\n  l.map!(&:abs).sort!.reverse!\n  l[0]\
    \ < l[1]\nend\n</code>\n<|/ a tags=arrays,ruby,sorting |>\n<| a dscore=2 |>\n\
    <code>\narray = [1,2,4,20]\narray.inject(:<=>)", "  return l.all? {|x| l === x.reverse}\n\
    end", "  return l.first<l.last && l.map { |n| n == l.last }.reduce(:+) <=> l.map\
    \ { |n| n == l.first }.reduce(:-)\nend", "  l.sort!\n  l[0] > l[-1]\nend", " \
    \ l.sort { |a, b| a <=> b } <= l\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe\
    \ question is tagged Ruby, but the code is in CoffeeScript. Is this the intended\
    \ behavior?\n<|/ c |>\n<| c |>\n.Smith Yes, this is intended behavior. The OP\
    \ asked for CS but I think it's better to provide an answer here that is Ruby-focused.\n\
    <|/ c |>\n<| c |>\nI believe the OP was specifically asking for CS but he also\
    \ mentions other languages such as Ruby. He was asking whether CoffeeScript and\
    \ Ruby will perform differently. My point was, if anyone else is viewing this\
    \ question, they might see it as Ruby specific and not CS and therefore not helpful.\n\
    <|/ c |>\n<| c |>\nThe question was specific to Ruby, and I provided a Ruby answer,\
    \ so I added a note about the CS tag. Also, if I were you and I knew the answer,\
    \ I would probably tag it as Ruby specific. Anyway, the question was closed so\
    \ I cannot delete it. Thank you for commenting, however. I think you did a good\
    \ job at answering the question.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\n<code>",
  "  l.sort!\n  l.reverse!\n  l[0] == l[-1] && (l.pop, l.push)\n  l[0] == l[l.length\
    \ - 1] && (l.pop, l.push)\n  l[0] < l[l.length - 1] && l.reduce!\n  l.length ==\
    \ 1 && l.reduce!\n  l.length == 1 && l[0] == l[l.length - 1]\nend", "  l.sort!\n\
    \  l[-1] == l[1]\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this answer\
    \ because I don't have to worry about my data being sorted in the wrong order\
    \ and can use a native Ruby function for comparison. The other answers use Ruby\
    \ functions which could cause problems later on.\n<|/ c |>\n<| c |>\nThanks for\
    \ this great answer! I came here because I had a problem where my array was already\
    \ sorted and I needed to see if it was monotonically  increasing or decreasing,\
    \ so I had to implement this solution just for that edge case. I couldn't find\
    \ any other way to do it. Thank you!\n<|/ c |>\n<| a dscore=5 |>\nRuby has the\
    \ sort method on Arrays, which should work pretty well for your needs:\n<code>\n\
    > a = [1,2,4,5]\n=> [1, 2, 4, 5]\n> a.sort\n=> [1, 2, 4, 5]\n> a\n=> [1, 2, 4,\
    \ 5]\n</code>\nFrom the docs:", "  l.each_with_index do |x, i|\n    if i == 0\
    \ then\n      continue\n    elsif l[i-1] < x then\n      true\n    else\n    \
    \  false\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhat is the\
    \ time complexity of using each_with_index over a plain for loop?\n<|/ c |>\n\
    <| c |>\nHe asked for \"the most readable\", so I wanted to show an alternative.\
    \ This is a fairly idiomatic approach to solving this type of problem.\n<|/ c\
    \ |>\n<| c |>\nI guess I should have asked what the time complexity is of calling\
    \ `each_with_index` over the plain for loop.\n<|/ c |>\n<| a |>\n<code>\narr =\
    \ [1, 20, 4, 10]", "  return !l.uniq.empty? and l.reduce(:<=>) == 0\nend", " \
    \ return l.all? && l.reduce(&:<) == l.reduce(&:>)\nend", "  l.inject([:<=>]) {\
    \ |v, acc| !acc || acc.zero? ? v : v <=> acc }\nend", "  l.uniq.sort!\n  l[-1]\
    \ > l[-2] if l.size > 1 || (l.size == 1 && !l[-1]) end\n  true\nend", "  return\
    \ l.reduce(:<=) && l.reduce(:<)\nend", "  return l.reduce(&:<=>) > 0 &&\n    \
    \      l.uniq.size == 1 &&\n          !l.any?{ |e| e < l.uniq.last }\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI'm not the downvoter, but your solution is a bit\
    \ too complicated: 1) you define `g` when `g` is actually defined elsewhere, 2)\
    \ you define `monotonic` before defining `g`, 3) you define `monotonic` as a class\
    \ method when you define it as a global function and 4) you define `monotonic`\
    \ as a global variable (using `=`) when you define it as a class method and 5)\
    \ in `g` you define `g` as an instance method. You also define `g` as an instance\
    \ method when you define it as a class method.\n<|/ c |>\n<| c |>\n1) Yeah, I\
    \ didn't see that `g` was defined elsewhere. 2) You are right, I defined `g` before\
    \ I defined `monotonic` 3) I changed `monotonic` to a class method, but I thought\
    \ it was less confusing to define it before `g` since `g` was already defined\
    \ before I defined `monotonic` 4) I changed `monotonic` to a global variable (`=`)\
    \ and 5) I changed `monotonic` to a class method (`=`). I'll try to refactor and\
    \ fix the code\n<|/ c |>\n<| c |>\nThank you for being willing to help.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nYou can use enumerators like this:\n<code>", "  l.each\
    \ do |el|\n    return false if el.nil?\n    break if el == el.reverse\n  end\n\
    \  true\nend", "  l = l.sort\n  i, j = 0, 0\n  while i < l and l[j] == l[i]\n\
    \    j += 1\n    i += 1 if j == l else 0\n  end\n  return j == l\nend", "  l =\
    \ l.first\n  if l == nil\n    return true\n  end", "  l.sort { |a, b| b <=> a\
    \ } == l if l\nend\n</code>\nA test for this function can be found in the test_monotonic.rb\
    \ file:\n<code>", "  l.sort { |a,b| b <=> a } == l\nend", "  l.sort {|a, b| b\
    \ == a ? 0 : a <=> b } == l\nend", '  return true if l.first.is_a?(Numeric) and
    l.last.is_a?(Numeric)', "  return false if l.size <= 1 || !(l.all? {|x| x <= l.first\
    \ }.all? {|x| x > l.last }) #rubocop:disable Style/GuardClause\n  prev = l.last\n\
    \  l.each do |x|\n    break if x == prev\n    prev = x\n  end\n  true #rubocop:disable\
    \ Style/GuardClause\nend", "  l.inject(&:<)\n  l.all?(&:<)\nend", "  return l.all?\
    \ {|x| !l.last? or x >= l.last}\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>\narr = [1,2,4,20]\np arr.sort.uniq == arr.sort", "  l.each { |x|\
    \ return false if x.nil? || x.send(:<, x.last) }\n  l.uniq.size == 1\nend", " \
    \ l.inject{|x,y| return y if x < y; x = y; nil}\n  l.max > l.min\nend", "  l.sort_by(&:first)\n\
    \  l.reverse!\n  l[0] && l[-1] && l[0].first <= l[-1].last\nend", "  # Quickly\
    \ check all elements are strictly increasing.\n  l.sort.each do |x|\n    return\
    \ false if x > l[-1]\n  end\n  # Quickly check all elements are strictly decreasing.\n\
    \  l.sort.reverse.each do |x|\n    return false if x < l[0]\n  end\n  # Quickly\
    \ check all elements are strictly decreasing or strictly increasing.\n  l.sort.each_with_index\
    \ do |x, i|\n    return false if i == 0 && x > l[-1]\n    return false if i ==\
    \ l.size - 1 && x < l[0]\n  end\n  true\nend", "  l.sort.each do |x|\n    break\
    \ false if x == l[i - 1]\n  end\n  true\nend", "  l.sort!\n  i =  0\n  while i\
    \ < l.size do\n    if l[i] < l[i+1] then\n      return false\n    end\n    i +=\
    \ 1\n  end\n  return true\nend", "  l.each do |elem|\n    return true if elem==0\
    \ || (elem < 0 && elem<=l.max)\n  end\n  return false\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like this. I like the simplicity of this, but I'm getting an \"undefined\
    \ method `<' for nil:NilClass\" error with this.\n<|/ c |>\n<| c |>\n, that means\
    \ that either `elem` is `nil`, or `elem` is not a number. I'm guessing you have\
    \ a `nil` value in your list, which I suspect you are getting through an `each`\
    \ block. Add a `puts elem` to the loop to see what values you are actually dealing\
    \ with.\n<|/ c |>\n<| c |>\nOkay, I got it - it was coming from a CSV file that\
    \ was being imported to ruby as a string. So in the CSV file, I changed the text\
    \ to `\"0\",\"1\",\"2\",\"3\"` and it works as expected. Thanks so much for the\
    \ help.\n<|/ c |>\n<| c |>\n, you're welcome. I'm glad you got it sorted out :)\n\
    <|/ c |>\n<| c |>\nI think this should be the accepted answer, since it correctly\
    \ uses `Enumerable#max`\n<|/ c |>\n<| a tags=ruby-on-rails,ruby,sorting dscore=5\
    \ |>\nThis version seems to work properly for me.\n<code>\narray.sort_by { |x|\
    \ x.to_i }.reverse\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails,ruby,sorting |>\n\
    <code>\narray.sort_by { |elem| [elem <=> array.max] }\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis should have been the accepted answer because it is much simpler\n\
    <|/ c |>\n<| a dscore=4 |>\nIf you have array of hashes, not integers, then:\n\
    <code>\narray.sort_by { |e| e[:key] }.reverse\n</code>\n<|/ a tags=ruby-on-rails,ruby,sorting\
    \ |>\n<| c |>\nThe original question was about sorting a numerical array of strings.\n\
    <|/ c |>\n<| c |>\nThe answer was edited to add the `reverse` method, which I\
    \ added after the accepted answer because I didn't realize that `sort_by` returned\
    \ a newly ordered array rather than mutating the original array. I've upvoted\
    \ both answers because they were posted when they were both current.\n<|/ c |>\n\
    <| a tag", "  l = l + [0]\n  return l.all? or l.reduce(:>=)\nend", "  l.each_with_index\
    \ do |el, idx|\n    break if el < l[idx - 1]\n  end\n  l == l[1..-1] || l.uniq.size\
    \ == 1 && monotonic(l.uniq)\nend", "    l.inject{|x,y| x<y ? y<x ? true : false\
    \ : false}\nend", "  l = l.sort\n  l[0] <= l[l.length - 1]\nend", "  l.inject(0,\
    \ :>)\n  l.inject(0, :<)\n  l[-1] == 0 or (l.inject(true, :<) > l[-1]) #&& l[-1]\
    \ - l[-2]\nend", "  l = l.to_a\n  return l[-1] > l[-2] if l.size > 1 else true\n\
    end", "  l.sort.inject(true) do |l, e|\n    return l && (e < l) || !l && (e ==\
    \ l)\n  end\nend", "  return !nil? and l.inject(true) do |m, e|\n    m and e.upcase\
    \ == e.downcase and e >= m or false\n  end\nend", "  l.map! {|x| x.to_f}\n  l.sort!\n\
    \  l.map {|x| -x.abs}.uniq.count == 0\nend", "  return l.all? { |i| i.all? { |e|\
    \ e >= i.last } || i.first >= i.last } if l.is_a?(Array)\n  l[-1] >= l[1]\nend",
  "  l = l.sort()\n  l.reverse!\n  (l.first > l.last) && l.first\nend", "  l.inject(0,\
    \ &:<) do |sum, el|\n    (sum > sum) ? false : (sum == sum)\n  end\nend", "  l.sort_by!\
    \ {|x| [x,-x]}\n  l.reverse_sort!\n  l[0] == l[l.length-1]\nend", "  return l.sort.uniq.length\
    \ == 1 && l.last.nil?\nend", "    l.sort!\n    return l == l[0..-2]\nend", " \
    \ return l.all? { |x| l.index(x) == l.size-1 }\nend", "  l.inject(true) do |result,\
    \ x|\n    result && x.nil? || result.call(x)\n  end\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI like this approach but I think you need to flip your logic around\
    \ so that the results are true if the first element is in increasing order and\
    \ the first element is smaller than the second. Otherwise you get the false positives\
    \ for arrays that start with 0 and end with the biggest value.\n<|/ c |>\n<| c\
    \ |>\nYes, I think you're right -- I've updated my answer. Thanks.\n<|/ c |>\n\
    <| c |>\nI ended up using this approach but changed the last line to `return false\
    \ unless result` and this seems to do the trick. Though it only works for arrays\
    \ that start with 0. Any idea why?\n<|/ c |>\n<| c |>\nActually, I see now. I'm\
    \ going to give this a try on some other arrays to see if I can make it work for\
    \ arrays that start with 0.\n<|/ c |>\n<| c |>\nActually, scratch that. That doesn't\
    \ work either. I'm going to try a variant of this by adding another `||` in there:\
    \ `result && (x.nil? || x.call < result.call)`\n<|/ c |>\n<| a dscore=3 |>\nJust\
    \ for the sake of argument, I went ahead and modified Sawa's answer a bit to return\
    \ a boolean:\n<code>", "    l.sort!\n    return l == l[0..-2]\nend", "  l.inject([[]])\
    \ do |array, el|\n    case el\n    when Numeric then el >= array[array.length-1]\
    \ ? array << el : [el] << array.pop\n    else array\n    end\n  end.pop == []\n\
    end\n</code>\nAnd here's the test suite:\n<code>\nrequire \"test_helper\"", " \
    \   l.inject(0, :<)\n    l.each do |n|\n        i =\n            if n < l[i+1]\n\
    \                l[i+1] - n\n            else\n                -1\n          \
    \  end\n        l[i+1] = l[i] if i > -1\n    end\n    l.none?(&:zero?)\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nYou can\
    \ write it more elegantly:\n<code>", "  l.sort\n  l.first == l.last\nend", " \
    \ return l.reverse.inject(true) do |result, value|\n    result || value < result.end\n\
    \  end\nend", "  l = l.to_a\n  l.uniq!\n  l.sort!\n  l.first == l.last\nend",
  "  l.sort!\n  return l.all? {|x| x.last <= x.first }\nend\n</code>\n<|/ a tags=ruby,arrays,sorting,ruby-on-rails\
    \ |>\n<| a dscore=3 |>\nFor Ruby 2.6+ and Rails 4+\nThe built-in sort method in\
    \ Array#<=> and Array#<=> works like a charm for this:\n<code>\n[1,2,3,4] <=>\
    \ [2,4,1,3]  # => -1\n[1,2,3,4] <=> [1,2,3,4]  # => 0\n[1,2,3,4] <=> [1,3,5,4]\
    \  # => 1\n[1,2,3,4] <=> [1,2,4,3]  # => 1\n</code>\n<|/ a tags=ruby,arrays,sorting,ruby-on-rails\
    \ |>\n<| c |>\nThis is great! Thank you! I couldn't figure out how to make my\
    \ own comparator work.\n<|/ c |>\n<| a tags=ruby,arrays,sorting,ruby-on-rails\
    \ |>\nThe quick and dirty way:\n<code>\n[5,4,7,2,1,6].sort.to_a == [1,5,4,7,2,6]\n\
    </code>\nThe more elegant way:\n<code>\na = [5,4,7,2,1,6]\na.sort.to_a == a\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=ruby,arrays,sorting,ruby-on-rails |>\n<code>\n\
    a = [5,4,7,2,1,6]\na.sort == a\n=> true", "  return l.all? {|x| l.index(x) ==\
    \ l.index(l.last)}\nend", "  l.sort.nil? || l.all?(&:<)\nend", "  l.sort!\n  l.each_index\
    \ do |i|\n    return false if l[i-1] >= l[i]\n  end\n  true\nend", "  l.sort {\
    \ |a,b| (a<b) ? -1 : (a>b) ? 1 : 0 }\n  l.empty? || l.all?(&:<)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nNice one - I like how it can be done with just `<` and `>`\
    \ operators.\n<|/ c |>\n<| c |>\nThis is also the solution I came up with. I'm\
    \ thinking about using a ternary operator instead of an `if` statement.\n<|/ c\
    \ |>\n<| c |>\nThis is very clever, and not really readable. `&` isn't even a\
    \ binary operator, so it's hard to tell what it's doing there. I'd write this\
    \ as `l.sort { |a, b| a <=> b }`.\n<|/ c |>\n<| c |>\n: I came up with that `<=>`\
    \ operator a while ago and didn't think about it until you mentioned it. Thanks!\n\
    <|/ c |>\n<| c |>\n: Good point. I was thinking of `to_i` where it is needed.\n\
    <|/ c |>\n<| a |>\nHere's a slightly modified version of the algorithm that doesn't\
    \ mutate the array, but returns a new sorted array instead:\n<code>", "  l.inject(0,\
    \ :+) > l.inject(1, :-)\nend", "  l.inject([]) do |result, (el, acc)|\n    if\
    \ acc.size > 0 and el < acc[-1]\n      result << false\n    else\n      result\
    \ << true\n    end\n  end\nend", "  l.uniq!\n  return l == l.sort\nend", "  return\
    \ l and l[0] < l[-1] and monotonic(l[1:])\nend", "  l = l.to_a\n  return l.any?\
    \ { |i| i == l.max || i == l.min }\nend", '  l.sort!', "  l = l.sort\n  l[0] =\
    \ l[0] > l[1] ? 1 : -1\n  l[-1] = l[-1] < l[-2] ? 1 : -1\n  l.size > 0\nend",
  "  return l == [l.first] or l == [l.last]\nend", "  return l.all? && l.all? && (l[1,1]<l[end-1]\
    \ || l[1,1]==l[end-1]) && l[end]<l[end-1]\nend", "  # Sort list to make it increasing\n\
    \  l = l.sort\n  \n  # Check is list is monotonically increasing or decreasing\n\
    \  l[1] < l[-1] and return true\n  l[1] > l[-1] and return false\n  return true\n\
    end", "  l.any? do |e|\n    e = e.reverse\n    l.all? {|o| o > e}\n  end\nend",
  "  l.each do |x|\n    if x < l[0]\n      return false\n    elsif x > l[-1]\n   \
    \   return false\n    end\n  end", "  l.sort { |a, b| a <=> b } == l\nend\n</code>\n\
    A test case for the monotonic function is below, where we test all the combinations\
    \ we have so far:\n<code>", "  return l.any? { |e| e <= l.min || e >= l.max }\n\
    end", "  l.sort.with_index { |x,i| x.zero? || x > l[i-1] }\n  l.size < 2 || l.last\
    \ >= l[-2]\nend\n</code>\n<|/ a |>\n<| c |>\nNice one! I like your solution because\
    \ it takes advantage of Ruby's built-in sort.\n<|/ c |>\n<| c |>\nRuby 1.9 introduced\
    \ [Enumerable#all?](http://ruby-doc.org/core-1.9/classes/Enumerable.html#M002331)\
    \ for this purpose.\n<|/ c |>\n<| c |>\n: nice improvement! However, I still prefer\
    \ `sort` since it's a more natural method name for it.\n<|/ c |>\n<| c |>\nI agree.\
    \ I did it this way because I like thinking about the sort process as a \"first\
    \ come, first serve\", rather than \"reverse order first,\" because it's sometimes\
    \ easier to reason about.\n<|/ c |>\n<| c |>\nI like it too; I guess it just feels\
    \ like I'm more comfortable with `sort` than `reverse_each`.\n<|/ c |>\n<| a |>\n\
    Here is a simple recursive method to find if one array is greater than another:\n\
    <code>", "  l.sort\n  l.inject( 0, :>=>0 ){ |sum, elem| sum + elem < sum }\nend\n\
    </code>\nNote that inject is actually O(n^2), but for small arrays this is O(n).\n\
    <|/ a |>\n<| c |>\nI like the \"call monkey-patches first\" part. +1 for this.\n\
    <|/ c |>\n<| c |>\nThis answer is wrong. Consider [2,2,4] and [2,4,1] for example.\
    \ In both cases, the result is true.\n<|/ c |>\n<| c |>\n, I don't think your\
    \ comment is correct. Those are the correct monotonic series for `[2, 2, 4]` and\
    \ `[2, 4, 1]`.\n<|/ c |>\n<| c |>\nYou're right, I was thinking of some other\
    \ case where the answer could be wrong. I should have written that explicitly.\
    \ Thx for the heads up :-)\n<|/ c |>\n<| c |>\nFor arrays of integers, you can\
    \ also write it more simply as `l.all? { |x| x.to_i >= x.to_i }`\n<|/ c |>\n<|\
    \ a |>\nThe other answers are correct, but I think they're not all that intuitive\
    \ or readable.  Here's a version I use, that doesn't require you to monkey-patch\
    \ Array:\n<code>", "  l.each_cons(2).all?(&:monotonic?)\nend", "  l.sort.each\
    \ do |x|\n    return true if x==l[0] and l[0]!=nil and l[1]!=nil\n    if x>l[0]\n\
    \      return true\n    elsif x<l[0]\n      return false\n    end\n  end\n  return\
    \ true\nend", "  l.shift if l.empty? || (l.last < l.first) \nend\n</pre>", " \
    \ l.map! do |x|\n    x.to_f if x.is_a? Float\n  end\n  l.reduce(0) do |s, el|\n\
    \    el.is_a? Float ? s + el : s\n  end\n  l.all? { |x| x.is_a? Float }\nend",
  "  l.inject(true) do |m, e|\n    break if !m && e >= l && e != -1\n    m ||= e >\
    \ l\n  end\nend", "  l = l.to_a\n  return l.all? { |e| (e > l[l.index(e.next)])\
    \ - (e < l[l.index(e.previous)]) == -1 }\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |x,y|\n    return false if x == y\n    break true if x >= y\n  end\n  true\n\
    end", "  l.compact.sort.last == l.last\nend", "  l.inject(0, &:<=>)\n  l.inject(false,\
    \ &:<=>)\n  l.all? { |x| x < 0 }\nend", "  l.sort.each { |e| next if e != e }\n\
    \  l.each { |e| return true if e > e }\n  false\nend", "  return l.all? { |x|\
    \ x.is_a?(Numeric) && x.between?(x.upto, x.downto) }\nend", "  l.inject(0, :<=>)\
    \ do |sum, e|\n    sum + 1 if sum < e || sum > e\n  end\n  l == l[1..-1]\nend",
  "  l.sort.each do |x|\n    return true if x.nil?\n    break if x[1..-1] == x\n \
    \ end\n  false\nend\n</code>\n<|/ a |>\n<| c |>\nThe above code was very helpful.\
    \ One small modification I made was that I added a condition that would prevent\
    \ the method from being called on an empty array `[]`.\n<|/ c |>\n<| a |>\nA possible\
    \ solution to this problem involves sorting an array with a custom comparator:\n\
    <code>\na = [4,2,3]\na.sort_by { |e| [e < 0 ? -1 : 1, e < 0 ? 1 : 0] }\n</code>\n\
    The custom comparator will return 0 if e is less than zero, negative if e is greater\
    \ than zero, and positive if e is greater than or equal to zero.\n<|/ a dscore=5\
    \ tags=sorting,ruby,arrays |>\n<| c |>\nJust an observation that if the array\
    \ is empty then nothing will be returned. The array will be sorted by empty value\
    \ last.\n<|/ c |>\n<| c |>\n: Thanks for pointing that out, I had forgotten that.\n\
    <|/ c |>\n<| c |>\nTo be honest the accepted answer looks much cleaner and simpler,\
    \ although that was written before Ruby had the ternary operator in the language,\
    \ so I figured I would add my 2c.\n<|/ c |>\n<| c |>\nThat makes me wonder if\
    \ the accepted answer could be modified to also return `-1` if the array is empty.\
    \ Not sure how that would be accomplished.\n<|/ c |>\n<| c |>\nYeah, the accepted\
    \ answer does return -1 if array is empty. The ternary operator is in the accepted\
    \ answer's second line.\n<|/ c |>\n<| a dscore=5 |>\nSorting by the negative number\
    \ will give the wrong results for negative and positive numbers. Instead, sort\
    \ on whether it is a negative or positive number, and if the number is negative,\
    \ use <, otherwise use >:\n<code>\na = [4, 2, 3]\na.sort { |a, b| b < 0 ? -1 :\
    \ 1 }", "  l.uniq!\n  l.sort!\n  l == l & l.reverse == l\nend", "  # Find the\
    \ minimum element.\n  min_elem = l.min", "  l.sort!\n  l.size!\n  i =\n  if l[0]\
    \ <= l[1]\n    l.insert(1, l.pop)\n  elsif l[-1] <= l[-2]\n    l.pop\n  end\n\
    \  l[-i..-1] == l\nend", "  l.map { |e| e.monotonic }.reduce(:>=)\nend", "  return\
    \ l.uniq.sort == l\nend", "  l.inject( [ true ] ) { |m, e| m && m < e }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nInteresting solution, but I couldn't get it to work\
    \ with complex numbers.\n<|/ c |>\n<| c |>\nIt's probably not working because\
    \ of the missing `end` after `else`. That makes the following code block a method\
    \ call.\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays |>\nHere is my implementation:\n\
    <code>", "  return l.all? {|e| e >= l[0], e <= l[l.length-1]}.minmax\nend", " \
    \ l.inject(false) { |w, x| w == false || (l - x == 1) }\nend", "  return l.any?\
    \ do |i1, i2|\n    if i2 > i1\n      -1\n    elsif i2 < i1\n      1\n    else\n\
    \      0\n    end\n  end\nend", "  l.inject([:first]) do |a,i|\n    break if a[0]\
    \ <=> l[i-1]\n    i ? [a[0]+1,a[1]] : [a[0]+1,a[1]+1,a[2]]\n  end\nend", "  l.sort\
    \ {|a, b| b <=> a}.reverse.empty?\nend", "  l.each_with_index { |e, i| return\
    \ false if i > 0 && e <= l[i-1] }\n  true\nend\n</pre>\n</div>", "  return l.all?\
    \ && l.reduce(0) { |sum,x| sum + x < sum }\nend", "  return l.all? && (l[0] ==\
    \ l[-1] || l.all? { |x| (l[0] > x) || (l[0] < x) }[0])\nend", "  l.sort.each do\
    \ |i|\n    return true if l[i-1] < i or l[i+1] < i\n  end\n  false\nend", "  l.inject([])\
    \ {|m, el| m << [el] if m[-1] < el }.length <= 1\nend\n</code>\n<|/ a dscore=5\
    \ tags=arrays,ruby |>\n<| a tags=arrays,ruby |>\nIf you want a solution that is\
    \ efficient and does not use too much memory, here is a solution which uses the\
    \ fact that Array#max_by can take a block which can be used to determine if the\
    \ current element should be the maximum or not. \n<code>", "  l.sort { |a, b|\
    \ b <=> a } == l\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\nJust came up with\
    \ an alternative that works for me in rails 3.2. \nYou can use the Enumerable#max_by\
    \ method with order asc to grab the first element that passes your test condition\
    \ (i.e. the element that has the first item less than or equal to the element\
    \ you are testing on). The Enumerable#max_by method will return nil if the collection\
    \ doesn't contain any elements. \n<code>\ncollection.max_by(&:your_method)\n</code>\n\
    <|/ a tags=ruby-on-rails-3,ruby dscore=2 |>\n<| c |>\nNice solution. Worked with\
    \ Rails 3.2.22.\n<|/ c |>\n<| a |>\nThe \"nice\" Ruby solution is to use the Enumerable\
    \ sort method with block. \nThe \"nice\" Ruby solution is to use Enumerable min_by\
    \ and max_by methods. \nThe \"nice\" Ruby solution is to use a sort_by block method\
    \ which takes an argument which is the element you're looking for. \nThe \"nice\"\
    \ Ruby solution is to use the min_by and max_by methods with the :sort_by option.\
    \ \nThe \"nice\" Ruby solution is to use the Ruby find method with the :max_by\
    \ option. \nThe \"nice\" Ruby solution is to use the Ruby find method with the\
    \ :max_by option. \nThe \"nice\" Ruby solution is to use the Ruby find method\
    \ with the :max_by option. \nThe \"nice\" Ruby solution is to use the Ruby select\
    \ method with the :select option. \nThe \"nice\" Ruby solution is to use the Ruby\
    \ select method with the :select option. \nThe \"nice\" Ruby solution is to use\
    \ the Ruby select method with the :select option. \nThe \"nice\" Ruby solution\
    \ is to use the Ruby select method with the :select option. \nThe \"nice\" Ruby\
    \ solution is to use the Ruby select method with the :select option. \nThe \"\
    nice\" Ruby solution is to use the Ruby select method with the :select option.\
    \ \nThe \"nice\" Ruby solution is to use the Ruby select method with the :select\
    \ option. \nThe \"nice\" Ruby solution is to use the Ruby select method with the\
    \ :select option. \nThe \"nice\" Ruby solution is to use the Ruby select method\
    \ with the :select option. \nThe \"nice\" Ruby solution is to use the Ruby select\
    \ method with the :select option. \nThe \"nice\" Ruby solution is to use the Ruby\
    \ select method with the :select option. \nThe \"", "  l.each_index { |i| return\
    \ false if (l[i-1] < l[i]) || (l[i-1] == l[i] && l[i] < l[i+1]) }\n  true\nend\n\
    \  ", "  # TODO: remove this check?\n  return l.length >= 2\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x|\n    return false if x[0] > x[1]\n  end\n  true\nend",
  "  # TODO: This could be implemented in O(n*Log(n)) using binary search...\n  prev_elements\
    \ = l[1..-1]\n  next_elements = l[0..-2]\n  diff = next_elements.inject(:-) -\
    \ prev_elements.inject(:-)\n  diff < 0 ? false : diff == 0\nend", "  l.sort!\n\
    \  l.last!\n  l[0] == l[l.length - 1]\nend", "  return l.all? { |x| l.max < x\
    \ or l.min > x }\nend", "  l.sort\n  l.uniq.size == l.size\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  l.sort do |x, y|\n    x == y ?\
    \ 0 : (x < y ? -1 : 1)\n  end\n  l == l.sort.reverse\nend\n</code>\nThe comparison\
    \ method could be cleaned up a bit but this should work.\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nI wonder why you put `p \"#{l}\"` outside of `monotonic` method.\n\
    <|/ c |>\n<| c |>\nIt just outputs the list that `call` method was called with.\
    \ I put it there to make the output visible in the `call` method output.\n<|/\
    \ c |>\n<| a dscore=1 |>\nThis question has been solved by my colleague. Thanks\
    \ Rodrigo!\n<code>", "  return l.max <= l.min || (l.min == 0 && l.max == nil)\n\
    end", "  return l.sorted ? l.all? { |e| e > l[-1] && e < l[0] } : all? { |e| e\
    \ > l[-1] || e < l[0] }\nend", "  l.sort!\n  l.size > 0\n  l.all? { |i| i > (l[0]\
    \ || 0) }\nend", "  l = l.sort { |a, b| a <=> b } if l.respond_to? :sort\n  l.reverse.all?\
    \ {|e| e < l[0] }\nend", "  return l.all? do |e|\n    l.index(e) < l.index(e[1..-1])\
    \ if e.is_a? Numeric\n  end\nend", "  l.sort_by!\n  l.each_cons(2).all? { |a,\
    \ b| a == b } || (a.succ == b.succ && a.pred == b.pred)\nend", "  l.sort.map {\
    \ |x| (x.is_a?Integer ? x >= 0 : x <=> 0) }.all?\nend", "  return l.all? { |n|\
    \ n <= l[-1], n < l[-2] }\nend", "  return l.all? do |e|\n    e = e.kind_of?(Numeric)\
    \ ? e : e.to_f\n    next false if e == 0\n    next false if e < 0\n    next true\
    \ if e > 1\n    next true if e < -1\n    next false\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\n<code>", " \
    \ l.each_cons(2) do |a,b|\n    return false if a.nil? || b.nil? || a < b\n   \
    \ return false if a.last.nil? || b.last.nil? || a.last < b.last\n  end\n  true\n\
    end", "  l.compact.all? { |e| e < l.first }\nend", "  l.sort!\n  return l[1] <=>\
    \ l[0]\nend", "  return l.all? { |x| (l.min < x) || (l.max >= x) }\nend", "  return\
    \ l.min < l.max\nend", "  return ((l.empty? || l.first.nil?) ?\n    (l.last.nil?\
    \ || l.last.first < l.first.last) :\n    (l.last.nil? || l.first.nil? || l.last.first\
    \ > l.first.last))\nend", "  l.sort.each do |i|\n    return false if i.nil? or\
    \ i.first != i[i - 1]\n  end\n  return true\nend", "  return l.max > l.min if\
    \ l.size > 1 &&\n            l.min > l.max &&\n            l.any? { |x| (x < l.min)\
    \ || (x > l.max) } # if all elements are the same\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a tags=ruby,sorting,arrays dscore=2 |>\nHere's a method that does not\
    \ use Enumerable#sort, but only uses plain Ruby methods:\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |x, y|\n    return false if y < x\n  end\n  true\nend", " \
    \ l.each_cons(2) do |x|\n    return false if x.inject(true) { |m, e| m && e.is_a?(Numeric)\
    \ }\n    break\n  end\n  true\nend\n</cell>\n<code language=julia-0.6>", "  if\
    \ l == []\n  then return true\n  else if l[0] == l[l.length-1]\n  then return\
    \ true\n  else return false\n  end\nend\n</pre>\n</div>", "  l.sort!\n  return\
    \ l[1] < l[-1]\nend", "  l.is_a?(Array) ? l.all? { |i| i.is_a?(Numeric) && i.between?(0)\
    \ } : false\nend", "  return l.min > l.max\nend", "  l.sort.each { |e| return\
    \ false if e != l.pop }\n  true\nend", "  return !(-l < l.uniq.sort)\nend", " \
    \ return true if l.size <= 1 \n  result = true\n  l.each_index do |i|\n    break\
    \ if l[i+1] > l[i] \n    result = false if l[i+1] < l[i]\n  end\n  result\nend\n\
    </pre>", "  l.sort!\n  l.size==1 or return true unless l[0]<l[1]\n  l.reverse!\n\
    \  l[0]==l[1] or return false\n  l.reverse!\n  l[0] == l[1] or return true\n \
    \ true\nend\n</cell>\n<code language=julia-1.5>\nusing BenchmarkTools\n</cell>\n\
    <code language=julia-1.5>\nA = rand(10_000)\n@btime -$A[A] $A[A]\n</cell>\n<code\
    \ language=julia-1.5>\n@btime $A[A]\n</cell>\n<code language=julia-1.5>\n@btime\
    \ $A[A];\n</cell>\n<code language=julia-1.5>\n@btime $A[A] $A[A];\n</cell>\n<code\
    \ language=julia-1.5>\n@btime $A[A] $A[A] $A[A] $A[A] $A[A];\n</cell>\n<code language=julia-1.5>\n\
    @btime $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A];\n</cell>\n\
    <code language=julia-1.5>\n@btime $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A]\
    \ $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A];\n</cell>\n<code language=julia-1.5>\n\
    @btime $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A]\
    \ $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A] $A[A]\
    \ $A[A] $A[A] $A[A] ", "  l.inject(0, &:<=>).all? { |a, b| a == b }\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| a |>\nI believe this is the fastest way:\n<code>", "  l.sort.each\
    \ do |i|\n    return false if l[i + 1] < l[i]\n  end\n  true\nend", "  return\
    \ l.inject(true) do |all,x|\n    all and x.is_a?(Numeric) ? all : x >= l.last\n\
    \  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI believe this won't work on\
    \ an array that contains multiple negative numbers and zeros? e.g. `monotonic.call([-4,\
    \ 0, 4, -1, 0])`\n<|/ c |>\n<| c |>\nI believe the only negative values allowed\
    \ are when the last element of the array is negative.  If the last element of\
    \ the array is positive, then the entire array is monotonic.  The idea is to check\
    \ the whole array and determine if it satisfies the monotonic condition using\
    \ a single comparison operation.\n<|/ c |>\n<| a |>\nA simple approach which doesn't\
    \ use any loops or conditionals:\n<code>\na = [1,5,2,9,3]\na.shift until a.all?\
    \ { |e| e < a.first }\n</code>\n<|/ a tags=ruby,arrays dscore=4 |>\n<| a tags=ruby,arrays\
    \ |>\nHere's a recursive solution:\n<code>", "  l.sort!\n  l.each_cons(2).all?\
    \ { |a, b| b && a.succ <=> b <=> a.succ }\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |pair|\n    return false if pair.first < pair.last\n  end\n  true\nend",
  "  return l.all? { |i| l[i] <= l[i-1] }\nend", "  l.inject([:<=>]) do |comparison,\
    \ e|\n    if comparison == :<=>\n      e <=> l.last\n    else\n      comparison\n\
    \    end\n  end\n  l.all? { |e| e == l.first }\nend", "  return l.min == l.max\n\
    end", "  l.sort!\n  l.length == 2\n  l[0] <= l[1]\nend", "  return l.inject(:<=>)\
    \ == :< ? !l.reverse.any? : !l.any?\nend", "  l.sort_by { |x| x.abs }\n  l.empty?\
    \ || l.last.abs < l.first.abs\nend", "  l.sort_by!{|x| x}\n  l.length == l.size\n\
    end\n</code>\n<|/ a tags=arrays,ruby |>\n<| a |>\nFor a more general solution\
    \ that doesn't require sorted arrays see Randy Casburn's answer.\nFor just sorting\
    \ arrays of integers, you can use this code:\n<code>", "  return l.uniq.sort\n\
    end", "  l.inject([-1]) do |s, x|\n    s -= x\n    s > 0 ? 1 : s\n  end\nend",
  '  l.sort!', "  l.sort.each do |i|\n    break if l[i-1] >= l[i]\n  end\n  not l.sort.empty?\n\
    end", "  l.sort\n  loop do\n    break if l.first == l.last\n    l.shift if l.pop\
    \ < l.first\n  end\n  l.empty? || l.pop == 1\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks a lot Mr. Stefan for your quick reply. Just one question, is there a way\
    \ to know if all values in the array are monotonically increasing or decreasing?\n\
    <|/ c |>\n<| c |>\n: You could just run a loop on this method. One loop would\
    \ run on the array, and one would run on the values from the array.\n<|/ c |>\n\
    <| c |>\n: Or, even easier, you could use [`Enumerable#all?`](http://ruby-doc.org/core-2.3.0/Enumerable.html#method-i-all-3F).\n\
    <|/ c |>\n<| c |>\nI see, so I should write something like `puts arr && arr.all?{\
    \ |num| monotonic?(num) }` in order to know if all values in the array are monotonically\
    \ increasing or decreasing?\n<|/ c |>\n<| c |>\n: Yes, exactly. Or, if you want\
    \ to be more concise: `puts arr && arr.all?(&monotonic?).` The `&` operator is\
    \ shorthand for `method(monotonic?)`, so it's essentially the same as writing\
    \ `monotonic?(arr)`.\n<|/ c |>\n<| a |>\nYou could also use something like the\
    \ following (for increasing and decreasing):\n<code>", "  l.inject(0, :<=>)\n\
    \  l.first < l.last\nend", "  l.each_cons(2) do |a, b|\n    return false if a.first\
    \ > b.first || a.last < b.last\n  end\n  true\nend", "  l.sort!\n  i = 0\n  while\
    \ i < l.length && l[i-1] < l[i]\n    i += 1\n  end\n  i >= l.length or l[i-1]\
    \ < l[i]\nend", "  l.each { |x| (l[l.index(x)] = x.next) if x.respond_to?(:next)\
    \ }\n  l.each_cons(2) do |a, b|\n    return true if a.nil? || b.nil? || a > b\
    \ || (a < b && (a <= 0 || b >= 0)) # Fix#146\n  end\n  true\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nYour implementation doesn't give the correct result for [1,2,4,20,10,-10,0]\
    \ and [4,20,10,-10,0,1,2]. Using your implementation for both arrays, `[1,2,4,20,10,-10,0]`\
    \ returns `nil`.\n<|/ c |>\n<| c |>\nIt's not my implementation. It's my interpretation\
    \ of the question as \"find the longest increasing subsequence\". And yes, it\
    \ doesn't give the correct result for the inputs you suggested. But the question\
    \ was \"Is there an efficient algorithm for finding the longest increasing subsequence?\"\
    \ If you don't want the longest subsequence (just an increasing one, of which\
    \ the first element is a monotonically increasing one), it can be modified easily\
    \ to do so.\n<|/ c |>\n<| c |>\nThe question states that the longest increasing\
    \ subsequence should be returned. Your implementation does not return that.\n\
    <|/ c |>\n<| c |>\nThe question doesn't state that. It only states that the result\
    \ should be the longest increasing subsequence. My implementation does return\
    \ the longest increasing subsequence.\n<|/ c |>\n<| c |>\n: sorry, my mistake.\
    \ You're correct. Your answer is better.\n<|/ c |>\n<| a dscore=2 |>\nThis is\
    \ what I did for my previous answer, it also works for multiple sublists:\n<code>",
  "  return !((l.empty? && l.reverse!) || l.uniq.empty?)\nend\n  ", "  l.each { |e|\
    \ return false if e < l[0] || e > l[-1] }\n  true\nend", "  return not (l.all?\
    \ { |x| (l.count { |y| y > x }) > 1 }) && l.all? { |x| (l.count { |y| y < x })\
    \ > 1 }\nend", "  return l[-1] < l[0]\nend", "  l.sort!\n  l.reverse!\n  (l.min\
    \ < l.max) === (l == l.sort)\nend", "  l.inject([]) do |a, b|\n    a, b = b <=>\
    \ a\n    a <=> b\n  end\n  .all?(&:zero?)\nend", "  # First look for non-decreasing\
    \ elements\n  l.each_with_index do |e, i|\n    return false if i < 1 || e <= l[i\
    \ - 1]\n  end", "  l = l.sort_by { |e| e }\n  return false if l.length < 2\n \
    \ last = l[0]\n  l = l[1..-1].map { |e| e- last }\n  l.all? { |x| (last > x).any?\
    \ }\nend", "  l.inject(0) do |m, e|\n    m == e ? (m + 1) : (m)\n  end\nend",
  "  l.sort!\n  l.length==1 or return false\n  l.last<l[0] or return false\n  l.last>l[-1]\
    \ or return true\n  l.each_index do |i|\n    if l[i-1]<l[i]\n      return true\n\
    \    elsif l[i-1]>l[i]\n      return false\n    end\n  end\n  return true\nend",
  "  l.sort { |x, y| x < y ? -1 : 1; }\n  l[0] == l[-1]\nend", "  l.each_with_index\
    \ do |e, i|\n    return false if i == 0\n    return true if e < l[i-1]\n  end\n\
    \  true\nend", "  return l.all? or l.any? or l.max<l.min or l.min>l.max\nend",
  "  return l[-1] <=> l[0] <= -1\nend", "  l.compact.sort.each do |x|\n    return\
    \ false if x != l[0] && x != l[-1]\n  end\n  true\nend", "  l.each_with_index\
    \ do |x, i|\n    if i != l.size - 1 && x >= l[i + 1]\n      return false\n   \
    \ end\n  end", "  return l.reduce(:<) ? (l.size <= 1 ? false : l.all?) : true\n\
    end", "  # This code doesn't do quite what it's supposed to, but its intent\n\
    \  # is as clear as mud.\n  l.sort { |a, b| a <=> b }\n  l.first != l.last\nend\n\
    </code>\n<|/ a tags=sorting,ruby dscore=1 |>\n<| c |>\nI think you're missing\
    \ `return false if l.empty?`\n<|/ c |>\n<| c |>\nHi, thank you for your answer.\
    \ I just wanted to make sure I fully understood the answer. Because of your first\
    \ example, I thought the code was sorting numbers, but it wasn't quite that simple.\
    \ The second example was a bit clearer for me to understand at the time (I haven't\
    \ had the opportunity to learn ruby for a while). Your code does seem to work,\
    \ but I wonder why it wouldn't work for the first example. Can you explain that\
    \ to me? Thanks again!\n<|/ c |>\n<| c |>\nThe first one doesn't work because\
    \ it's comparing strings instead of integers. \"1\" < \"10\" is true because strings\
    \ are compared left to right. Try calling `monotonic.call([1,\"2\",4,20])` and\
    \ see what happens.\n<|/ c |>\n<| c |>\nThanks, that makes a lot more sense. I've\
    \ read about comparing strings in Ruby and haven't encountered that before. Thanks\
    \ again\n<|/ c |>\n<| a dscore=1 |>\nI think the simplest thing to do is just\
    \ to sort by the absolute value of the difference between adjacent items.  I assume\
    \ that the order you want is that the first item is less than the last.\n<code>\n\
    require 'pp'", "  l.inject([]) do |results, x|\n    results.push(x.lt(results.last)\
    \ ? true : false)\n    results\n  end.reduce(:&)\nend", '  return l.first <= l.last',
  "  l.inject([]) do |lst, elt|\n    lst.last < elt ? lst << elt : lst.last\n  end\n\
    \  l.reduce(:<)\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice solution, although\
    \ I ended up just adding a `<=` method since my use-case was a bit more complicated\
    \ than my example.\n<|/ c |>\n<| c |>\nI'm glad to see you found a solution you\
    \ like! I added another solution, too, but it's less readable for me at the moment.\n\
    <|/ c |>\n<| a |>\nThe easiest solution is probably to add it as an instance method\
    \ to the Array class.\n<code>", "  l.sort!\n  l.each_cons(2).all?{|l, r| l <=>\
    \ r }\nend", "  l.each { |x| return false if x < l[l.size - 1] && x >= l[0] }\n\
    \  true\nend", "  l.inject([]) do |sum, (el, i)|\n    sum.last > el ? sum << el\
    \ : sum << sum.last\n    sum\n  end.length <= l.length\nend", "  l.sort { |a,\
    \ b| b <=> a } == l\nend", "  return l.first <= l.last\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
