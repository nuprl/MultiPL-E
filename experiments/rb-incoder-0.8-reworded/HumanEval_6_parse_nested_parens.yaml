name: HumanEval_6_parse_nested_parens
language: rb
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\"\
  )\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n\
  \    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"\
  (()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"\
  () (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"\
  ))\n  end\nend\n"
completions: ["  if paren_string == \"\"\n    []\n  else\n    paren_string.scan(/[(())]/)\
    \ do\n      level = paren_string.count(\"(\") - paren_string.count(\")\")\n  \
    \    return level if level > 0 && level < (paren_string.length - 1)\n      []\n\
    \    end\nend", "  return paren_string.split(\" \").map(&:length).max\nend\n</code>\n\
    <|/ a tags=ruby,string,arrays,nested-loops |>\n<| c |>\nThanks so much. Your answer\
    \ was so simple, yet it did the trick for me. Thank you.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. It works really well too, but I had to accept the other\
    \ one for its simplicity. I appreciate the effort you put into answering this\
    \ question, though. Thanks again for being so responsive.\n<|/ c |>\n<| a |>\n\
    <code>", "  res = []\n  paren_stack = paren_string.split(\"\")\n  level = 0\n\
    \  while paren_stack.size > 0\n    paren = paren_stack.pop\n    res << level\n\
    \    level += 1 if paren == \"(\" else -1\n    level -= 1 if paren == \")\" else\
    \ 0\n  res\nend", "  level = 0\n  parsed_parens = []\n  parsed_paren = nil\n \
    \ parentheses = paren_string.chars\n  parentheses.reverse!\n  parentheses.each\
    \ do |char|\n    if char == '('\n      level += 1\n    elsif char == ')'\n   \
    \   level -= 1\n    end\n    if level > 0\n      parsed_parens << level\n    end\n\
    \  end\n  parsed_parens.reverse!\n  parsed_parens.map { |i| i+1 }\nend", "  paren_count\
    \ = 0\n  max_level = 0\n  paren_stack = []\n  \n  open_parens = 0\n  open_paranthesis\
    \ = 0\n  \n  paren_stack << paren_string.length", "  # Get all nested parentheses.\n\
    \  nesting_parens = ParenthesesNesting.new(paren_string)\n  # Find maximum nested\
    \ parentheses.\n  max_depth = nesting_parens.max_nesting_depth\n  # Create a list\
    \ of nested parenthesis.\n  nesting_parens_list = nesting_parens.nesting_parens_list\n\
    \  # Get number of parentheses enclosed in the group.\n  max_enclosed_parentheses\
    \ = nesting_parens.max_enclosed_parentheses\n  # Create a list of nested parentheses\
    \ enclosed in the group.\n  nesting_parens_list_enclosed = nesting_parens.nesting_parens_list_enclosed",
  "  max_level = 0\n  levels = []\n  opening_parens = paren_string.count(\"(\")\n\
    \  closing_parens = paren_string.count(\")\")\n  level = 0\n  while opening_parens\
    \ > 0 or closing_parens > 0\n    opening_parens = paren_string.count(\"(\", level\
    \ + 1, opening_parens)\n    closing_parens = paren_string.count(\")\", level +\
    \ 1, closing_parens)\n    level += 1\n  end", "  groups = paren_string.split('\
    \ ')\n  max_level = 0\n  max_group_level = 0\n  current_level = 0\n  for i in\
    \ range(len(groups)):\n    group_level = current_level\n    group_str = groups[i]\n\
    \    current_level = group_str.count('(')\n    if current_level > max_level:\n\
    \      max_level = current_level\n      max_group_level = group_level\n  return\
    \ [max_group_level+1, max_level+1]\nend", "  paren_count = paren_count = 0\n \
    \ parentheses_level = []\n  paren_stack = [paren_string]", "  paren_level = 0\n\
    \  paren_depth = 0\n  paren_position = 0", "  paren_count = paren_string.count(\"\
    (\") - paren_string.count(\")\")\n  return [paren_count] + parse_nested_parens(paren_string.partition(\"\
    )\")[0])\nend\n</cell>\n<text>\nWe will use the previous function to count the\
    \ nesting level of each parentheses in the string. Let's see the output for our\
    \ simple case.", "  groups = paren_string.split(\" \").map { |g| g.to_i }\n  groups\
    \ = groups.inject([0]) { |memo, g| memo + g }\n  levels.reverse_each.with_index\
    \ { |level, n| levels[n] += groups[level] }\nend", "  return paren_string.scan(/\\\
    ((?:[^()]+|\\((?1)\\))+\\)/).flatten.size\nend\n</pre>\n</div>\n</div>\n</div>\n\
    \  \n<div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt\
    \ input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"text_cell_render\
    \ border-box-sizing rendered_html\">\n<p>We'll now define the function <code>count_chars</code>\
    \ to count the number of occurrences of each character in a string.</p>\n<ul>\n\
    <li>The <code>count_chars</code> function takes one argument - a string - and\
    \ returns a hash table of character frequencies.</li>\n<li>To get the number of\
    \ occurrences of a character in a string, we can simply use the <code>get</code>\
    \ method on the <code>Hash</code> object we created earlier.</li>\n<li>For example,\
    \ <code>count_chars('abracadabra')</code> returns <code>{\"a\"=3, \"r\"=2, \"\
    b\"=3, \"c\"=2}</code>.</li>\n</ul>", "  paren_stack = [0]\n  paren_stack.push(0)\n\
    \  max_level = 0", '  result = Array.new', "  max_depth = nil\n  depth_counter\
    \ = 0\n  paren_string.split(\" \").each do |paren_group|\n    depth_counter +=\
    \ 1 if paren_group =~ /^\\((.+)\\)$/\n    max_depth = depth_counter if max_depth.nil?\
    \ || max_depth > depth_counter\n    depth_counter = 1\n  end\n  max_depth\nend",
  "  level = 0\n  parentheses_nesting = [level] * MAX_NESTING\n  parentheses_nesting[0]\
    \ = 0\n  parentheses_nesting[1] = -1\n  parentheses_nesting[2] = -1", "  paren_count\
    \ = 0\n  paren_levels = [0] * len(paren_string)\n  paren_groups = [[]] * len(paren_string)\n\
    \  paren_groups[0] = paren_string\n  paren_level = -1\n  while True:\n    paren_count\
    \ += 1\n    if paren_count > len(paren_groups):\n      break\n    for i in range(len(paren_groups)):\n\
    \      if paren_levels[i] == -1:\n        paren_levels[i] = 0\n      elif paren_groups[i]\
    \ != paren_string:\n        paren_levels[i] = paren_levels[i - 1] + 1\n      \
    \  break\n  paren_max_level = 0\n  for i in range(len(paren_groups)):\n    if\
    \ paren_levels[i] > paren_max_level:\n      paren_max_level = paren_levels[i]\n\
    \  return paren_max_level\nend", "  level = 0\n  nesting_level = 0\n  depth =\
    \ 0\n  group_count = 0\n  levels = []\n  paren_string.split(\" \").each do |group|\n\
    \    if group == '('\n      level += 1\n      depth += 1\n    elsif group == ')'\n\
    \      level -= 1\n      depth -= 1\n    elsif group == ')('\n      level -= 1\n\
    \      nesting_level += 1\n    end\n    \n    levels += [level, nesting_level,\
    \ depth] if level <= nesting_level\n    group_count += 1\n  end\n  \n  if group_count\
    \ > 1\n    raise \"Too many groups in the string\"\n  else\n    levels = [*levels,\
    \ group_count]\n  end\n  \n  levels\nend", "  groups = paren_string.split(\" \"\
    )\n  groups = groups.map { |e| e.gsub(\")\", \"|) \").gsub(\"(\", \"|(\") }\n\
    \  groups.map!{ |e| e.split(\"|\") }\n  max = 0\n  groups.each do |group|\n  \
    \  if group.length < max\n      max = group.length\n    end\n  end\n  return max\n\
    end", "    level = 0\n    level_count = 0\n    last_open = paren_string.index('(')\n\
    \    last_close = paren_string.index(')')\n    result = []\n    \n    while(last_open\
    \ != -1 and last_close != -1 and last_close > last_open)\n        if level ==\
    \ 0 then\n            level += 1\n        elsif level > 0 and level_count < level\n\
    \            level += 1\n            level_count += 1\n            result.push(level\
    \ - 1)\n        elsif level > 0 then\n            level -= 1\n            level_count\
    \ -= 1\n            result.push(level)\n        elsif level == 0 and level_count\
    \ == 0 then\n            result.push(level - 1)\n            level -= 1\n    \
    \    end\n        last_open = paren_string.index('(', last_open + 1)\n       \
    \ last_close = paren_string.index(')', last_close + 1)\n    end", "  parentheses_count\
    \ = paren_string.count(\"(\")\n  parentheses_count += paren_string.count(\")\"\
    )\n  parentheses_count = parentheses_count.to_f", "  paren_string = paren_string.gsub(/\\\
    s+/, \"\") # Remove all spaces\n  max_level_of_nesting = 0\n  paren_groups = []\n\
    \  \n  paren_groups.each { |i| \n    i = i.gsub(/(\\()|(\\))/, \"\") # Remove\
    \ parentheses enclosed groups\n    if i.empty? \n      max_level_of_nesting =\
    \ 0\n      return\n    end\n    \n    if i.start_with?(\"(\")\n      max_level_of_nesting\
    \ += 1\n    elsif i.start_with?(\")\")\n      max_level_of_nesting -= 1\n    end\n\
    \  }\n  \n  return max_level_of_nesting\nend", "  paren_string.scan(/^\\(\\s*(.*\\\
    s*)\\)\\s*$/) {|m| return m.to_s.size}\nend", "  level = 1\n  max_level = 1\n\
    \  bracket_pairs = []\n  cur = 0\n  paren_count = 0\n  while cur < paren_string.length\n\
    \    if paren_string[cur] == paren_string[cur + 1]\n      cur += 1\n    else\n\
    \      bracket_pairs << paren_string[cur..cur + 2]\n      cur += 2\n    end\n\
    \  end\n  bracket_pairs.each do |bpair|\n    if level > max_level\n      max_level\
    \ = level\n    end\n    level += (bpair.count('(') - bpair.count(')'))\n  end\n\
    \  max_level\nend", "  return [\n    paren_string.count(\"(\") - paren_string.count(\"\
    )\") + 1,\n    paren_string.count(\"(\") + paren_string.count(\"(\") - paren_string.count(\"\
    )\") + 1,\n    paren_string.count(\"(\") + paren_string.count(\"(\") - paren_string.count(\"\
    )\"),\n    paren_string.count(\"(\") + paren_string.count(\"(\") - paren_string.count(\"\
    )\"),\n    paren_string.count(\"(\") + paren_string.count(\"(\") - paren_string.count(\"\
    )\"),\n  ]\nend", "  paren_count = 0\n  nested_paren_count = [0]", "  paren_string.scan(/([^()]+|(\\\
    (|\\))|())+/) do |group|\n    group.is_a?(Array) ? group.length : 1\n  end\nend",
  "  paren_stack = []\n  paren_count = 0", "  groups = paren_string.split \" \"\n\
    \  levels.each do |level|\n    if groups.size > level\n      max_level = level\n\
    \      groups.drop(level).each do |group|\n        if level <= levels[group]\n\
    \          max_level = levels[group]\n        end\n      end\n      return max_level\n\
    \    end\n  end\n  max_level = levels[0]\n  groups.each do |group|\n    if level\
    \ <= levels[group]\n      max_level = levels[group]\n    end\n  end\n  return\
    \ max_level\nend\n</code>\n<|/ a tags=algorithm,string,nested,ruby |>\n<| c |>\n\
    It's better but doesn't work for string like \"(()()) () ((())()())\", as OP states\
    \ in his example: \"this expression has 3 levels of nesting\". His example has\
    \ 2 levels of nesting. It looks like `levels` is returning only the deepest level\
    \ of nesting for each group of parentheses\n<|/ c |>\n<| c |>\nYou are right,\
    \ I fixed the code accordingly. Thank you for the notice.\n<|/ c |>\n<| c |>\n\
    Awesome! But `levels` doesn't work for string like `((())())`, as OP states in\
    \ his example: \"this expression has 3 levels of nesting\". His example has 2\
    \ levels of nesting. It looks like `levels` is returning only the deepest level\
    \ of nesting for each group of parentheses. I fixed the code accordingly.\n<|/\
    \ c |>\n<| a |>\nHere is another solution using regexp.\n<code>", '  return paren_string.scan(/\(|\)|
    \(\(|\)\)|\(\(|\)|\)\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\(|\)|\',
  "  paren_string.gsub!(/\\s/, \"\") # remove spaces\n  return paren_string.gsub(/\\\
    (\\(?[()]\\)?\\)|\\(\\(?[()]\\)?\\)|(\\(\\(?[()]\\)?\\))/) { |m|\n    m.to_i }\n\
    end", "  openings = 0\n  paren_depths = []\n  paren_depth = 0\n  paren_depth_max\
    \ = 4\n  while openings < paren_depth_max\n    openings += 1\n    paren_level\
    \ = (paren_depth + openings) / paren_depth_max\n    opening_closed = paren_depth\
    \ * paren_depth + openings - paren_level * paren_depth\n    if paren_level < 0\n\
    \      break\n    paren_depth = paren_depths[paren_level]\n    paren_depths[paren_level]\
    \ += 1\n  end\n  paren_depths.map { |depth| depth * paren_depth }.max\nend", " \
    \ paren_string.count('(', 0, 0) - paren_string.count(')', 0, 0)\nend", "  nesting\
    \ = 0\n  paren_string_parts = paren_string.split(\" \").map { |s| s.strip }\n\
    \  paren_string_parts.each do |paren_string|\n    par = paren_string.strip\n \
    \   if par == \"(\" then\n      nesting += 1\n    elsif par == \")\" then\n  \
    \    nesting -= 1\n      if nesting == 0 then\n        return nesting\n      end\n\
    \    end\n  end\n  return -1\nend", "  nested_parens = ParenLevelFinder.new(paren_string)\n\
    \  \n  max_level = 0\n  level_of_nesting = []\n  level_of_nesting.push(0)\n  while\
    \ level_of_nesting.any?\n    level_of_nesting = level_of_nesting.pop\n    current_level\
    \ = level_of_nesting.pop\n    level_of_nesting.push(current_level+1)\n    \n \
    \   if max_level < current_level\n      max_level = current_level\n      nesting_level\
    \ = level_of_nesting.last\n      \n      while nesting_level > 0\n        level_of_nesting.push(nesting_level-1)\n\
    \        nesting_level = level_of_nesting.last\n      end\n      \n      level_of_nesting.push(nesting_level+1)\n\
    \    end\n  end\n  \n  max_level\nend", "  paren_string = paren_string.to_s.gsub(/\\\
    s+/, \" \").gsub(/\\(|\\)/, \"\") # remove all spaces and parentheses.\n  paren_groups\
    \ = paren_string.scan(/[^(]+|\\(|\\)|\\(?[^()]+\\)|\\(?[^()]+\\))|\\(?[^()]+\\\
    )?|\\(?[^()]+\\))|(?<=[(])[^(]+|\\(?[^()]+\\)|\\(?[^()]+\\))|(?<=[(])[^(]+\\)?|\\\
    (?[^()]+\\))/)\n  max_level = 0\n  result = []\n  last_group = 0\n  last_group_level\
    \ = 1\n  for i in paren_groups\n    if i[1].nil?\n      level = 1\n    else\n\
    \      level = 0\n    end\n    if level > max_level\n      max_level = level\n\
    \    end\n    last_group = i[0].to_i\n    last_group_level = level\n    result\
    \ << last_group\n  end\n  if paren_groups.first && paren_groups.first.size > 1\n\
    \    result << max_level\n  end\n  return result\nend", "  result = parse_nested_parens_helper(paren_string,\
    \ \"\")\n  if result\n    return result\n  else\n    return [0]\nend", "  paren_string.strip!\n\
    \  max_level = -1\n  result_list = []\n  parens_stack = Stack.new", "  level =\
    \ 0\n  while level < paren_string.length\n    level_char = paren_string[level]\n\
    \    case level_char\n    when '('\n      level += 1\n    when ')'\n      level\
    \ -= 1\n    when ' '\n      level += 1\n    when '\\n'\n      level += 1\n   \
    \ when '\\t'\n      level += 1\n    when '\\r'\n      level += 1\n    end\n  end\n\
    \  paren_string.split(' ').map do |char|\n    case char\n    when '('\n      1\n\
    \    when ')'\n      0\n    when '\\n'\n      1\n    when '\\t'\n      1\n   \
    \ end\n  end\nend", "  paren_string.gsub!(/\\([)]\\)/, '')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\(([^()]*\\))\\)/, '\\2')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\\
    ([^()]*\\))/, '\\1')\n  paren_string.gsub!(/(\\([^()]*", "  paren_count = 0\n\
    \  max_level = -1\n  nesting_level = 0\n  current_level = 0\n  stack = []\n  paren_string.split(\"\
    \ \").each do |char|\n    if char == \"(\"\n      paren_count += 1\n      stack.push\
    \ nesting_level\n      nesting_level += 1\n    elsif char == \")\"\n      paren_count\
    \ -= 1\n      if paren_count < 1\n        current_level = stack.pop\n        if\
    \ nesting_level > max_level\n          max_level = nesting_level\n        end\n\
    \      end\n      nesting_level = current_level\n    end\n  end\n  if nesting_level\
    \ > max_level\n    max_level = nesting_level\n  end\n  max_level\nend", "  paren_string.scan(/[^\\\
    (\\)]+/).map do |paren|\n    paren.scan(/([^\\(\\)]+(?=[^\\(\\)]*\\)))/).map(&:size).max_by(&:last).last\n\
    \  end\nend", "  paren_string.split(\" \").map do |paren_string|\n    paren_string.gsub(/\\\
    (|\\)/) { |match| match.length == 0 ? \"\" : parse_nested_parens(match) }\n  end.reduce(:+)\n\
    end", "  depth = 0\n  nested_paren_strings = paren_string.split(\" \").map do\
    \ |paren_string|\n    paren_string.gsub(/\\(/, '')\n      .gsub(/\\)/, '')\n \
    \     .gsub(')', ')()')\n      .gsub(')', ')()()')\n      .gsub(')', ')()()()')\n\
    \      .gsub(')', ')()()()()')\n      .gsub(')', ')()()()()()')\n      .gsub(')',\
    \ ')()()()()()()')\n      .gsub(')', ')()()()()()()()')\n      .gsub(')', ')()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()()()()()()()()()')\n\
    \      .gsub(')', ')()()()()()()()()()()()()()()()()()')\n      .gsub(')', ')()()()()()()()()",
  "  level = 0\n  stack = []\n  paren_count = 0\n  result = []\n  paren_stack = []",
  "  paren_chars = paren_string.gsub(/[\\(\\)]/, '').chars\n  paren_levels = []\n\
    \  i = 0\n  while i < paren_chars.length\n    if paren_chars[i] == '('\n     \
    \ i += 1\n      while i < paren_chars.length and paren_chars[i] != ')'\n     \
    \   i += 1\n      paren_levels += [i]\n      i += 1\n      while i < paren_chars.length\
    \ and paren_chars[i] != ')'\n        i += 1\n    else # paren_chars[i] == '#'\n\
    \      i += 1\n    end # else paren_chars[i] == '#'\n  end # while i < paren_chars.length\n\
    \  return paren_levels\nend # def parse_nested_parens(paren_string)", "  paren_count\
    \ = paren_string.count('(')\n  paren_count += paren_string.count(')')\n  return([paren_count\
    \ for i in range(0, paren_count)])\nend", "  paren_tokens = paren_string.split(\"\
    \ \")\n  paren_tokens.map!(&:chomp)\n  paren_tokens.map!(&:strip)\n  paren_tokens.map!(&:strip!)",
  "  # Split each element of input string by space and convert to list where each\
    \ element is a group.\n  # E.g. (()()) will be converted to [(), ()] where each\
    \ element is a group.\n  groups_list = paren_string.split(\" \")\n  # Calculate\
    \ the depth of nesting of each group.\n  # E.g. (()) has maximum nesting while\
    \ ((())) has three levels of nesting.\n  # So for each group, set its maximum\
    \ level of nesting to its depth.\n  group_depth = [len(groups_list[0])]\n  # Keep\
    \ track of level which is currently being processed.\n  current_depth = 0\n  #\
    \ Keep track of whether we are currently in a group.\n  current_group = False\n\
    \  # Keep track of the current maximum level of nesting for each group.\n  max_group_depth\
    \ = 0\n  # For each group, set the level of nesting to its depth by adding its\
    \ group depth to the current group depth.\n  # If we are in a group, ignore any\
    \ nested parentheses.\n  for i in range(len(groups_list)):\n    # If the current\
    \ group is currently being processed, ignore any nested parentheses.\n    if current_group\
    \ == True:\n      continue\n    # If the current group has a nested level of parentheses,\
    \ add it to the current group depth.\n    elif groups_list[i][0] == '(':\n   \
    \   group_depth.append(group_depth[current_depth] + 1)\n      current_depth +=\
    \ 1\n      # Increment the current group depth.\n      current_group = True\n\
    \      # Set the maximum level of nesting for each group to its group depth.\n\
    \      max_group_depth = group_depth[current_depth]\n      # If we are at the\
    \ deepest level of nesting, set the current depth to 0.\n      if current_depth\
    \ == max_group_depth:\n        current_depth = 0\n    else:\n      group_depth[current_depth]\
    \ += 1\n      # Increment the current group depth.\n      current_group = False\n\
    \  return group_depth\n    ", "  max_nesting = 0\n  level = 1\n  paren_count =\
    \ 0\n  tokens = paren_string.split()\n  while not tokens.empty?\n    token = tokens.shift()\n\
    \    if token == \"(\"\n      paren_count += 1\n    elsif token == \")\"\n   \
    \   paren_count -= 1\n    elsif paren_count < 0\n      max_nesting = level\n \
    \   elsif paren_count == 0\n      level += 1\n    end\n  end\n  max_nesting\n\
    end", "  depth = 0\n  parens = []\n  \n  # The regex below is just for demonstration\
    \ and is not perfect.\n  paren_string.split(\"\").each_with_index do |char, i|\n\
    \    if char == \")\"\n      if depth == 0\n        raise \"Unexpected closing\
    \ parenthesis: #{char}\"\n      elsif parens[-1] == char\n        parens.delete\
    \ char\n        depth -= 1\n      else\n        raise \"Unexpected unclosed parenthesis:\
    \ #{char}\"\n      end\n    elsif char == \"(\"\n      depth += 1\n      parens\
    \ << char\n    elsif depth > 0\n      parens[-1] = char\n    end\n  end\n  \n\
    \  parens.inject { |acc, curr| acc + 1 } - 1\nend\n</code>\n<|/ a tags=ruby,string,arrays,depth,parentheses\
    \ |>\n<| c |>\nI added one more for fun, just for fun. :-) I believe it has the\
    \ same asymptotic time complexity as the other answers, but it's just for fun.\n\
    <|/ c |>\n<| c |>\nYour solution is better because it handles unbalanced parentheses\
    \ and is more efficient in terms of memory usage by just using `split`\n<|/ c\
    \ |>\n<| a tags=ruby,string,arrays,depth,parentheses dscore=2 |>\n<code>", " \
    \ nesting = [0]\n  paren_string_arr = paren_string.split \" \"", "  parentheses_stack\
    \ = Array.new(1) { 0 }\n  parentheses_stack.push(0)\n  group_count = 0\n  parentheses_count\
    \ = 0\n  paren_string.each_char do |char|\n    if char == ')'\n      parentheses_count\
    \ -= 1\n    elsif char == '('\n      parentheses_count += 1\n    elsif char ==\
    \ ')' and parentheses_count == 0\n      parentheses_stack.push(group_count)\n\
    \      parentheses_count += 1\n      group_count += 1\n      parentheses_count\
    \ += 1\n    end\n  end\n  parentheses_stack.last\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nThe problem is in the `if char == '('` part\n<|/ c |>\n<| c |>\n\
    yes, but the only thing that can happen is that you end up with 0 parentheses\
    \ left on the stack. In that case, `parentheses_stack.last` returns -1. I'll change\
    \ it.\n<|/ c |>\n<| c |>\nI actually meant that `if char == '(' and parentheses_count\
    \ == 0` since if parentheses count is 0 then parentheses_stack.last will return\
    \ -1\n<|/ c |>\n<| a |>\nHere's a recursive implementation:\n<code>", "    paren_stack\
    \ = []\n    paren_count = 0\n    paren_max_depth = 0\n    paren_max_count_stack\
    \ = []\n    paren_count_stack = []\n    paren_count_stack_len = []\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n  \
    \  paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n    paren_count_stack_len.append(0)\n\
    \    paren_count_stack_len.append(0)\n    paren_", "  paren_depth = [0]\n  paren_stack\
    \ = []\n  paren_stack.push(0)\n  paren_stack.push(0)\n  paren_stack.push(0)\n\
    \  paren_stack.push(0)\n  paren_depth[0] = paren_depth[0] + 1 # Since we initially\
    \ want to count the parenthesis.\n  paren_stack.each do |val|\n    if val > 0\n\
    \      paren_stack.push(val)\n    end\n    paren_depth[val] = paren_depth[val]\
    \ - 1\n  end\n  return paren_depth\nend", "  paren_string.strip!\n  max_level\
    \ = 0\n  paren_levels = Array.new\n  paren_levels << 0\n  \n  paren_levels.each\
    \ do |level|\n    paren_levels[level] += 1\n    \n    if paren_levels[level] >\
    \ max_level\n      max_level = paren_levels[level]\n    end\n  end\n  \n  max_level\n\
    end", "    nesting_level = 0\n    # Parse all groups in one shot.\n    groups\
    \ = paren_string.gsub(/\\s*\\(([^()]+)\\)\\s*/, '').split /\\s+/\n    nesting_levels.zip(groups).each_with_index\
    \ do |(nesting_level, group), i|\n        i += 1\n        if group == '('\n  \
    \          nesting_level += 1\n            groups[i]\n        elsif group == ')'\n\
    \            nesting_level -= 1\n            groups[i] if nesting_level == 0\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=ruby,regex dscore=2 |>\n<| a tags=ruby,regex\
    \ |>\n<code>\n\"((())())((()))(())\" =~ /^(\\([^()]*\\)){0,3}/\n</code>\nor\n\
    <code>\n\"((())())((()))(())\" =~ /^(?:\\([^()]*\\)){0,3}/\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nNice, I had no idea that Ruby RegEx could do that kind of thing.\
    \ Though I think the second one should be `/^(?:\\([^()]*\\)){0,3}/`. To catch\
    \ only the first level of nesting.\n<|/ c |>\n<| a dscore=1 |>\nHere's a non-recursive\
    \ solution:\n<code>", "  # Use a stack to keep track of level of nesting of parantheses.\n\
    \  # Return list of level of nesting of parentheses.\n  paren_stack = [0]\n  depth_list\
    \ = []\n  \n  for i in 0..paren_string.length - 1\n    ch = paren_string[i]\n\
    \    if ch == '('\n      paren_stack.push i\n    elsif ch == ')'\n      # Get\
    \ level of nesting of parentheses.\n      nest_level = paren_stack.pop\n     \
    \ \n      # Add level of nesting to list of levels.\n      depth_list.push nest_level\n\
    \  \n  depth_list.push 0\n  return depth_list\nend", "  result = []\n  level =\
    \ 0\n  pos = 0\n  while pos < paren_string.length\n    opening = paren_string[pos]\n\
    \    if opening? == '('\n      level += 1\n    elsif opening? == ')'\n      level\
    \ -= 1\n      if level == 0\n        result << level\n      end\n    end\n   \
    \ pos += 1\n  end\n  result\nend", "  groups = paren_string.split(\" \").map(&:to_i).inject(:+)\n\
    \  max_count = groups.max || -1\n  max_count != -1 ? [max_count] : []\nend", " \
    \ paren_tokens = paren_string.split \" \"\n  paren_tokens[0..-2].inject([]) {\
    \ |acc, token| acc << acc.length }.reverse.map { |level| paren_tokens.count(token)\
    \ }.reduce(:+)\nend", "  result = []\n  opening_count = 1\n  paren_stack = []\n\
    \  paren_count = 0\n  paren_level = 0\n  for i in paren_string\n    if i == '('\n\
    \      paren_count += 1\n      paren_stack << paren_count\n    elsif i == ')'\n\
    \      paren_count -= 1\n      if paren_stack.size == 0\n        result << paren_level\n\
    \      elsif paren_stack.size == paren_count\n        result << paren_level\n\
    \      else\n        result << paren_stack.last\n        result << paren_stack.size\n\
    \      end\n      paren_stack = paren_stack.last(paren_count)\n    end\n    result\
    \ << i\n  end\n  if paren_stack.size == 0\n    result << paren_level\n  end\n\
    \  return result\nend", "  level = 0\n  parentheses = paren_string.count(\"(\"\
    , paren_string.count(\")\")) + 1\n  result = [parentheses]\n  paren_stack = []\n\
    \  paren_stack[0] = paren_string\n  while level > 0 or paren_stack.count > 0\n\
    \    level += 1\n    if paren_stack.count > 0\n      new_level = paren_stack.count\n\
    \      paren_stack.rotate(-1)\n    else\n      new_level = 0\n    stack_string\
    \ = paren_stack.last\n    paren_stack.last = 0\n    paren_stack.push(stack_string)\n\
    \    if new_level == 0\n      new_level = level\n    end\n    for parens in 1..new_level\n\
    \      parens = paren_string.count(\"(\", paren_string.count(\")\"))\n      paren_stack.push(paren_string)\n\
    \    end\n    paren_stack.rotate(1)\n  end\n  return result\nend", "  # Parsing\
    \ each group\n  max_level = paren_string.count(\"(\")\n  result = []\n  i = 0\n\
    \  while i < paren_string.length\n    group = paren_string[i..i+max_level]\n \
    \   if group.length <= max_level\n      # Just one level group\n      result[i]\
    \ = group.length\n      i += group.length - 1\n    else\n      # Recursively calling\
    \ parse_nested_parens for each of the group\n      result << parse_nested_parens(group)\n\
    \      i += 1\n    end\n  end\n  return result\nend", "  paren_string_arr = paren_string.split(\"\
    \ \")\n  max_level = 0\n  current_level = 0\n  stack = []\n  paren_chars = []\n\
    \  paren_chars_map = {}\n  paren_chars_stack = []\n  max_level_stack = []", " \
    \ strings = paren_string.split(' ')\n  strings[-1] = strings[-1].strip\n  strings\
    \ = [strings[i].strip! for i in 0...(strings.length - 1)]\n  depth = strings.length\n\
    \  while strings.length > 0\n    strings[strings.length-1] = strings[strings.length-1].strip\n\
    \    depth += 1\n  end\n  return depth\nend\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ dscore=2 tags=ruby,parentheses |>\nYet another solution using regexp. This one\
    \ is more efficient than the recursive solutions posted here.\n<code>", "  max_level\
    \ = 0\n  level_count = Hash.new(0)\n  paren_chars = paren_string.chars\n  paren_char\
    \ = paren_chars.next\n  while !paren_chars.nil?\n    if paren_char == ')'\n  \
    \    level = level_count.delete paren_char\n      if level > max_level\n     \
    \   max_level = level\n      end\n    elsif paren_char == '('\n      level_count[paren_char]\
    \ += 1\n    end\n    paren_char = paren_chars.next\n  end\n  max_level\nend",
  "  paren_array = paren_string.split(\" \") # Split into array.\n  paren_count =\
    \ 0\n  max_count = 0\n  \n  # Keep track of the deepest level encountered.\n \
    \ max_level = 0\n  \n  # For each of the array.\n  for i in 0..paren_array.length-1\n\
    \    \n    # If current element is the opening parenthesis.\n    if paren_array[i]\
    \ =~ /^\\(/\n      \n      # If this level is greater than max level, update max\
    \ level.\n      if paren_count > max_level\n        max_level = paren_count\n\
    \      \n      # If current level is equal to max level, increment the count by\
    \ 1.\n      elsif paren_count == max_level\n        paren_count += 1\n      else\n\
    \        # Reset count\n        paren_count = 1\n      end\n    else\n      #\
    \ If current element is the closing parenthesis.\n      if paren_array[i] =~ /^\\\
    )$/\n        \n        # If this level is greater than max level, update max level.\n\
    \        if paren_count > max_level\n          max_level = paren_count\n     \
    \   end\n        \n        # If current level is equal to max level, decrement\
    \ the count by 1.\n        if paren_count == max_level\n          paren_count\
    \ -= 1\n        else\n          # Reset count\n          paren_count = 1\n   \
    \     end\n      else\n        paren_count += 1 # Increment count.\n      end\n\
    \    end\n  end\n  \n  # Return max level.\n  return max_level\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,regex |>\nI prefer a recursive solution:\n<code>",
  "  max_level_of_nesting = 1\n  paren_chars = paren_string.chars\n  paren_level =\
    \ 0\n  paren_counter = 0\n  paren_nesting_depth = 0\n  \n  while paren_counter\
    \ < paren_chars.length\n    paren_char = paren_chars[paren_counter]\n    \n  \
    \  # Handle a opening parenthesis.\n    if paren_char == \"(\"\n      paren_level\
    \ += 1\n      paren_counter += 1\n    \n    # Handle a closing parenthesis.\n\
    \    elif paren_char == \")\"\n      paren_level -= 1\n      \n      # Check if\
    \ this is the deepest level of nesting possible\n      max_level_of_nesting =\
    \ paren_level if paren_level > max_level_of_nesting else max_level_of_nesting\n\
    \      \n      if paren_level == 0\n        break # End of parenthesis sequence.\n\
    \      end\n      \n      paren_counter += 1\n      \n    end\n    \n  end\n \
    \ \n  paren_nesting_depth = max_level_of_nesting\n  \n  return max_level_of_nesting\n\
    end\n</cell>\n<text>\nTest Cases", "    level = 0\n    stack = []\n    paren_count\
    \ = 0\n    paren_symbol = ''\n    paren_symbol_count = 0\n    level_count = 0\n\
    \    level_symbol = ''\n    level_symbol_count = 0\n    paren_open = False\n \
    \   level_open = False", "  paren_nesting_levels = paren_string.scan(/(?:\\((?>[^()]+|\\\
    ((?<paren>)|\\)(?<paren>))*\\))+/g).map {|i| i[0] ? i[0].count(\"(\") - i[0].count(\"\
    )\") : 0 }\n  paren_nesting_levels.max\nend\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nFor those who can't make sense of the regex, here are some helpful links\
    \ to explain: [link to explanation of regex](http://www.regular-expressions.info/refflavors.html)\
    \ and [link to explanation of (?<name> syntax](http://www.regular-expressions.info/named.html)\n\
    <|/ c |>\n<| c |>\nI wonder why this solution doesn't have more upvotes. This\
    \ is definitely the simplest and most effective one. The only problem with this\
    \ approach is that it only works in Ruby. I was looking for a solution that would\
    \ work in both Python and Ruby, so I ended up implementing a custom solution in\
    \ Python (which is not too difficult once you understand regex)\n<|/ c |>\n<|\
    \ c |>\n: this solution isn't too simple.  It has two bugs I see with it -- it\
    \ fails on expressions like `(a) + (b)`, which should be returning `[1, 0]`; it\
    \ also fails with expressions like `(a+b+c)*(d+e+f)`, which should return `[6,\
    \ 4, 5]`, not `[6, 4, 5, 5]`.  All of the bugs are in fact bugs in the way the\
    \ regex is written.  It's not hard to fix those bugs.  I've added a new answer\
    \ showing how to fix those bugs.\n<|/ c |>\n<| c |>\n: I added a Python implementation.\
    \  It's a little more complicated than this because it's parsing something that\
    \ has parentheses inside parentheses, so it needs to do a little extra work recognizing\
    \ that a paren inside a paren inside a paren inside a paren inside a paren inside\
    \ a paren inside a paren inside a paren inside a paren inside a paren inside a\
    \ paren inside a paren inside a paren inside a paren inside a paren inside a paren\
    \ inside a paren inside a paren inside a paren inside a paren inside a paren inside\
    \ a paren inside a paren inside a paren inside a paren inside a paren inside a\
    \ paren inside a paren inside a paren inside a paren inside a paren inside a paren\
    \ inside a paren inside a paren inside a paren inside a paren inside a paren inside\
    \ a paren inside a paren inside a paren inside a paren inside a paren inside a\
    \ paren ", "  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  paren_stacks = []\n  paren_levels_set\
    \ = false\n  paren_count = 0\n  paren_levels = []\n  ", "  return paren_string.scan(/[^()]*(\\\
    ((?1)+\\))[^()]*/).flatten.compact.uniq.size\nend", "  paren_stack = []\n  max_nested_level\
    \ = 0\n  paren_level = 0", "  paren_string.scan(/[()]/) do |char|\n    case char\n\
    \    when ')'\n      nesting_level += 1\n    when '('\n      nesting_level -=\
    \ 1\n    end\n  end\n  nesting_level\nend", "  # The input string can be invalid\
    \ so we just output an empty list.\n  parsed_list = []\n  if paren_string.empty?\n\
    \    parsed_list << 0\n  elsif paren_string.chars.all? { |c| c == '(' || c ==\
    \ '[' }\n    # If the paren string is valid, then parse it recursively.\n    parsed_list\
    \ = parse_nested_parens(paren_string[1..-1])\n  elsif paren_string.chars.all?\
    \ { |c| c == '(' }\n    # If the paren string is valid, then parse it recursively.\n\
    \    parsed_list = parse_nested_parens(paren_string[1..-1])\n  elsif paren_string.chars.all?\
    \ { |c| c == ')' }\n    # If the paren string is valid, then parse it recursively.\n\
    \    parsed_list = parse_nested_parens(paren_string[1..-1])\n  elsif paren_string.chars.all?\
    \ { |c| c == ']' }\n    # If the paren string is valid, then parse it recursively.\n\
    \    parsed_list = parse_nested_parens(paren_string[1..-1])\n  elsif paren_string.chars.all?\
    \ { |c| c == ')' || c == ']' }\n    # If the paren string is valid, then parse\
    \ it recursively.\n    parsed_list = parse_nested_parens(paren_string[1..-1])\n\
    \  else\n    parsed_list << 0\n  end\n  parsed_list\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like this solution, though it is more verbose than `parse_tree` solution.\n\
    <|/ c |>\n<| c |>\nI like the recursive solution. It works well with nested parenthesis\
    \ having one additional level. Thank you !\n<|/ c |>\n<| c |>\nWhat about nested\
    \ parenthesis without additional level?\n<|/ c |>\n<| a tags=ruby,algorithm |>\n\
    You don't need recursion, just use string splitting and pattern matching:\n<code>",
  "  level = 0\n  paren_stack = []\n  paren_count = 0\n  nested_parens = []\n  parsing_done\
    \ = false\n  last_char = \"\"", "  paren_string = paren_string.gsub(/\\(|\\)|\\\
    )/, \"\")\n  return paren_string.scan(/\\(([^()]*)\\)/).map{|parens| parens.map{|x|\
    \ x.count('(') - x.count(')')}}.max\nend", "  paren_nesting = -1\n  last_pos =\
    \ 0\n  paren_pairs = paren_string.split(' ')\n  paren_pairs.each do |paren_pair|\n\
    \    if paren_nesting > 0\n      if paren_pair == '('\n        paren_nesting +=\
    \ 1\n      elsif paren_pair == ')'\n        paren_nesting -= 1\n      end\n  \
    \  else\n      paren_nesting = paren_pair\n      last_pos = paren_pair.size -\
    \ 1\n    end\n  end\n  paren_nesting -= 1\n  paren_pairs[last_pos]\nend", "  paren_string.gsub!(/\\\
    s*\\)\\s*\\)/, \")\")\n  paren_string.gsub!(/\\s*\\(([^)]*)\\)/, \"(\\2)\")\n\
    \  paren_string.gsub!(/(\\(\\(([^)]*)\\)([^()]*))*\\))/, \"\\\\1\\\\2\\\\3\\\\\
    2\")\n  paren_string.gsub!(/(\\(([^)]*)\\))/, \"\\\\1\\\\2\")\n  paren_string.gsub!(/([^(]*)(\\\
    (.*?\\))/, \"\\\\2\\\\1\")\n  paren_string.gsub!(/([^(]*)(\\([^)]*\\))/, \"\\\\\
    1\\\\2\")\n  paren_string.gsub!(/(\\([^)]*\\))/, \"\\\\1\")\n  return paren_string.count(\"\
    (\")\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but note\
    \ that it fails in situations where there are nested `()` inside other parentheses,\
    \ like `(((((((())))())))()())`. [Here](https://regex101.com/r/vzvYc6/1) is a\
    \ link to what this regex matches.\n<|/ c |>\n<| c |>\nI like the idea of the\
    \ recursive regex, but I couldn't get it to work for me (it only matched some\
    \ strings and not others, which is why I ended up writing a brute-force recursive\
    \ solution).\n<|/ c |>\n<| c |>\nOh that's interesting - I guess that's not really\
    \ the definition of \"parentheses nesting\". `((()))` is one level nesting and\
    \ `((()()))` is two. I'd say this is one level nesting, as `((())())` has three\
    \ levels of nesting.\n<|/ c |>\n<| c |>\nYes, you are right. But I thought I was\
    \ defining that in my comment :-)\n<|/ c |>\n<| c |>\nOh thank you for the comment!\
    \ I added a note at the top of my answer to indicate this.\n<|/ c |>\n<| a tags=regex,ruby\
    \ |>\nI made a recursive function to solve this problem and here is my implementation\n\
    <code>", "  # TODO: Use stack to improve performance\n  level_stack = [0]\n  parsed_parens\
    \ = []", "  tokens = paren_string.split(\"()\")\n  levels = [0]\n  for i in 0..tokens.length-1\n\
    \    levels[i+1] = levels[i]+(1 if tokens[i].match(/\\(.*?\\)$/) =~ /\\(/) end)\n\
    \  end\n  levels.length\nend\n</code>\n<|/ a tags=string,ruby dscore=1 |>\n<|\
    \ c |>\n\"For each of the group, output the deepest level of nesting of parentheses.\"\
    \ should be \"For each of the group, output the deepest level of nesting of parentheses\
    \ separated by spaces.\"\n<|/ c |>\n<| a dscore=1 |>\nHere's a more readable version\
    \ using regular expressions. I used a negative lookahead to match parenthesized\
    \ strings, but you could do it just as well with positive lookbehind, or just\
    \ with positive lookahead. The only difference between the two lookarounds is\
    \ that lookahead checks that the next token is a parenthesized string, and lookbehind\
    \ checks that it's not, but that doesn't really matter here since you're looking\
    \ for balanced parentheses.\n<code>", "  paren_string.split(\" \").map.with_index\
    \ do |group, i|\n    depth = paren_string.scan(/\\(|\\)/).length - i\n    puts\
    \ depth\n  end\nend", "  \n  paren_count = 0\n  open_paren_count = 0\n  \n  max_nesting\
    \ = 0\n  \n  paren_string.scan(/(\\(\\S*\\))|(\\((\\S*)\\))/) { |m|\n    \n  \
    \  open_paren_count += 1 if m[1]\n    \n    max_nesting += 1 if m[2]\n    \n \
    \   open_paren_count -= 1 if m[3]\n    \n    if open_paren_count == 0\n      \n\
    \      max_nesting = open_paren_count if max_nesting.zero?\n      \n      max_nesting\
    \ += 1 if open_paren_count > max_nesting\n      \n      open_paren_count = 0\n\
    \      \n    end\n    \n  }\n  \n  return max_nesting\nend", "  paren_string.squeeze!(\"\
    \ \")\n  paren_string.squeeze!(\"()\")\n  paren_string.scan(/(?:[^()]+|\\([^()]*\\\
    ))+\\(\\)/) do |m|\n    levels = m[0].count(\"(\") - m[0].count(\")\")\n    if\
    \ levels == 0\n      m[0]\n    else\n      m[0].count(\"(\").times {|i| m[0].delete(i)\
    \ }\n      m[0].count(\")\").times {|i| m[0].insert(m[0].size, \")\") }\n    end\n\
    \  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhat about `(((()))`? Or `()((())`?\n\
    <|/ c |>\n<| c |>\nYeah, I noticed that after I posted, but I didn't think about\
    \ `()((()))`.\n<|/ c |>\n<| c |>\nThis code breaks on `\"((()))\"`.\n<|/ c |>\n\
    <| a dscore=4 |>\nAnother implementation for those who like to live dangerously\
    \ (for whatever reason).\n<code>", "  return parse_nested_parens_recurse(paren_string,\
    \ -1)\nend", "  paren_depth = [0]\n  while paren_string.present?\n    if paren_string.chars.to_a.include?('()')\n\
    \      while paren_depth.last < paren_depth.length\n        paren_depth.push(0)\n\
    \      end\n      levels_of_nesting = paren_depth.length - 1\n    else\n     \
    \ levels_of_nesting = 0\n    end\n    paren_string.slice!('()')\n    paren_depth.pop\n\
    \    paren_depth.last = (paren_depth.last + levels_of_nesting) + 1\n  end\n  return\
    \ paren_depth\nend", "  paren_string.gsub!(/([()]+)/, '\\\\1') # get rid of outer\
    \ parens\n  paren_string.gsub!(/\\(/, '') # get rid of inner parens\n  groups\
    \ = []\n  nesting = 1\n  parens = paren_string.gsub!(/\\)/, '').gsub(/\\(/, '').split('\
    \ ') # split into multiple groups\n  parens.each do |x|\n    if x.empty?\n   \
    \   groups.push(nesting)\n    else\n      nesting += 1\n      groups.push(nesting)\n\
    \    end\n  end\n  groups.max_by { |x| x }\nend", "    stack = []\n    curr_level\
    \ = 1\n    stack_string = []\n    stack_strings = []\n    level = 0\n    depth\
    \ = 0\n    levels = []\n    while curr_level <= 0 do\n        depth = level -\
    \ 1\n        level = []\n        levels = [level]\n        stack_string = [paren_string]\n\
    \        stack_strings = [stack_string]\n        level = level + 1\n        curr_level\
    \ = level\n        while level <= depth do\n            parens_count = stack_string[level].count(\"\
    (\") - stack_string[level].count(\")\")\n            level[parens_count] = level[parens_count]\
    \ + 1\n            stack.push(parens_count)\n            stack_string = stack_string\
    \ + stack_strings[level]\n            levels = levels + [stack_string]\n     \
    \       level = level + 1\n        stack = stack - 1\n    end", "  # The return\
    \ value is a list of the number of levels of nesting encountered in the string.\n\
    \  paren_levels = []\n  paren_stack = []\n  paren_count = 0", "  paren_levels\
    \ = [0]\n  paren_count = paren_levels.length\n  paren_string.gsub(/(\\([^()]*\\\
    ))|(\\(([^()]*\\))*\\))/) do |str|\n    if paren_levels.length > 0\n      new_level\
    \ = paren_levels[paren_count - 1] + 1\n      paren_levels.push(new_level)\n  \
    \    paren_count = paren_levels.length\n    end\n    str = str.strip\n    case\
    \ str\n    when \"(\", \"[\", \"{\" then paren_levels.pop\n    when \")\", \"\
    ]\", \"}\" then paren_levels.delete_at(-1)\n    end\n  end\n  paren_levels.delete_at(0)\n\
    end", "  paren_array = paren_string.split(' ')\n  max_level = 0\n  result = []\n\
    \  paren_level = 0\n  max_level_paren = 0\n  paren_level_paren = 0\n  paren_pair\
    \ = []\n  for i in paren_array\n    if i == '('\n      paren_level += 1\n    \
    \  paren_level_paren += 1\n      if paren_level_paren > max_level_paren\n    \
    \    max_level_paren = paren_level_paren\n    if i == ')'\n      paren_level -=\
    \ 1\n      paren_level_paren -= 1\n      max_level_paren += 1\n    if paren_level\
    \ > max_level\n      max_level = paren_level\n      max_level_paren = paren_level_paren\n\
    \    paren_pair << paren_level\n  end\n  for i in paren_array\n    if i == ')'\n\
    \      paren_pair << paren_level_paren\n    end\n  end\n  paren_pair << max_level\n\
    \  result.push max_level_paren\n  result2 = []\n  for i in paren_pair\n    if\
    \ i > 0\n      result2.push i\n    end\n  end\n  return result\nend\n</cell>\n\
    <code language=julia-0.4>\nparse_nested_parens.call(\"(()()) ((())) () ((())()())\"\
    )\n</cell>\n<code language=julia-0.4>", "  paren_stack = []\n  paren_depth_stack\
    \ = []\n  paren_stack_size = -1", "  levels = [0]\n  group_counter = 0\n  group_level\
    \ = 0\n  group_stack = []\n  parens_stack = []\n  paren_count = 0", "  \n  strings\
    \ = paren_string.split(/\\s+/)\n  \n  parens = []\n  parens_level = []", "  paren_string.scan(/^([()]){(\\\
    d+)}\\1/).map { |_, count| count }.reduce(:+)\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I love the regex solution, I didn't think of it.  I changed it slightly to support\
    \ nestings of 2, 3 and more parentheses:\n`paren_string.scan(/^([()]){(\\d+)}\\\
    1/).map { |_, count| count }.reduce(:+)`\n<|/ c |>\n<| a tags=regex,ruby,ruby-on-rails\
    \ |>\nYou could do something like this:\n<code>", "  paren_string.chars.each do\
    \ |ch|\n    if ch == '('\n      parse_nested_parens(paren_string)\n    elsif ch\
    \ == ')'\n      return paren_string.length\n    end\n  end\n  return -1\nend",
  "  nested_paren_counter = 0\n  nested_paren_levels = [[]]\n  for i in paren_string.split('\
    \ ')\n    if i =~ /^\\)/\n      nested_paren_counter += 1\n      nested_paren_levels\
    \ << nested_paren_counter\n      nested_paren_counter = 0\n    else\n      nested_paren_levels\
    \ << nested_paren_counter\n    end\n  end\n  nested_paren_levels.max #get the\
    \ deepest level of nesting of parens\nend\n</code>\n<|/ a |>\n<| c |>\nI understand\
    \ this is a super old topic, but this implementation doesn't work if there are\
    \ any nested parentheses. For example, `((()))` returns `nil`.\n<|/ c |>\n<| a\
    \ dscore=1 tags=ruby,regex |>\nHere's a solution that uses recursion. There are\
    \ two parts of the problem that need to be solved, the first is getting the count\
    \ of parentheses before the matching one and the second is getting the string\
    \ of the parentheses that need to be removed before calling the recursive function:\n\
    <code>", "  result = Array.new\n  result.push(0)\n  paren_stack = Array.new\n\
    \  paren_stack.push(0)\n  paren_stack.push(paren_string)\n  while !paren_stack.empty?\n\
    \    char = paren_stack.shift\n    if char == \"(\"\n      result.push(paren_stack.size)\n\
    \      paren_stack.push(char)\n    elsif char == \")\"\n      result.push(result.last)\n\
    \      paren_stack.pop\n    end\n  end\n  return result\nend", "  if paren_string.empty?\n\
    \    []\n  else\n    stack = [paren_string]\n    levels = []\n    level = 0",
  "  result = []\n  count = 1\n  stack = []\n  paren_count = 0", "  paren_stack =\
    \ Stack.new\n  paren_stack.push(0)\n  paren_stack.push(0)\n  paren_stack.push(0)\n\
    \  \n  paren_stack.push paren_string\n  \n  paren_stack.each do |i|\n    paren_stack.push(paren_string.count)\n\
    \  \n    paren_string.each do |j|\n      if paren_string.count == j + 1  \n  \
    \      paren_stack.push(1)\n      else\n        paren_stack.push(paren_stack.pop)\n\
    \      end\n    end\n  end\n  \n  paren_stack.each do |i|\n    paren_stack.push(paren_stack.pop)\n\
    \  end\n  \n  return paren_stack.pop\nend", "    stack = []\n    paren_count =\
    \ 0\n    nesting_depth = 0\n    paren_level = 0\n    nesting_paren_count = 0\n\
    \    paren_string.split(\" \").each do |token|\n        if (token =~ /\\(/)\n\
    \            paren_count += 1\n            stack.push(0)\n        else\n     \
    \       paren_count -= 1\n            stack.pop\n        end\n        if (stack.empty?)\n\
    \            nesting_depth = paren_count - nesting_paren_count\n            nesting_paren_count\
    \ = paren_count\n        end\n    end\n    return [nesting_depth, nesting_paren_count]\n\
    end", "\tparentheses = paren_string.split(\" \").map {|paren| paren.to_i }\n\t\
    max_nesting = 0\n\tnesting = parentheses.map do |paren|\n\t\tmax_nesting = [paren,\
    \ max_nesting].max\n\t\tmax_nesting if max_nesting > 1\n\tend\n\tnesting.map {|depth|\
    \ depth.to_i }.max\nend", "    open = 0\n    open_list = []\n    close = 0\n \
    \   close_list = []\n    level = 0\n    level_list = []\n    inside = 0\n    for\
    \ index, char in enumerate(paren_string)\n        if char == \"(\"\n         \
    \   open += 1\n            open_list.append index\n            level += 1\n  \
    \          level_list.append level\n            if level > len(paren_string) -\
    \ 1:\n                inside = 0\n        elif char == \"(\"\n            close\
    \ += 1\n            close_list.append index\n            level += 1\n        \
    \    level_list.append level\n            if level > len(paren_string) - 1:\n\
    \                inside = 0\n        elif char == \")\"\n            if inside\
    \ > 0 and close > open:\n                inside_level = level_list[inside]\n \
    \               close_level = level_list[close]\n                if inside_level\
    \ > close_level:\n                    open_list[close] = open_list[open]\n   \
    \                 close_list[open] = close_list[close]\n                    del\
    \ open_list[close]\n                    del close_list[open]\n               \
    \     del open_list[open]\n                    del close_list[close]\n       \
    \         elif inside_level < close_level:\n                    open_list[close]\
    \ = open_list[open]\n                    close_list[open] = close_list[close]\n\
    \                    del open_list[close]\n                    del close_list[open]\n\
    \                    del open_list[open]\n                    del close_list[close]\n\
    \                open -= 1\n                close -= 1\n        elif char == \"\
    (\" or char == \"[\":\n            open += 1\n            open_list.append index\n\
    \            level += 1\n            level_list.append level\n            if level\
    \ > len(paren_string) - 1:\n                inside = 1\n        elif char == \"\
    ]\" or char == \")\":\n            close += 1\n            close_list.append index\n\
    \            level += 1\n            level_list.append level\n            if level\
    \ > len(paren_string) - 1:\n                inside = 1\n        elif char == \"\
    )\" or char == \"]\":\n            level += 1\n            level_list.append level\n\
    \            if level > len(paren_string) - 1:\n                inside = 0\n \
    \   if open > 0 or close > 0:\n        open_list.append len(paren_string)\n  \
    \      close_list.append len(paren_string)\n        open_list.append len(paren_string)\n\
    \        close_list.append len(paren_string)\n    return list(set(open_list).intersection(set(close_list)))",
  "    paren_stack = []\n    i = 0\n    open_parentheses = 0\n    while i < paren_string.length\n\
    \        if paren_string[i] == '('\n            paren_stack.push i\n         \
    \   i += 1\n            open_parentheses += 1\n        else if paren_string[i]\
    \ == ')'\n            depth = paren_stack.pop\n            i += 1\n          \
    \  open_parentheses -= 1\n            i += depth - 1\n        else\n         \
    \   i += 1\n    return paren_stack\nend\n</code>\n<|/ a tags=string,ruby,recursion\
    \ dscore=1 |>\n<| a tags=string,ruby,recursion |>\nHere is an example using recursion.\n\
    The idea is to keep a stack to keep track of the parenthesis.\n<code>", "  return\
    \ paren_string.scan(/[()]+/).flatten\nend", '  paren_string = paren_string.strip',
  "  open_bracket_counts = count_open_brackets(paren_string)\n  max_level = open_bracket_counts.max_by(&:last)\n\
    \  max_level[0]\nend", "  paren_stack = []\n  paren_level = 0\n  paren_depth =\
    \ []\n  paren_nesting = []\n  paren_queue = Queue()\n  paren_queue.enq(paren_string)",
  "  nested_parens = Array.new(paren_string.split(\" \").length).fill(0)\n  for i\
    \ in 0...nested_parens.length\n    nested_parens[i] = parse_parens(paren_string,\
    \ i)\n  end\n  nested_parens\nend", "  # The function assumes that the given string\
    \ has some nested parentheses.\n  # This function returns at most the length of\
    \ the longest nested parentheses.\n  # If there are no nested parentheses, it\
    \ will return 0.\n  # >>> parse_nested_parens.call(\"(())\")\n  # 2\n  # >>> parse_nested_parens.call(\"\
    (())()\")\n  # 3\n  # >>> parse_nested_parens.call(\"(()))()\")\n  # 3\n  # >>>\
    \ parse_nested_parens.call(\"((((())))()\")\n  # 4\n  # >>> parse_nested_parens.call(\"\
    (((((())))))()\")\n  # 4\n  # >>> parse_nested_parens.call(\"((()))((()))((()))\"\
    )\n  # 4\n  # >>> parse_nested_parens.call(\"(((())())()()))\")\n  # 3\n  # >>>\
    \ parse_nested_parens.call(\"(((((((()()))())))))()\")\n  # 3\n  # >>> parse_nested_parens.call(\"\
    ((((()())()())))()\")\n  # 3\n  # >>> parse_nested_parens.call(\"(((((())))())())()\"\
    )\n  # 2\n  # >>> parse_nested_parens.call(\"((())))((()))((())())\")\n  # 5\n\
    \  # >>> parse_nested_parens.call(\"(((())))))()(((()))()))\")\n  # 6\n  # >>>\
    \ parse_nested_parens.call(\"((((())))(()))((())()))\")\n  # 6\n  # >>> parse_nested_parens.call(\"\
    ((((())))()()())((())())\")\n  # 6\n  # >>> parse_nested_parens.call(\"((((())))()()()())((()))()\"\
    )\n  # 6\n  # >>> parse_nested_parens.call(\"(()()))()()()()()\")\n  # 3\n  parsed_levels\
    \ = [0]\n  brackets = []\n  level = 0\n  index_in_paren = 0\n  while index_in_paren\
    \ <= paren_string.length\n    if paren_string[index_in_paren] == \")\"\n     \
    \ level += 1\n      brackets.pop\n      index_in_paren += 1\n    else\n      if\
    \ paren_string[index_in_paren] == \")\"\n        level += 1\n      else\n    \
    \    if paren_string[index_in_paren] == \"(\"\n          level += 1\n        \
    \  brackets << level\n          index_in_paren += 1\n        else\n          if\
    \ level == parsed_levels[parsed_levels.length-1]\n            parsed_levels <<\
    \ level\n          else\n            parsed_levels << level\n          end\n \
    \       end\n      end\n    end\n  end\n  return parsed_levels.length\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=python dscore=0 |>\n", "  nested_depth = 0\n  nested_parens\
    \ = []\n  paren_string.scan(/\\(([^()]*)\\)/ do |parens|\n    nested_parens <<\
    \ parens.captures.map do |paren|\n      paren.scan(/\\(/)\n      paren.scan(/\\\
    )/)\n    end.flatten.map {|paren| paren.count('(') - paren.count(')')}\n    nested_depth\
    \ = [nested_depth].flatten.max\n  end).flatten.map {|depth| depth + nested_depth}\n\
    end", "  paren_stack = []\n  max_paren_level = 0", "  paren_depths = paren_string.split('\
    \ ').map.with_index{|char, i| char.empty? ? 0 : char.size + i}\n  paren_depths.delete_if{|depth,\
    \ index| index == 0}.max\nend", "  paren_string.gsub!(/([()(\\[)])/) do\n    match\
    \ = paren_string.match($1)\n    match.pre_match << 1\n    match.post_match <<\
    \ 2\n    match.pre_match + match.post_match\n  end\n  paren_string.gsub!(/\\(([^()]+)\\\
    )/) do\n    match = paren_string.match($1)\n    match.pre_match << 1\n    match.post_match\
    \ << 1\n    match.pre_match + match.post_match\n  end\n  paren_string.gsub!(/\\\
    (([^()]+)\\)/) do\n    match = paren_string.match($1)\n    match.pre_match <<\
    \ 2\n    match.post_match << 2\n    match.pre_match + match.post_match\n  end",
  "  max_levels = []\n  level = 0\n  levels = [level]\n  string = paren_string.gsub(/(\\\
    (\\{|(|\\))|\\n)/, '')\n  index = 0\n  while level > 0 && index < string.length\n\
    \    opening_brace = string[index]\n    closing_brace = string[index + 1]\n  \
    \  index += 1\n    level += 1\n    if closing_brace == '{'\n      if opening_brace\
    \ == '{'\n        if level > levels[levels.length-1]\n          levels[levels.length-1]\
    \ = level\n      else\n        levels << level\n      end\n      levels << level\n\
    \    end\n    if opening_brace == '('\n      levels << level\n    end\n    if\
    \ opening_brace == '['\n      levels << level\n    end\n  end\n  max_levels =\
    \ levels.reverse\nend", "    stack = []\n    level = 0\n    levels = [level]\n\
    \    while level < max_nesting\n        parens = paren_string.count(\"(\", level)\n\
    \        if parens > 0\n            paren_levels = paren_string.count(\"(\", level\
    \ - 1).to_i\n        else\n            paren_levels = 0\n        end\n       \
    \ \n        level = paren_levels + ((paren_string.count(\"(\", level + 1)) / parens)\n\
    \        level += 1\n        levels << level\n        stack << (paren_levels >\
    \ 0 ? (parens - paren_levels + 1) : 0)\n    end\n    levels.pop\n    stack\nend",
  "  paren_string.scan(/[^()]+/).each do |item|\n    item.scan(/[^()]+/).each do |item|\n\
    \      item.scan(/[^()]+/).each do |item|\n        yield item.length if item ==\
    \ \"(\"\n      end\n    end\n  end\nend", "  # TODO: Implement your solution here.\n\
    \  return []\nend", "  brackets_count = 0\n  open_paren_count = 0\n  close_paren_count\
    \ = 0", "  level_stack = []\n  opening_count = 0\n  while opening_count > 0\n\
    \    opening_count = paren_string.count('(', opening_count)\n    closing_count\
    \ = paren_string.count(')', opening_count)\n    level_stack.push([opening_count,\
    \ closing_count])\n    if closing_count == 0\n      raise ArgumentError, \"Error\
    \ parsing input: No closing parens found. Input was: #{paren_string}\"\n    end\n\
    \    opening_count -= 1\n  end\n  output_array = []\n  level_stack.each do |level|\n\
    \    if level[0] > 0\n      output_array << level[0]\n    end\n    opening_count\
    \ = level[1]\n    while opening_count > 0\n      opening_count = paren_string.count('(',\
    \ opening_count)\n      closing_count = paren_string.count(')', opening_count)\n\
    \      output_array << closing_count - 1\n      opening_count -= 1\n    end\n\
    \  end\n  output_array\nend", "  paren_string.scan(/(?<parens>\\(+|\\)+|\\)(?<-parens>\\\
    (+|\\)+|\\))+/)\n  parens = []\n  paren_index = 0\n  paren_stack = []\n  paren_stack.push([paren_index,\
    \ paren_string.size, paren_string])\n  paren_stack_len = paren_stack.length\n\
    \  while paren_stack.length > 0\n    paren_index, paren_len, paren_string = paren_stack.pop\n\
    \    if paren_string.size > paren_len\n      paren_index -= 1\n      paren_string\
    \ = paren_string[0..paren_len]\n      parens << paren_index\n    end\n  end\n\
    \  parens\nend", "  paren_stack = []\n  parentheses_levels = []\n  paren_counter\
    \ = 0", "  result = {}\n  group_level = 1\n  nested_level = 0\n  group = \"\"\n\
    \  paren_stack = []\n  paren_stack[-1] = 0\n  paren_stack[paren_stack.length-1]\
    \ = 0\n  paren_stack[0..-1].each do |n|\n    if paren_stack.length <= n\n    \
    \  nested_level = 1\n    end\n    level =\n      if n > 0\n        nested_level\n\
    \      else\n        group_level\n      end\n    if level > group_level\n    \
    \  group_level = level\n    end\n    if level < nested_level\n      nested_level\
    \ = level\n    end\n  end\n  result.delete(\"\")\n  result.each do |k, v|\n  \
    \  v.each { |i| paren_stack.push(i) }\n  end\n  paren_stack.pop\n  paren_stack\n\
    end\n</code>\nThis way we are getting all the levels of nesting by popping all\
    \ the nested levels from the stack, by iterating over the group string, popping\
    \ the next level from each of the group and pushing them back.\n<|/ a tags=python,algorithm,regex\
    \ dscore=1 |>\n<| c |>\nNice solution. But this only works for regular parentheses.\
    \ Parentheses with square brackets won't work.\n<|/ c |>\n<| c |>\nI actually\
    \ had a version that worked on all parentheses (except some that had nested parentheses\
    \ in them, such as `(()()())`) but couldn't figure out the regex for parentheses\
    \ with square brackets. I actually spent a lot of time trying to figure it out\
    \ so I thought it would be worth sharing. I actually did try to find a regex for\
    \ parentheses with square brackets but was unable to figure it out. Good point\
    \ though!\n<|/ c |>\n<| c |>\nI didn't realize that parentheses with square brackets\
    \ were allowed. I think I figured it out, but I'll edit my post to include that\
    \ as well.\n<|/ c |>\n<| a dscore=1 tags=python,algorithm,regex |>\nI have done\
    \ this in JavaScript with regex and I believe it can be done in Python too.\n\
    Here is my solution:\n<code>\nvar test = \"(abc)(abc)(abc)(abc)abc\";\nvar re\
    \ = /[()]/g;\nvar levels = 0;\nvar lastLevel = 0;\nvar levelsArray = [];\nwhile\
    \ ((result = re.exec(test)) != null) {\n    if (result[0] === \"(\") {\n     \
    \   levels++;\n    }\n    else {\n        if (lastLevel < levels) {\n        \
    \    levelsArray.push(levels);\n        }\n        levels = 0;\n    }\n    lastLevel\
    \ = levels;\n}\nvar max", "  group_levels, max_level = 0, -1\n  paren_chars =\
    \ paren_string.split(\"\").map { |c|\n    if c == '('\n      group_levels += 1\n\
    \    elsif c == ')'\n      group_levels -= 1\n      if group_levels > max_level\n\
    \        max_level = group_levels\n      end\n    end\n  }\n  paren_chars\nend",
  "  groups = paren_string.split(\" \")\n  result = [1]\n  max_level = 1\n  group_level\
    \ = 0\n  \n  # Traverse the groups and increment the level of nesting\n  # for\
    \ each group of the form '(()())' \n  # increment the level by 2 if group contains\
    \ more than 1 set of paranthesis\n  for i in 0...groups.length\n    cur_groups\
    \ = groups[i..i+2]\n    group_level = group_level + 1 if cur_groups.include?(\"\
    ()\") else group_level\n    if group_level > max_level\n      max_level = group_level\n\
    \    end\n  end\n  \n  result << max_level\n  return result\nend", "  paren_array\
    \ = []\n  paren_stack = []\n  paren_count = 0\n  while paren_count > 0\n    paren_count\
    \ += 1\n    paren_char = paren_string[paren_count]\n    if paren_char == \"(\"\
    \n      if paren_stack.size > 0\n        paren_stack.pop\n      paren_stack.push(1)\n\
    \    elsif paren_char == \")\"\n      while paren_stack.size > 0\n        paren_stack.pop\n\
    \      paren_array.append(paren_count)\n    end\n  end\n  paren_stack.pop\n  paren_array\n\
    end", "  level = 0\n  open_paren = 1\n  result = []\n  while level > 0\n    if\
    \ paren_string[open_paren] == '('\n      open_paren += 1\n    else \n      open_paren\
    \ -= 1\n    level += 1\n  end\n  return result\nend", "  opening_paren_count =\
    \ 0\n  level = 0\n  current_paren = 0\n  output = []\n  open_parens = paren_string.split(\"\
    \ \").map do |nested_parens|\n    if opening_paren_count < 1\n      opening_paren_count\
    \ += 1\n      return\n    end\n    opening_paren_count -= 1\n    if nested_parens[0]\
    \ == \")\"\n      level += 1\n      return\n    end\n    level -= 1\n  end\n \
    \ output.append(level)\n  open_parens.compact\nend", "  parens = paren_string.split(\"\
    \ \").map { |s| s.length.positive? ? s.length : 0 }\n  \n  max_level = 0\n  level\
    \ = 0\n  \n  for i in 0...parens.length\n    if parens[i] > max_level\n      max_level\
    \ = parens[i]\n      level = i\n    end\n  end\n  \n  max_level\nend", "  level\
    \ = 1\n  max_level = 0\n  paren_level = 0\n  paren_group_counts = []\n  paren_groups\
    \ = []\n  paren_group = \"\"\n  paren_group_string = \"\"\n  paren_counter = 0\n\
    \  paren_group_counter = 0\n  paren_group_string = \"\"", "  nested_counts = Hash.new(0)\n\
    \  paren_open_index = -1\n  paren_close_index = -1\n  level = 0\n  i = 0\n  paren_string.split(\"\
    \ \").each do |paren|\n    if paren != \"()\"\n      nested_counts[paren] += 1\n\
    \      paren_open_index = i\n      i += 1\n    elsif paren == \"()\"\n      level\
    \ += 1\n      paren_close_index = i\n      i += 1\n    end\n  end\n  return [nested_counts[paren_open_index],\
    \ nested_counts[paren_close_index], level]\nend", "  result = []\n  stack = []\n\
    \  stack_size = paren_string.length - 1\n  stack[stack_size] = nil\n  level =\
    \ 1", "  paren_string.scan(/\\(([^()]+)\\)|\\(([^()]+)\\)|\\([^()]+\\)/) do |group_1,\
    \ group_2|\n    unless group_2.nil?\n      group_1_count = parse_nested_parens(group_1).size\n\
    \      group_2_count = parse_nested_parens(group_2).size\n      if group_1_count\
    \ < group_2_count\n        return group_1_count\n      else\n        return group_2_count\n\
    \      end\n    end\n    unless group_1.nil?\n      return 1\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| a |>\n<code>", "  # Write your code here.\nend", " \
    \ max_level = 0\n  open_pars = 0\n  close_pars = 0\n  results = []\n  paren_count\
    \ = 0\n  for i in 0...paren_string.length\n    if paren_count > 0 then\n     \
    \ if paren_count % 2 == 0 then\n        if paren_count > close_pars then\n   \
    \       close_pars = paren_count\n        end\n      else\n        if paren_count\
    \ > open_pars then\n          open_pars = paren_count\n        end\n      end\n\
    \    end\n    if paren_string[i] == \")\"\n      if paren_count > 0 then\n   \
    \     if open_pars > close_pars then\n          close_pars = open_pars\n     \
    \   end\n        close_pars += 1\n      end\n      results.push(close_pars)\n\
    \      paren_count = 0\n      open_pars = 0\n    elsif paren_string[i] == \"(\"\
    \n      paren_count += 1\n      if open_pars > 0 then\n        close_pars = open_pars\n\
    \        open_pars = 0\n      end\n    else\n      open_pars = 0\n    end\n  end\n\
    \  results.push(close_pars)\n  return results\nend", "  # initialize a stack\n\
    \  stack = []\n  # traverse through all characters\n  paren_chars = paren_string.chars\n\
    \  max_level = 0\n  level = 0\n  bracket_level = 0\n  stack << paren_chars.first\n\
    \  paren_chars.shift\n  \n  while paren_chars.any? \n    # increase level of parentheses\n\
    \    level += 1\n    # if we reach parentheses\n    if level == paren_chars.last\n\
    \      # check if stack is empty (no more parentheses)\n      if stack.empty?\n\
    \        max_level = level\n        break\n      # if the level of brackets is\
    \ larger than the level of parentheses\n      # increase the level of brackets\n\
    \      bracket_level = level\n      while bracket_level < level\n        bracket_level\
    \ += 1\n        stack << paren_chars.shift\n      end\n    end\n    # increase\
    \ level of brackets\n    bracket_level += 1\n    stack << paren_chars.shift\n\
    \  end\n  # decrease the level of brackets\n  bracket_level -= 1\n  # decrease\
    \ level of parentheses\n  level -= 1\n  while level > 0\n    level -= 1\n    stack\
    \ << paren_chars.shift\n  end\n  \n  result = [max_level]\n  stack.each_with_index\
    \ do |s, i|\n    if s == '('\n      result << i\n    elsif s == ')'\n      result\
    \ << stack.size - result.last + 1 - i\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nI like the way you use stacks to find nested\
    \ parens.\n<|/ c |>\n<| c |>\nI like my answer better, however I found a bug in\
    \ it, I fixed it but I can't push it to gitHub because it has a lot of other changes\
    \ that break the tests. I'll post the fix as an answer, if you're interested.\n\
    <|/ c |>\n<| c |>\nThanks for fixing it. I had been working on a different solution\
    \ for several days and now I'm back to it.\n<|/ c |>\n<| c |>\nI liked your solution\
    \ too. However,  I noticed that your solution will give wrong result if the string\
    \ is `\"(()()) ()\"`. It will return `[5, 2]` instead of the expected `[2,2]`.\
    \ I think it is because you cannot determine which parentheses is the deepest.\
    \ Because for the first parantheses, it is at the deepest level (`5`). For the\
    \ second ", "  max_level = 0\n  stack = paren_string.chars.map { |c| c }\n  paren_stack\
    \ = stack.map { |c| [c, 0] }", "  paren_levels = paren_string.scan(/\\((.*?)\\\
    )/)\n  max_level = 0\n  max_levels = Array.new(0)\n  paren_levels_sorted = paren_levels.sort_by\
    \ { |i| i[1] }.reverse.map { |i| i[0] }\n  paren_levels_sorted.each do |i|\n \
    \   parentheses = paren_string.split(i).map(&:strip)\n    levels = parentheses.count\
    \ { |x| x[0] == '(' }\n    max_level = max_level if levels > max_level\n    max_levels\
    \ << levels\n  end\n  max_levels\nend", "  level_stack = []\n  level_result =\
    \ 0\n  paren_count = 0", "  levels = paren_string.scan(/\\(([^\\(\\)]+)\\)/).map\
    \ { |x| x.count }\n  max_level = levels.max()\n  return max_level if max_level\
    \ > 0\n  0\nend", "    parens = paren_string.split(/ +/)\n    paren_levels = [0\
    \ for paren in parens]\n    level = 0\n    index = paren_string.index(parens[0])\n\
    \    while index do\n        if parens[index] == '('\n            paren_levels[index]\
    \ += 1\n        else\n            paren_levels[index] -= 1\n        index = paren_string.index(parens[index],\
    \ index + 1)\n    \n    levels = paren_levels.map{|level| level.nonzero? ? level\
    \ : 0}\n    levels.max_by {|level| level}\nend\n</code>\n<|/ a tags=string,ruby,parentheses\
    \ dscore=3 |>\n<| c |>\nThis solution works great on Ruby 2.2 but fails on  Ruby\
    \ 2.2.2. Can anyone confirm if it works on ruby 2.2?\n<|/ c |>\n<| a |>\nUsing\
    \ a regular expression:\n<code>", "  parentheses_levels = [0]\n  paren_string.scan(/[\\\
    (\\)])/) do\n    if $1 == \")\"\n      parentheses_levels.pop\n    else\n    \
    \  parentheses_levels << parentheses_levels.last + 1\n  end\n  parentheses_levels\n\
    end", "  # If string has only one group, treat it as a unit expression (no nesting).\n\
    \  if paren_string.length == 1\n    return [1]\n  # Find the deepest level by\
    \ walking the groups from left to right.\n  depth = 1\n  paren_string.each_byte\
    \ do |b|\n    # Keep track of current parenthesis.\n    if b == ?(\n      if paren_string[depth]\
    \ == ?(\n        # Next group is in same level\n        depth += 1\n      else\n\
    \        # Next group is in a deeper level\n        depth -= 1\n      end\n  \
    \    break\n    end\n  end\n  # Return number of levels of nesting.\n  depth +\
    \ 1\nend", "  # If parenstring is empty, return an empty array or list\n  case\
    \ paren_string.empty?\n  when true\n    []\n  when false\n    []\n  else\n   \
    \ # Split string by parentheses, and iterate through each group\n    paren_string.split(/\\\
    (\\)/).map { |x| x } # Return an array of groups\n                       .inject(0)\
    \ do |result, x|\n                         case x\n                         when\
    \ \"(\"\n                           result + 1\n                         when\
    \ \")\"\n                           result - 1\n                         end\n\
    \                       end\n  end\nend", "  paren_string.split(\" \").each_with_object([-1])\
    \ do |token, levels|\n    levels << token.size if token == '(' || token == ')'\n\
    \  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nAs already noted, this can be\
    \ solved using regular expressions.\nHowever, I thought I would provide an alternative\
    \ using recursion.  This version makes use of Ruby's \"truthiness\" methods (i.e.\
    \ !foo).\n<code>", "  nested_level = 0\n  stack = []\n  paren_index = 0\n  parentheses_count\
    \ = 0", "  parentheses = paren_string.split(' ')\n  max_nesting = -1\n  i = 0\n\
    \  while i < parentheses.length\n    opening = parentheses[i]\n    if opening\
    \ == '('\n      i += 1\n      while i < parentheses.length\n        closing =\
    \ parentheses[i]\n        if closing == ')'\n          i += 1\n        else\n\
    \          max_nesting = Math.max(max_nesting, nesting_level(parentheses, i))\n\
    \          i += 1\n        end\n      end\n    end\n    i += 1\n  end\n  return\
    \ max_nesting\nend", "  paren_stack = []\n  results = []\n  paren_count = 0\n\
    \  paren_level_counter = -1\n  paren_groups = paren_string.split \" \"", "  return\
    \ [\n    parse_parens(paren_string.split(\" \").map { |c| c==\"()\" ? 0 : 1 })\n\
    \  ].max\nend", "  paren_string.scan(/\\(\\([^\\(\\)]*\\)\\)/) { |group|\n   \
    \ levels = group.scan(/\\(([^\\(\\)]*)(\\([^\\(\\)]*\\))?(\\s|\\()*[^\\(\\)]*)\\\
    )/).flatten.size\n    if levels > max_levels\n      max_levels = levels\n    end\n\
    \  }\n  max_levels\nend", '  paren_string = paren_string.dup', "  level = 0\n\
    \  levels = []\n  parens = []\n  bracket_levels = []\n  bracket_level = 0\n  bracket_count\
    \ = 0\n  prev_char = \"\"\n  i = 0\n  paren_groups = paren_string.split(\" \"\
    )\n  while i < paren_groups.length\n    if paren_groups[i] == \"\"\n      i +=\
    \ 1\n      next\n    end\n    char = paren_groups[i]\n    if char == \"(\"\n \
    \     level += 1\n      bracket_count += 1\n      if level > 1\n        bracket_levels[-1]\
    \ += 1\n      end\n      levels << level\n      bracket_levels << bracket_count\n\
    \      parens << bracket_levels.length - 1\n      bracket_count = 0\n    end\n\
    \    i += 1\n    if char == \")\"\n      level -= 1\n      bracket_count -= 1\n\
    \      if level == 0\n        bracket_levels.pop()\n      end\n      levels <<\
    \ level\n      bracket_levels << bracket_count\n      parens << bracket_levels.length\
    \ - 1\n      bracket_count = 0\n    end\n  end\n  parens\nend", "  paren_groups\
    \ = paren_string.split(' ')\n  max_level = 0\n  current_level = 0\n  while current_level\
    \ <= max_level\n    current_level += 1\n    if current_level > max_level\n   \
    \   current_level = max_level\n      max_level = current_level\n      paren_groups[0]\
    \ = paren_groups[0].gsub(/\\(\\([^\\(\\)]*\\)[^\\(\\)]*\\)*/, '').gsub(/\\(\\\
    (\\([^\\(\\)]*\\)[^\\(\\)]*\\)*)\\)/, '')\n      paren_groups.each {|s| s = s.strip}\n\
    \    end\n    paren_groups.each {|g| break unless paren_groups.include? g}\n \
    \ end\n  paren_groups\nend\n</code>\nThe function works by removing the nested\
    \ parentheses first by gsub'ing all the nested parentheses with an empty string.\
    \ Then it searches the string for the group containing all the nested parentheses.\
    \ If it finds it, it removes that group from the string and continues until all\
    \ groups have been processed.\nThe next gsub is needed for removing parentheses\
    \ from the nested groups if there are any in the nested groups (they appear twice,\
    \ once with parentheses and once without parentheses).\nThis was all done by doing\
    \ everything in one gsub. There is probably a more efficient way to do it.\n<|/\
    \ a tags=ruby |>\n<| c |>\nVery nice solution!\n<|/ c |>\n<| c |>\nThis is a good\
    \ one, but I used the code as a proof of concept for my own project. It was very\
    \ difficult to write in Ruby.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\n<code>\n\
    '(()())'.gsub(/\\(\\([^\\(\\)]*\\)[^\\(\\)]*\\)*/, '')\n</code>\n<|/ a |>\n<|\
    \ c |>\nHi, thanks for your response. I didn't even think of using regex to remove\
    \ nested parentheses.\n<|/ c |>\n<| a dscore=2 |>\nI came up with this solution:\n\
    <code>", "  if paren_string.empty?\n    [nil]\n  else\n    stack = paren_string.to_s.chars.map\
    \ do |char|\n      case char\n      when \"(\"\n        [char]\n      when \"\
    )\"\n        [nil]\n      else\n        stack.last << char\n        [stack.pop]\n\
    \      end\n    end\n    stack\n  end\nend", "  depth = 0\n  index = 0\n  results\
    \ = []", "    depth = 1\n    paren_count = paren_string.count(\"(\")\n    paren_pair_count\
    \ = 0\n    parens_levels = []", "  parens = paren_string.split(\" \").map { |s|\
    \ s.length }\n  parens.reduce(:+).to_a\nend", "  paren_string = paren_string.strip\n\
    \  paren_counts = paren_string.scan(/[\\(\\)\\)]/)\n  return paren_counts.map\
    \ { |count, paren_count| count if paren_count == 0 }.max\nend", "  stack = []\n\
    \  count = 1\n  paren_count = 0\n  \n  paren_string.split(' ') do |sub_str|\n\
    \    if sub_str == \"(\" || sub_str == \"[\"\n      stack_str = stack.to_s.gsub('(','').gsub('[','').gsub(')','').gsub(']','')\n\
    \      paren_count += 1\n      \n      if stack_str.length <= paren_count\n  \
    \      stack.push sub_str\n        count += 1\n      elsif stack_str.length >\
    \ paren_count\n        count = stack.pop.size + 1\n      end\n    elsif sub_str\
    \ == \")\"\n      paren_count -= 1\n      if paren_count == 0\n        count -=\
    \ 1\n      end\n    end\n  end\n  stack.reverse\n  count\nend", "  stack = []\n\
    \  paren_count = 0\n  paren_level = 0", "  paren_count = paren_string.length\n\
    \  stack_array = []\n  stack = []\n  while ((paren_count) != 0)\n    if paren_count\
    \ > 0 && paren_count < 7\n      paren_count += 1\n      stack << paren_count\n\
    \    elsif paren_count > 7\n      stack.pop\n      paren_count -= 7\n      paren_count\
    \ += 1\n      stack << paren_count\n    elsif paren_count == 0\n      if stack.empty?\n\
    \        paren_count = 1\n        stack_array << stack\n      else\n        if\
    \ stack.last.length > stack.last.last\n          stack_array << stack.last.last\n\
    \          stack.last.last -= 1\n        else\n          stack_array << stack.last.last\n\
    \          stack.last.last += 1\n        end\n      end\n      stack.pop\n   \
    \ end\n    paren_count -= 1\n  end\n  stack_array\nend", "  paren_count = paren_string.scan(/\\\
    (|\\)/).count\n  max_depth = paren_count-1\n  paren_levels = paren_count\n  paren_levels_string\
    \ = \"\"\n  paren_level = 0\n  while paren_count > 0\n    if paren_level < paren_levels\n\
    \      paren_levels_string << paren_level\n    end\n    paren_level -= 1\n   \
    \ paren_count = paren_string.scan(/\\(|\\)/).count\n  end\n  return paren_levels_string\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI guess you meant `paren_count` instead\
    \ of `paren_string.count`\n<|/ c |>\n<| c |>\nIt works fine but how do I return\
    \ this result back to my main script? I have to use it in a variable and use it\
    \ in another script for parsing the result and return the result to it. Please\
    \ help. I have used global variable in main script and tried setting and getting\
    \ it in another script but didn't work.\n<|/ c |>\n<| c |>\nIt depends on how\
    \ your script is set up. Let's say the variable is named `my_var`. Then `global\
    \ my_var` at the top of your script and then `my_var = some_function`. Then `return\
    \ my_var` at the end of the function.\n<|/ c |>\n<| c |>\nI added another method\
    \ using hashes. Let me know if it works.\n<|/ c |>\n<| a |>\nThis is a recursive\
    \ solution that uses a stack. The stack keeps track of which parentheses are open\
    \ and which are closed. It doesn't handle nested parentheses but it's straightforward\
    \ to add that functionality if desired.\n<code>", '  paren_string.downcase!',
  "    nested_levels = []\n    paren_level = 0\n    paren_open_count = 0\n    paren_close_count\
    \ = 0\n    paren_levels = []\n    paren_level = 0", "  parens = paren_string.split('\
    \ ')\n  return parens.inject(0) do |max_nesting, paren|\n    match = paren.to_s.match(/\\\
    (.*?\\)|\\(.*?\\)|\\(.*?\\)|[^\\(]+/)\n    match ? match[0].split('').inject(0)\
    \ { |max_level, char| max_level > max_level ? max_level : max_level + ((char =~\
    \ /[()]/) ? 0 : 1) : -1 }\n  end\nend", "  level = 0\n  nested_paren_level = 0\n\
    \  paren_string.split(\"\").each do |char|\n    if char == \"(\"\n      level\
    \ += 1\n    elsif char == \")\"\n      level -= 1\n    elsif char == \"(\"\n \
    \     nested_paren_level += 1\n    elsif char == \")\"\n      nested_paren_level\
    \ -= 1\n    end\n    if level < 0 or level > nested_paren_level\n      return\
    \ -1\n    end\n  end\n  return level\nend", "  paren_levels_map = {}\n  paren_level\
    \ = 0\n  brackets_count = 0\n  paren_chars = paren_string.split(\"\")\n  paren_chars.each\
    \ do |char|\n    if char == \"(\"\n      paren_levels_map[char] = paren_level\n\
    \      paren_level += 1\n      brackets_count += 1\n    elsif char == \")\"\n\
    \      paren_level -= 1\n      if paren_levels_map[char] == 0\n        paren_levels_map[char]\
    \ = paren_level\n      end\n      brackets_count -= 1\n    elsif char == \" \"\
    \n      brackets_count += 1\n    end\n  end\n  if paren_levels_map.keys.any?\n\
    \    paren_max_level = paren_levels_map.values.max\n    paren_levels_map.each\
    \ do |key, value|\n      paren_max_level = value if paren_max_level < value\n\
    \    end\n    return paren_max_level\n  else\n    return 0\n  end\nend", "  level\
    \ = 0\n  levels = []\n  start_paren_index = 0\n  end_paren_index = 0\n  parentheses_count\
    \ = 0\n  while parentheses_count < paren_string.length\n    # Get the next char.\n\
    \    char = paren_string[parentheses_count]", "  paren_level = 0\n  paren_stack\
    \ = []\n  paren_stack_size = -1\n  paren_max_size = 0\n  for i in paren_string.gsub(/\\\
    (|\\)|\\s/, \"\").split(\" \") do\n    if paren_stack_size == -1 then\n      if\
    \ paren_string == \"\" then\n        paren_max_size = i\n      else\n        paren_stack_size\
    \ = i\n        paren_stack = []\n      end\n    else\n      if paren_string ==\
    \ \"\" then\n        paren_stack_size = -1\n        paren_max_size = i\n     \
    \ else\n        paren_stack = [paren_stack]\n        paren_stack_size = -1\n \
    \       paren_max_size = i\n      end\n    end\n  end\n  return paren_stack\n\
    end", "  paren_string.squeeze!(\" \")\n  paren_string.gsub!(\"^\\\\(([\\\\w\\\\\
    -]*)\\\\) \\\\(([\\\\w\\\\-]*)\\\\)$\",\"\\\\2,\\\\1\")\n  paren_string.gsub!(/((\\\
    (.*\\))|(\\(.*\\)))/, \"\\\\1\")\n  paren_string.gsub!(/(\\(.*\\))/, \"\\\\1\"\
    )\n  paren_string.gsub!(\"\\\\(\", \"\\\\(\")\n  paren_string.gsub!(\"\\\\)\"\
    , \"\\\\)\")\n  paren_string.gsub!(\"\\\\,\", \",\")\n  paren_string.gsub!(\"\\\
    \\)(\", \"\\\\(\")\n  paren_string.gsub!(\"\\\\(\", \")\")\n  paren_string.gsub!(\"\
    \\\\)$\", \")\")\n  paren_string.gsub!(/(\\[|\\])(.*)/, \"\\\\1 \\\\2\")\n  paren_string.gsub!(/([()])/,\
    \ \"\\\\1\")\n  paren_string.gsub!(\"[()]\", \"()\")\n  paren_string.gsub!(/(.*)\\\
    ((.*)/, \"\\\\1 \\\\2 \\\\3\")\n  paren_string.gsub!(\"\\\\(\", \"\\\\(\")\n \
    \ paren_string.gsub!(\"\\\\)\", \"\\\\)\")\n  paren_string.gsub!(\"\\\\)(\", \"\
    \\\\(\")\n  paren_string.gsub!(\"\\\\(\", \")\")\n  paren_string.gsub!(\"\\\\\
    )$\", \")\")\n  paren_string.gsub!(/(\\[|\\])(.*)/, \"\\\\1 \\\\2\")\n  paren_string.gsub!(\"\
    [()]\", \"()\")\n  paren_string.gsub!(/(.*)\\((.*)/, \"\\\\1 \\\\2 \\\\3\")\n\
    \  paren_string.gsub!(/([\\w\\-]+)(\\s|\\(|\\))/, \"\\\\1 \\\\2\")\n  paren_string.gsub!(\"\
    \\\\(\", \"\\\\(\")\n  paren_string.gsub!(\"\\\\)\", \"\\\\)\")\n  paren_string.gsub!(\"\
    \\\\)(\", \"\\\\(\")\n  paren_string.gsub!(\"\\\\(\", \")\")\n  paren_string.gsub!(\"\
    \\\\)$\", \")\")\n  paren_string.gsub!(/(\\[|\\])(.*)/, \"\\\\1 \\\\2\")\n  paren_string.gsub!(\"\
    [()]\", \"()\")\n  paren_string.gsub!(/(.*)\\((.*)/, \"\\\\1 \\\\2 \\\\3\")\n\
    \  paren_string.gsub!(\"\\\\(\", \"\\\\(\")\n", "  paren_level = 0\n  output =\
    \ []\n  paren_start = 0\n  paren_nest = 0\n  paren_last_char = \"\"", "  # Split\
    \ string into array of strings to support nested paranthesis\n  paren_string =\
    \ paren_string.split\n  paren_string = paren_string.map(&:strip)", "  level =\
    \ 0\n  last_opening_paren = nil\n  bracket_stack = Array.new\n  nested_paren_stack\
    \ = Array.new\n  paren_chars = paren_string.chars\n  paren_chars.reverse_each\
    \ do |char|\n    if char == '('\n      if !last_opening_paren\n        level +=\
    \ 1\n        nested_paren_stack.push level\n        last_opening_paren = char\n\
    \      else\n        bracket_stack.push char\n      end\n    elsif char == ')'\n\
    \      if bracket_stack.empty?\n        level -= 1\n      else\n        bracket_stack.pop\n\
    \        last_opening_paren = bracket_stack.empty? ? nil : bracket_stack.pop\n\
    \      end\n    elsif char == ')'\n      nested_paren_stack.pop\n      last_opening_paren\
    \ = nil\n    end\n  end\n  return nested_paren_stack\nend", "  result = \"\"\n\
    \  paren_count = 0\n  open_count = 0", "  paren_stack = []\n  paren_nesting_level\
    \ = 0\n  paren_levels = []", "  max_level = 0\n  paren_stack = paren_string.split(\"\
    \ \")\n  paren_stack.each do |paren_string|\n    if paren_stack.length <= max_level\n\
    \      max_level = paren_stack.length\n    end\n    paren_stack = paren_string.split(\"\
    \ \")\n  end\n  max_level\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,parsing,regex,algorithm\
    \ |>\n<| a tags=ruby,ruby-on-rails,parsing,regex,algorithm |>\nHere's an example\
    \ implementation in Python:\n<code>\nimport re", "  if paren_string.strip == \"\
    \"\n    []\n  else\n    parentheses = []\n    paren_count = 1\n    paren_level\
    \ = 1\n    paren_stack = []\n    paren_string.each_char do |char|\n      if char\
    \ == \")\"\n        paren_stack.pop\n        paren_level -= 1\n      elsif char\
    \ == \"(\"\n        paren_stack << paren_count\n        paren_count += 1\n   \
    \   else\n        if paren_stack.empty?\n          paren_level = 1\n         \
    \ paren_stack << paren_count\n          paren_count += 1\n        else\n     \
    \     paren_stack.pop\n          parentheses << (paren_stack.last)\n         \
    \ paren_count += 1\n        end\n      end\n    end\n    paren_stack.last\n  end\n\
    end\n</code>\n<|/ a dscore=3 tags=parsing,ruby |>\n<| c |>\nPlease note that `[1,2,3]`\
    \ can easily be turned into `[1,2,3]` because it is valid Ruby. `[1,2,3]` doesn't\
    \ mean \"an array with three elements `[1,2,3]`\", it means \"a literal array\
    \ with three elements, `[1,2,3]`\", but an array literal can be nested with any\
    \ number of elements. `[1,2,3]` is syntactically equivalent to `[[1,2,3]]`\n<|/\
    \ c |>\n<| a dscore=3 tags=parsing,ruby |>\nA bit more optimized version of the\
    \ previous answers:\n<code>", "  paren_string = paren_string.strip\n  return paren_string.split(\"\
    \ \").map do |nested|\n    nested.count(\"(\") - nested.count(\")\")\n  end.max_by(&:last)\n\
    end\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThis won't work if the input\
    \ string has parentheses inside the parens, like `(())`, or other nesting parentheses\
    \ inside parentheses. In fact, my answer won't work at all, because I left out\
    \ some cases. Try it out with `\"(())\"`.\n<|/ c |>\n<| c |>\nYou are right! I\
    \ didn't take that case into account.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "\t\n\
    \t# To find the deepest level \n\tdepth = 0\n\t\n\t# To find the start of a group\n\
    \tgroup_start = 0\n\t\n\t# To store the group\n\tgroup = []\n\t\n\t# To store\
    \ the number of opening and closing parenthesis used in a group\n\tnum_opening_parens\
    \ = 0\n\t\n\t# To store the number of opening and closing parenthesis used in\
    \ a group\n\tnum_closing_parens = 0\n\t\n\tin_paren_group = 0\n\t\n\t# To store\
    \ the parenthesis used to close a group\n\tparen_after_close = 0\n\t\n\t# To store\
    \ the parenthesis used to open a group\n\tparen_after_open = 0\n\t\n\t\n\t# For\
    \ storing all the opening parenthesis in a group\n\tgroup_opening = []\n\t\n\t\
    # For storing all the closing parenthesis in a group\n\tgroup_closing = []\n\t\
    \n\t# To store the group of nested parenthesis\n\tnested_parens = []\n\t\n\t\n\
    \ti = 0\n\t\n\t\n\t# Loop to read from left to right\n\twhile i < len(paren_string)\n\
    \t\t\n\t\t# Loop to check if current char is a parenthesis\n\t\tif paren_string[i]\
    \ == \"(\" or paren_string[i] == \"{\" or paren_string[i] == \"[\" or paren_string[i]\
    \ == \"<\"\n\t\t\t\n\t\t\tif num_opening_parens == 0\n\t\t\t\t\n\t\t\t\t# Loop\
    \ to read from right to left\n\t\t\t\twhile paren_string[i - 1] != \"(\" or paren_string[i\
    \ - 1] != \"{\" or paren_string[i - 1] != \"[\" or paren_string[i - 1] != \"<\"\
    \n\t\t\t\t\t\n\t\t\t\t\tif paren_string[i - 1] == paren_string[i]\n\t\t\t\t\t\t\
    \n\t\t\t\t\t\tif paren_string[i - 1] == \"(\" or paren_string[i - 1] == \"<\"\n\
    \t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif num_closing_parens == 0\n\t\t\t\t\t\t\t\t\n\t\
    \t\t\t\t\t\t\t# If the current char is the opening parenthesis\n\t\t\t\t\t\t\t\
    \tif paren_string[i - 1] == paren_string[i]\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\
    \t# If number of open parenthesis is zero\n\t\t\t\t\t\t\t\t\tif num_opening_parens\
    \ == 0\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t# Append the current char to\
    \ the group\n\t\t\t\t\t\t\t\t\t\tgroup.append(paren_string[i])\n\t\t\t\t\t\t\t\
    \t\t\t\n\t\t\t\t\t\t\t\t\t\t# Increment the number of opened parenthesis\n\t\t\
    \t\t\t\t\t\t\t\tnum_opening_parens = num_opening_parens + 1\n\t\t\t\t\t\t\t\t\t\
    \t\n\t\t\t\t\t\t\t\t\t# If number of open parenthesis is one\n\t\t\t\t\t\t\t\t\
    \telif num_opening_parens == 1\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t# If\
    \ the current char is the closing parenthesis\n\t\t\t\t\t\t\t\t\t\tif paren_string[i\
    \ - 2] == paren_string[i]\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (paren_after_close\
    \ == 0 and paren_after_open == 0)\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\
    \t# Append the current char to the group\n\t\t\t\t\t\t\t\t\t\t\tgroup.append(paren_string",
  "    levels = 0\n    parens = paren_string.split(\" \").inject([]) do |memo, elem|\n\
    \        if elem.start_with?(\"(\")\n            memo << 1\n        else\n   \
    \         memo.last[memo.length-1] += 1\n        end\n        memo\n    end\n\
    \    parens.uniq.map{|elem| elem.last[elem.length-1]}.max\nend", "  paren_string\
    \ = paren_string.strip\n  left_parens_count = paren_string.count(\"(\")\n  right_parens_count\
    \ = paren_string.count(\")\")\n  levels_of_parentheses = left_parens_count + right_parens_count\n\
    \  return levels_of_parentheses\nend", "  paren_stack = []\n  paren_stack_length\
    \ = 0\n  \n  # To find the deepest level of nested parentheses, we start from\
    \ the lowest level\n  # of nesting and check each of its parents. When we encounter\
    \ a parentheses which has not\n  # been encountered in our iteration, we add that\
    \ parenthesis to our stack.\n  # E.g. if we encounter the parentheses () in '((()))',\
    \ we add a '(' to the stack\n  # and encounter the parentheses () in '((()))',\
    \ we add a '(' to the stack and encounter a\n  # parentheses () in '(((())))',\
    \ we add a '(' to the stack and encounter the parentheses ()\n  # in '(((())))',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parentheses () in '(((()())())())',\
    \ we add a '(' to the stack and encounter the parenthese", "  if paren_string\
    \ == \"\"\n    []\n  else\n    levels = paren_string.gsub(\"()\", \"  \").scan(/\
    \  ([^()]+)/).flatten\n    levels.inject(0){|sum, e| sum + e.to_i}\nend\n</code>\n\
    <|/ a dscore=2 tags=ruby,regex,parentheses,string |>\n<| a |>\nThis can be done\
    \ with regex in a single pass. \n<code>", "  stack = paren_string\n  level = 0\n\
    \  while level > 0\n    level -= 1\n    pos = stack[level].index(\")\")\n    if\
    \ pos == -1\n      stack.insert(level + 1, \"(\")\n      pos += 1\n    else\n\
    \      stack[level] = stack[level].sub(/\\)$/, \"\")\n    level += 1\n  end\n\
    \  parse_paren_level(paren_string)\nend", "  max_level = 0\n  nestings = []",
  "  paren_counts = paren_string.scan(/[(())]/)\n  paren_counts.each_with_index do\
    \ |count, index|\n    # Handle the empty string case before we throw an exception\n\
    \    if index == 0\n      paren_counts[index]\n    else\n      # Handle all other\
    \ cases\n      next_count = paren_counts[index + 1]\n      current_count = paren_counts[index]",
  '  parens = paren_string.scan(/\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?(\(([^()]*?',
  "  level = 0\n  parens = []\n  bracket_count = 0\n  in_parens = 0\n  open_bracket_count\
    \ = 0\n  paren_stack = []", "  stack = []\n  parentheses = 0\n  level = 0\n  \n\
    \  paren_string.scan(/([()])/g) do\n    parentheses += 1\n    stack.push parentheses\n\
    \  end", "  groups = paren_string.split(\" \") # Split by spaces to get an array\
    \ of groups\n  levels = [0,]*groups.count # Create a list to keep track of each\
    \ level of nesting.\n  \n  levels.zip(groups) do |level, group|\n    level +=\
    \ 1\n    level <= groups.count ? levels[level] = level : levels[level] = level\n\
    \  end # Each element in the levels array is the deepest level of nesting for\
    \ a given group.\n  \n  levels.max\nend", "  max_levels = 0 # maximum number of\
    \ levels of nesting encountered so far\n  paren_count = 1 # number of opening\
    \ parentheses encountered so far\n  paren_levels = [] # the level of nesting represented\
    \ by each parenthesis\n  chars = paren_string.split(\"\")\n  char_stack = [] #\
    \ stack of characters being processed while parenthesis\n  char_stack.push(paren_string[0])\
    \ # push the first character onto the stack\n  while paren_count <= max_levels\n\
    \    char = char_stack.pop() # pop the character from the stack\n    chars.delete(char)\
    \ # remove the character from the list\n    if char == \"(\"\n      paren_count\
    \ += 1\n      paren_levels.push(paren_count)\n    elsif char == \")\"\n      paren_count\
    \ -= 1\n      max_levels = paren_count if paren_count > max_levels else max_levels\n\
    \    end\n    if paren_levels.length == paren_count # if the number of opening\
    \ parentheses equals the number of closing parentheses \n      char_stack.push(char)\
    \ # push the current character onto the stack\n      paren_levels.pop # remove\
    \ the opening parentheses from the stack\n    end\n  end\n  char_stack.empty?\
    \ # empty the stack if it's empty\n  paren_levels\nend\n</code>\n<|/ a tags=ruby,regex\
    \ dscore=0 |>\n<| c |>\nThis is way too complicated. I can't imagine someone would\
    \ need this more than once.\n<|/ c |>\n<| c |>\nYes, it is complex for such a\
    \ simple purpose. But it is also very powerful, allowing you to implement complex\
    \ regex which is not possible with regular expressions.\n<|/ c |>\n<| c |>\nIt\
    \ is a very general solution. Anything that can be solved with a regular expression,\
    \ can also be solved with this code.\n<|/ c |>\n<| c |>\nYes, I know. But my answer\
    \ was not meant to solve the problem of doing this by regular expressions. It\
    \ was meant to solve the problem of doing this in a general way. Anyway, my answer\
    \ was only meant to solve the immediate problem of solving this particular problem.\
    \ Anything more complicated would probably be best solved using something like\
    \ this approach.\n<|/ c |>\n<| c |>\nI agree with you. My answer was only meant\
    \ to solve the immediate problem of solving the problem of parsing nested parentheses.\n\
    <|/ c |>\n<| a tags=ruby,regex |>\nThis can easily be solved using a recursive\
    \ regex:\n<code>\nre = %r{\n    (?:\\(\\))?                # Open paren\n    (\
    \                       # Capture ", "  \n  nested_parens_levels = {}", "  result\
    \ = []\n  nesting_level = 0\n  nested_parens_string = paren_string.strip\n  while\
    \ nested_parens_string != \"\"\n    nested_parens_string = nested_parens_string.sub(/^\\\
    ((.*?)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    ((.*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\((\\\
    ([^\\(\\)]*\\))\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_parens_string.sub(/^\\\
    (([^\\(\\)]*)\\)$/, '\\1')\n    nested_parens_string = nested_", "  # Use stack\
    \ to record the level of nesting in the parenthesis.\n  stack = []\n  # Initialize\
    \ the level count of nesting to zero.\n  count = 0\n  # Split the string by whitespace\
    \ and add each element to the stack.\n  paren_string.split(\" \").each { |paren_word|\n\
    \    # If the current word is a closing parenthesis, decrease the level count\
    \ by one\n    if paren_word == \")\"\n      stack[count].downto(0)\n    end\n\
    \    # If the current word is a opening parenthesis, increase the level count\
    \ by one\n    if paren_word == \"(\"\n      stack.push(count+1)\n    end\n   \
    \ # If the current word is a closing parenthesis, decrease the level count by\
    \ one\n    if paren_word == \")\"\n      count = stack[count].to_i\n    end\n\
    \  }\n  # Return the level count\n  count\nend", "  max_level = 0\n  paren_string.each_char\
    \ do |char|\n    if char == \")\" && max_level > 0\n      max_level -= 1\n   \
    \ elsif char == \"(\" && max_level < 0\n      max_level += 1\n    end\n  end\n\
    \  max_level\nend", "  level = 0\n  output_levels = []\n  current_level = 0\n\
    \  parens = paren_string.chars\n  while parens\n    if parens == ')'\n      output_levels.push(current_level)\n\
    \      level += 1\n    elsif parens == '('\n      level += 1\n    elsif parens\
    \ == '['\n      level += 1\n      current_level += 1\n    elsif parens == ']'\n\
    \      current_level -= 1\n    elsif parens == '{' || parens == '}'\n      output_levels.push(current_level)\n\
    \    end\n    parens = parens.next\n  end\n  output_levels.reverse\nend\n</code>\n\
    <|/ a |>\n<| c |>\nGreat work and thanks for the help! My question is actually\
    \ more about a solution that was asked as a practice interview question from CodeWars,\
    \ I guess they wanted to see how you think about these kinds of problems.\n<|/\
    \ c |>\n<| c |>\nI agree, this was a tough question. I'm also glad you asked.\n\
    <|/ c |>\n<| a dscore=2 tags=algorithm,ruby,python,regex |>\nI won't claim to\
    \ be a regex expert, but I think this would be fairly straightforward to implement.\n\
    The strategy is to keep a stack of \"levels\" that indicate how many levels of\
    \ parentheses you currently have. Whenever a new opener is found, the number of\
    \ levels is incremented. Whenever a closer is found, the number of levels is decremented.\
    \ If the number is zero, the string is in an open state. \nThe idea is to be able\
    \ to push and pop a number of levels from a stack (push the current number of\
    \ levels to the stack; pop the number of levels from the stack; if the stack is\
    \ empty the string is closed), which is an easy problem to implement in Ruby using\
    \ push/pop and an array, for example:\n<code>", "  # Write your code here.\n \
    \ result = []\n  i = 0\n  paren_count = 0\n  while (i < paren_string.length)\n\
    \    if (paren_count == 0)\n      if (paren_string[i] == \"(\")\n        paren_count\
    \ += 1\n      end\n    if (paren_count == 0)\n      if (paren_string[i] == \"\
    )\")\n        paren_count -= 1\n      end\n    if (paren_count != 0)\n      break\n\
    \    i += 1\n  end\n  result << paren_count\n  i = 1\n  while (i < paren_string.length)\n\
    \    if (paren_count == 0)\n      if (paren_string[i] == \")\")\n        paren_count\
    \ -= 1\n      end\n    if (paren_count == 0)\n      if (paren_string[i] == \"\
    (\")\n        paren_count += 1\n      end\n    if (paren_count != 0)\n      break\n\
    \    i += 1\n  end\n  result << paren_count\n  return result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
