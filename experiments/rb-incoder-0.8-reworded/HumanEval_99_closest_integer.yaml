name: HumanEval_99_closest_integer
language: rb
prompt: "# Create a function that takes a value (string) representing a number\n#\
  \ and returns the closest integer to it. If the number is equidistant\n# from two\
  \ integers, round it away from zero.\n# Examples\n# >>> closest_integer.call(\"\
  10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away\
  \ from zero means that if the given number is equidistant\n# from two integers,\
  \ the one you should return is the one that is the\n# farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should\
  \ return -15.\ndef closest_integer(value)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
  \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
  10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
  -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"\
  0\"))\n  end\nend\n"
completions: ["  if value == nil\n    return nil\n  end\n  diff = value - @array[0]\n\
    \  diff = diff * diff\n  return if diff < 0\n  diff = diff ** 2\n  diff = diff\
    \ * diff\n  if diff < 0\n    diff *= -1\n  end\n  closest = (-diff).round\n  return\
    \ if closest == 0\n  return if closest > @array.length\n  return @array[closest]\n\
    end", "  return value.to_i == value.to_i.round ? value.to_i : value.to_i.round\n\
    end", "  value.to_i\nend", "  value, integer = value.to_s.split('.')\n  integer.to_i\n\
    \  integer.abs.floor == value ? 0 : integer\nend\n</code>\nThe next thing is to\
    \ write an algorithm that determines what to do if two numbers are equidistant\
    \ to a power of 10, so that you can do something like closest_integer(value_to_check).to_s\
    \ + \"0\".to_i.to_s if you want to convert a number to a string. \nYou already\
    \ know how to get the number itself from the string (the value parameter in your\
    \ code). Just split the string on the decimal point and get the integer value\
    \ from the resulting array. \nNext, you want to check if the number you're working\
    \ with is divisible by a power of 10. If it is, you want to find out what the\
    \ closest power of 10 is, add one to it, and then divide that number by that new\
    \ power of 10. \nIf not divisible, just add one to the number. \nFinally, use\
    \ your algorithm to return the closest integer to your number by adding \"0\"\n\
    I haven't added any error checking to my code here. If your input is not valid,\
    \ this will be a problem. \n<code>", "  Integer(value.to_f).round\nend", "  i\
    \ = value.to_i\n  return i if i.abs < i.to_f && i.abs <= 0 \n        i.ceil -\
    \ i.abs \n      else\n        i.floor - i.abs \n      end\nend\n</code>\n<|/ a\
    \ dscore=4 |>\n<| a tags=ruby-on-rails,ruby |>\nA short and easy solution:\n<code>",
  "  value.to_s.to_f\n  value.to_s.to_i\n  value.to_f.round\n  value.to_f.round(-1)\n\
    \  value.to_f.round(1)\n  value.to_f.floor\n  value.to_f.ceil\n  value.to_f.truncate\n\
    end", "  value = value.length.to_f / 2.0\n  value.ceil.to_i\nend", "  value =\
    \ value.to_i\n  closest = (value == 0) ? value : value - Float::INFINITY\n  while\
    \ Float::INFINITY < closest.abs do\n    next if value.abs2.floor.is_a? Integer\n\
    \    closest = (value - closest).round\n  end\n  closest\nend", '  value = value.to_f',
  "  value = value.to_i\n  candidate = value.abs\n  i = 1\n  while candidate > 0 &&\
    \ i <= value\n    candidate = candidate + (value.abs - candidate).abs\n    i +=\
    \ 1\n  candidate\nend", "  return value.to_i.to_s.split(\".\")[0].to_i\nend",
  "  rounding = (value < 0) ? 1 : -1\n  value, factor = (value || 0), 0\n  loop {\n\
    \    factor += 1\n    if value % factor == 0\n      break\n  }\n  ((value / factor)\
    \ * rounding) + rounding / factor\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails,rubygems,ruby-on-rails-3.1\
    \ dscore=2 |>\n<| c |>\nI edited my question with your answer (which I voted up),\
    \ but since I have less than 15 reputation I cannot vote your answer up. Thanks!\n\
    <|/ c |>\n<| c |>\nAh, I'm sorry. :)\n<|/ c |>\n<| a |>\nI've done some benchmarking\
    \ to this and I came up with 3 different methods:", "  if value.is_a? Integer\n\
    \    return value\n  elsif value.is_a? Float\n    value.floor\n  else\n    value.to_i\n\
    \  end\nend", "  to_return = value\n  if value == to_return\n    return value\n\
    \  to_return = to_return.to_f\n  if to_return == 0.0\n    return 0\n  to_return\
    \ = to_return.to_i\n  i = to_return.to_i + 1\n  f = 1\n  while to_return != i\n\
    \    to_return += f\n    i += f\n    f = 1 / to_return.to_i\n  return i\nend",
  "  int_value = Integer(value)\n  smallest_difference = int_value.abs # Find the\
    \ smallest difference\n  closest = nil # Declare an empty variable\n  int_range\
    \ = Integer(-Float::INFINITY..Float::INFINITY) # Define a range", "  value = value.to_f\n\
    \  closest = (value - Float::INFINITY).round\n  (closest<0 && closest!=0) || closest\n\
    end", "  return value.to_i == value.to_s ?\n    value.to_i :\n    value.to_i.ceil\n\
    end", "  if value.is_a?(Integer)\n    value\n  elsif value.is_a?(Float)\n    value.to_i\n\
    \  else\n    raise \"invalid input type\"\n  end\nend", "  closest_integer = nil\n\
    \  (0...Float(value).to_i).each do |i|\n    diff = abs(value - i)\n    if diff\
    \ > closest_integer\n      closest_integer = diff\n    end\n  end\n  closest_integer\n\
    end\n</code>\n<|/ a dscore=4 tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<| c\
    \ |>\nThis is just about as good as you can get without having to install any\
    \ gems.\n<|/ c |>\n<| a |>\nI wrote a gem to solve this problem (and a few other\
    \ problems you may encounter, too):\n<code>", "  value = to_number(value)\n  values\
    \ = [value]\n  values.concat(to_number(i).to_f / to_number(2).to_f for i in 0..(value.length\
    \ - 1)) if value.length < 2 end\n  values.each_with_index do |v, i|\n    difference\
    \ = to_number(to_s.split(value.to_s).to_f[i.to_s - 1]) - to_number(to_s.split(value.to_s).to_f[i])\n\
    \    if difference < 0\n      values[i] = 0\n    end\n  end if value.length >\
    \ 1\n  values.first\nend", "  return Math.ceil(value)\nend", "  value = value.to_f\n\
    \  smallest_delta = value.abs.abs\n  second_smallest_delta = -smallest_delta\n\
    \  smallest_delta == second_smallest_delta ? nil : smallest_delta\n  if value\
    \ < smallest_delta\n    smallest_delta\n  else\n    value.ceil\n  end\nend", " \
    \ number = value.to_f\n  difference = nil", "  value = value.to_f\n  closest =\
    \ 0\n  closest = value\n  return closest\nend", "  value.to_i.round\nend", " \
    \ return value.to_i > value.to_i ? value.to_i : value.to_i - 1\nend", "    number\
    \ = Integer(value)\n    number.round unless number.nan?\n    candidates = candidates_for(number)\n\
    \    closest_candidate(candidates)\nend", "  new_value = value.to_f\n  old_value\
    \ = value.to_f\n  while new_value < old_value\n    new_value += 1.0\n  end\n \
    \ while new_value > old_value\n    new_value -= 1.0\n  end\n  new_value.to_i\n\
    end", "  value = value.to_i\n  smallest = value\n  largest = value\n  num = 1\n\
    \  while num < value\n    smallest = num\n    num += num\n  end\n  num = 1\n \
    \ while num < value\n    largest = num\n    num += num\n  end\n  if largest <\
    \ smallest\n    smallest\n  else\n    largest\n  end\nend", "  Integer(value.to_s).round\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThe answer above is pretty good, but\
    \ here's another way (although slightly less efficient)\n<code>", "  rounded_value\
    \ = value.to_s.split('.').map(&:to_i)\n  rounded_value.each { |i| rounded_value.push(i)\
    \ }\n  rounded_value.each_with_index { |a, i|\n    rounded_value[i] = (rounded_value[i]\
    \ - rounded_value.min).abs\n  }\n  rounded_value.map!(&:round)\n  rounded_value.map!(&:floor)\n\
    \  if rounded_value.min == 0\n    rounded_value.min = -(rounded_value[rounded_value.min\
    \ - 1] + 1)\n  end\n  rounded_value.max > rounded_value.length ? rounded_value.max\
    \ : rounded_value.min\nend", "  closest = 0\n  num = (value || 0).to_i\n  num.times\
    \ do |i|\n    if i != 0\n      if closest\n        if num - closest > i\n    \
    \      closest = num\n        else\n          if num + closest < i\n         \
    \   closest = num\n          else\n            closest = i\n          end\n  \
    \      end\n      else\n        closest = num\n      end\n    end\n  end\n  closest\n\
    end", "  nearest_integer, remainder = value.divmod(1)\n  if remainder.zero?\n\
    \    nearest_integer\n  else\n    nearest_integer - 1 + closest_integer(nearest_integer)\n\
    \  end\nend", "  value = value.to_f\n  value += 0.5\n  diff = (value % 1).abs\
    \ < 0.5 ? value : (value - 1)\n  diff = (diff + 1) / 2\n  return diff.round\n\
    end", "  value.to_i.round\nend", "    v = value.to_i\n    diff = v - @prev_num\n\
    \    if diff > 0\n        return v\n    elsif diff < 0\n        return @prev_num\n\
    \    end\n    while diff > 0\n        diff = diff - @prev_num\n        @prev_num\
    \ += 1\n    end\n    return @prev_num - 1\nend", "  return Math.round_to((value\
    \ * (10 ** -Float::log10) - Float::log10).floor, 2)\nend", "  value.to_i.floor\n\
    end", "  value = value.to_i\n  smallest = value % 10\n  largest = smallest.to_i\n\
    \  if largest == value - 1\n    largest = value - 10\n  end\n  if smallest ==\
    \ value + 1\n    smallest = value + 10\n  end\n  return largest < smallest ? smallest\
    \ : largest\nend\n</code>\n<|/ a tags=ruby,math |>\n<| c |>\nI like your solution,\
    \ although I don't understand why the `reverse` method was used.\n<|/ c |>\n<|\
    \ c |>\nThanks, you are correct, I had reversed it by mistake. I've fixed the\
    \ answer now.\n<|/ c |>\n<| a dscore=2 |>\nThe way I do this is to just convert\
    \ the string to a number, then check the difference between the current number\
    \ and the number you want, and round up to the nearest integer. For example\n\
    <code>\n(current - number).ceil\n</code>\n<|/ a tags=ruby,math |>\n<| c |>\nThis\
    \ would round `4.5` to `4`, which is not the behavior we want for integer values.\
    \ Also it doesn't work if the difference is negative.\n<|/ c |>\n<| c |>\nYou\
    \ are correct. I'll change it.\n<|/ c |>\n<| a |>\nI would probably do something\
    \ like this:\n<code>", "  # Create a list of all numbers between the given value\
    \ and\n  # the value plus one\n  # Create a set that contains the given value\n\
    \  # Calculate the difference between each value and the given value\n  # and\
    \ use that to find the closest number\n  # Return the closest number\n  close_numbers\
    \ = []\n  close_numbers.add(value)\n  close_numbers.add (value+1)", "  int_value\
    \ = value.to_i\n  if int_value >= value\n    int_value = int_value.floor\n  elsif\
    \ int_value <= value\n    int_value = int_value.ceil\n  end\n  return int_value\n\
    end", "  return value.to_f.round\nend", "  if value.length == 1\n    value.to_i\n\
    \  else\n    value.to_i + (value.length.floor - value.length.ceil).abs\n  end\n\
    end", "\tclosest_integer = value.to_i", "  if value.is_a?(Integer)\n    return\
    \ value\n  else\n    number = value.to_f\n    closest = (number - int(\"0.\" +\
    \ number.to_s.split(\".\")[1])) / float(\"1.0\") * 10 ** number.to_s.length\n\
    \    if closest == number\n      return number\n    else\n      return closest\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nYou can try this one:\n<code>", "  value = \"#{value}\"\n  value_float =\
    \ value.to_f\n  closest_integer = value_float.round\n  return closest_integer.to_i\n\
    end\n</code>\nAgain for simplicity I removed some error checking here and there\
    \ to make it cleaner and easier to read. Now you should be able to run this test\
    \ file to see how it works.\n<code>\nrequire 'test_helper'", "  # Your code here\n\
    \  return closest_integer.call(value)\nend", "  to_return = value\n  if value.is_a?(String)\n\
    \    # See if value is a number or a floating point number\n    if value.include?\
    \ \".\"\n      to_return = value.to_f\n    else\n      to_return = value.to_i\n\
    \    end\n  end\n  to_return = to_return.round\n  return to_return if to_return.is_a?\
    \ Numeric\n  to_return\nend\n</code>\nThen I did the following:\n<code>", "  numbers\
    \ = value.split('.')\n  integers = numbers.map(&:to_i)\n  nearest_integer = integers[integers.index(integers.min)]\n\
    \  ((nearest_integer < 0) ? nearest_integer + 1 : nearest_integer).to_s\nend",
  "  closest = nil\n  closest = value.to_i\n  if closest == value\n    value\n  elsif\
    \ closest > value\n    value.to_i\n  else\n    value.to_i - 1\n  end\nend", " \
    \ if value == \"-\"\n    value = value.abs\n    sign = -1\n  else\n    sign =\
    \ 1\n  end", "  num = value.to_i\n  difference = num - floor(num)\n  return num\
    \ if difference == 0 \n  difference > 0\n  ? num + difference\n  : num - difference\n\
    end", "  return value.to_s.to_i if value.to_s.to_i == value.to_s.to_f \n  # We\
    \ use to_i to convert the string to a number, and to_f to convert the\n  # number\
    \ to a float, so our comparison will be numerical.\n  value = value.to_f\n  if\
    \ value < closest_integers[0] \n    closest_integers[0] = value\n  elsif value\
    \ > closest_integers[-1]\n    closest_integers[-1] = value\n  else\n    closest_integers.each\
    \ do |closest_integer|\n      if value < (closest_integer - .1) || value > (closest_integer\
    \ + .1)\n        closest_integer = value\n        break\n      end\n    end\n\
    \  end\n  closest_integer\nend", "  to_return = value.to_i\n  \n  unless to_return\
    \ == to_return.to_i\n    raise ArgumentError, \"The given value #{value} is not\
    \ an integer.\"\n  end\n  \n  to_return.downto(0)[0]\nend\n</code>\nNow we can\
    \ do the following:\n<code>\nclosest_integer(10) # => 10\nclosest_integer(15)\
    \ # => 15\nclosest_integer(\"10\") # => 10\nclosest_integer(\"15\") # => 15\n\
    </code>\n<|/ a tags=ruby,rounding |>\n<| a tags=ruby,rounding |>\nThis may seem\
    \ like a rather roundabout way of doing it, but in Ruby 1.9.2, you can also use\
    \ Float#round, which rounds to an arbitrary precision.\nFor example,\n<code>\n\
    10.round\n=> 10\n10.round(2)\n=> 10.5\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5\
    \ |>\n<code>\nrequire 'bigdecimal'\nBigDecimal.new(x).floor.to_f\n</code>\n<|/\
    \ a tags=ruby,rounding |>\n<| c |>\nThis is actually the only solution here that\
    \ works for me. No need for BigDecimal or anything else. Thanks!\n<|/ c |>\n<|\
    \ c |>\nThis is the most accurate answer. Thanks!\n<|/ c |>\n<| c |>\nThis solution\
    \ doesn't work for me, it returns 0.0. BigDecimal.new(x).to_s returns \"0.00000000000000\"\
    \ and to_s isn't a method of BigDecimal.\n<|/ c |>\n<| c |>\nI think this is due\
    \ to rounding down\n<|/ c |>\n<| a tags=ruby,rounding |>\nBigDecimal is the best\
    \ way but if you want to use pure Ruby you can use this way\n<code>", "  if value.is_a?(Numeric)\n\
    \    # Convert to a float in case the value is a float.\n    value = value.to_f\n\
    \    return 0 if value.zero? || value <= 1 || value == -1 ? value : round(value\
    \ * 10) / 10\n  end\n  value = value.to_s\n  raise ArgumentError.new(\"Invalid\
    \ number #{value}\") unless value.is_a?(String)\n  \n  integers = Integer(value).between(-10..10)\n\
    \  if integers.size == 1\n    return integers[0]\n  end\n  \n  closest_integer\
    \ = nil\n  integers_diff = nil\n  integers.each do |i|\n    integers_diff = integers_diff\
    \ || i.to_f - value\n    break if i.to_f - value <= 0.0 && integers_diff < 0\n\
    \    closest_integer = i\n  end\n  return closest_integer if integers_diff\n \
    \ \n  difference = value.to_i - closest_integer.to_i\n  case difference\n  when\
    \ 2...0\n    closest_integer\n  when 0\n    Integer.new(value.to_i)\n  when 1\n\
    \    Integer.new(value.to_i + 1)\n  else\n    Integer.new(value.to_i - 1)\n  end\n\
    end", "    value.to_i.round == value.to_i.round\nend\n</code>\n<|/ a tags=ruby,rounding\
    \ dscore=3 |>\n<| c |>\nWhy does this return an integer?\n<|/ c |>\n<| c |>\n\
    This returns a decimal if the original value was a decimal, or the original value\
    \ if it was a float.\n<|/ c |>\n<| c |>\n`[5, 5.2, 10.1]` will return `5` rather\
    \ than `10.0` for these values.\n<|/ c |>\n<| c |>\nWhat do you mean?\n<|/ c |>\n\
    <| c |>\nIt returns `5` for every value in the array that isn't a float.\n<|/\
    \ c |>\n<| a tags=ruby,rounding dscore=3 |>\nHere's a solution using Math.round,\
    \ which does not have the problem of rounding down to zero:\n<code>", "  value\
    \ = value.to_i\n  smallest_difference = float(\"inf\")\n  smallest_difference_index\
    \ = nil\n  \n  (0..value.to_s.length).each do |i|\n    difference = value.to_i\
    \ - i.to_i\n    if difference < 0\n      smallest_difference = -difference\n \
    \     smallest_difference_index = i\n    else\n      if smallest_difference >\
    \ difference\n        smallest_difference = difference\n        smallest_difference_index\
    \ = i\n      end\n    end\n  end", "  value = [value] unless value.is_a?(Array)\n\
    \  value.each do |value|\n    integer = value.to_i\n    return integer if integer\
    \ > 0 && integer < 1000\n  end\n  return value.to_i\nend", "    difference = Integer(value\
    \ - integer_to_string(Float(value)))\n    return difference.to_i\nend", "  value.to_i\n\
    \  if value >= value\n    value.ceil\n  else\n    value.floor\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| a |>\n<code>\n'4.3'.to_f.ceil",
  "  value = value.to_s\n  integer = value.to_i\n  if integer == 0\n    return 0\n\
    \  else\n    difference = abs(integer - value)\n    positive_integer = integer.abs\n\
    \    return positive_integer if difference < positive_integer * 0.5 \n    else\
    \ integer\n  end\nend", "  value = value.to_f\n  return value.round\nend", " \
    \ # Initialize min to either 0 or the value of the number\n  min = value", " \
    \ if value == nil\n    value\n  elsif value == \"\"\n    nil\n  else\n    # Get\
    \ the first two characters of the string, convert to an integer\n    first = int(value[0])\n\
    \    second = int(value[1])", "  return value.to_i + value.to_f / 2.0\nend", " \
    \ return value.to_i\nend", "\tvalue = value.to_f\n\tif value == 0\n\t\tnil\n\t\
    elsif value == 1\n\t\t0\n\telsif value < 10\n\t\tvalue.round\n\telse\n\t\t(value\
    \ - 9.9).round\n\tend\nend", "  value = value.to_f\n  closest = (value < 0 &&\
    \ value % 1 != 0) ? -Infinity : -Math::infinity\n  if value < 0\n    value.abs\n\
    \  else\n    value.abs\n  end\n  abs = value.abs rescue value\n  i = abs.to_i\n\
    \  return i + 1 if i == 0\n  i = abs.to_i\n  j = i + 1 if i < abs.to_i\n  abs.round\n\
    \  i = i + 1 while abs > 0 && i <= abs\n  j = j + 1 while abs(j) < abs.to_i\n\
    \  i\nend", "  value.to_i.closest(@min_value.to_i)\nend", "  number_to_int = to_number(value)\n\
    \  if number_to_int == 0\n    puts \"Invalid value: #{value}\"\n  elsif number_to_int\
    \ > max_integer or number_to_int < min_integer\n    puts \"Invalid value: #{value}\"\
    \n  elsif number_to_int == max_integer\n    min_integer\n  else\n    number_to_int\
    \ - min_integer\n  end\nend", "  i = value.to_i\n  diff = i - Math.round(i) #\
    \ rounding away from zero\n  return 0 if diff < 0 || diff == Math.round(i) &&\
    \ i > 0 # 0 and -0 are equidistant\n  diff = i - Math.round(i)\n  return diff\
    \ if diff < Math.round(i) && diff != 0 # 0 and Math.round(i) are not equidistant\n\
    \  return Math.round(i) # we found an equidistant integer\nend", "  unless value.is_a?(String)\n\
    \    raise ArgumentError, \"Expected a String\"\n  end\n  value = [value.to_i,\
    \ value.to_f, value.to_r].find { |v| !v.nil? }\n  return value unless value\n\
    \  # Determine the two integers closest to the target number\n  num = (value.to_i\
    \ || value.to_f || value.to_r).abs\n  [num / 2, num / 2 + 1][num % 2 ? 0 : 1].ceil\n\
    end", "  # If the value is already an integer, just return it.\n  return value.to_i\
    \ if value.is_a?(Integer) \n  # If the value is negative, add one to it.\n  return\
    \ value.to_i + 1 if value.is_a?(Float)\n  # If the value is between -1000 and\
    \ 1000, round it away from\n  # zero.\n  return value.to_i if -1000.0 < value\
    \ && value <= 1000\n  # If the value is within 0.001 to 0.999, round it away from\n\
    \  # zero.\n  return value.to_i if 0.001 <= value && value <= 0.999\n  # If the\
    \ value is between -0.001 and -0.999, round it away from\n  # zero.\n  return\
    \ value.to_i if -0.001 <= value && value <= -0.999\n  # If the value is between\
    \ -1 and 1, round it away from zero.\n  return value.to_i if -1.0 <= value &&\
    \ value <= 1.0\n  # Otherwise return the value itself.\n  return value.to_i\n\
    end\n</code>\n<|/ a |>\n<| c |>\nIf you have `-nan` then you'll get `-0`. So this\
    \ won't work.\n<|/ c |>\n<| c |>\n, Yeah I guess it's just not something that's\
    \ likely to happen.\n<|/ c |>\n<| c |>\nThis answer is very useful but I think\
    \ it should be the accepted answer if someone is looking for a ruby solution instead\
    \ of C (ruby has native support for [BigDecimals](http://www.ruby-doc.org/stdlib-2.0.0/libdoc/bigdecimal/rdoc/BigDecimal.html))\
    \ to handle floats.\n<|/ c |>\n<| c |>\nSure, but this also returns zero if the\
    \ value is out of range. For example, `closest_integer(\"0.000000000000001\")`\
    \ returns `0`, which is wrong.\n<|/ c |>\n<| c |>\n, If you want it to return\
    \ an integer, you can just add a call to `.to_i` to the end of it.\n<|/ c |>\n\
    <| a tags=rounding,ruby,ruby-on-rails |>\nSince Ruby 1.9 you can use the rint\
    \ method defined on Fixnum:\n<code>\na = 3.14\na.rint # => 3\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=rounding,ruby,ruby-on-rails |>\nIn Ruby 1.9.1 you can use Numeric#round\n\
    <code>\nirb(main):001:0> 1.9.1p374 :002 > 1.round\n=> 1\nirb(main):001:0> 1.9.1p374\
    \ :003 > 1.8.7.round\n=> 1\n</code>\n<|/ a dscore=4 |>\n", "  value = Float(value)\n\
    \  value = Math.round(value)\n  value = Math.max(0, value)\n  return value\nend",
  "  return int(Math.round(value))\nend", "  # Initialize all needed variables\n \
    \ new_value = nil\n  best_value = nil\n  best_distance = 0\n  # Split the input\
    \ value string into a list\n  parts = value.to_s.split(\".\")\n  # Check the input\
    \ value against the smallest and largest integers\n  if parts[0].to_i > parts[parts.count-1].to_i\n\
    \    parts = parts[0..-1]\n  elsif parts[parts.count-1].to_i > parts[0].to_i\n\
    \    parts = parts[1..parts.count-1]\n  end\n  # Iterate through the list until\
    \ the value matches or there is no more\n  # integers to try\n  parts.each do\
    \ |part|\n    # If the input value and the closest integer is equidistant from\
    \ each\n    # other, set the new value to the closest integer. Otherwise, set\
    \ the\n    # new value to the input value rounded to the closest integer\n   \
    \ if part.to_i == parts[parts.count-1].to_i\n      new_value = part\n    else\n\
    \      new_value = part.round(best_distance)\n    end\n    # Find the difference\
    \ between the new value and the best value so far\n    distance = ((new_value.to_f\
    \ - best_value.to_f) / best_value.to_f).abs\n    # Set the best value if it is\
    \ closer to the input value than the best value\n    if distance < best_distance\n\
    \      best_value = new_value\n      best_distance = distance\n    end\n  end\n\
    \  # Return the best value rounded to the closest integer\n  return best_value.round\n\
    end\n</cell>\n<code language=conda-root-py>", "  int_value = value.to_i\n  diff\
    \ = closest_integer(value - int_value) unless int_value.between?(-(2**63), 2**63)\n\
    \  diff || int_value\nend", "  return value.to_f.ceil\nend\n</code>\nAnd now the\
    \ code:\n<code>", "  i = value.to_f\n  diff = (i - value.to_f).abs\n  closest_integer\
    \ = nil\n  diff > 0.1 ? ( diff < 0.5 ?\n    closest_integer = value + 1 : closest_integer\
    \ = value - 1 ) :\n    closest_integer = value\n  closest_integer.to_i\nend",
  "  value.is_a?(String) ? closest_integer.call(value.to_i) : value.round\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<| c |>\nNice! I changed it\
    \ up a bit so it could take a string too:", "  return Math.round(value) if (value\
    \ =~ /^-?\\d+$/ && value >= 0 && value <= 20) ? Math.round(value) : 0\nend", " \
    \ closest_integer = nil\n  candidate.each { |cand|\n    diff = value.to_i - cand.to_i\n\
    \    if diff == 0\n      closest_integer = cand\n      break\n    elsif diff <\
    \ 0\n      closest_integer = cand\n    end\n  }\n  closest_integer\nend", "  rounding_value\
    \ = value.to_s.to_f\n  rounding_value = (rounding_value * 10**12).round\n  difference\
    \ = rounding_value - value.to_i\n  difference = difference.abs\n  difference =\
    \ difference.div(10**12).round\n  if difference.zero?\n    return value.to_i\n\
    \  else\n    difference\n  end\nend", "  value = value.to_i\n  return value.round(-value)\
    \ if value < 0 else value.round(value)\nend", "  value = value.to_f\n  integer\
    \ = value.ceil\n  difference = value - integer\n  return integer if difference\
    \ <= 0.0 && difference >= 0.000001 \\\n    else integer\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a |>\nThis question has already been answered, but i want to\
    \ share my solution. I think it can be simplified. Here is it:\n<code>", "  value\
    \ = value.to_i\n  return value + (value - 1) / (2 ** (value.bit_length() / 2 -\
    \ 1))\nend", "  if value.is_a?(Fixnum)\n    ceil(value)\n  else\n    round_away_from_zero(value)\n\
    \  end\nend", "  num = value.to_i\n  smallest_difference = 0\n  smallest_difference_index\
    \ = 0\n  for i in 0..(integers.length-1)\n    if abs(num-integers[i]) < smallest_difference\n\
    \      smallest_difference = abs(num-integers[i])\n      smallest_difference_index\
    \ = i\n    end\n  end\n  return integers[smallest_difference_index]\nend", " \
    \ # Convert the given value into a floating point number, if necessary.\n  value\
    \ = Float(value)", "  num = value.to_i\n  if num == value.to_i then return num\n\
    \  diff = closest_integer(value.to_f).to_f - closest_integer(value.to_i).to_f\n\
    \  return num if diff > 0 and num + diff == value else num - diff\nend", "  value\
    \ = value.to_s.to_i\n  value.upcase!\n  value = value.to_i\n  closest = (value\
    \ - value/2).round\n  return value == closest ? value.round : closest\nend\n</code>\n\
    This is now my helper function - I now just need to figure out how to invoke it,\
    \ and pass it an argument.\n<|/ q dscore=0 |>\n<| a |>\n<code>", "  num = value.to_i\n\
    \  min_diff = value.to_i - num\n  max_diff = num - value.to_i\n  if max_diff ==\
    \ 0\n    num\n  else\n    if max_diff < min_diff\n      num\n    else\n      num\
    \ - max_diff\n    end\n  end\nend", "  value = value.to_f\n  candidates = [value,\
    \ value - 1, value - 2, value - 3]\n  candidates.sort_by(&:abs)\n  candidates.last\n\
    end", "  x = value.to_i\n  \n  diffs = []\n  \n  diffs.push(x - x)\n  diffs.push(x\
    \ - x * 2)\n  diffs.push(x - x * 3)\n  \n  diffs.each do |diff|\n    if diff >\
    \ 0 and diff < diffs.last\n      return x\n    end\n  end\n  \n  nil\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby |>\n<| a dscore=1 |>\n<code>\nrequire 'bigdecimal'",
  "  # Initialize a variable to hold the closest integer.\n  closest = None\n  # Find\
    \ the index of the first integer.\n  index_of = value.index(\".\")\n  # If the\
    \ index is -1 (meaning the string does not contain a decimal),\n  # then just\
    \ return the given number. Otherwise, find the number that\n  # is closest to\
    \ 0 and the rest of the number. Then, return the index of\n  # the closest number.\n\
    \  if index_of == -1\n    closest\n  else\n    number = value.to_i\n    diffs\
    \ = (number - 0) - (number - 0.to_i)\n    closest = diffs.abs\n    closest\n \
    \ end\nend", "  value = value.to_f\n  return value.to_f == value ? value : ((value\
    \ - (value.to_f - value.to_f % 0.1)) % (value.to_f + 0.1))\nend", "    closest_value\
    \ = nil\n    closest_value = value.to_i if value.is_a? Integer\n    value = value.to_s\n\
    \    minimum = value.to_f\n    minimum = minimum.abs\n    minimum = (minimum -\
    \ minimum/2 if minimum > 0) || minimum\n    maximum = value.to_f\n    maximum\
    \ = maximum.abs\n    maximum = (maximum + maximum/2 if maximum < 0) || maximum\n\
    \    minimum, maximum, difference = minimum, maximum, minimum\n    difference,\
    \ minimum, maximum = [minimum.to_i, maximum.to_i].max\n    difference, minimum,\
    \ maximum = minimum.to_f, maximum.to_f\n    minimum, maximum, difference = minimum.to_i,\
    \ maximum.to_i, minimum.to_i\n    difference, minimum, maximum = [minimum.to_i,\
    \ maximum.to_i].max\n    difference, minimum, maximum = minimum.to_f, maximum.to_f,\
    \ minimum.to_f\n    minimum, maximum, difference = minimum.to_i, maximum.to_i,\
    \ minimum.to_i\n    difference, minimum, maximum = [minimum.to_i, maximum.to_i].max\n\
    \    difference, minimum, maximum = minimum.to_f, maximum.to_f, minimum.to_f\n\
    \    minimum, maximum, difference = minimum.to_i, maximum.to_i, minimum.to_i\n\
    \    difference, minimum, maximum = [minimum.to_i, maximum.to_i].max\n    difference,\
    \ minimum, maximum = minimum.to_f, maximum.to_f, minimum.to_f\n    minimum, maximum,\
    \ difference = minimum.to_i, maximum.to_i, minimum.to_i\n    difference, minimum,\
    \ maximum = [minimum.to_i, maximum.to_i].max\n    difference, minimum, maximum\
    \ = minimum.to_f, maximum.to_f, minimum.to_f\n    minimum, maximum, difference\
    \ = minimum.to_i, maximum.to_i, minimum.to_i\n    difference, minimum, maximum\
    \ = [minimum.to_i, maximum.to_i].max\n    difference, minimum, maximum = minimum.to_f,\
    \ maximum.to_f, minimum.to_f\n    minimum, maximum, difference = minimum.to_i,\
    \ maximum.to_i, minimum.to_i\n    difference, minimum, maximum = [minimum.to_i,\
    \ maximum.to_i].max\n    difference, minimum, maximum = minimum.to_f, maximum.to_f,\
    \ minimum.to_f\n    minimum, maximum, difference = minimum.to_i, maximum.to_i,\
    \ minimum.to_i\n    difference, minimum, maximum = [minimum.to_i, maximum.to_i].max\n\
    \    difference, minimum, maximum = minimum.to_f, maximum.to_f, minimum.to_f\n\
    \    minimum, maximum, difference = minimum.to_i, maximum.to_i, minimum.to_i\n\
    \    difference, minimum, maximum = [minimum.to_i, maximum.to_i].max\n    difference,\
    \ minimum, ", "  value = value.to_f\n  if value.abs < epsilon\n    value\n  else\n\
    \    value.ceil - value.floor\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n+1. But\
    \ I guess you meant `value.ceil` instead of `ceil`.\n<|/ c |>\n<| a |>\nIn case\
    \ anybody is looking to convert a string of numbers to an array:\n<code>", " \
    \ value1 = value.to_i\n  value2 = value.to_i\n  index1 = value1\n  index2 = value2\n\
    \  distance1 = value1 - value1\n  distance2 = value2 - value1\n  if distance2\
    \ < distance1\n    index1 = value2\n    index2 = value1\n    distance1 = value1\
    \ - value2\n    distance2 = value2 - value2\n  end\n  if distance1 == 0\n    index1\
    \ = value1\n    index2 = value2\n    distance1 = value1 - value1\n    distance2\
    \ = value2 - value2\n  end\n  return index1\nend", "  integer = value.to_i\n \
    \ difference = value - integer\n  return integer if difference < 0 || (integer\
    \ == 0 and difference < 0) else integer\nend\n</cell>\n<text>\nLet's try out the\
    \ function and see what it does. Let's test it on the following two examples:",
  "  value = [value.to_i]\n  value[0] = 0 if value[0] < 0 else value[0]\n  value[1]\
    \ = value[0] if value[1] > value[0] else value[1]\n  value[1] += 1 if value[1]\
    \ != 0 else 0\n  return value[0]\nend", "  num = value.to_f\n  floor = num.floor\n\
    \  ceil = num.ceil\n  difference = ceil - floor\n  if difference < 0\n    ceil\
    \ - difference\n  else\n    floor + difference\n  end\nend", "  return value.to_i\
    \ + 1 if value.to_i.zero? || value.to_i == value ? value.to_i : value.to_i - 1\n\
    end", "  value.to_s.to_f\n  value.to_f\n  value.to_i\nend", "    number_integer_to_round_away_from\
    \ = closest_integer(value.to_i)\n    return number_integer_to_round_away_from\
    \ - value.to_i\nend", "  nums = value.to_i.to_f\n  return Math.max(Math.min(*nums),\
    \ *nums)\nend", "    unless value.is_a?(String)\n        raise ArgumentError,\
    \ \"The argument must be a String\"\n    end", "  value = value.to_f\n  value.abs\n\
    \  value = value - value.abs.floor\n  if value < value.abs.floor * -1\n    value\
    \ += value.abs.floor * -1\n  end\n  value\nend", "  int_value = value.to_i\n \
    \ if int_value <= 0\n    return 0\n  dist = int_value.abs\n  closest_integer =\
    \ int_value.abs.ceil\n  while int_value.abs.is_a? Integer\n    int_value = closest_integer.call(int_value)\n\
    \    int_value = int_value.to_i\n    dist += int_value.abs\n    closest_integer\
    \ = int_value.abs.ceil\n  end\n  if int_value == int_value.abs\n    return int_value\n\
    \  end\n  return int_value if dist < int_value.abs\n  return int_value.abs\nend",
  "  value = to_number(value)\n  return to_number(math.floor(value + .5)) if value\
    \ > 0 else to_number(math.ceil(value - .5))\nend\n</cell>\n<code language=julia-1.1>\n\
    using DataFrames", "  closest = 0\n  if value >= 0 and value < 10\n    closest\
    \ = 0\n  elsif value >= 10 and value < 100\n    closest = 10\n  elsif value >=\
    \ 100 and value < 1000\n    closest = 100\n  elsif value >= 1000 and value < 10000\n\
    \    closest = 1000\n  elsif value >= 10000 and value < 100000\n    closest =\
    \ 100000\n  elsif value >= 100000 and value < 1000000\n    closest = 1000000\n\
    \  elsif value >= 1000000 and value < 10000000\n    closest = 10000000\n  elsif\
    \ value >= 10000000 and value < 100000000\n    closest = 100000000\n  elsif value\
    \ >= 100000000 and value < 1000000000\n    closest = 1000000000\n  elsif value\
    \ >= 1000000000 and value < 10000000000\n    closest = 10000000000\n  elsif value\
    \ >= 10000000000 and value < 100000000000\n    closest = 100000000000\n  elsif\
    \ value >= 100000000000 and value < 1000000000000\n    closest = 1000000000000\n\
    \  elsif value >= 1000000000000 and value < 10000000000000\n    closest = 10000000000000\n\
    \  elsif value >= 10000000000000 and value < 100000000000000\n    closest = 100000000000000\n\
    \  elsif value >= 100000000000000 and value < 1000000000000000\n    closest =\
    \ 1000000000000000\n  elsif value >= 1000000000000000 and value < 10000000000000000\n\
    \    closest = 10000000000000000\n  elsif value >= 10000000000000000 and value\
    \ < 100000000000000000\n    closest = 100000000000000000\n  elsif value >= 100000000000000000\
    \ and value < 100000000000000000\n    closest = 100000000000000000\n  elsif value\
    \ >= 100000000000000000 and value < 100000000000000000\n    closest = 100000000000000000\n\
    \  elsif value >= 100000000000000000 and value < 100000000000000000\n    closest\
    \ = 100000000000000000\n  elsif value >= 100000000000000000 and value < 100000000000000000\n\
    \    closest = 100000000000000000\n  elsif value >= 100000000000000000 and value\
    \ < 100000000000000000\n    closest = 100000000000000000\n  elsif value >= 100000000000000000\
    \ and value < 100000000000000000\n    closest = 100000000000000000\n  elsif value\
    \ >= 100000000000000000 and value < 100000000000000000\n    closest = 100000000000000000\n\
    \  elsif value >= 100000000000000000 and value < 100000000000000000\n    closest\
    \ = 100000000000000000\n  elsif value >= 100000000000000000 and value < 100000000000000000\n\
    \    closest = 100000000000000000\n  elsif value >= 100000000000000000 and value\
    \ < 10000000000", "  return value.to_i if value.to_i < (@num_to_round).to_i \n\
    \  (@num_to_round).to_i\nend", "  value = value.to_f\n  difference = value - values.min\n\
    \  if difference < 0\n    values.min\n  else\n    values.max\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nI did it by this way\n<code>", "  numbers\
    \ = value.to_s.split('.')\n  if numbers.length < 2\n    numbers.push numbers[0]\n\
    \  numbers.map! {|n| n.to_i}\n  numbers_sorted = numbers.sort\n  numbers_sorted.delete_if\
    \ {|n| n<0}\n  if numbers_sorted.length > 2\n    numbers_sorted.last\n  else\n\
    \    numbers_sorted.first\n  end\nend", "  value.to_s.split('.')[0].to_i\nend",
  "  unless value.to_f..\n    value = value.to_i\n  end\n  value = value + (value\
    \ / 2).floor\n  case value\n    when value < 0\n      -value.abs\n    when value\
    \ > 0\n      value\n    else\n      nil\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ tags=ruby,ruby-on-rails |>\nHere is a solution that uses the ternary operator\
    \ and without if/else. It also takes care of rounding.\n<code>", "  return value.to_s.sub(/[^\\\
    d]\\.?(\\d+)/).to_f\nend\n</code>\nThe regex to extract the number from the string\
    \ above is:\n<code>\n[^\\d]\\.?(\\d+)\n</code>\nLet's test it\n<code>\nclosest_integer(\"\
    15.5\")", "  new_value = (value.to_f / 100).round\n  new_value += 0.5\n  new_value\
    \ = new_value.to_i\n  return new_value if new_value == value else new_value\n\
    end", "  # If the number is close to zero, return it.\n  return value if value\
    \ == 0 \n  # If the number is equidistant from two integers, return the\n  # one\
    \ that is farthest from zero.\n  difference = value - closest_integer.call(value.abs)\n\
    \  difference = difference if difference.abs != value else 0\n  difference = difference\
    \ if difference.abs == value else difference\n  return value.round(difference)\n\
    end\n</code>\n<|/ a dscore=5 tags=ruby,math |>\n<| c |>\n`1.to_i` is unnecessary.\
    \ `1` is already an `Integer`. Just use `1`.\n<|/ c |>\n<| c |>\nAnd you don't\
    \ want to use `to_f` since `1` is a `Fixnum` not an `Integer`.\n<|/ c |>\n<| c\
    \ |>\nBut `to_f` would yield `1.0` when the argument is `1`.\n<|/ c |>\n<| c |>\n\
    It would yield `1` only if the argument is `1.0`.\n<|/ c |>\n<| a |>\nThe simplest\
    \ way to round a decimal number up in Ruby is to use the ceil method. \n<code>\n\
    2.ceil\n => 2 \n2.ceil.upto(2)\n => [2,3] \n2.ceil.upto(nil)\n => [2, 3]\n</code>\n\
    <|/ a tags=ruby,math dscore=5 |>\n<| a tags=ruby,math |>\n<code>\n> 1.ceil\n=>\
    \ 1\n> 2.floor\n=> 1\n> 2.ceil\n=> 2\n> 3.floor\n=> 2\n> 3.ceil\n=> 3\n> 4.ceil\n\
    => 4\n> 4.floor\n=> 4\n</code>\n<|/ a dscore=4 |>\n<| c |>\n`ceil` will round\
    \ up the decimal number. `floor` will floor the decimal number.\n<|/ c |>\n<|\
    \ a dscore=4 |>\n<code>", "  value.to_s.split(\"\").map{ |digit| digit * 10 +\
    \ value.to_i }.sort.last\nend", "  value = value.to_i\n  difference = value -\
    \ @value\n  return @value if difference == 0\n  @value = @value - difference\n\
    \  rounded_value = @value.round\n  difference = rounded_value - @value\n  return\
    \ rounded_value if difference == 0\nend", "  if value.is_a? Numeric\n    closest\
    \ = (value - 1).abs\n    if closest == value || closest == value + 1\n      closest\n\
    \    else\n      closest + 1\n    end\n  elsif value.is_a? String\n    value.to_i.abs\n\
    \  else\n    nil\n  end\nend\n</code>\n<|/ a dscore=3 tags=ruby,integer,rounding\
    \ |>\n<| c |>\nThanks, this is great.  I used it in a Rails controller method\
    \ like this:", "  value = value.to_s\n  value.chomp!\n  value = value.to_f\n \
    \ return value.to_i\nend", "  value = value.to_s\n  return value.to_i if value.to_i.between?(@min_value,@max_value)\
    \ \n  \n  diff = value.to_f - @min_value\n  diff > 0 ? value.to_i : @max_value.to_i\n\
    end", "  value = (value.to_f).round\n  if value >= 0 && value % 1 == 0\n    value.to_i\n\
    \  else\n    value - 0.5\n  end\nend", "  value = value.to_f\n  closest_integer\
    \ = value.abs.floor\n  closest_integers_between = value.abs.round / 2\n  closest_integers_between\
    \ = [closest_integer, closest_integers_between].min", "  case value.is_a?(String)\n\
    \  when /^[+-]?[0-9]+$/\n    value.to_i.round\n  when /^[+-]?[0-9]*(\\.[0-9]+)?$/\n\
    \    value.to_f.round(0)\n  else\n    nil\n  end\nend", "    difference = value\
    \ - nearest_integer(value)\n    if difference < 0\n        difference = difference\
    \ * (-1)\n    end\n    return value + difference\nend", "  return value[/(?=.+)\\\
    d+/].to_i\nend", "  # TODO: Your code here!\n  return value\nend", "  # Split\
    \ out the float\n  number_as_float = value.to_f\n  # Figure out the number of\
    \ decimal places in the input\n  num_decimals = value.to_s.split(\".\")[1].to_i\n\
    \  # If there are an odd number of decimal places\n  if num_decimals.odd?\n  \
    \  # If the number is negative, round up to the nearest integer up\n    if number_as_float\
    \ < 0\n      number_as_float = number_as_float + (1.0/num_decimals).round\n  \
    \  # If the number is positive, round down to the nearest integer down\n    else\n\
    \      number_as_float = number_as_float - (1.0/num_decimals).round\n  end\n \
    \ # Return it\n  number_as_float.to_i\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby\
    \ dscore=0 |>\nI believe this would do what you are looking to do.\n<code>", " \
    \ # Create a variable named x that takes in value as a string and then\n  # calls\
    \ to_i on it.\n  x = value.to_i", "    value.to_s.to_i\nend", "  return value\
    \ % 10 ? value : (value - 5 + closest_integer(10.0 / value))\nend", "  # Your\
    \ code here\n  value = value.to_i\n  difference = Integer(value)-Integer(value)\n\
    \  if difference<0 then\n    difference*=-1\n  else\n    difference*=0\n  end\n\
    \  difference\nend\n</code>\n<|/ a tags=ruby,methods |>\n<| a tags=ruby,methods\
    \ |>\nI needed this solution for my assignment and thought I'd share my solution.\
    \ It's similar to other responses but it is a little different.\n<code>", "  value\
    \ = value.to_f\n  closest = (value.abs).round\n  value = closest + value\n  while\
    \ value == closest\n    value = value - 0.5\n  end\n  value\nend\n</code>\nThe\
    \ code below implements the function. It is probably not the most efficient way\
    \ to achieve this but it is easy to understand and will allow you to practice\
    \ making your own functions in Ruby.\n<code>", "  value = value.to_f\n  closest_integer\
    \ = Math.min( Math.ceil(value.to_f), Math.floor(value.to_f))\n  ((closest_integer\
    \ - value) < 0) ? closest_integer = 0 : nil\nend", "  if value.is_a?(Fixnum) or\
    \ value.is_a?(Bignum) or value.is_a?(Float)\n    value\n  else\n    value.to_s.split(//).map\
    \ {|x| x.to_i }.sort.last\n  end\nend", "  return value.to_i unless value.is_a?(Float)\n\
    \  d = value - ceil(value)\n  d == 0 ? ceil(value) : ceil(value) + d + 1\nend",
  "  value = value.to_f\n  closest = value\n  direction = value < 0 ? 1 : -1\n  while\
    \ direction != 0\n    closest = (closest.abs + direction).floor\n    direction\
    \ = (direction * 2) / 2\n  end\n  closest\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-4,ruby-on-rails-3\
    \ |>\n<| c |>\nThis is a great answer and I think it's worth adding that Ruby\
    \ 1.9 has its own rounding behavior where negative numbers are rounded away from\
    \ zero, positive numbers are rounded towards zero.\n<|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-4,ruby-on-rails-3\
    \ |>\n<code>\n(-60.5).floor", "  value.to_s.split(%r{\\.(\\d*)(?:\\.0*)?$}).each\
    \ do |digit|\n    if digit.to_i > value\n      return digit.to_i\n    end\n  end\n\
    \  value.to_s.split(%r{\\.(\\d*)(?:\\.0*)?$}).each_with_index do |digit, i|\n\
    \    if digit.to_i > value\n      return i\n    end\n  end\n  return value.to_s.split(%r{\\\
    .(\\d*)(?:\\.0*)?$}).length\nend", "    number = value.to_i\n    closest_integer\
    \ = number\n    difference = (number - closest_integer).abs\n    while difference\
    \ > 0\n        if difference < 1\n            return closest_integer\n       \
    \ else\n            closest_integer = (closest_integer + difference).floor\n \
    \           difference = (number - closest_integer).abs\n        end\n    end\n\
    \    return closest_integer\nend", '  closest = (value - closest_integer(value/value)).round',
  "  value.to_f().round\nend", "  value.to_i\n  return value.to_i % [10,100,1000].max\n\
    end", "  value = value.to_f\n  abs = Math.abs(value)\n  closest_integer = (value.abs<abs)?\
    \ value : -abs(value)\n  closest_integer.round\nend", "  value.gsub!(/\\.|,/,\
    \ '')\n  value = value.to_f\n  floor = (value % value.abs).floor\n  ceil = (value\
    \ % value.abs).ceil\n  if floor == value\n    floor\n  else\n    if floor < ceil\n\
    \      floor\n    else\n      ceil\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=ruby-on-rails,ruby,math |>\nRuby has a BigDecimal class\
    \ that you can use for this.\nThe gcd2 method will return the first number that\
    \ is a factor of the second number.\nFor example:\n<code>\nBigDecimal.new(24).gcd2(BigDecimal.new(8))\n\
    => 2\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails,ruby,math |>\nTo get the greatest\
    \ common divisor of two numbers you can do the following:\n<code>", "  return\
    \ value.to_i == 0 ? value : value.ceil\nend\n</code>\nI hope this helps!\n<|/\
    \ a |>\n<| a tags=ruby,integer,string,rounding |>\nTo round up or down a number,\
    \ use ceil or floor.\n<code>\n(4.8).ceil", "  return value.to_i > value.to_i +\
    \ 1 ? value.to_i + 1 : value.to_i\nend", "  value.to_i.round(precision: 0).to_s\n\
    end", "  # Return the closest integer to the value.\n  return value.to_i if value.to_i\
    \ >= 0 && value.to_i < value ? value.to_i : value.to_i\nend", "  return value.to_i.ceil\
    \ if value.length == 1 ? value.to_i : value.to_i.floor\nend", "  if value.is_a?(Numeric)\n\
    \    return value.to_i\n  elsif value.is_a?(String)\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('.')]\n\
    \    value = value[0..value.rindex('.')]\n    value = value[0..value.rindex('",
  '  value = value.to_f', '  value = value.to_f', "    closest_integer = value.to_i\n\
    \    difference = closest_integer - value\n    if difference == 0 then\n     \
    \   closest_integer\n    else\n        closest_integer = value + difference -\
    \ 1\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string dscore=1\
    \ |>\nOne more alternative in one line:\n<code>\n\"10\".to_i().round(2)\n</code>\n\
    <|/ a |>\n<| a |>\nTry this:\n<code>", "  if value.is_a?(String)\n    value =\
    \ value.to_f\n  end", "  return Integer(value.to_i).round\nend", "  # Convert\
    \ to a float and round it to the nearest integer.\n  # This is to prevent some\
    \ rounding errors that could occur if your\n  # number was an integer.\n  value\
    \ = Float(value)\n  value = value.round\n  return value.round\nend", "  value\
    \ = value.to_i\n  \n  # Handle zero and negatives\n  if value == 0\n    value\
    \ = 1\n  elsif value < 0\n    value = -value\n  end\n  \n  int_diff = value_to_diff(value)\n\
    \  int_diff += 2 if int_diff > 2\n  int_diff -= 2 if int_diff < -2\n  \n  int_diff\
    \ += value_to_diff(value.abs)\n  int_diff += value_to_diff(value.abs.abs)\n  \n\
    \  if int_diff == 0\n    int_diff = 1\n  elsif int_diff < 0\n    int_diff = int_diff.value\n\
    \  end\n  \n  return int_diff\nend", "  value.to_i\n  closest_integers = all_close_integers\n\
    \  closest_integers.sort!", "  return value.to_i + (value.to_i - value.to_i.abs)\
    \ * round( (value.to_i - value.to_i.abs.abs)/(value.to_i.abs.abs) )\nend\n</code>\n\
    And here's a test case for a few different cases:\n<code>", "  to_return = value.to_i\n\
    \  min_value = to_return\n  max_value = to_return\n  min_diff = 1\n  max_diff\
    \ = to_return\n  while to_return > 0 and max_diff > 0\n    min_value = to_return\n\
    \    max_value = to_return\n    min_diff = to_return\n    max_diff = to_return\n\
    \    if to_return % 2 == 0\n      to_return /= 2\n    else\n      to_return /=\
    \ 2\n    end\n  end\n  return min_value if min_value == to_return\n  return max_value\
    \ if max_value == to_return\n  return max_value if min_diff > max_diff\n  return\
    \ min_value if min_diff < max_diff\n  \n  return to_return\nend\n</code>\n<|/\
    \ a tags=ruby,algorithm |>\n<| a dscore=0 tags=ruby,algorithm |>\nRuby's built\
    \ in methods only work for integers. If you want to round to any float-like number,\
    \ you can use this code:\n<code>", "  if value.is_a?(String) # Make sure it's\
    \ a number\n    value = value.to_f\n  end\n  \n  return value - (value % 100)\n\
    end", "  return value if value.is_a?(Integer) && value > 0 && value < 100 ? value\
    \ : value.to_i.round\nend", "  value = Float(value)\n  return value.to_i if value\
    \ >= 0 && value <= MAX_INT\n  ((value - 1).abs <= MAX_INT / 2).ceil\nend\n</code>\n\
    This code has been tested against several examples and is certainly not exhaustive.\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,floating-point,int |>\nTry this\n<code>", " \
    \ value = value.to_f\n  value = value.round\n  return value if value >= 0 else\
    \ value\nend", "  value = value[0]\n  min = value\n  max = value\n  for i in (1..value.size)\n\
    \    min = i if value[i] < min else min\n    max = i if value[i] > max else max\n\
    \  end", "  # Split the value into an array of digits representing the\n  # number\
    \ as an integer with '.' being the decimal point. This\n  # will be needed to\
    \ find the closest integer from it.\n  number = value.split('.')\n  # Convert\
    \ the number into an integer so we can operate on it.\n  number = number.inject(:+).to_i\n\
    \  # Calculate the difference between the original value and the\n  # number from\
    \ the array we just created.\n  difference = value.to_i - number\n  # If the difference\
    \ is zero, just return the original value.\n  # This happens when the value is\
    \ a whole number. Otherwise,\n  # return the original value plus the difference\
    \ from zero.\n  if difference == 0\n    value\n  else\n    value\n    +difference\n\
    \  end\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails |>\n<| a dscore=1\
    \ tags=ruby,ruby-on-rails |>\nHere's my take on it\n<code>", "  return (value.to_f.ceil\
    \ - value.to_f.floor).round\nend", "  if value =~ /^-?\\d*\\.\\d$/\n    number\
    \ = $1\n  else\n    number = $1\n  end", "  closest_integer_value = value.to_i\n\
    \  nearest_integer = value.to_f\n  while nearest_integer % 1 == 0\n    nearest_integer\
    \ -= 1\n  end\n  while closest_integer_value % 1 == 0\n    closest_integer_value\
    \ -= 1\n  end\n  return closest_integer_value if (nearest_integer < closest_integer_value)\n\
    \  nearest_integer += 1\n  nearest_integer -= 1\n  while nearest_integer % 1 ==\
    \ 0\n    nearest_integer -= 1\n  end\n  while closest_integer_value % 1 == 0\n\
    \    closest_integer_value -= 1\n  end\n  while nearest_integer < closest_integer_value\n\
    \    nearest_integer += 1\n    nearest_integer -= 1\n  end\n  while closest_integer_value\
    \ % 1 == 0\n    closest_integer_value -= 1\n  end\n  return closest_integer_value\n\
    end", "  value = value.to_i\n  closest = nil\n  if value == 0\n    value\n  else\n\
    \    min = value\n    max = (value / 2).ceil\n    (1..max - 1).each do |i|\n \
    \     value = min * 2\n      next if value == 0\n      break if value.abs < value\n\
    \      if value\n        closest = (min + i).floor\n        break\n      end\n\
    \    end\n    closest\n  end\nend", "  value = value.to_f\n  smallest_diff = value.abs\n\
    \  closest_integer = value\n  \n  value.each_with_index do |val, i|\n    if val\
    \ < 0\n      smallest_diff -= val\n      closest_integer -= val\n    else\n  \
    \    smallest_diff += val\n      closest_integer += val\n      break\n    end\n\
    \  end\n  \n  if smallest_diff < 0\n    closest_integer = closest_integer.abs\
    \ - smallest_diff\n  end\n  \n  closest_integer\nend", "  value = Float(value)\n\
    \  if value == value / 2\n    round(value)\n  else\n    value - value % 2\n  end\n\
    end", "  value_string = value.to_s\n  value_digits = value_string.split('.')\n\
    \  value_digits.each do |digit|\n    next if digit.empty?\n    digit = digit.to_i\n\
    \    diff_to_prev = prev_integer_diff(digit, digit)\n    diff_to_next = next_integer_diff(digit,\
    \ digit)\n    if diff_to_prev > diff_to_next\n      return digit\n    elsif diff_to_prev\
    \ < diff_to_next\n      return digit - 10\n    end\n  end\n  value\nend", "  value\
    \ = value.to_f\n  return nil if value == 0.0\n  differences = []\n  (1..value).each\
    \ do |i|\n    difference = AbsMath.fabs(i - value)\n    differences << difference\
    \ if difference < differences.last\n  end\n  differences.max\nend", "  # Convert\
    \ the value to a string and store it in a new variable.\n  value = StringUtils.string_to_lower(value)\n\
    \  # Get the two numbers and store them in variables.\n  value = StringUtils.string_to_number(value)\n\
    \  minValue = value\n  maxValue = value\n  # Get the remainder of the division\
    \ between the two numbers.\n  remainder = (value - minValue) % maxValue\n  # If\
    \ the remainder is zero, both numbers are equidistant.\n  if(remainder == 0)\n\
    \    # Return the minimum value that is equidistant from both values.\n    return\
    \ minValue\n  # Otherwise, return the number that is equidistant from both values,\n\
    \  # but closest to zero.\n  else\n    # Return the minimum value of the two numbers\
    \ minus the\n    # remainder.\n    return minValue - remainder\nend", "  # Convert\
    \ the value to a string and store the digits in an array.\n  digits = value.to_s.split(\"\
    \")\n  # Add one to the length of the digits.\n  digits = digits.unshift(1)\n\
    \  # Create a variable that represents the integer that will be\n  # returned\
    \ as the closest. Initially, it should be equal to the\n  # value passed in.\n\
    \  nearest_integer = value\n  # Loop through each digit in the digits. If the\
    \ digit is equal\n  # to one of the nearest integers, replace it with the integer\
    \ that\n  # is farthest from zero.\n  digits.each_with_index do |digit, i|\n \
    \   if nearest_integer == digit\n      nearest_integer = digits[digits.index(d)\
    \ - 1]\n    end\n  end\n  return nearest_integer\nend", "  return value.to_i if\
    \ value.to_i\n  \n  def find_nearest_integer(value)\n    distance = value.to_f\
    \ - value.to_i.to_f\n    closest_integer = value.to_i\n    \n    if distance <\
    \ 0\n      closest_integer  = value.to_i - distance\n    elsif distance  > 0\n\
    \      closest_integer = value.to_i + distance\n    end\n    \n    closest_integer\n\
    \  end\n  \n  find_nearest_integer(value)\nend", "  value.to_i.floor\nend", " \
    \ value.to_i\n  new_value = value.to_f\n  new_value = new_value - (new_value %\
    \ 1.0).floor\n  return new_value\nend", "  # TODO: write your code here\nend",
  "  value = value.to_i\n  # If the value is equidistant from two integers, round\
    \ it away from zero.\n  if value == 0\n    value += 1\n  elsif (value < 0)\n \
    \   value += 1\n  elsif (value > 0)\n    value -= 1\n  end\n  value\nend", " \
    \ value = value.to_i\n  candidates = []\n  # The loop below goes through all potential\
    \ candidates that can be\n  # made in rounding away from zero. The candidates\
    \ start at integers\n  # divisible by three and continue with two factors of three\
    \ until the\n  # number is not divisible by any factor. Then the loop stops and\
    \ the\n  # candidate with lowest number is chosen.\n  candidates << value % 3\n\
    \  i = 3\n  while candidates.size < 10\n    candidates << i * 3\n    i += 2\n\
    \  end\n  candidates.reverse_each.find { |v| value == v }\nend\n</code>\nThe implementation\
    \ above uses a while loop because it is simpler to read and easier to understand\
    \ than recursion. If you are interested in recursion, here is the same algorithm\
    \ in C#:\n<code>\n// Given a number and a divisor, return the closest integer\
    \ to it.\n// If the number is equidistant from two integers, round it away from\
    \ zero.\n// Returns -1 if the number is less than zero.\npublic static int ClosestIntegerWithRecursion(string\
    \ value, int divisor)\n{\n  if (value.Length == 1)\n  {\n    if (int.Parse(value)\
    \ > 0) return int.Parse(value);\n    return -1;\n  }\n  if (int.Parse(value) ==\
    \ int.Parse(value.Substring(0, value.Length - 1))) return int.Parse(value);\n\
    \  int closestValue = int.Parse(value);\n  for (int i = 3; i <= divisor; i++)\n\
    \  {\n    closestValue = closestValue + (int.Parse(value.Substring(0, value.Length\
    \ - i)) / i);\n    if (closestValue >= int.Parse(value))\n    {\n      break;\n\
    \    }\n  }\n  return closestValue;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    This solution is incorrect if your input is \"-16.7\" for example. it will return\
    \ 16.7 (which is the closest integer) instead it should return -16 (which is not\
    \ close)\n<|/ c |>\n<| c |>\nI fixed the algorithm to handle negative numbers\
    \ as well. I also fixed the bug that was causing it to give wrong answers for\
    \ some reason.\n<|/ c |>\n<| a dscore=3 |>\nFor those of you who find this thread\
    \ looking for a Javascript solution, I have come up with this one:\n<code>\nfunction\
    \ closestInteger(value){\n    var factor = 3;\n    var closest = null;\n    var\
    \ closestFactor = 0;\n    var factors = value.split('.');\n    var value = parseFloat(factors[0]);\n\
    \    var i = 0;", "  return value if value.is_a?(Integer) && value < 0 ||\n  \
    \                value.is_a?(Float) && value.to_i < 0 ||\n                  value.is_a?(String)\
    \ && value.include?('-') ||\n                  value.is_a?(String) && value.include?('+')\
    \ ? value.to_i : nil\nend\n</code>\n<|/ a tags=ruby,rounding |>\n<| a tags=ruby,rounding\
    \ |>\nI wrote a gem for that: round-number\n<code>\nrequire 'round_number'", " \
    \   num = value.to_i\n    if num > 0 and num.even?\n        return (num - num.floor)\
    \ / 2\n    else\n        return num\n    end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,integer,string\
    \ |>\n<| c |>\nNice! `num.even?` is more Ruby than `num % 2 == 0`, so I've included\
    \ it in the answer (for future readers).\n<|/ c |>\n<| c |>\nWhat is \"more Ruby\"\
    \ about `num % 2 == 0` than `num.even?`?\n<|/ c |>\n<| c |>\n`num % 2 == 0` returns\
    \ `true` or `false` depending on the remainder after division by two. `num.even?`\
    \ returns a boolean.\n<|/ c |>\n<| c |>\nThat's fine, but I think `num.even?`\
    \ expresses your intent more clearly, whereas `num % 2 == 0` does not.\n<|/ c\
    \ |>\n<| c |>\nAgreed, `num % 2 == 0` is more clear. I'm just saying it's more\
    \ Ruby, not that it's \"more Ruby\" ;)\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,integer,string\
    \ |>\nI came up with something along the lines of your solution:\n<code>", "\t\
    value.to_i.round\nend", "  case value.to_s\n  when '-inf', '+inf' then value\n\
    \  else value.to_i\n  end\nend", "  # If the given value is not valid, return\
    \ it.\n  next unless float(value).is_a?(Float)\n  # Find the two closest numbers\
    \ to value.\n  num1 = value - 0.5\n  num2 = value + 0.5\n  # Return the smaller\
    \ value.\n  num1 < num2 ? num1 : num2\nend\n</code>\n<|/ a dscore=4 tags=integer,ruby\
    \ |>\n<| c |>\nWhy isn't this the accepted answer? I wouldn't expect anyone to\
    \ do this without using an external gem.\n<|/ c |>\n<| a |>\nYou could use the\
    \ to_i method of String.\n<code>", "  value.to_i\n  diff = (@value.to_i - @value.floor).abs\n\
    \  diff.zero? ? value : @value.ceil + diff\nend\n</code>\n<|/ a tags=ruby,rounding\
    \ |>\n<| c |>\nNice answer, but this doesn't handle the edge cases where `@value.ceil`\
    \ would be zero, where `@value.floor` would be, in that case, would it round up\
    \ or down? To handle edge cases, you can either use `@value.ceil - diff` or `@value.floor\
    \ + diff`, I believe.\n<|/ c |>\n<| a tags=ruby,rounding |>\nThis seems like a\
    \ reasonable place to use Kernel#ceil and Kernel#floor:\n<code>", "  return closest_integer_fix(value)\
    \ if value[/^\\-?\\d+\\.?\\d*$/] else value\nend", "  value.to_f\n  \n  if value.to_f\
    \ - value.to_f.floor > value.to_f.abs.sqrt\n    return value.to_f - value.to_f.floor\n\
    \  else\n    return value.to_f - value.to_f.ceil\n  end\nend", "  # Create a variable\
    \ to store the nearest integer to value\n  # (note that this will be the closest\
    \ integer that is\n  # greater than value)\n  closest_integer = 0\n  # If value\
    \ is negative, find the closest integer that is less\n  # than value\n  if value\
    \ < 0\n    closest_integer = -1 * (value - (1 / value))\n  # If the number is\
    \ equidistant from two integers, round it away from zero\n  # (this does not work\
    \ properly for negative numbers)\n  elsif closest_integer == 0\n    closest_integer\
    \ = value - (1 / value)\n  elsif closest_integer == -1\n    closest_integer =\
    \ value + (1 / value)\n  elsif closest_integer == 1\n    closest_integer = value\n\
    \  else\n    # If closest_integer is greater than or equal to 1 and the value\n\
    \    # is equidistant from two integers, set closest_integer to the\n    # smaller\
    \ integer (this works properly).\n    if value == 1 / closest_integer\n      closest_integer\
    \ = -1 * (value - (1 / value))\n    end\n  end\n  # Return closest_integer\n \
    \ closest_integer\nend\n</code>\n<|/ a dscore=1 tags=rounding,ruby |>\n<| a dscore=1\
    \ |>\nThis is my solution:\n<code>", "  if value.is_a? String\n    value = value.to_i\n\
    \  else\n    value = value.to_f\n  end\n  return value.round if value < 0\n  return\
    \ value if value == 0 || value == 1\n  return value - 1 if value == -1 && value.abs\
    \ < 1.0\n  int_value = value\n  int_value.round - 1 if int_value.abs >= 1.0\n\
    end\n</cell>\n<cell>", "  if value.to_f == 0.0\n    value.to_i\n  else\n    ceiling\
    \ = value.to_f / 1.41\n    floor = value.to_f / 1.40\n    return value.to_i if\
    \ (ceiling <= value && value <= floor)\n    ceiling\n  end\nend", "  int_value\
    \ = Integer(value)\n  min_value = int_value.floor\n  max_value = int_value.ceil\n\
    \  \n  if max_value - min_value == 0\n    min_value = int_value.ceil\n  else\n\
    \    max_value = int_value.floor\n  end\n  \n  return int_value.to_i == min_value\
    \ ? min_value : max_value\nend", "  value = value.to_i\n  return value if value\
    \ < 0 || (value > 0 && value.negative?)", "  rounded_value = value.to_f.round(1)\
    \ == 0\n  return rounded_value ? value.to_i : value.to_f\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
