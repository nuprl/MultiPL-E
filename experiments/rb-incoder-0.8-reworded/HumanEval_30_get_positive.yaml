name: HumanEval_30_get_positive
language: rb
prompt: "# Return only positive numbers in the array.\n# >>> get_positive.call([-1,\
  \ 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0,\
  \ 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n\
  \    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1,\
  \ -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5,\
  \ 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1,\
  \ -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"
completions: ["  l.select{|x| x >= 0}\nend", "  l.select { |x| x >= 0 }\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,arrays |>\n<| a dscore=1 |>\nHow about\n<code>\narr.reject\
    \ {|i| i.zero? }\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=1 |>\n<code>\n\
    arr.reject{|i| i.zero?}\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nPlease add\
    \ an explanation as to why this answers the question.\n<|/ c |>\n<| c |>\nThe\
    \ question was \"how to remove all zeroes from array\" and i believe my answer\
    \ answers that question. How does my answer not answer it?\n<|/ c |>\n<| c |>\n\
    The question was \"how to remove all zeroes from array\". How does your answer\
    \ remove only zeroes from the array? It doesn't answer the question and doesn't\
    \ explain why. Furthermore, the question was already answered by another answer.\
    \ I'm sorry if this bothers you.\n<|/ c |>\n<| a dscore=0 |>\nYou could do this\n\
    <code>\narr.reject!{|a| a != 0}\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    No need to use `!`: `arr.reject{|a| a != 0}`. Also, `a == 0` is a boolean expression,\
    \ `a != 0` is redundant.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\narr.reject{|i|\
    \ i.zero?}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add an explanation as\
    \ to why this answers the question.\n<|/ c |>\n<| c |>\nSorry, I forgot about\
    \ this one. Just edited my post a bit.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\n\
    arr.reject{|x| x == 0 }\n</code>\nOr:\n<code>\narr.reject!{|x| x == 0 }\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\n<code>", "  l.map! {|x| x if x >\
    \ 0}\nend", "    l.select { |x| x >= 0 }\nend", "  l.select { |n| n < 0 }\nend",
  "  l.select { |x| x.positive? }\nend", "  l = l(1); l = (l<=0?[]:l); return l\n\
    end", "  l.select { |x| x > 0 }\nend", "  l.map! {|x| x > 0 ? x : nil}\n  l\n\
    end", "  return l.select { |x| x >= 0 }\nend", "  l.map { |x| return x if x >\
    \ 0 }\nend", "  l.map(&:abs).select(&:positive?)\nend", "  l.collect { |x| x <\
    \ 0 ? nil : x }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer,\
    \ but this does not return the same as the code I posted. It returns `[1, -1,\
    \ 2, 4, 5, 6]` instead of `[2, 5, 6]`.\n<|/ c |>\n<| c |>\nThe code I posted works\
    \ as intended. Try it out: `get_positive.call([-1, 2, -4, 5, 6])` returns `[2,\
    \ 5, 6]`. Also tested with Ruby 1.9.2p180.\n<|/ c |>\n<| c |>\nOh okay, I didn't\
    \ know you used `collect` instead of `map`. I just updated the code in the question\
    \ to reflect your answer. Thanks!\n<|/ c |>\n<| a dscore=0 |>\nHere's an example\
    \ of a recursive solution using recursion. This method can be called on any array\
    \ and it will return the array with the values changed:\n<code>", "    l.select{|x|\
    \ x > 0}\nend\n    ", "  l.select(&:positive?)\nend", "  l.select{|e| e >= 0}\n\
    end", "  l.each do |i|\n    if i > 0 && i <= 0\n      l.delete(i)\n    end\n \
    \ end\n  l\nend", "  l.collect! do |x|\n    if x > 0 && x < 0\n      x\n    else\n\
    \      x\n    end\n  end\n  l\nend", "  # Return all positive numbers excluding\
    \ zero.\n  # Note that zero is excluded because 0 has a special meaning in Python.\n\
    \  l.delete_if { |n| n < 0 }\nend", "  l.select { |v| v > 0 }\nend", "  return\
    \ l.reject { |x| x < 0 }\nend", "  l.select {|x| x > 0}\nend\n</pre>\n</div>",
  "  l.select {|x| x >= 0 }\nend", "  l.select { |x| x > 0 }\nend", "  l.select {|n|\
    \ n > 0}\nend", "  return l.select { |x| x >= 0 }\nend", "    l.map! { |x| x if\
    \ x > 0 }\n    l\nend", "  l.map {|i| return i if i > 0}\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThank you very much!\n<|/ c |>\n<| a |>\n<code>", "  return l.select(l.positive?)\n\
    end", "  l.each_with_index do |x, i|\n    if x.positive?\n      yield i\n    end\n\
    \  end\nend", "  # Return only the positive numbers in the array.\n  return l.select\
    \ {|x| x > 0}\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\n`select!` and\
    \ `reject!` are mutating methods, so they don't play nice with functional languages.\
    \  Ruby is a pure functional language.  `map` and `collect` are more idiomatic\
    \ in Ruby.\n<|/ c |>\n<| c |>\nThis is exactly the kind of answer I was looking\
    \ for.  Thanks so much.  I guess I was confused because I was expecting the method\
    \ to return the array after it was modified, which is not the case for these methods.\n\
    <|/ c |>\n<| c |>\n- Yes, those are mutating methods.  They return values that\
    \ could be used to alter the original object.  They are also generally faster\
    \ because they don't need to create new objects.\n<|/ c |>\n<| c |>\nI believe\
    \ you can also use `select` instead of `grep` if you are using a version of Ruby\
    \ earlier than 1.8.7 where `grep` returns an enumerator instead of a `Set`.  Then\
    \ it would be `select { |x| x > 0 }`\n<|/ c |>\n<| a dscore=5 tags=arrays,ruby\
    \ |>\nFor those looking for a succinct way to do this in Ruby 1.9+, you can use\
    \ Array#reject!, which removes items from the array while preserving order:\n\
    <code>\n[1,-3,4,5].reject! { |n| n < 0 }", "  # Return the first positive number\
    \ in the array.\n  positive = l[0]\n  l.each do |x|\n    if x >= positive\n  \
    \    positive = x\n    end\n  end\n  return positive\nend", "  l.map!(&:abs)\n\
    \  l.select { |x| x >= 0 }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThank you,\
    \ I did something similar to that with the `sum` method. Didn't know it worked\
    \ on hashes.\n<|/ c |>\n<| c |>\nThis is great, thank you for sharing that. Can\
    \ you please explain what happens in `get_positive.call([5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10])`?\n<|/ c |>\n<| c |>\nWhat happens there is the same thing\
    \ that happens in `get_positive.call([-1, 2, -4, 5, 6])`: the `map` method iterates\
    \ over each element in the array, and applies an arbitrary function (here `abs`)\
    \ to each one. `get_positive` then takes the positive elements of each array (that\
    \ is, `[5, 3, 2, 3, 9, 123, 1]`), and returns those.\n<|/ c |>\n<| c |>\nAh, I\
    \ get it. Thanks!\n<|/ c |>\n<| c |>\nI realized that it's possible to call `get_positive`\
    \ on `nil`, which is why I made it raise an exception in that case.\n<|/ c |>\n\
    <| a tags=ruby,functional-programming |>\nThe easiest way to do this would be\
    \ to use #reduce and some boolean logic.\n<code>\na = [1, 2, 3, 4, 5]\na.inject(true)\
    \ { |flag, el| flag &= el > 0; flag }\n=> true\n</code>\nBut if you really want\
    \ to use a named function, you could just wrap your method into another method:\n\
    <code>", "  l.select{ |e| e > 0 }\nend\n</code>\n<|/ a tags=ruby,arrays,methods\
    \ |>\n<| c |>\nI don't think you need to use that `select` method. That's a method\
    \ that comes with Enumerable. Just do `l.select { |e| e > 0 }`\n<|/ c |>\n<| c\
    \ |>\nTrue. Though I like that syntax for readability, it's really just a preference.\n\
    <|/ c |>\n<| c |>\nThanks, this is very helpful! And I really like the way you\
    \ explained it too, I will be using that going forward :)\n<|/ c |>\n<| c |>\n\
    The OP specifically asked for a method that returns only positive numbers.\n<|/\
    \ c |>\n<| a |>\n<code>", "    l.select { |x| x >= 0 }\nend", "  if l\n    l.map{|x|\
    \ x if x > 0 }\n  else\n    []\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nHere's a shorter solution:\n<code>", "  l.select { |e| e > 0 }\nend", " \
    \ l.map{|x| x if x > 0 }\nend\n</cell>\n<text>\nSort functions\nsort functions\
    \ in Ruby are more concise than those in Perl. Ruby has some nice sorting algorithms\
    \ in its standard library (though it's not a part of core language). You can pass\
    \ comparison function as a parameter to sort function and Ruby will use it to\
    \ compare items.", "  l.map { |e| e < 0 ? nil : e }\nend\n</cell>\n<cell>", " \
    \ l.map { |e| return e if e >= 0 }\nend", "  l.compact.select { |x| x >= 0 }\n\
    end", "  l.compact.select(&:positive?)\nend", "  return l.select { |e| e > 0 }\n\
    end", "  return l.select { |x| x > 0 }\nend", "  l.map{|x| x > 0 ? x : nil}\n\
    end", "  l.select { |e| e >= 0 }\nend\n</pre>", "  l.select { |x| x >= 0 }\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a |>\nI like Mario's answer because it's concise,\
    \ but I wouldn't use it because it takes advantage of a feature Ruby has to offer\
    \ you: Object#public_methods.\n<code>", "  l.select{|i| i > 0}\nend", "  l.each\
    \ do |x|\n    return x if x > 0 and x != nil\n  end\n  return nil\nend", "  l.each_with_index\
    \ { |e, i| return e if i > 0 }\nend", "    positives = []\n    l.each { |x| \n\
    \        if (x != 0 && x != nil && x >= 0)\n            positives << x\n     \
    \   end\n    }\n    return positives\nend", "  l.map! {|x| x >= 0 ? x : nil }\n\
    end", "  l.select { |x| x > 0 }\nend", "  l.each do |item|\n    return item if\
    \ item >= 0\n  end\n  return []\nend", "  if l == nil\n    nil\n  elsif l == 0\n\
    \    0\n  else\n    l.inject(0, &:+) || 0\n  end\nend", "    l.map! { |n| n if\
    \ n >= 0 }\nend", "  l.each_index do |i|\n    next if l[i] < 0\n    l[i] = l[i].abs\n\
    \  end\nend", "  if l.is_a? Enumerable\n    l.select {|e| e > 0 }\n  else\n  \
    \  l.select {|e| e >= 0 }\n  end\nend", "  return l[l.select{|x| x > 0}.map{|x|\
    \ x + 1}]\nend", "  l.map! { |x| x if x > 0  }\n  l\nend", "  l.select { |x| x\
    \ > 0 }\nend", "  l.select{ |x| x > 0 }\nend", "  l.map! {|i| i if i >= 0}\nend\n\
    </cell>\n<code language=julia-1.5>", "  l.map{|x| x if x > 0 else nil}\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\n`if x > 0` is not very elegant, and could\
    \ possibly be optimized away. Better would be `if x.positive?`.\n<|/ c |>\n<|\
    \ c |>\nThanks, I've corrected my answer. I'm new to Ruby, but I'm always interested\
    \ how things could be optimized :)\n<|/ c |>\n<| c |>\n`if x.positive?` wouldn't\
    \ work, because `[].positive? #=> false`\n<|/ c |>\n<| c |>\nIt would work because\
    \ `[].positive?` is `nil`. `[].positive?` returns `nil` when called on an empty\
    \ array. `if x.positive?` returns `nil` when called on an element of an empty\
    \ array.\n<|/ c |>\n<| a |>\nI prefer using .blank? and .empty? over #to_i\n<code>",
  "    l.select{|x| x >= 0}\nend", "  return l.select { |x| x >= 0 }\nend", "  l.select{|x|\
    \ x > 0}.collect{|x| x}\nend\n</cell>\n<text>\nExercise 2: Write a method that\
    \ takes a list of integers and returns all the odd numbers below 100.", "  return\
    \ l.select { |e| e > 0 }\nend", "  l.sort!\n  l.select { |x| x > 0 }\nend", " \
    \ return l[l.select { |e| e >= 0 }]\nend", "  l.compact.select { |x| x >= 0 }\n\
    end", "  # Your code here\n  return [i for i in l if i > 0]\nend", "  l = l.map{|x|\
    \ x if x > 0 }\n  l.compact\nend", "  l.map! { |x| x if x > 0 }\n  l\nend\n</code>\n\
    And then we have\n<code>", "  l.map! {|num| return num > 0 ? num : nil}\n  l\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis fails with `ArgumentError: wrong\
    \ number of arguments (2 for 1)` if the array is nil.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nThis works for me:\n<code>", "  l.each do |x|\n    unless x > 0\n      l.delete(x)\n\
    \    end\n  end\n  return l\nend", "  return l.select { |e| e > 0 }\nend\n</pre>\n\
    </div>", "  return l.select { |x| x >= 0 }\nend", "  l.select!{|x| x > 0}\nend\n\
    </code>\n<|/ a tags=ruby,arrays,methods dscore=3 |>\n<| a tags=ruby,arrays,methods\
    \ |>\n<code>", "  l.compact.select { |x| x > 0 }\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nI love how you use select and map to make the code more readable!\n<|/ c\
    \ |>\n<| a dscore=2 tags=ruby,regex |>\n<code>\n[4, 2, 3, 9, 123, 1, -10].grep{|e|\
    \ e.to_i} #=> [2, 5, 6]\n</code>\n<|/ a |>\n<| c |>\n`to_i` will fail for negative\
    \ numbers, see [my answer](http://stackoverflow.com/questions/1779780/regex-to-parse-integers/1779797#1779797).\n\
    <|/ c |>\n<| c |>\n: Thanks, I forgot about that case.\n<|/ c |>\n<| a dscore=2\
    \ |>\nA regex is overkill for this.\n<code>\n> [-4, 2, 3, 9, 123, 1, -10].grep\
    \ /\\d+/\n=> [2, 5, 6]\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThis also\
    \ will fail for negative numbers, see [my answer](http://stackoverflow.com/questions/1779780/regex-to-parse-integers/1779797#1779797).\n\
    <|/ c |>\n<| a |>\n<code>\narray.select { |element| element > 0 }\n</code>\n<|/\
    \ a tags=ruby,regex dscore=1 |>\n<| c |>\nI believe you meant `array.reject {\
    \ |element| element < 0 }`.\n<|/ c |>\n<| c |>\nI believe he meant `array.select\
    \ { |element| element > 0 }`\n<|/ c |>\n<| c |>\nI believe he meant `array.select\
    \ { |element| element > 0 }`\n<|/ c |>\n<| c |>\nHe actually means `array.select\
    \ { |element| element > 0 }` since he's looking for positive numbers.\n<|/ c |>\n\
    <| c |>\nI think the question asks for positive numbers, and a negative number\
    \ would throw an error.\n<|/ c |>\n<| a dscore=1 |>\nJust for fun, here is a one-liner\
    \ using Array#collect, String#rindex, and a regex:\n<code>\narray = [4, 2, 3,\
    \ 9, 123, 1, -10]\np array.collect { |i| i.to_i if i.to_i.to_s.rindex('1') !=\
    \ -1 }.compact", "  l.select{|x| x.positive?}\nend\n</code>\n<|/ a tags=ruby dscore=3\
    \ |>\n<| c |>\nThis is great, thanks for posting it. I'll have to digest it a\
    \ little more. In the mean time, I made a change to my code that allows the user\
    \ to specify any number of values to be considered \"positive\" (I added a second\
    \ `get_positive` method in the example above)\n<|/ c |>\n<| c |>\nYeah, I noticed\
    \ that, it's just a matter of calling `get_positive` with the values you want.\
    \  I actually wanted the method to be able to take an array of any number of numbers\
    \ and return only positive numbers (since I assumed that would make my code more\
    \ efficient).\n<|/ c |>\n<| c |>\nI made a change to my code that allows the user\
    \ to specify any number of values to be considered \"positive\" (I added a second\
    \ `get_positive` method in the example above)\n<|/ c |>\n<| a |>\nI assume you\
    \ want the method to return an array containing only the positive numbers of the\
    \ given array.\nThis can be easily achieved by iterating over the array and add\
    \ every positive number to a new array. \n<code>", "    l.select { |x| x > 0 }\n\
    end", "  return l.select { |e| e >= 0 }\nend", "  l.each do |i|\n    unless i\
    \ < 0\n      return i\n    end\n  end\n  nil\nend", "  return l.reject {|x| x\
    \ < 0} if l.is_a? Array\n  l.select {|x| x > 0} # Filter positive numbers.\nend",
  "  return l.select { |e| e > 0 }\nend", "  l.select { |e| e > 0 }\nend", "  return\
    \ l.select {|x| x > 0}\nend\n</code>\nTo find the negatives you would use\n<code>",
  "  l.select { |x| x > 0 }\nend", "  l.select {|x| x > 0 }\nend\n</code>\nThen the\
    \ function could be called like this:\n<code>", "  return l .select {|e| e>0}\n\
    end", "  return l.select { |x| x > 0 }\nend", "  return l.select { |x| x > 0 }\n\
    end", "  l.each_with_index { |val, index|\n    if val < 0\n      l.delete_at(index)\n\
    \    end\n  }\n  l\nend", "  l.select { |n| n if n > 0 }\nend", "  l.select(&:positive?)\n\
    end", "    positives = []\n    for number in l\n        if number > 0\n      \
    \      positives << number\n        end\n    end\n    return positives\nend",
  "  l.map { |e| e > 0 ? e : nil }\nend\n</cell>\n<code language=conda-env-Coursera-CrashCourses-py>",
  "  l.select { |x| x >= 0 }\nend", "  l.collect { |e| e > 0 ? e : nil }\nend", " \
    \ l.select { |i| i >= 0 }\nend", "  l.select { |e| e > 0 }\nend", "  l.select\
    \ {|e| e > 0}.sort!\nend", "  return [n for n in l if n > 0]\nend", "  l.map{|x|\
    \ return x if x > 0;}\nend", "  l.collect{|x| x > 0 ? x : nil}\nend", "  l.select\
    \ { |v| v >= 0 }\nend", "  l.each do |n|\n    return n if n > 0\n  end\n  nil\n\
    end", "  l.delete_if do |x|\n    x < 0\n  end\nend", "  l.select { |e| e > 0 }\n\
    end", "  l = l.to_a\n  l.select {|e| e > 0 }\nend", "  return l.map {|x| x > 0\
    \ ? x : nil}\nend", "  l.map!(&:abs)\nend", "  l.select { |e| e > 0 }\nend", " \
    \ return l.select { |x| x >= 0 }\nend", "  l.map!(&:to_i) unless l.is_a?(Array)\n\
    \  l.reject {|x| x < 0 }\nend", "  l.map { |i| if i > 0 then i else nil }\nend",
  "  l.select { |x| x > 0 }\nend", "  l.select(&:positive?)\nend\n</code>\nThe final\
    \ step is to add the get_positive method to the Array class using include. This\
    \ is a bit more efficient than using alias_method. \n<code>", "  if l\n    l.select!\
    \ {|x| x > 0}\n  else\n    l = []\n  end\n  l\nend\n</code>\nNow you can use the\
    \ above methods with Arrays, Ranges, Sets or Hashes by simply using the methods\
    \ you created for them:\n<code>\nget_positive([-1, 2, -4, 5, 6])", "  # Return\
    \ a new array containing the values which are positive.\n  result = new_array(l)\n\
    \  result.map! do |x| x > 0 ? x : nil end\n  result\nend", "  l.select{|e| e >=\
    \ 0}\nend", "  l.delete_if { |x| x < 0 }\n  l\nend", "    l.map! {|i| i.zero?\
    \ ? i : i + 1}\nend", "    l.map { |e| e if e > 0 }\nend", "  l.select { |i| i\
    \ >= 0 }\nend", "  l.map!(&:abs)\n  l.compact!\n  l.uniq!\nend", "  l.select {\
    \ |e| e > 0 }\nend", "  l.select { |x| x > 0 }\nend", "  l.select(&:positive?)\n\
    end", "  l.map!{ |e| e if e > 0 ; e }\n  l\nend\n</cell>\n<cell>\nget_positive([1,\
    \ 2, 3, -2, -4, 5])\n</cell>\n<cell>\nget_positive([-1, -2, -4, 5])\n</cell>\n\
    <cell>\nget_positive([5, 3, -2, -3, 3, 9, 0, 123, 1, -10])\n</cell>\n<text>\n\
    Now that we have our get_positive function, let's see how it works on an entire\
    \ array:", "  l.map!{ |e| e > 0 ? e : nil }\nend", "  l.sort!\n  l.map {|e| return\
    \ e if e >= 0} # Return only positive numbers in the array.\nend", "  l.sort!\n\
    \  while l.size > 0 \n    l.shift\n  end\n  l\nend", "  l.map{|i| i > 0 ? i :\
    \ nil}\nend", "  l.each do |x|\n    puts \"#{x}\" if x > 0 and x != 0\n  end\n\
    end", "  l.delete_if { |x| x > 0 }\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=1 |>\nYou can use the fact that sorting by multiple fields is\
    \ a merge sort, and merge sort is a stable sort.\n<code>\n def merge_sort arr\n\
    \    length = arr.length\n    arr.dup.each_with_index { |i, index| arr[index]\
    \ = i if i.odd? }\n    arr = (arr + arr + arr).sort\n    arr[0..(length/2)].zip(arr[length/2..length]).map\
    \ { |x, y| x.merge(y, &:itself, &:<=>) }\n end\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\nThe most efficient way to sort an array is to use the\
    \ Quicksort algorithm. This has O(n) complexity on average, and is also very simple\
    \ to implement and understand.\nThe ruby standard library includes Quicksort already\
    \ in the Array class:\n<code>", "  return l.select{|x| x > 0}\nend", "    l =\
    \ l.to_a\n    l = l.dup\n    l = l.select { |x| x >= 0 }\n    return l\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\n`return l unless l.empty?` is slightly more\
    \ succinct than `return l if l.empty?`\n<|/ c |>\n<| c |>\nIt is, but I think\
    \ `empty?` is slightly more clear that `count { true }` is more clear.\n<|/ c\
    \ |>\n<| c |>\nI guess so, but it's an edge case that might not be immediately\
    \ apparent.\n<|/ c |>\n<| a tags=ruby |>\nI thought I might add a variation on\
    \ Frederick's solution that I came up with. I thought it might help others. I\
    \ think this is what he means by \"more idiomatic\". I believe he means using\
    \ Ruby's array methods instead of Enumerable methods. I like that he uses each_cons.\n\
    <code>", "  return l.select {|n| n > 0} unless l.empty?\n  []\nend", "  l.select\
    \ { |e| e > 0 }\nend", "  l.select {|e| e >= 0}\nend\n</code>\nI then called it\
    \ with the arguments you supplied and got:\n<code>", "  l.select {|e| e > 0 }\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is good code.  I'd add that using\
    \ `select` with a block is functionally equivalent to `grep`.  If you use that\
    \ to select all positive numbers, you get an `Array` rather than an `Enumerator`\
    \ of `Integer`s.\n<|/ c |>\n<| c |>\nAm I right in thinking that the reason this\
    \ works is because `.select` returns an array?  I thought it didn't, but then\
    \ I tried it out and it does.\n<|/ c |>\n<| c |>\nThis is great code.  I do want\
    \ to add that if you use \"grep {|x| x > 0 }\", you lose the ability to pass in\
    \ an array\n<|/ c |>\n<| c |>\n, thanks for the feedback. Updated my answer to\
    \ use `select` instead of `grep`.\n<|/ c |>\n<| c |>\n, thanks for the feedback.\
    \ Updated my answer to use `select` instead of `grep`.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a Ruby idiom that may interest you:\n<code>", "  l.each do |n|\n\
    \    n if n > 0 # only positives\n  end\nend", "  l.map! { |x| x if x > 0 }\n\
    end", "  return l.select { |x| x >= 0 }\nend", "  l.select {|x| x > 0 }\nend\n\
    </code>\n<|/ a |>\n<| a |>\nI did this with Array#select:\n<code>", "  return\
    \ l.select { |x| x >= 0 }\nend\n</cell>\n<text>\nNow let's use this in our program.\
    \ We'll use a Ruby array as the programming language for our calculator, and we'll\
    \ use the following expression:", "  l.sort!\n  l.map! { |x| x > 0 ? x : nil }\n\
    \  l\nend\n</code>\nTo return only positive numbers in an array, sort and map\
    \ to remove negative numbers, then return it.\n<code>", "  l.select {|n| n.positive?}\n\
    end", "    l.each do |x|\n        if x > 0\n            yield x\n        end\n\
    \    end\nend\n</code>\nIn Ruby, it's common to call Enumerable#select and Enumerable#reject\
    \ to achieve a similar result, although it isn't strictly required.  In terms\
    \ of readability, Enumerable#select is preferable to #find_all. Enumerable#reject\
    \ is preferable to #select. \nNote also, that Ruby does not have a function called\
    \ get_positive, only get_positive!.  In Ruby, you should use all lowercase variable\
    \ names to avoid confusion with methods in other languages, even though Ruby does\
    \ not enforce that rule. \n<code>", "  l.select {|x| x >= 0} \nend", "  l.map!\
    \ { |x| x > 0 ? x : nil }\nend\n</code>\n<|/ a dscore=3 tags=ruby,arrays,math\
    \ |>\n<| a tags=ruby,arrays,math |>\nI find this one very useful.\n<code>", " \
    \ l.map { |x| x.positive? ? x : nil }.compact\nend", "  l.select {|e| e > 0}\n\
    end\n</cell>\n<text>\nIn Ruby, you can do everything with method calls in one\
    \ line, like so:", "    l.each do |i|\n        if i > 0 then\n            yield\
    \ i\n        end\n    end\nend\n</code>\nAs you can see in the first example,\
    \ the same method can be used on any array, whether it is a hash or an array.\n\
    Using the same principle in the second example, it is easy to create an array\
    \ that contains every odd number between a given range [start, end].\n<code>",
  "  l.map { |x| x if x >= 0 }\nend", "  l.select {|x| x > 0}\nend", "  l.map! { |i|\
    \ iif i >= 0, i, nil }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks Steve,\
    \ that looks a lot like the ruby solutions above. Though I wonder if it's possible\
    \ to put it in a single function, rather than having to call it twice...\n<|/\
    \ c |>\n<| c |>\n: No, not possible, but I did add the code for the `get_positive`\
    \ function.\n<|/ c |>\n<| c |>\n: Thanks again Steve. Though I wonder if it's\
    \ possible to put the 'filter' into one? I don't want a whole extra function just\
    \ to do the filtering, and I also want to do it in a way that returns nil if no\
    \ positive numbers appear. I'll update my question to include these details.\n\
    <|/ c |>\n<| c |>\n: Sure, I added a version to your function to show how it could\
    \ be done.\n<|/ c |>\n<| c |>\n: Thanks again Steve, it's really nice of you to\
    \ show your solution. I think it might be a better solution to use the 'find'\
    \ method, to stop iterating once the first positive number appears. This would\
    \ mean that the 'map!' line would need to be changed to 'map.find { |i| i >= 0\
    \ }.nil? ? nil : i', which would make 'get_positive' one line and look neater.\
    \ I'll check it out soon, and will update my question if there are any issues.\
    \ Thanks again.\n<|/ c |>\n<| a |>\nHere's a way to do it with some simple recursion.\
    \ \n<code>", "  l.select { |x| x > 0 }\nend\n</code>\nNow we can combine them\
    \ into one method: get_positive!\n<code>", "  return l.select {|x| x > 0}\nend\n\
    </cell>\n<cell>", "  l = l.dup\n  l.map! {|i| i.abs} if l.respond_to?(:map)\n\
    \  l.select(&:positive?)\nend", "  l.select {|x| x > 0 }\nend\n</code>\nThe new\
    \ function will allow you to pass in a collection and a number n and return the\
    \ n smallest values in the collection. \n<code>", "  l.filter {|x| x > 0 }\nend",
  "  if l.empty?\n    l\n  else\n    l.reject { |e| e < 0 }\n  end\nend", "    l.each\
    \ { |x| x if x > 0 }\nend", "  l.select{|x| x > 0}\nend\n  ", "  return l.select\
    \ { |x| x >= 0 }\nend\n</code></pre>", "  l.select { |x| x >= 0 }\nend", "  l.each\
    \ do |x|\n    return x if x >= 0\n  end\nend", "  l = l.sort\n  l.select! { |x|\
    \ x > 0 }\n  l\nend", "  l.each do |n|\n    return n if n > 0\n  end\n  l\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails dscore=2 |>\n<| c |>\nIt isn't always necessary\
    \ to write this kind of method. `select { |e| e > 0 }` will do.\n<|/ c |>\n<|\
    \ a tags=ruby,ruby-on-rails |>\nI haven't found any nice way of doing this in\
    \ Rails, but you can always do it with a plain old ruby array.\n<code>\n my_array\
    \ = [1, 2, -4, 5, 6]\n my_array.select{|e| e > 0}\n</code>\nwill give you all\
    \ non-zero values in the array.\n<|/ a dscore=2 |>\n<| a dscore=0 |>\nI ended\
    \ up creating a module that works well enough for my needs. I call it Positive,\
    \ since it behaves like a positive number (i.e. not negative, positive, zero,\
    \ negative, etc), and allows you to do things like\n<code>\n1.positive? #=> true\n\
    2.positive? #=> false\n0.positive? #=> true\n</code>\nand more\n<code>\n(1 + -1).positive?\
    \ #=> true\n</code>\nIt also keeps my code clean, since I use it so often.\nPositive.rb\n\
    <code>", "  l.map { |x| x > 0 ? x : nil }\nend", "  l.map!{|x| x if x >= 0}\n\
    end", "  l.select { |e| e.positive? }\nend", "  l.select { |x| x > 0 }\nend",
  "  l.select {|e| e > 0 }\nend", "  l.each do |i|\n    if i > 0 then yield i end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is great as well. Thanks.\n\
    <|/ c |>\n<| c |>\n: That's what SO is for, isn't it? :-)\n<|/ c |>\n<| c |>\n\
    Ah :) And that one was pretty much a fun excercise. :)\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHere's another way:\n<code>", "  return l - get_negative(l)\nend\n</cell>\n\
    <code language=julia-1.0>", "  l.select {|x| x > 0 }\nend", "  return l.select\
    \ { |i| i > 0 }\nend\n</code>\n<|/ a dscore=5 tags=ruby,arrays,ruby-on-rails,filtering\
    \ |>\n<| c |>\nThis should be the accepted answer\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails,filtering\
    \ dscore=5 |>\nRails 4.1 introduced Enumerable#select which does exactly that:\n\
    <code>\n> [1,2,3].select { |n| n>0 }\n=> [2, 3]\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,ruby-on-rails,filtering\
    \ dscore=5 |>\nTry this:\n<code>", "  l.map!{|x| x > 0 ? x : nil}\n  l\nend",
  "  l.map(&:abs)\n  l.compact.select(&:>0)\nend\n  ", "  l.map! {|i| i}\n  l.delete_if\
    \ {|i| i < 0}\n  l\nend", "  l.map {|x| x > 0 ? x : nil}\nend\n</code>\nThe main\
    \ difference from your code is that the filter is being done on the array instead\
    \ of calling it on a single element. The map version keeps track of the indices\
    \ that are non-nil, while the filter version doesn't.\nYou can then write the\
    \ function like this, and use that as your get_positive function:\n<code>", " \
    \ l = l.dup\n  l.sort { |a, b| a <=> b }\n  l.reject { |e| e < 0 }\nend", "  l.map!\
    \ { |x| x < 0 ? -x : x }\n  l\nend\n</code>\nYou can then call it with:\n<code>\n\
    get_positive(@array)\n</code>\n<|/ a tags=ruby,arrays,multidimensional-array,arrays\
    \ dscore=4 |>\n<| a tags=ruby,arrays,multidimensional-array,arrays dscore=3 |>\n\
    In addition to the other answers you can also use a more compact and faster way:\n\
    <code>\narr = Array(0...99)", "  positive = []\n  l.each {|x| x.is_a?(Numeric)\
    \ ? x != 0 && positive << x : nil}\n  positive\nend\n</code>\n<|/ a |>\n<| a |>\n\
    This would do it:\n<code>\n> [1,2,3].reject {|x| x.is_a? Numeric}\n=> [2, 3]\n\
    </code>\n<|/ a tags=ruby,arrays dscore=5 |>\n<| a dscore=4 tags=ruby,arrays |>\n\
    I know the question was answered, but I thought I'd throw my two cents into the\
    \ mix:\n<code>\n> [1,2,3,4,5,6,7,8,9].select { |x| x.is_a?(Numeric) }\n=> [1,2,3,4,5,6,7,8,9]\n\
    </code>\n<|/ a |>\n<| c |>\nThis should really be a comment on's answer.\n<|/\
    \ c |>\n<| c |>\nYeah, I wanted to comment on the answer but you beat me to it.\n\
    <|/ c |>\n<| c |>\nI wouldn't consider this to be the right answer, but it did\
    \ help me with my issue, thanks!\n<|/ c |>\n<| a tags=ruby,arrays |>\nIf you want\
    \ to remove elements from a list that match a condition you should use the reject\
    \ method instead of select:\n<code>\n> a = [1,2,3]\n> a.select { |i| i.even? }\n\
    => [1, 2, 3]\n> a.reject { |i| i.even? }\n=> [1, 3]\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\n`reject` is for removing elements that match the condition, `select`\
    \ is for selecting elements that match the condition.\n<|/ c |>\n<| a dscore=4\
    \ |>\nHere is a solution using Enumerable#reject:\n<code>\na = [1, 2, 3, 4]\n\
    a.reject { |i| i.is_a?(Numeric) }", "  l.select {|x| x.positive?}\nend", "   \
    \ positive = []\n    l.each do |x|\n        if x > 0\n            positive <<\
    \ x\n        end\n    end\n    return positive\nend", "  l.compact.select { |x|\
    \ x >= 0 }\nend", "  if l.is_a? Numeric\n    l.select { |x| x.positive? }\n  elsif\
    \ l.is_a? Array\n    l.select { |x| x.positive? }\n  else\n    raise ArgumentError,\
    \ \"The argument must be an Array or Numeric\"\n  end\nend", "  l.map { |x| x\
    \ > 0 ? x : nil }\nend", "  l.map! { |e| e < 0 ? -(e) : e }\n  l\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYour first solution is not O(n), because your `g` is still\
    \ `O(n)` for each call. You are correct that `map` will create an entirely new\
    \ array, but since `g` is only called once for the entire array, it's O(1). Your\
    \ second solution will call `g` `n` times which is `O(n)`, but the entire `g`\
    \ function is not `O(1)`. My solution also does `O(n)` calls to `g` so your answer\
    \ is wrong.\n<|/ c |>\n<| c |>\nIt can be written without using g at all, however\
    \ it makes much more sense to me to write it with g as it is a very good example\
    \ for explaining why to use it (in this specific case).\n<|/ c |>\n<| c |>\nAh\
    \ yes, I didn't notice that `g` was called so many times. I thought it was only\
    \ called once. Still, the second solution is still `O(n)`, it makes `n` calls\
    \ to the function `g`. My solution is `O(n)`, it makes one call to the function\
    \ `g` with n arguments. `map` doesn't create `n` new arrays, it creates 1 new\
    \ array with `n` elements. So your solution is `O(n^2)`. Your second solution\
    \ is `O(n)` because it makes `n` calls to the function `g`. Your first solution\
    \ is `O(n)` because it makes one call to the function `g`.\n<|/ c |>\n<| c |>\n\
    I agree with you, I reread the question and now think that the first solution\
    \ is correct and should be accepted. Thank you for the clarification.\n<|/ c |>\n\
    <| c |>\nYes, the first solution is correct, but this isn't really an improvement\
    \ over `g`, it's just an improvement over `map`. See my answer for an explanation\
    \ of what it really is.\n<|/ c |>\n<| a dscore=1 |>\nI prefer to use select to\
    \ filter out negative values. \n<code>\na = [-1,2,-4,5,6]\np a.select { |v| v\
    \ > 0 } # => [2, 5, 6]\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=1 |>\n\
    I find that using Enumerable#select makes sense, especially in the case where\
    \ you want to avoid creating a new array object.\nTo my mind, it reads more like\
    \ it returns the positive numbers, whereas your ", "    l.select { |x| x > 0 }\n\
    end", "  l.select { |e| e > 0 }\nend\n</code>\nIt also works on arrays.\n<code>",
  "  l.map! { |x| x < 0 ? nil : x }\n  l\nend", "  l.collect { |x| x if x > 0 }\n\
    end", "    positive = []\n    l.each do |x|\n        if x > 0\n            positive\
    \ << x\n        end\n    end\n    positive\nend", "  return l.select { |x| x >\
    \ 0 }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`[5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]`\n<|/ c |>\n<| c |>\nYes, I fixed it. Thanks.\n<|/ c |>\n<| c |>\n\
    It's not necessary to make it a class method. Instead, make the method a normal\
    \ instance method, then use the block passed to it to define the conditions on\
    \ which elements are kept.\n<|/ c |>\n<| c |>\nThat sounds like a good idea, but\
    \ then you cannot use the same method to select negative or positive numbers from\
    \ different arrays. What do you think would be the best approach?\n<|/ c |>\n\
    <| c |>\nI see now. Just make two methods, one for positive numbers and one for\
    \ negative numbers. Use `select` to get positives and negatives.\n<|/ c |>\n<|\
    \ a tags=ruby |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
