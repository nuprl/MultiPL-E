name: HumanEval_41_car_race_collision
language: rb
prompt: "# Imagine a road that's a perfectly straight infinitely long line.\n# n cars\
  \ are driving left to right;  simultaneously, a different set of n cars\n# are driving\
  \ right to left.   The two sets of cars start out being very far from\n# each other.\
  \  All cars move in the same speed.  Two cars are said to collide\n# when a car\
  \ that's moving left to right hits a car that's moving right to left.\n# However,\
  \ the cars are infinitely sturdy and strong; as a result, they continue moving\n\
  # in their trajectory as if they did not collide.\n# This function outputs the number\
  \ of such collisions.\ndef car_race_collision(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n\
  \    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n\
  \    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n\
  \    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n\
  \  end\nend\n"
completions: ["  collisions = 0\n  n_times = n*(n+1)/2\n  for i in (1..n)\n    j =\
    \ n+1-i\n    collisions += n_times*j\n  end\n  collisions\nend", "\tsum = 0\n\t\
    for i in 1..n\n\t\tsum1 = i\n\t\tj = 1\n\t\twhile j <= n\n\t\t\tsum1 = sum1 +\
    \ j\n\t\t\tj = j + i\n\t\tsum = sum + sum1\n\treturn sum\nend", "  count = 0\n\
    \  n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.times { n.times { n.times { n.times { n.times { n.times { n.times\
    \ { n.times { n.", "    # Write your code here.\n    count = 0\n    max_count\
    \ = 0\n    speeds = Array.new(n)\n    for i in 0 ... n-1\n        speeds[i] =\
    \ rand(max)+rand(max)\n    end\n    for i in 0 ... n-1\n        for j in i+1 ...\
    \ n\n            speed_1 = speeds[i]\n            speed_2 = speeds[j]\n      \
    \      distance_1 = sqrt(speed_1^2 + speed_2^2)\n            distance_2 = sqrt(speed_1^2\
    \ + speed_2^2)\n            if distance_1 < distance_2 \n                # These\
    \ two cars collide.\n                count += 1\n            end\n        end\n\
    \    end\n    return count\nend\n</cell>\n<text>\nQuestion 3\nA car has speed\
    \ $v_i$ and acceleration $a_i$, where $i$ is a positive integer. There are also\
    \ speed limits $v_j$ and acceleration limits $a_j$ for some positive integer $j$.\
    \ Two cars collide when:", "  collisions = 0\n  (0..n.to_i).each do  |i|\n   \
    \ j = n - i - 1\n    if i < j\n      collisions += 1\n    elsif i > j\n      collisions\
    \ += 1\n    elsif i == j\n      collisions += 1\n    end\n  end\n  collisions\n\
    end", "  # Return the number of cars that collide in this race\n  # Input: n (integer):\
    \ the size of the state space\n  # Output: collisions (integer): the total number\
    \ of cars that collide\n  # The code herein is commented to help you understand\
    \ why it works.\n  # You do not need to understand how it works in order to fix\
    \ this function.\n  num_collisions = 0\n  collide = 0\n  j = 0\n  # To help us\
    \ keep track of the cars currently being collided with, create an array that will\
    \ hold the\n  # current indices of the cars currently being collided with.\n \
    \ collide_array = []\n  # To help us keep track of the cars currently colliding\
    \ with others, create an array that will hold the\n  # current indices of the\
    \ cars currently colliding with others.\n  collision_array = []\n  # As we iterate\
    \ through the state space, we will keep track of the cars that are colliding with\
    \ each other.\n  while collide < n:\n    # If our current car is colliding with\
    \ another car, add its index to the collision_array list\n    if j != 0:\n   \
    \   collision_array.append(j)\n      j = j + 1\n    # If our current car is colliding\
    \ with any other car, add its index to the collide_array list\n    collide_array.append(j)\n\
    \    j = j + 1\n  # While we are not done with our loop yet, keep track of the\
    \ number of cars that we already saw collide with.\n  j = 0\n  while j < n:\n\
    \    # We see how many cars are colliding with each other.\n    if j not in collide_array:\n\
    \      if j in collision_array:\n        num_collisions = num_collisions + 1\n\
    \      # If the car is colliding with another car, increment its count by 1\n\
    \      else:\n        num_collisions = num_collisions + 1\n    # If the car has\
    \ already collided with another car, increment its count by 1\n    else:\n   \
    \   num_collisions = num_collisions + 1\n    # We see which cars are colliding\
    \ with each other.\n    j = j + 1\n  return num_collisions", "  num_collisions\
    \ = 0\n  for i in 1..n\n    for j in (i..n-1)\n      if cars[i].x > cars[j].x\n\
    \        num_collisions += 1\n      end\n    end\n  end\n  return num_collisions\n\
    end", "  collisions = 0\n  cars = Array.new(1000) { 0 }\n  cars_right = Array.new(1000)\
    \ { 0 }\n  cars_left = Array.new(1000) { 0 }\n  speed = 20\n  time = Time.now\n\
    \  time_limit = time + 60*1.5 # Allow a 1.5 second driving period.\n  collision_time\
    \ = nil\n  time_left = time_limit\n  while cars.count < n\n    car = cars.last\n\
    \    next_car = cars.shift\n    next_car_right = cars_right.shift\n    next_car_left\
    \ = cars_left.shift\n    next_car_speed = speed\n    next_car_time = nil\n   \
    \ car_direction = next_car_right > next_car_left ? 'right' : 'left'\n    # Set\
    \ the car to collide when two cars collide.\n    collision_time = Time.now\n \
    \   while Time.now < collision_time\n      next_car_time = Time.now\n      if\
    \ next_car_speed > 0\n        collision_time = nil\n        # Drive right.\n \
    \       if car_direction == 'right'\n          next_car_speed -= 1\n         \
    \ next_car_right += 1\n          next_car_time = time_limit + rand(100)*5\n  \
    \      else\n          next_car_speed -= 1\n          next_car_left += 1\n   \
    \       next_car_time = time_limit + rand(100)*5\n        end\n        collisions\
    \ += 1\n      elsif next_car_speed < 0\n        collision_time = nil\n       \
    \ # Drive left.\n        if car_direction == 'right'\n          next_car_speed\
    \ += 1\n          next_car_left -= 1\n          next_car_time = time_limit + rand(100)*5\n\
    \        else\n          next_car_speed += 1\n          next_car_right -= 1\n\
    \          next_car_time = time_limit + rand(100)*5\n        end\n        collisions\
    \ += 1\n      end\n      # Keep driving until the time has come to make another\
    \ collision.\n      while Time.now < next_car_time\n        next_car_time += rand(100)*5\n\
    \      end\n      car_direction = next_car_right > next_car_left ? 'right' : 'left'\n\
    \    end\n    if car_direction == 'right'\n      cars_right << car\n      cars_left\
    \ << next_car\n    else\n      cars_left << car\n      cars_right << next_car\n\
    \    end\n  end\n  return collisions\nend\n</code>\n<|/ a tags=ruby,multithreading,ruby-on-rails\
    \ |>\n<| c |>\n", "  collisions = 0\n  for i in 1..n\n    for j in 1..n\n    \
    \  if (i+j) == n\n        collisions += 1\n  return collisions\nend\n</code>\n\
    <|/ a tags=algorithm,ruby |>\n<| c |>\nNice answer. It seems to me that if the\
    \ cars move in that direction, the first collision will happen right away while\
    \ the second collision will happen later. Is that right?\n<|/ c |>\n<| a |>\n\
    A car may stop at a collision with the nearest car when they are moving towards\
    \ each other, as they cannot get closer and collide with the existing cars.  So\
    \ there are two possible sets of collisions:", "  collided = 0.0;\n  for i in\
    \ 0..(n-1)\n    collided += car_collision(i);\n  end\n  collided\nend", "  sum\
    \ = 0\n  for i in 0..(n-1)\n    sum = sum + car_collision(n,i)\n  end\n  sum\n\
    end", "\tresult = 0\n\tfor i in 1..n\n\t\tcar1 = gets(n)\n\t\tcar2 = gets(n)\n\
    \t\tif (car1 == car2)\n\t\t\tresult += 1 #\_they will collide\n\t\tend\n\tend\n\
    \treturn result\nend", "  collisions = 0\n  for i in 1...n do\n    for j in (n-1..1)\
    \ do\n      if i > j and car_race_can_collide?(i, j, n)\n        collisions +=\
    \ 1\n      end\n    end\n  end\n  return collisions\nend", "  # Create a 2D array\
    \ that will hold the results of collisions.\n  # The dimensions of the array are\
    \ (n,n).\n  result = [[] for i in [0..n]]\n  # Initialize a variable called 'car_count'\
    \ to 0.\n  car_count = 0", "  count = 0\n  for i in range(n)\n    count += i\n\
    \  end\n  return count\nend\n</cell>\n<code language=julia-1.0>\ncar_race_collision(100)\n\
    </cell>\n<text>\nWe have now shown that we can count the number of times a set\
    \ of n cars collide.  We just have to repeat the process $n$ times.  Then, we\
    \ can sum these counts to get an estimate of the probability that each car collides\
    \ with each other car.", "  collisions = 0\n  xs = [rand(1,n), rand(1,n)].sort\n\
    \  ys = [rand(1,n), rand(1,n)].sort\n  (0..n-1).each do |i|\n    j = i+1\n   \
    \ (xs[i] == xs[j] and ys[i] == ys[j] and i != j and i != n - 1).each do |j|\n\
    \      if i != j then\n        collisions += 1\n        break\n      end\n   \
    \ end\n  end\n  collisions\nend", "  count = 0\n  for i in (0...n)\n    for j\
    \ in (0...n)\n      if i != j\n        if i != 0 && j != 0 && speed < 0\n    \
    \      # If the cars are moving at an equal speed, they will never collide.\n\
    \          count += 1\n        end\n      end\n    end\n  end\n  count\nend",
  "  num_collisions = 0\n  left_lane_length = lane_width/(n-1)\n  right_lane_length\
    \ = lane_width - (lane_width/(n-1))\n  lane_ends = Array.new(lane_length, n+1)\n\
    \  lane_ends.each do |lane_end|\n    lane_end[0] = lane_end[0]/2 + lane_width/2\n\
    \    lane_end[n] = lane_end[n]/2 - lane_width/2\n  end\n  left_lane = Array.new(lane_length,\
    \ n+1)\n  left_lane.each do |lane_end|\n    lane_end[0] = lane_end[0]/2 - lane_width/2\n\
    \    lane_end[n] = lane_end[n]/2 + lane_width/2\n  end\n  right_lane = Array.new(lane_length,\
    \ n+1)\n  right_lane.each do |lane_end|\n    lane_end[0] = lane_end[0]/2 + lane_width/2\n\
    \    lane_end[n] = lane_end[n]/2 - lane_width/2\n  end\n  lane_collisions = []\n\
    \  left_lane.each do |lane_end|\n    lane_collisions <<\n      if car_race_left(lane_end[0],\
    \ lane_end[1], left_lane_length)\n        num_collisions += 1\n      end\n  end\n\
    \  right_lane.each do |lane_end|\n    lane_collisions <<\n      if car_race_right(lane_end[0],\
    \ lane_end[1], right_lane_length)\n        num_collisions += 1\n      end\n  end\n\
    \  left_lane_collisions = []\n  right_lane.each do |lane_end|\n    left_lane_collisions\
    \ <<\n      if car_race_left(lane_end[0], lane_end[1], left_lane_length)\n   \
    \     num_collisions += 1\n      end\n  end\n  right_lane_collisions = []\n  left_lane.each\
    \ do |lane_end|\n    right_lane_collisions <<\n      if car_race_right(lane_end[0],\
    \ lane_end[1], right_lane_length)\n        num_collisions += 1\n      end\n  end\n\
    \  left_lane_collisions.each do |left_lane_collision|\n    lane_collisions <<\n\
    \      if car_race_left(lane_end[0], lane_end[1], left_lane_length)\n        num_collisions\
    \ += 1\n      end\n  end\n  right_lane_collisions.each do |right_lane_collision|\n\
    \    lane_collisions <<\n      if car_race_right(lane_end[0], lane_end[1], right_lane_length)\n\
    \        num_collisions += 1\n      end\n  end\n  return num_collisions\nend",
  "  collisions = 0\n  car_count = n + 1 # since we're starting from 0\n  while car_count\
    \ < n+1 do\n    # Generate a random starting position.\n    car_x = rand 1000.0\n\
    \    car_y = rand 1000.0\n    car_speed = rand 10.0\n    car_direction = 0.0\n\
    \    car_collisions = 0\n    while car_speed > 0.01 do\n      # Find the next\
    \ possible car location given the current car position.\n      car_x = car_x +\
    \ car_speed * car_direction\n      car_y = car_y + car_speed * car_direction\n\
    \      car_collisions = car_collisions + 1\n      car_speed = car_speed / 2.0\n\
    \    end\n    if car_collisions == 0 then\n      break\n    end\n    car_count\
    \ = car_count + 1\n  end\n  collisions = car_collisions\nend", "  # Initialize\
    \ variables to count the number of collisions.\n  count = 0\n  \n  # Iterate over\
    \ the cars, one at a time.\n  (0..n).each do |i|\n    # Keep track of whether\
    \ a car has collided with this car.\n    collide = i\n    # Keep track of the\
    \ current speed of the car that's moving left to right.\n    left_to_right_speed\
    \ = cars[i].speed * -1\n    # Keep track of the current speed of the car that's\
    \ moving right to left.\n    right_to_left_speed = cars[i].speed\n    # Keep track\
    \ of the current speed of the car that's moving left to right.\n    left_to_right_speed_when_collided\
    \ = right_to_left_speed\n    \n    # Iterate over each car that's currently colliding\
    \ with car.\n    cars_at_collision = [collide]\n    (cars_at_collision.each_index\
    \ do |i|\n      # The car that's colliding with this car is cars_at_collision[i].\n\
    \      (cars_at_collision[i+1..n]).each do |j|\n        # If the car at index\
    \ j is ahead of cars_at_collision[i],\n        # then cars_at_collision[i] is\
    \ ahead of cars_at_collision[j].\n        (cars_at_collision[j-1] < cars_at_collision[i])\
    \ ? \n          cars_at_collision.delete_at(i) : cars_at_collision.delete_at(j)\n\
    \        end\n      end\n    end)\n    \n    # Add the number of cars colliding\
    \ with car i to count.\n    count += cars_at_collision.length\n    \n    # Keep\
    \ track of the speed of the car that's moving left to right.\n    left_to_right_speed_when_collided\
    \ = left_to_right_speed_when_collided * -1\n  end\n  \n  count\nend", "  num_collisions\
    \ = 0\n  for i in 1..n\n    car_speed = i/n - 1\n    car_move_left = car_speed\
    \ <= 0\n    car_move_right = car_speed > 0\n    if (car_move_left and not car_move_right)\
    \ or (car_move_right and not car_move_left)\n      num_collisions += 1\n    end\n\
    \  end\n  num_collisions\nend", "  # Write your collision detection code here\n\
    \  collisions = 0\n  collisions += 1 if n and (n == 2) else 0\n  collisions +=\
    \ 1 if n and (n == 4) else 0\n  collisions += 1 if n and (n == 6) else 0\n  collisions\
    \ += 1 if n and (n == 8) else 0\n  collisions += 1 if n and (n == 10) else 0\n\
    \  collisions += 1 if n and (n == 12) else 0\n  collisions += 1 if n and (n ==\
    \ 16) else 0\n  collisions += 1 if n and (n == 20) else 0\n  collisions += 1 if\
    \ n and (n == 32) else 0\n  collisions += 1 if n and (n == 48) else 0\n  collisions\
    \ += 1 if n and (n == 64) else 0\n  collisions += 1 if n and (n == 128) else 0\n\
    \  collisions += 1 if n and (n == 256) else 0\n  collisions += 1 if n and (n ==\
    \ 512) else 0\n  collisions += 1 if n and (n == 1024) else 0\n  collisions +=\
    \ 1 if n and (n == 2048) else 0\n  collisions += 1 if n and (n == 4294967296)\
    \ else 0\n  collisions += 1 if n and (n == 1) else 0\n  collisions += 1 if n and\
    \ (n == 0) else 0\n  collisions += 1 if n and (n == -1) else 0\n  collisions +=\
    \ 1 if n and (n == -2) else 0\n  collisions += 1 if n and (n == -3) else 0\n \
    \ collisions += 1 if n and (n == -4) else 0\n  collisions += 1 if n and (n ==\
    \ -5) else 0\n  collisions += 1 if n and (n == -6) else 0\n  collisions += 1 if\
    \ n and (n == -7) else 0\n  collisions += 1 if n and (n == -8) else 0\n  collisions\
    \ += 1 if n and (n == 9) else 0\n  collisions += 1 if n and (n == 10) else 0\n\
    \  collisions += 1 if n and (n == 11) else 0\n  collisions += 1 if n and (n ==\
    \ 12) else 0\n  collisions += 1 if n and (n == 13) else 0\n  collisions += 1 if\
    \ n and (n == 14) else 0\n  collisions += 1 if n and (n == 15) else 0\n  collisions\
    \ += 1 if n and (n == 16) else 0\n  collisions += 1 if n and (n == 17) else 0\n\
    \  collisions += 1 if n and (n == 18) else 0\n  collisions += 1 if n and (n ==\
    \ 19) else 0\n  collisions += 1 if n and (n == 20) else 0\n  collisions += 1 if\
    \ n and (n == 21) else 0\n  collisions += 1 if n and (n == 22) else 0\n  collisions\
    \ += 1 if n and (n == 23) else 0\n  collisions += ", "  car_collisions = 0\n \
    \ for i in 1..n\n    for j in (i..n)\n      if i != j\n        car_collisions\
    \ += car_race_collision_helper(i, j, [])\n    end\n  end\n  car_collisions\nend\n\
    </cell>\n<code language=julia-0.6>", "  count = 0\n  for i in 1...n\n    other_i\
    \ = n-1-i\n    if my_car.x > other_car.x + other_car.width then\n      count +=\
    \ 1\n      my_car.x = other_car.x + other_car.width\n    end\n  end\n  return\
    \ count\nend", "  count = 0\n  for i in (1..n)\n    for j in (1..n)\n      if\
    \ (i !=j) && (cars[i] + cars[j] > car_sum)\n        count +=1\n  return count\n\
    end", "  \n  # The distance between two consecutive cars is the same as the distance\
    \ between\n  # the cars on the same row and column.\n  row_dist = (n*(n+1))/2\n\
    \  col_dist = (n*(n+1))/2", "  count = 0\n  for i in 1..n\n    count += 1\n  \
    \  count += (car_race_collision(n-i) - i)\n  end\n  count\nend\n</code>\nA second\
    \ version has fewer calls to car_race_collision since it only recurses the number\
    \ of times it needs to recurse.\n<|/ a dscore=4 |>\n<| c |>\nThis is a great solution.\
    \  It will take a bit more time to run than the other solutions though.  Thanks\
    \ for your help - I will play around with it and try to get my head around it.\n\
    <|/ c |>\n<| c |>\nYou also need an explicit return statement after you increment\
    \ count.\n<|/ c |>\n<| c |>\n- Thanks for your help - I still have a few questions.\
    \  How does the function recurse?  What does the function return?  How does it\
    \ know how many times it has to recurse?\n<|/ c |>\n<| c |>\n- I think I am getting\
    \ it - I added some comments to the code above to help explain it.  Thanks for\
    \ your help.\n<|/ c |>\n<| c |>\n: I added a couple of other versions, too.\n\
    <|/ c |>\n<| a tags=recursion,ruby |>\nI didn't try this but the following could\
    \ work:\n<code>", "  num_collisions = 0\n  car_left = Array.new(n)  \n  car_right\
    \ = Array.new(n)\n  (0..n).each do |i|\n    car_left[i] = rand(1..3)\n    car_right[i]\
    \ = rand(1..3)\n  end\n  (0..n).each do |i|\n    car_collisions = false\n    j\
    \ = i\n    \n    while !car_collisions do\n      car_collisions = true\n     \
    \ (j..n).each do |i|\n        if car_left[i] == car_right[i]\n          car_collisions\
    \ = false\n        end\n      end\n      j += 1\n    end\n    num_collisions +=\
    \ car_collisions\n  end\n  num_collisions\nend", "  count = 0\n  for i in 1..n\n\
    \    j = n - i\n    k = n - j\n    count += 1 if i >= j AND i >= k AND j >= k\
    \ else 0\n  end\n  count\nend\nputs \"Case #\" << test_case_index << \": #{car_race_collision(50)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(50)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(50)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(100)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(100)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(100)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(1000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(1000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(1000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(10000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(10000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(10000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(10000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(10000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(100000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(100000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case #\" << test_case_index << \": #{car_race_collision(100000)}\"\
    \nputs \"\"\ntest_case_index += 1\nputs \"Case ", "  collisions = 0\n  collisions\
    \ = collisions + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  collisions = collisions\
    \ + car_race_collision(n-1)\n  collisions = collisions + car_race_collision(n-1)\n\
    \  collisions = collisions + car_race_collision(n-1)\n  ", "  car_set = Array.new(n)\
    \ {Car.new}\n  collisions = 0\n  for i in 0...n\n    car_set[i] = Car.new\n  end",
  "  collisions = 0\n  for i in 1..n-1\n    collisions += (n - i) * (n + 1 - i).even?\n\
    \  end\n  collisions\nend", "  x = n*10 + 100\n  y = x*10 + 10\n  count = 0\n\
    \  while ((x != 0 or y != 0) and (x < 100 and y < 100)):\n    count += 1\n   \
    \ if car_collision(x % 10, y % 10, n): count += 1\n    x += 1\n    y -= 1\n  return\
    \ count", "\tcollisions = 0", "  collisions = 0\n  start_x = 0\n  start_y = 0\n\
    \  end_x = 0\n  end_y = 0\n  start_speed = 0\n  end_speed = 0\n  x = []\n  y =\
    \ []\n  speed = []\n  \n  start_x = get_start_x\n  start_y = get_start_y\n  end_x\
    \ = get_end_x\n  end_y = get_end_y\n  start_speed = get_start_speed\n  end_speed\
    \ = get_end_speed", "  count = 0\n  for i in 1..n\n    count += (car_race_collision(n-2)\
    \ - car_race_collision(n+1))\n  end\nend\n</cell>\n<cell>\ncar_race_collision(10)\n\
    </cell>\n<text>\nNow try it on a large problem", "  collisions = 0\n  for i in\
    \ 0 .. n-1\n    for j in i+1 .. n-1\n      if distance(cars[i].location, cars[j].location)\
    \ <= radius*2\n        collisions += 1\n    end\n  end\n  return collisions\n\
    end", "  return n*(n-1)/2\nend", "  collisions = 0\n  car_x = 0.0\n  car_y = 0.0\n\
    \  car_dx = 0.0\n  car_dy = 0.0\n  for i in range(1, n) # loop over all cars\n\
    \    car_x = -car_dx\n    car_y = -car_dy\n    if car_x > 0.0\n      car_x +=\
    \ car_dx\n      car_y += car_dy\n    else\n      car_x += car_dx\n      car_y\
    \ -= car_dy\n    collisions += 1\n  end\n  puts \"# There were #{collisions} collisions\"\
    \n  puts \"# The cars are travelling left to right\"\n  puts \"# The cars collide\
    \ when they collide\"\n  puts \"# The cars collide when they collide\"\n  puts\
    \ \"# The cars are travelling right to left\"\n  puts \"# The cars collide when\
    \ they collide\"\n  puts \"# The cars collide when they collide\"\n  puts \"#\
    \ The cars are travelling left to right\"\n  puts \"# The cars collide when they\
    \ collide\"\n  puts \"# The cars collide when they collide\"\n  puts \"# The cars\
    \ are travelling right to left\"\n  puts \"# The cars collide when they collide\"\
    \n  puts \"# The cars collide when they collide\"\n  puts \"# The cars are travelling\
    \ left to right\"\n  puts \"# The cars collide when they collide\"\n  puts \"\
    # The cars collide when they collide\"\n  puts \"# The cars are travelling right\
    \ to left\"\n  puts \"# The cars collide when they collide\"\n  puts \"# The cars\
    \ collide when they collide\"\n  puts \"# The cars are travelling left to right\"\
    \n  puts \"# The cars collide when they collide\"\n  puts \"# The cars collide\
    \ when they collide\"\n  puts \"# The cars are travelling right to left\"\n  puts\
    \ \"# The cars collide when they collide\"\n  puts \"# The cars collide when they\
    \ collide\"\n  puts \"# The cars are travelling left to right\"\n  puts \"# The\
    \ cars collide when they collide\"\n  puts \"# The cars collide when they collide\"\
    \n  puts \"# The cars are travelling right to left\"\n  puts \"# The cars collide\
    \ when they collide\"\n", "  car_collisions = 0\n  car_collisions = car_collisions\
    \ + n if car_collisions < n \n  car_collisions = car_collisions + n\n  car_collisions\
    \ = car_collisions + n if car_collisions < n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n\n  car_collisions\
    \ = car_collisions + n if car_collisions < n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n if car_collisions\
    \ < n\n  car_collisions = car_collisions + n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n if car_collisions\
    \ < n\n  car_collisions = car_collisions + n if car_collisions < n\n  car_collisions\
    \ = car_collisions + n if car_collisions < n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n if car_collisions\
    \ < n\n  car_collisions = car_collisions + n if car_collisions < n\n  car_collisions\
    \ = car_collisions + n if car_collisions < n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n if car_collisions\
    \ < n\n  car_collisions = car_collisions + n if car_collisions < n\n  car_collisions\
    \ = car_collisions + n if car_collisions < n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n if car_collisions\
    \ < n\n  car_collisions = car_collisions + n if car_collisions < n\n  car_collisions\
    \ = car_collisions + n if car_collisions < n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n if car_collisions\
    \ < n\n  car_collisions = car_collisions + n if car_collisions < n\n  car_collisions\
    \ = car_collisions + n if car_collisions < n\n  car_collisions = car_collisions\
    \ + n if car_collisions < n\n  car_collisions = car_collisions + n if car_collision",
  "  collisions = n \n  speeds = [0]*n\n  for i in 1..n\n    speeds[i] = speeds[i-1]\
    \ + speeds[i-1]\n    collisions += i\n  \n  speeds.reverse!\n  collisions.reverse!",
  "  count = 0\n  n = n*2\n  i = n\n  while i < n\n    j = n\n    while j < i\n  \
    \    puts j\n      if i % j == 0\n        count = count+1\n      end\n      j\
    \ = j+1\n    end\n    i = i+1\n  end\n  puts count\nend", "  car_left = [1, 3]\n\
    \  car_right = [1, 2]\n  collision_count = 0\n  for i in 1..n\n    collision_count\
    \ += car_left.product(car_right).detect{|i,j| i == j}\n    car_left.rotate!\n\
    \    car_right.rotate!\n  end\n  collision_count\nend", "  num_collisions = 0\n\
    \  car_1_coords = Array.new(2*n)\n  car_2_coords = Array.new(2*n)\n  car_1_coords.fill([])\n\
    \  car_2_coords.fill([])", "  s = 0\n  for i in (1..n)\n    s += 1 if car_race(i)\
    \ == car_race(n - 1)\n  end\n  s\nend", "  collisions = 0\n  for i in 0...n-1\n\
    \    for j in (i+1)...n\n      if abs(i^j) == n\n        collisions += 1\n  end\n\
    \  collisions\nend", "  collisions = 0\n  for i in 0...n-1\n    for j in i+1...n\n\
    \      if (cars[i,1] - cars[j,1]).abs < 0.1\n        collisions += 1\n  end\n\
    \  return collisions\nend", "  return 1 - ((1 - (2 * n) / (2 * n + 1))**((2 *\
    \ n) / (2 * n + 1))) - 1\nend", "  car_left = Array.new(n + 1).fill(0)\n  car_right\
    \ = car_left.clone\n  car_left.length.times do |i|\n    car_right[i] += i + 1\n\
    \  end\n  (1..n).each do |i|\n    collide = 0\n    (car_right[i] - car_left[i]).times\
    \ do |j|\n      if ((car_left[j] > car_right[j] && car_left[j] < car_right[j +\
    \ 1]) ||\n          (car_left[j] > car_right[j - 1] && car_left[j] < car_right[j\
    \ + 2]))\n        collide += 1\n      end\n    end\n    puts collide if collide\
    \ != 0\n  end\n  car_left.zip(car_right).each do |car, i|\n    puts \"Car #{i\
    \ + 1}: #{car}\"\n  end\nend", "  num_collisions = 0\n  num_collisions += 1 if\
    \ n > n / 4\n  num_collisions += 1 if n < 3 / 4 * n\n  return num_collisions\n\
    end", "  collisions = 0\n  for i in 0...n\n    colliding = true\n    for j in\
    \ i+1...n\n      if (car_collision(car_position(i - 1, j), car_position(i, j -\
    \ 1), car_position(i, j)) || \n          car_collision(car_position(i - 1, j),\
    \ car_position(i - 1, j - 1), car_position(i, j)) || \n          car_collision(car_position(i\
    \ - 1, j), car_position(i, j - 1), car_position(i - 1, j)) ||\n          car_collision(car_position(i,\
    \ j - 1), car_position(i, j), car_position(i - 1, j - 1))) then\n        colliding\
    \ = false\n        break\n      end\n    end\n    if (colliding) then\n      collisions\
    \ = collisions + 1\n    end\n  end\n  return collisions\nend\n</cell>\n<code language=julia-1.5>",
  "  count = 0\n  1.upto(n) do |i|\n    2.upto(n) do |j|\n      1.upto(n) do |k|\n\
    \        1.upto(n) do |l|\n          count += 0 if i != j && j != k && k != l\
    \ && l != i\n        end\n      end\n    end\n  end\n  count\nend\n</cell>\n<text>\n\
    Q. How many cars can move left and right at the speed of 100 cars per second?",
  "  n = (n * 10000000).to_i\n  collisions = 0\n  total = 0\n  for i in 0...n\n  \
    \  total += i % 10\n  end\n  collisions = total - (total % 10)\n  return collisions\n\
    end", "  count = 0\n  x = -1\n  y = 0\n  for i in (0 .. n-1)\n    x = (x + 1)\
    \ % n\n    y = (y + 1) % n\n    count = 0 if car_race_collision_helper(x, y, n)\
    \ else\n    count += 1\n  end\n  count\nend", "  ncars = 0\n  ncars = ncars +\
    \ car_race_collision(n - 1)\n  ncars = ncars + car_race_collision(n - 2)\n  return\
    \ ncars\nend", "    sum = 0\n    n.times do |i|\n        sum += car_race_collision_right(i)\n\
    \        sum += car_race_collision_left(i)\n    end\n    sum\nend", "  result\
    \ = 0\n  i = 0\n  while i < n\n    j = i + 1\n    while j < n\n      if i != j\
    \ && car_collision(i, j, r)\n        result += 1\n        j = n\n      end\n \
    \     j += 1\n    end\n    i += 1\n  end\n  result\nend", "  count = 0\n  cars\
    \ = Array.new(n) { Car }\n  cars[0].x = 1\n  cars[0].y = 1\n  cars[1].x = 2\n\
    \  cars[1].y = 1\n  cars[2].x = 3\n  cars[2].y = 1\n  cars[3].x = 4\n  cars[3].y\
    \ = 1\n  cars[4].x = 4\n  cars[4].y = 1\n  cars[5].x = 4\n  cars[5].y = 1\n  cars[6].x\
    \ = 4\n  cars[6].y = 1\n  cars[7].x = 4\n  cars[7].y = 1\n  cars[8].x = 5\n  cars[8].y\
    \ = 2\n  cars[9].x = 5\n  cars[9].y = 2\n  cars[10].x = 5\n  cars[10].y = 2\n\
    \  cars[11].x = 5\n  cars[11].y = 2\n  cars[12].x = 5\n  cars[12].y = 2\n  cars[13].x\
    \ = 5\n  cars[13].y = 2\n  cars[14].x = 6\n  cars[14].y = 2\n  cars[15].x = 6\n\
    \  cars[15].y = 2\n  cars[16].x = 6\n  cars[16].y = 2\n  cars[17].x = 6\n  cars[17].y\
    \ = 2\n  cars[18].x = 7\n  cars[18].y = 2\n  cars[19].x = 7\n  cars[19].y = 2\n\
    \  cars[20].x = 7\n  cars[20].y = 2\n  cars[21].x = 7\n  cars[21].y = 2\n  cars[22].x\
    \ = 7\n  cars[22].y = 2\n  cars[23].x = 8\n  cars[23].y = 2\n  cars[24].x = 8\n\
    \  cars[24].y = 2\n  cars[25].x = 8\n  cars[25].y = 2\n  cars[26].x = 8\n  cars[26].y\
    \ = 2\n  cars[27].x = 9\n  cars[27].y = 2\n  cars[28].x = 9\n  cars[28].y = 2\n\
    \  cars[29].x = 9\n  cars[29].y = 2\n  cars[30].x = 9\n  cars[30].y = 2\n  cars[31].x\
    \ = 10\n  cars[31].y = 2\n  cars[32", "  (0..n-1).each do |i|\n    ((i-1)..n).each\
    \ do |j|\n      ((j-1)..n).each do |k|\n        # Collision only occurs when moving\
    \ from i to j and j to k\n        if ((j == k) || (i == k)) then\n          return\
    \ 1 + car_race_collision(n)\n        end\n      end\n    end\n  end\n  return\
    \ 0\nend", "  collisions = 0\n  for i in 1..n\n    for j in (i..n)\n      collisions\
    \ += ( (i-j) % (n - j) == 0 ) ? 1 : 0\n  end\n  collisions\nend", "  count = 0\n\
    \  for i in (1..n) # from 1 to n\n    count += ncards_collide(n-i)\n  return count\n\
    end", "  n = (n * (n + 1)) / 2\n  n0 = n - 1\n  n1 = 2 * n\n  n2 = 2 * n + 1\n\
    \  n3 = 2 * n + 2\n  n4 = 2 * n + 3\n  n5 = 2 * n + 4\n  n6 = 2 * n + 5\n  n7\
    \ = 2 * n + 6\n  n8 = 2 * n + 7\n  n9 = 2 * n + 8\n  n10 = 2 * n + 9\n  n11 =\
    \ 2 * n + 10\n  n12 = 2 * n + 11\n  n13 = 2 * n + 12\n  n14 = 2 * n + 13\n  n15\
    \ = 2 * n + 14\n  n16 = 2 * n + 15\n  n17 = 2 * n + 16\n  n18 = 2 * n + 17\n \
    \ n19 = 2 * n + 18\n  n20 = 2 * n + 19\n  n21 = 2 * n + 20\n  n22 = 2 * n + 21\n\
    \  n23 = 2 * n + 22\n  n24 = 2 * n + 23\n  n25 = 2 * n + 24\n  n26 = 2 * n + 25\n\
    \  n27 = 2 * n + 26\n  n28 = 2 * n + 27\n  n29 = 2 * n + 28\n  n30 = 2 * n + 29\n\
    \  n31 = 2 * n + 30\n  n32 = 2 * n + 31\n  n33 = 2 * n + 32\n  n34 = 2 * n + 33\n\
    \  n35 = 2 * n + 34\n  n36 = 2 * n + 35\n  n37 = 2 * n + 36\n  n38 = 2 * n + 37\n\
    \  n39 = 2 * n + 38\n  n40 = 2 * n + 39\n  n41 = 2 * n + 40\n  n42 = 2 * n + 41\n\
    \  n43 = 2 * n + 42\n  n44 = 2 * n + 43\n  n45 = 2 * n + 44\n  n46 = 2 * n + 45\n\
    \  n47 = 2 * n + 46\n  n48 = 2 * n + 47\n  n49 = 2 * n + 48\n  n50 = 2 * n + 49\n\
    \  n51 = 2 * n + 50\n  n52 = 2 * n + 51\n  n53 = 2 * n + 52\n  n54 = 2 * n + 53\n\
    \  n55 = 2 * n + 54\n  n56 = 2 * n + 55\n  n57 = 2 * n + 56\n  n58 = 2 * n + 57\n\
    \  n59 = 2 * n + 58\n  n60 = 2 * n + 59\n  n61 = 2 * n + 60\n  n62 = 2 * n + 61\n\
    \  n63 = 2 * n + 62\n  n64 = 2 * n + 63", "\t\n\tcounter = 1\n\t\n\twhile(counter\
    \ < n)\n\t\n\t\tcounter = counter + 1\n\t\t\n\t\tleft = counter - 1;\n\t\tright\
    \ = counter + 1;\n\t\t\n\t\tif(left < n)\n\t\t\n\t\t\tleft_end = left + 1\n\t\t\
    \tleft_start = left - 1\n\t\t\t\n\t\t\twhile(left_end < n)\n\t\t\t\n\t\t\t\tleft_end\
    \ = left_end + 1\n\t\t\t\tleft_start = left_start - 1\n\t\t\t\t\n\t\t\t\twhile(left_start\
    \ > 0)\n\t\t\t\t\n\t\t\t\t\tleft_start = left_start - 1\n\t\t\t\t\t\n\t\t\t\t\t\
    if(collision(left, left_end, left_start))\n\t\t\t\t\t\n\t\t\t\t\t\tleft_start\
    \ = left_start\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(collision(left_end, right, right_start))\n\
    \t\t\t\t\t\t\n\t\t\t\t\t\t\tleft_end = left_end\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\
    if(collision(left, right_end, left_end))\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tleft_end\
    \ = left_end\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(collision(left, right_end, left))\n\
    \t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\
    \t\t\tif(collision(left_end, right, right))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\
    \t\t\tleft_end = right\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(collision(left, right,\
    \ right))\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tleft_end = right\n\t\t\t\t\t\t\t\n\
    \t\t\t\t\t\t\t\t\tif(collision(left_end, right, left))\n\t\t\t\t\t\t\t\t\t\n\t\
    \t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left,\
    \ right, left))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\
    \t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end, left, left))\n\t\t\t\t\t\t\
    \t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\
    if(collision(left_end, left, right))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\
    left_end = right\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left, right_end,\
    \ right))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = right\n\t\t\t\t\t\
    \t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end, right, left_end))\n\t\t\t\t\t\t\
    \t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\
    if(collision(left, right_end, left))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\
    left_end = right\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end, right,\
    \ right))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\t\t\t\
    \t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end, left, right))\n\t\t\t\t\t\t\t\t\
    \t\n\t\t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end,\
    \ right, left_end))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = right\n\
    \t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end, left, left))\n\t\t\t\t\
    \t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = right\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\
    \t\t\tif(collision(left_end, left, right))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\
    \t\t\tleft_end = left\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end,\
    \ right, left))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = left\n\t\t\
    \t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(left_end, right, left_end))\n\t\t\t\
    \t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tleft_end = right\n\t\t\t\t\t\t\t\n\t\t\t\t\t\
    \t\t\t\tif(collision(left, right_end, right))\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\
    \t\t\t\tleft_end = right\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(collision(", " \
    \ collisions = 0\n  for i in 0...n\n    collisions += car_race_collision_helper(i)\n\
    \  return collisions\nend", "  collisions = 0\n  collision_points = []\n  \n \
    \ num_cars = n\n  num_cars_per_side = n\n  num_cars_per_side_other = n\n  \n \
    \ # Initialize and store the initial positions of each car.\n  initial_positions\
    \ = [\n    Car.new(0.0, 0.0),\n    Car.new(0.0, 0.0),\n    Car.new(0.0, 0.0)\n\
    \  ]\n  \n  collision_points.push(initial_positions)\n  \n  last_collision_points\
    \ = []\n  \n  num_collisions = 0\n  \n  # The loop continues until all of the\
    \ cars have collided.\n  while num_collisions < num_cars\n    last_collision_points\
    \ = collision_points.pop()\n    \n    car_positions = last_collision_points\n\
    \    \n    collisions = 0\n    \n    # Go through each car position, going from\
    \ left to right.\n    for car_position in car_positions\n      # Get the speed\
    \ of the car in the current position.\n      car_speed = car_position.get_speed()\n\
    \      \n      while num_collisions < num_cars\n        # Get a random other car\
    \ position.\n        other_car_position = car_positions[rand(num_cars)-1]\n  \
    \      \n        # If the two cars are in collision, then this loop will continue.\n\
    \        if other_car_position == car_position\n          collisions += 1\n  \
    \        break\n        \n        # Otherwise the two cars won't collide; so stop\
    \ the inner loop.\n        end\n      \n        # Increment the number of collisions.\n\
    \        num_collisions += collisions\n        \n        # If the two cars collide,\
    \ then break the inner loop.\n        if collisions > 0\n          break\n   \
    \     end\n        \n        # Move the two cars apart, so the collision doesn't\
    \ happen.\n        car_position.move_apart()\n        other_car_position.move_apart()\n\
    \      end\n    end\n    \n    collision_points.push(last_collision_points)\n\
    \  end\n  \n  num_collisions = collision_points.size-1\n  return num_collisions\n\
    end", "  count = 0\n  num_cars = n\n  # Initialize the set of cars\n  left_cars\
    \ = Array.new(n) { Car.new(num_cars) }\n  right_cars = Array.new(n) { Car.new(num_cars)\
    \ }\n  # Initialize the set of collisions\n  left_collisions = Array.new(n) {\
    \ 0 }\n  right_collisions = Array.new(n) { 0 }\n  while left_cars.length > 0 and\
    \ right_cars.length > 0\n    left_car = left_cars.shift\n    right_car = right_cars.shift\n\
    \    collided_left = false\n    collided_right = false\n    \n    # Move cars\
    \ left until they collide\n    while collided_left == false and left_cars.length\
    \ > 0\n      collided_left = left_car.collides?(right_car)\n      left_cars.unshift(left_cars.shift)\n\
    \    end\n    \n    # Move cars right until they collide\n    while collided_right\
    \ == false and right_cars.length > 0\n      collided_right = right_car.collides?(left_car)\n\
    \      right_cars.unshift(right_cars.shift)\n    end\n    \n    # Check for collisions\n\
    \    if collided_left == true and collided_right == false\n      count += 1\n\
    \    end\n  end\n  \n  return count\nend", "  collisions = 0\n  car_race_count\
    \ = 0\n  for i in 1..n-1\n    for j in i+1..n\n      if cars[i].distance_to(cars[j])\
    \ < cars[i].size + cars[j].size\n        collisions += 1\n        car_race_count\
    \ += 1\n      end\n    end\n  end\n  collisions, car_race_count\nend", "  collision\
    \ = 0\n  for i in 1...n\n    leftmost = n - (n//2) - i\n    rightmost = n - i\n\
    \    if leftmost > rightmost\n      left = leftmost\n      right = rightmost\n\
    \    else\n      left = rightmost\n      right = leftmost\n    end\n    for j\
    \ in left...right\n      left = n\n      right = n\n      collision += 1\n   \
    \ end\n  end\n  collision\nend", "  cars = Array.new(n)\n  cars[0] = Car.new(1,\
    \ 0)\n  cars[1] = Car.new(-1, 0)", "    s = 0\n    for car in 1:n\n        for\
    \ car in 1:n\n            collide = False\n            for car in 1:n\n      \
    \          if car == (car+1)%n\n                    collide = True\n         \
    \           break\n            if collide\n                s = s + 1\n    return\
    \ s\nend", "  s = 0\n  for i in range(n - 1)\n    s += (Math.sqrt(Math.pow(speed_limit,2)\
    \ - Math.pow(car_speeds[i],2)))\n  return s\nend", "  (0..n-1).each do |i|\n \
    \   (1..n-1).each do |j|\n      j2 = j + 1 if j + 1<n and j + 1>1\n      collision_points\
    \ = car_collision(i, j, j2)\n      collision_points = [collision_points]\n   \
    \   collision_points.each do |collision_point|\n        if i != collision_point\n\
    \          j3 = j + 2 if j + 2<n and j + 2>1\n          collision_points = car_collision(i,\
    \ collision_point, j3)\n          collision_points = [collision_points]\n    \
    \      collision_points.each do |collision_point|\n            if j != collision_point\n\
    \              collision_points = car_collision(collision_point, j, j3)\n    \
    \          collision_points = [collision_points]\n              collision_points.each\
    \ do |collision_point|\n                collision_points = [[i, j, collision_point]]\n\
    \                collision_points.each do |collision_point|\n                \
    \  collision_points = [collision_point]\n                  collision_points.each\
    \ do |collision_point|\n                    collision_points = [collision_point]\n\
    \                    collision_points.each do |collision_point|\n            \
    \          collision_points = [collision_point]\n                      collision_points.each\
    \ do |collision_point|\n                        collision_points = [collision_point]\n\
    \                        collision_points.each do |collision_point|\n        \
    \                  collision_points = [collision_point]\n                    \
    \      collision_points.each do |collision_point|\n                          \
    \  collision_points = [collision_point]\n                            collision_points.each\
    \ do |collision_point|\n                              collision_points = [collision_point]\n\
    \                              # collision_points.each do |collision_point|\n\
    \                              #   collision_points = [collision_point]\n    \
    \                          # end\n                            end\n          \
    \                end\n                        end\n                      end\n\
    \                    end\n                  end\n                end\n       \
    \       end\n            end\n          end\n        end\n      end\n    end\n\
    \  end\n  return 0\nend\nputs car_race_collision(8)\n</code>\n<|/ q tags=ruby\
    \ |>\n<| c |>\nWhy do you think your code is not working? How can we check it?\
    \ Have you looked at `Car.new`, `Car.move_left`, and `Car.move_right` methods?\n\
    <|/ c |>\n<| c |>\nPlease read the rules of the site. Your question is poorly\
    \ written, confusing, and does not meet the rules. http://stackoverflow.com/help/how-to-ask\n\
    <|/ c |>\n<| c |>\n", "  num_collisions = 0\n  \n  # Initialize a matrix of 0s\
    \ with n+1th row and n columns\n  collision_matrix = Array.new(n+1)\n  collision_matrix.push(Array.new(n))\n\
    \  \n  # We also need two lists of collisions.  One contains all collisions involving\
    \ cars at distance 0\n  # and another that contains all collisions involving cars\
    \ at distance n.  \n  collision_list_0 = Array.new(n)\n  collision_list_1 = Array.new(n)\n\
    \  \n  # Initialize a counter and two boolean values for keeping track of whether\
    \ a collision has occurred.\n  collision_occurred = false\n  collision_occurred_1\
    \ = false\n  \n  car_0_pos_x = 0\n  car_0_pos_y = 0\n  \n  car_1_pos_x = 0\n \
    \ car_1_pos_y = 0\n  \n  # A car at distance 0 will never collide with a car at\
    \ distance n.\n  collision_list_0.push(true)\n  \n  # A car at distance n will\
    \ never collide with a car at distance 0.\n  collision_list_1.push(false)\n  \n\
    \  while true\n    # Find out if one of the cars is at distance n.\n    car_1_pos_x\
    \ = car_0_pos_x + car_1_speed_x * 2 * n \n    car_1_pos_y = car_0_pos_y + car_1_speed_y\
    \ * 2 * n\n    \n    car_1_pos_x = min(car_1_pos_x, n - 1)\n    car_1_pos_y =\
    \ min(car_1_pos_y, n - 1)\n    \n    # A car is at distance n if it is not the\
    \ one at the current position\n    if car_1_pos_x != car_1_pos_y\n    \n     \
    \ # If the car at distance n has a collision with any car in the other list then\
    \ increment the collision counter\n      collision_occurred_1 = collision_list_1.any?\
    \ { |c| c==true }\n      \n      if collision_occurred_1\n        collision_list_1.pop\n\
    \        \n        collision_occurred = true\n      else\n        collision_list_0.push(true)\n\
    \        \n        collision_occurred = false\n      end\n      \n      collision_matrix[car_1_pos_x][car_1_pos_y]\
    \ = collision_occurred\n    end\n    \n    # Update the current position of the\
    \ car at distance n.\n    car_0_pos_x += car_0_speed_x * 2 * n\n    car_0_pos_y\
    \ += car_0_speed_y * 2 * n\n    \n    # Stop the simulation when we reach the\
    \ end of the road.\n", "    count = 0\n    collisions = 0\n    # for each car\
    \ from 1 to n\n    # and for each possible pair of cars\n    # one from each set\
    \ that don't collide\n    for i in 1..n\n        for j in (i..n)\n           \
    \ # count cars that don't collide\n            # and count cars that do collide\n\
    \            if (car_collision(i, j) == false)\n                count += 1\n \
    \           else\n                collisions += 1\n    end\n    return collisions\n\
    end", '    number_of_collisions = 0', "    car_speed = 1\n    collisions = 0\n\
    \    car_collided = [false, false, false]\n    other_collided = [false, false,\
    \ false]\n    colliding = [false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, ", "  num_collided = 1\n  cars\
    \ = Array.new(n) { Array.new(n) }\n  c = 0\n  while c < n\n    cars[c][0] = (rand(10)\
    \ + 6).to_i\n    cars[c][1] = (rand(10) + 6).to_i\n    cars[c][2] = (rand(10)\
    \ + 6).to_i\n    cars[c][3] = (rand(10) + 6).to_i\n    cars[c][4] = (rand(10)\
    \ + 6).to_i\n    c += 1\n  end\n  c = 0\n  while c < n\n    cars[c][0] = (rand(10)\
    \ + 6).to_i\n    cars[c][1] = (rand(10) + 6).to_i\n    cars[c][2] = (rand(10)\
    \ + 6).to_i\n    cars[c][3] = (rand(10) + 6).to_i\n    cars[c][4] = (rand(10)\
    \ + 6).to_i\n    c += 1\n  end\n  car_distance = 0\n  c = 0\n  while c < n\n \
    \   car_distance += Math.sqrt(Math.pow(cars[c][0] - cars[c-1][0], 2) + Math.pow(cars[c][1]\
    \ - cars[c-1][1], 2) + Math.pow(cars[c][2] - cars[c-1][2], 2) + Math.pow(cars[c][3]\
    \ - cars[c-1][3], 2) + Math.pow(cars[c][4] - cars[c-1][4], 2))\n    c += 1\n \
    \ end\n  collisions = 0\n  c = 0\n  while c < n\n    if Math.sqrt(Math.pow(cars[c][0]\
    \ - cars[c-1][0], 2) + Math.pow(cars[c][1] - cars[c-1][1], 2) + Math.pow(cars[c][2]\
    \ - cars[c-1][2], 2) + Math.pow(cars[c][3] - cars[c-1][3], 2) + Math.pow(cars[c][4]\
    \ - cars[c-1][4], 2)) < car_distance\n      collisions += 1\n      cars[c-1][0]\
    \ = cars[c][3]\n      cars[c-1][1] = cars[c][2]\n      cars[c-1][2] = cars[c][1]\n\
    \      cars[c-1][3] = cars[c][0]\n      cars[c-1][4] = cars[c][4]\n    end\n \
    \   c += 1\n  end\n  c = 0\n  while c < n\n    cars[c-1][0] = cars[c][3]\n   \
    \ cars[c-1][1] = cars[c][2]\n    cars[c", "  race_time = 0\n  cars_left = n\n\
    \  cars_right = n\n  collisions = 0\n  collision_time = Time.now - Time.now %\
    \ 10\n  while (cars_left > 0) || (cars_right > 0)\n    collided = false\n    if\
    \ cars_left > 0\n      car_collided = true\n      cars_left -= 1\n      collisions\
    \ += 1\n    else\n      car_collided = false\n      cars_right -= 1\n      collisions\
    \ += 1\n    end\n    unless car_collided\n      if collision_time < 1\n      \
    \  collision_time = Time.now - Time.now % 10\n      end\n      collision_time\
    \ -= 1\n      car_race_speed = car_race_speeds[car_race_speeds.index(car_race_speed)-1]\n\
    \      car_race_speed = car_race_speeds[car_race_speeds.index(car_race_speed)-1]\n\
    \    end\n  end\n  return collisions\nend", "  count = 0\n  for i in 0...n-1\n\
    \    for j in i+1...n\n      if ((i > 0 and j < n-1) or\n          (i < n-1 and\
    \ j > 0)) then\n        count = count + 1\n      end\n    end\n  end\n  count\n\
    end", "  return n*(n + 1)/2\nend", "  count = 0\n  for i in (0 .. n)\n    for\
    \ j in (1 .. n)\n      if i!=j && i != j && i != j && i != j && i != j && i !=\
    \ j && i != j\n        count += j\n  end\n  count\nend", "  result = 0\n  for\
    \ i in 0..n - 1\n    for j in (i + 1..n)\n      if i != j\n        speed = car_speed(car_pos(i),\
    \ car_pos(j))\n        if speed < 0\n          result = result + 1\n        end\n\
    \      end\n    end\n  end\n  return result\nend", "  count = 0\n  for i in 1..n\n\
    \    for j in 1..n\n      if(a[r+i] == b[l+j])\n        count += 1\n    end\n\
    \  end\n  return count\nend", "  count = 0\n  \n  # Initialize variables\n  start_speed_left\
    \ = start_speed_right = start_speed_center = 0\n  start_speed_left = start_speed_right\
    \ = start_speed_center = 1\n  start_speed_left = start_speed_right = start_speed_center\
    \ = 0\n  \n  # Loop over cars right to left\n  for car in (1..(n-1))\n    \n \
    \   next_speed_left = start_speed_left\n    next_speed_right = start_speed_right\n\
    \    next_speed_center = start_speed_center\n    \n    # Loop over cars left to\
    \ right\n    for car_prime in (2..n)\n    \n      # If two cars are intersecting,\
    \ they must collide\n      if ( car_prime > car )\n        next = 1\n      else\n\
    \        next = 0\n      \n      speed_center = speed + car_prime - car + next_speed_center\
    \ * 1.0\n      speed_right = speed + car - car_prime + next_speed_right * 1.0\n\
    \      speed_left = speed + car + car_prime - next_speed_left * 1.0\n      \n\
    \      # If car is colliding with itself (this doesn't happen very often),\n \
    \     # it means we have a collision.  (However, it's possible this happens\n\
    \      # because we loop through every pair of cars.)\n      if ( car == car_prime\
    \ )\n        count = count + 1\n        \n      else\n        # If car center\
    \ speed is less than or equal to car right and left speeds\n        if ( (speed_center\
    \ <= speed_left) && (speed_center <= speed_right) )\n          # and speed center\
    \ is closer to right or left than car center,\n          # (meaning the cars don't\
    \ collide at all)\n          if ( (speed_center < speed_right) && (speed_center\
    \ < speed_left) )\n            # and the distance between the cars center and\
    \ the car is less than the distance between cars center and the cars' other ends,\n\
    \            count = count + 1\n            \n        # If car center speed is\
    \ greater than car right and left speeds\n        else\n          # and speed\
    \ center is closer to right or left than car center,\n          # (meaning the\
    \ cars don't collide at all)\n          if ( (speed_center > speed_right) && (speed_center\
    \ > speed_left) )\n            # and the distance between the cars center and\
    \ the car is less than the distance between cars center and the cars' other ends,\n\
    \            count = count + 1\n      end\n    end\n  end\n  \n  return count\n\
    end\n</cell>\n<text>\nProblem 7: Implementing A* search algorithm\nA* is also\
    \ known as an improved version of Dijkstra's algorithm. A version of A* that can\
    \ handle negative weights (weights that ", "  # Your code here\n  \n  if n ==\
    \ 1\n    return 0\n  \n  collisions = 0\n  \n  x = 0\n  y = 0\n  \n  for i in\
    \ 1..n\n    x += i\n    y += i\n    \n    if x == 2\n      x += 1 \n      y +=\
    \ 1 \n      \n      if y == 1\n        collisions += 1\n        \n      break\n\
    \      \n  collisions /= n\n  \n  return collisions", "  count = 0\n  x = 0\n\
    \  y = 0\n  while x < n\n    while y < n\n      # if the cars are colliding, add\
    \ 1 to count\n      if car_race_collision_at(x, y, x, y) then\n        count +=\
    \ 1\n      end\n      y += 1\n    end\n    x += 1\n  end\n  count\nend\ncar_race_collision(6)",
  "  car1 = rand(n - 1)\n  car2 = rand(n - 1)\n  count = 0\n  collision = 0\n  car1_travel\
    \ = 0\n  car2_travel = 0\n  while car1 != car2\n    if car1 < car2\n      car1\
    \ += 1\n      car1_travel += 1\n    else\n      car2 += 1\n      car2_travel +=\
    \ 1\n  end\n  if car1_travel <= car2_travel\n    if car1_travel == car2_travel\n\
    \      collision += 1\n    end\n    count += 1\n  end\n  count\nend", "  num_collisions\
    \ = 0\n  \n  left_cars = Array.new(n + 1) \n  right_cars = Array.new(n + 1)\n\
    \  \n  left_cars[0] = Car.new(0, 0)\n  right_cars[0] = Car.new(0, 1000)\n  \n\
    \  # The first car always starts at the same spot on its lane.\n  left_cars[1]\
    \ = left_cars[0]\n  right_cars[1] = right_cars[0]\n  \n  left_cars[2] = Car.new(0,\
    \ 1000)\n  right_cars[2] = Car.new(0, 1000)\n  \n  left_cars[3] = Car.new(0, 2000)\n\
    \  right_cars[3] = Car.new(0, 2000)\n  \n  left_cars[4] = Car.new(0, 3000)\n \
    \ right_cars[4] = Car.new(0, 3000)\n  \n  left_cars[5] = Car.new(0, 4000)\n  right_cars[5]\
    \ = Car.new(0, 4000)\n  \n  left_cars[6] = Car.new(0, 5000)\n  right_cars[6] =\
    \ Car.new(0, 5000)\n  \n  left_cars[7] = left_cars[6]\n  right_cars[7] = right_cars[6]\n\
    \  \n  left_cars[8] = left_cars[7]\n  right_cars[8] = right_cars[7]\n  \n  left_cars[9]\
    \ = left_cars[8]\n  right_cars[9] = right_cars[8]\n  \n  left_cars[10] = left_cars[9]\n\
    \  right_cars[10] = right_cars[9]\n  \n  left_cars[11] = left_cars[10]\n  right_cars[11]\
    \ = right_cars[10]\n  \n  left_cars[12] = Car.new(0, 6000)\n  right_cars[12] =\
    \ Car.new(0, 6000)\n  \n  left_cars[13] = left_cars[12]\n  right_cars[13] = right_cars[12]\n\
    \  \n  left_cars[14] = left_cars[13]\n  right_cars[14] = right_cars[13]\n  \n\
    \  left_cars[15] = left_cars[14]\n  right_cars[15] = right_cars[14]\n  \n  left_cars[16]\
    \ = left_cars[15]\n  right_cars[16] = right_cars[15]\n  \n  left_cars[17] = left_cars[16]\n\
    \  right_cars[17] = right_cars[16]\n  \n  left_cars[18] = left_cars[17]\n  ",
  "    count = 0\n    for c in cars:\n        if c.x > n.x:\n            c.x -= 1\n\
    \            count += 1\n        elif c.x < n.x:\n            c.x += 1\n     \
    \       count += 1\n    return count", "  collisions = 0\n  for i in range(1,\
    \ n)\n    col = (i+1) * (n+1)\n    collisions += ((n-i) * (n-1) + i * (i-1))\n\
    \  \n  return collisions\nend\n</cell>\n<text>\nNext, we'll write a function that\
    \ takes an n-sided polygon, like this:", "  collisions = 0\n  car_1 = (1..n).to_a\n\
    \  car_2 = (n..2*n).to_a\n  car_collisions = car_2.each{ |car2|\n    car_1.each{\
    \ |car1|\n      next if car1 == car2\n      if car_collide(car_1, car_2, car1,\
    \ car2)\n        collisions += 1\n      end\n    }\n  }\n  collisions\nend\n</code>\n\
    Now we can make a few tests.\n<code>\nn = 100\np car_race_collision(n)", "  collisions\
    \ = 0\n  for i in 0...n\n    collisions += car_race_collision_naive(i)\n  end\n\
    \  collisions\nend", "  left_collisions = 0\n  right_collisions = 0\n  for i in\
    \ range(n-1)\n    left_collisions += (i & 1) + ((n - (i >> 1)) & 1)\n    right_collisions\
    \ += ((n - (i >> 1)) & 1) + (i & 1)\n  end\n  left_collisions += (n - 1)\n  right_collisions\
    \ += (n - ((n >> 1) - 1))\n  return left_collisions + right_collisions\nend",
  "\tcount = 0\n\tfor i in (1..n)\n\t\tii = n-i\n\t\tiii = 0\n\t\twhile (i < ii)\n\
    \t\t\tc = rand(n)\n\t\t\tif (c > i)\n\t\t\t\tc = c-1\n\t\t\twhile ((c < ii) &\
    \ (iii < n) & ((c == ii) | (ii == iii)))\n\t\t\t\tiii = iii+1\n\t\t\t\tc = rand(n)\n\
    \t\t\ti = i+1\n\t\t\tcount = count + c\n\treturn count\nend", "    collisions\
    \ = 0\n    car_one = Car.new(1, 1)\n    car_two = Car.new(2, 2)\n    car_three\
    \ = Car.new(4, 4)\n    car_four = Car.new(8, 8)\n    car_five = Car.new(16, 16)\n\
    \    car_six = Car.new(32, 32)\n    car_seven = Car.new(64, 64)\n    car_eight\
    \ = Car.new(128, 128)\n    car_nine = Car.new(256, 256)\n    car_tan = Car.new(512,\
    \ 512)", "  count = 0\n  for i in 1..n\n    count = count + car_collision(i)\n\
    \  end\n  count\nend", "    count = 0\n    \n    begin = 0\n    end = n # inclusive",
  "  # Initialize number of collisions\n  num_collisions = 0\n  \n  # Consider all\
    \ pairs of cars\n  for i in 1...n\n    for j in (i+1)...n\n      # Find the speed\
    \ that causes a collision\n      left_speed = cars[i].speed - cars[j].speed\n\
    \      right_speed = cars[j].speed - cars[i].speed\n      if left_speed == right_speed\n\
    \        # A collision occurs if the cars are so close together that they never\
    \ \n        # collide.  A collision occurs when the cars are so close together\
    \ that\n        # they move the same distance in the same speed.\n        num_collisions\
    \ = num_collisions + 1\n    end\n  end", "  a = [0,n] # left and right lane positions\n\
    \  b = [0,n] # left and right lane positions\n  c = [0,n] # left and right lane\
    \ positions\n  count = 0\n  \n  while true\n    \n    # Calculate lane positions\
    \ with left and right lane velocities at t=0 and t=n\n    i = 0\n    while true\n\
    \      a = car_right_lane(i)\n      b = car_left_lane(i)\n      if a[1] != b[1]\
    \ && a[1] != 0\n        if a[1] == b[1] then\n          c[i] = a[0]\n        \
    \  c[i + 1] = 0\n          count += (n-i-1) # when there is a collision, count\
    \ up from i to n\n        else\n          c[i] = 0\n          c[i + 1] = a[0]\n\
    \          count += (n-i-1)\n        end\n      end\n      if a[1] != b[1] &&\
    \ a[1] != 0\n        if a[1] == b[1] then\n          c[i] = a[0]\n          c[i\
    \ + 1] = a[1]\n          count += (n-i-1)\n        end\n      end\n      i +=\
    \ 1\n    end\n    i += 1\n    \n    # Calculate lane positions with left and right\
    \ lane velocities at t=0 and t=n\n    i = 0\n    while true\n      a = car_left_lane(i)\n\
    \      b = car_right_lane(i)\n      if a[1] != b[1] && a[1] != 0\n        if a[1]\
    \ == b[1] then\n          c[i] = a[0]\n          c[i + 1] = a[1]\n          count\
    \ += (n-i-1)\n        end\n      end\n      if a[1] != b[1] && a[1] != 0\n   \
    \     if a[1] == b[1] then\n          c[i] = a[0]\n          c[i + 1] = 0\n  \
    \        count += (n-i-1)\n        end\n      end\n      i += 1\n    end\n   \
    \ i += 1\n    \n    \n    # Now check the lane positions with the left and right\
    \ lane velocities at t=0 and t=n\n    i = 0\n    while true\n      a = car_left_lane(i)\n\
    \      b = car_right_lane(i)\n      if a[1] != b[1] && a[1] != 0\n        if a[1]\
    \ == b[1] then\n          c[i] = a[0]\n          c[i + 1] = a[1]\n          count\
    \ += (n-i-1)\n        end\n      end\n      if a[1] != b[1] && a[1] != 0\n   \
    \     if a[1] == b[1] then\n          c[i] = a[0]\n          c[i + 1] = 0\n  \
    \        count += (n-i-1)\n        end\n      end\n      i += 1\n    end\n   \
    \ i += 1\n    \n    \n    \n    # Now check the lane positions with the left and\
    \ right lane velocities at t=0 and t=n\n    i = 0\n", "  collisions = 0\n  start_position\
    \ = initial_position\n  while start_position + 10 < final_position\n    if [start_position\
    \ + 10, start_position + 20].all? {|pos| valid_positions?(pos)}\n      start_position\
    \ = start_position + 20\n      collisions += 1\n    end\n  end\n  return collisions\n\
    end", "  count = 0\n  for i in 1..n\n    count += car_collision(n)\n  end\n  count\n\
    end", "  a = 1\n  b = 2\n  c = 4\n  d = 32\n  e = 1\n  f = 3\n  g = 1\n  h = 32\n\
    \  i = 0\n  j = 1\n  k = 4\n  l = 1\n  m = 1\n  n = 1\n  while n < n*n*n*n*n*n*n*n\
    \ do\n    n += 1\n  n = n*n*n*n*n*n*n*n\n  while n > 0 do\n    n -= 1\n    car_collision(a,\
    \ a)\n    car_collision(b, b)\n    car_collision(c, b)\n    car_collision(d, b)\n\
    \    car_collision(e, b)\n    car_collision(f, b)\n    car_collision(g, a)\n \
    \   car_collision(h, a)\n    car_collision(i, a)\n    car_collision(j, b)\n  \
    \  car_collision(k, a)\n    car_collision(l, a)\n    car_collision(m, a)\n  end\n\
    end", "  count = 0\n  for i in 1..n\n    for j in 1..n\n      if (car_collision(i,j)\
    \ OR car_collision(j,i))\n        count += 1\n  return count\nend", "  car_collisions\
    \ = 0\n  car_collisions_left = 0\n  car_collisions_right = 0\n  car_collisions_left_right\
    \ = 0\n  car_collisions_left_right_left = 0\n  car_collisions_right_left_right\
    \ = 0\n  car_collisions_left_right_left_left = 0\n  car_collisions_right_left_left_right\
    \ = 0\n  car_collisions_left_right_left_left_right = 0\n  car_collisions_right_left_left_left_left_right\
    \ = 0\n  car_collisions_left_right_left_left_right_left = 0\n  car_collisions_right_left_left_left_right_right_left\
    \ = 0\n  car_collisions_left_right_left_right_right_left_left = 0\n  car_collisions_right_left_left_right_right_left_right_left\
    \ = 0\n  car_collisions_left_right_left_right_right_left_right_left_left = 0\n\
    \  car_collisions_right_left_left_right_right_left_right_left_right_left = 0\n\
    \  car_collisions_left_right_left_right_right_left_right_left_right_left_right\
    \ = 0\n  car_collisions_right_left_left_right_right_left_right_left_right_right_left_right_left\
    \ = 0\n  car_collisions_left_right_left_right_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_right_left_left_right_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_right_left_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_right_left_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_right_left_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_right_left_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left_right_left\
    \ = 0\n  car_collisions_left_right_left_right_left_right_left_right_left_right_left_right_",
  "    count = 0\n    num = 0\n    car_speed = 15\n    while num < n\n       while\
    \ num > 0 and car_speed > 0\n          count += 1\n          num -= 1\n      \
    \    car_speed -= 1\n       num += 1\n       car_speed += 5\n    end\n    count\n\
    end", "  result = 0\n  i = 0\n  while i < n do\n    j = i + 1\n    while j < n\
    \ do\n      result = result + ((j-i) % 2) + 2*(j-i)\n      j = j + 1\n    end\n\
    \    i = i + 1\n  end\n  result\nend\nend", "  car_collisions = 0\n  for i in\
    \ (1..n)\n    for j in (n..i-1)\n      car_collisions += (distance(vec(road_coords(i),\
    \ vec(road_coords(j))),\n                               vec(road_coords(j), road_coords(i)))\
    \ < race_length_threshold)\n  end\n  car_collisions\nend\n</cell>\n<code language=julia-0.4>",
  "  count = 0\n  for x in 1..n\n    for y in 1..n\n      count += 1 if ((x - y) %\
    \ 2 != 0) || (((x - y) / x % 2 != 0) and ((x - y) / y % 2 != 0))\n    end\n  end\n\
    \  count\nend", "  # The number of collisions\n  num_collisions = 0\n  # Loop\
    \ through every car that is in the right direction.\n  for i in 1..n\n    # See\
    \ which other car has this same index\n    j = n-1-i\n    if i != j\n      # If\
    \ this car collides with another car\n      if car_collision(i, j)\n        num_collisions\
    \ = num_collisions + 1\n    end\n  end\n  num_collisions\nend", "  number_of_collisions\
    \ = 0\n  for i in 1..n\n    if i != n\n      left_speed = 0\n      right_speed\
    \ = 0\n      left_count = 0\n      right_count = 0\n      left_speed = i*0.1\n\
    \      right_speed = (n-i)*0.1\n      while left_speed <= right_speed\n      \
    \  left_count += 1\n        right_count += 1\n        left_speed += 0.1\n    \
    \    right_speed += 0.1\n      left_speed = left_speed * 1.0\n      right_speed\
    \ = right_speed * 1.0\n      if left_count + right_count >= n\n        number_of_collisions\
    \ += 1\n      else\n        left_speed *= 0.8\n        right_speed *= 0.8\n  \
    \      left_speed += rand(1) * 0.04\n        right_speed += rand(1) * 0.04\n \
    \     end\n    end\n  end\n  return number_of_collisions\nend", "  # Return the\
    \ number of collisions for n cars.\n  return n\nend\n</cell>\n<code language=julia-0.6>",
  "  counter = 0\n  left.each do |left_car|\n    right.each do |right_car|\n     \
    \ if (left_car.x > right_car.x + 200) && (left_car.x < right_car.x - 200) && (left_car.y\
    \ > right_car.y + 200) && (left_car.y < right_car.y - 200)\n        counter +=\
    \ 1\n      end\n    end\n  end\n  return counter\nend", "  collisions = 0\n  #\
    \ n number of cars\n  car_positions = [rand(1..200)] * n\n  for i in 1..n\n  \
    \  for j in i..n\n      car_positions[i] += rand(-1..1)\n      car_positions[j]\
    \ += rand(-1..1)\n      if car_positions[i] >= car_positions[j] \n        collisions\
    \ += 1\n      end\n    end\n  end\n  collisions\nend\n</cell>\n<code language=julia-0.6>",
  "  puts \"Cars racing with each other:\"\n  collisions = 0\n  cars = Array.new(n)\n\
    \  car_1_coords = Array.new(n)\n  car_2_coords = Array.new(n)\n  (0..n).each do\
    \ |i|\n    cars[i] = i.next\n    car_1_coords[i] = [i,cars[i][1]]\n    car_2_coords[i]\
    \ = [-i,cars[i][2]]\n  end", "  collisions = 0\n  for i in 1...n\n    for j in\
    \ 1...n\n      if i != j \n        collisions +=  (  ((j - i) % n) > 0 &&  ((i\
    \ - j) % n) > 0 )\n      end\n    end\n  end\n  return collisions\nend\n</cell>\n\
    <code language=julia-1.5>", "  (0..(n/2) - 1).each do |i|\n    (1..n).each do\
    \ |j|\n      i2 = i - 1\n      i3 = i + 1\n      j2 = j - 1\n      j3 = j + 1\n\
    \      if ((i == j) &\n          (i == i2) |\n          (j == j2) &\n        \
    \  (j == j3)) {\n        return true\n      }\n    end\n  end\n  return false\n\
    end\nputs car_race_collision(1000000)", "    cars = [Car.new(0, 'a'), Car.new(1,\
    \ 'b')]\n    count = 0\n    cars.each { |car1| cars.each { |car2| car1.move(car2.speed,\
    \ car2.direction, car2.name) } }\n    cars.each { |car| puts car.name if car.collided?\
    \ && car.position != car.collision_position }\n    puts \"Cars have collided\"\
    \ if count == 0\nend", "  count = 0\n  for i in 1..n\n    next unless i % 2\n\
    \    for j in i+1..n\n      next unless j % 2\n      count = count + 1\n    end\n\
    \  end\n  count\nend", "  collisions = 0\n  for i in 0..n-1\n    for j in (i+1)..n\n\
    \      if abs(i-j) == n and i != j\n        collisions += 1\n        break\n \
    \   end\n  end\n  return collisions\nend", "\tcollisions = 0\n\t\n\tfor i in 1:n\n\
    \t\tj = i\n\t\twhile j > 0\n\t\t\tk = j - 1\n\t\t\tif distance_car(i, k) > distance_car(k,\
    \ j)\n\t\t\t\tbreak\n\t\t\telse \n\t\t\t\tj -= 1\n\t\tend\n\t\tcollisions += j\n\
    \tend\n\t\n\treturn collisions\nend", "  c = 0\n  for i in (0..n-1)\n    for j\
    \ in (i+1..n-1)\n      c = c+1 if i != j\n      c = c+1 if i > j\n    end\n  end\n\
    \  return c\nend", "  count = 0\n  for i in 0 .. n-1\n    for j in i+1 .. n\n\
    \      if cars_are_colliding(i)\n        count += 1\n      end\n    end\n  end\n\
    \  count\nend\n</cell>\n<code language=julia-1.5>", "    count = 0\n    beginning_x\
    \ = car_x\n    beginning_y = car_y\n    beginning_direction = car_direction\n\
    \    for i in range(n):\n        new_x = car_x + car_speed_x * cos(car_direction)\n\
    \        new_y = car_y + car_speed_y * sin(car_direction)\n        new_direction\
    \ = (new_y - car_y) / (new_x - car_x)\n        if abs(new_x - beginning_x) < car_radius\
    \ + beginning_radius + car_radius:\n            count += 1\n            car_x\
    \ = new_x\n            car_y = new_y\n            car_direction = new_direction\n\
    \    return count", "  count = 0\n  cars = rands.rands(1, n).shuffle.first\n \
    \ for i in 1...n\n    left = cars[i - 1]\n    right = cars[i]\n    if left ==\
    \ right\n      count += 1\n    end\n  end\n  count\nend", "  # Base case:  If\
    \ there's only one car in a position, and it goes all the way around,\n  # there's\
    \ only one possible set of cars that can go that one position.\n  count = 0 if\
    \ n == 1 else n\n  # If there's two cars in a position, and at least one goes\
    \ left, and\n  # the other goes right, the two sets of cars are mutually exclusive.\n\
    \  count += n if n == 2 and ((n%2) == 0 and (n == 2 ^ n % 2) == 0) else 0\n  \n\
    \  for i in 1..n\n    count += car_race_collision(n - i)\n  end\n  \n  return\
    \ count\nend", "  counter = 0\n  c = 0\n  while c < n\n    c += 1\n    counter\
    \ = counter + car_race_collision_helper(n - c)\n  end\n  counter\nend", "  # Initialize\
    \ colliding counter\n  colliding = 0", "  count = 0\n  for i in (1..n)\n    count\
    \ += 1\n  end\n  return count\nend", "\tcount = 0\n\tfor i in 1..n\n\t\tcount\
    \ += car_race_collision_at(i)\n\tend\n\treturn count\nend", "  count = 0\n  (car_left_race,\
    \ car_right_race) = ( [n*2, n*2] )\n  (car_left_collide, car_right_collide) =\
    \ ( [n*2, n*2] )\n  (car_left_move, car_right_move) = ( [n*2, n*2] )\n  (car_left_hit_right,\
    \ car_right_hit_left) = ([n*2, n*2] )\n  (car_left_hit_left, car_right_hit_right)\
    \ = ([n*2, n*2] )\n  (car_left_hit_left, car_left_hit_right) = ([n*2, n*2] )\n\
    \  (car_left_hit_left, car_right_hit_left) = ([n*2, n*2] )\n  (car_left_hit_right,\
    \ car_left_hit_right) = ([n*2, n*2] )\n  (car_left_hit_right, car_right_hit_left)\
    \ = ([n*2, n*2] )\n  (car_left_hit_left, car_right_hit_left) = ([n*2, n*2] )\n\
    \  (car_left_hit_left, car_left_hit_right) = ([n*2, n*2] )\n  (car_left_hit_right,\
    \ car_left_hit_left) = ([n*2, n*2] )\n  (car_left_hit_right, car_right_hit_left)\
    \ = ([n*2, n*2] )\n  (car_left_hit_left, car_right_hit_left) = ([n*2, n*2] )\n\
    \  (car_left_hit_left, car_left_hit_right) = ([n*2, n*2] )\n  (car_left_hit_right,\
    \ car_left_hit_left) = ([n*2, n*2] )\n  (car_left_hit_right, car_right_hit_left)\
    \ = ([n*2, n*2] )\n  (car_left_hit_left, car_right_hit_left) = ([n*2, n*2] )\n\
    \  (car_left_hit_left, car_left_hit_right) = ([n*2, n*2] )\n  (car_left_hit_right,\
    \ car_left_hit_left) = ([n*2, n*2] )\n  (car_left_hit_right, car_right_hit_left)\
    \ = ([n*2, n*2] )\n  (car_left_hit_left, car_right_hit_left) = ([n*2, n*2] )\n\
    \  (car_left_hit_left, car_left_hit_right) = ([n*2, n*2] )\n  (car_left_hit_right,\
    \ car_left_hit_left) = ([n*2, n*2] )\n  (car_left_hit_right, car_right_hit_left)\
    \ = ([n*2, n*2] )\n  (car_left_hit_left, car_right_hit_left) = ([n*2, n*2] )\n\
    \  (car_left_hit_left, car_left_hit_", "  collision = 0\n  for i in 1..n\n   \
    \ for j in 1..n\n      if i <> j\n        if car_collision(i) && car_collision(j)\n\
    \          collision += 1\n        end\n      end\n    end\n  end\n  collision\n\
    end\n</cell>\n<cell>\ncar_race_collision(3)\n</cell>\n<cell>", "  collisions =\
    \ 0\n  num_cars = n\n  cars = [0 for i in range(num_cars)]\n  max_speed = 0\n\
    \  min_speed = INFINITY_\n  speeds = [0 for i in range(num_cars)]", "  for i in\
    \ 0...n\n    count = 0\n    for j in 0...n\n      distance = sqrt((i - j)^2)\n\
    \      if distance < 1\n        count += 1\n        break\n    end\n    if count\
    \ > 1\n      return count\n    end\n  end\n  return n\nend", "  count = 0\n  1.upto(n\
    \ - 1, 2) do |i|\n    1.upto(n - 1, 2) do |j|\n      count += 1\n    end\n  end\n\
    \  count\nend\n</cell>\n<code language=conda-env-cta-py>", "    collisions = 0\n\
    \    car_locations = [-x for x in range(n)]\n    other_car_locations = [x + 1\
    \ for x in car_locations]\n    car_distances = car_locations.map {|x| car_locations.map{|y|\
    \ \n        (x+y-n).abs}}\n    other_car_distances = other_car_locations.map {|x|\
    \ other_car_locations.map{|y| \n        (x+y-n).abs}}\n    car_distances.zip(other_car_distances).each\
    \ {|x, y| \n        collisions += 1 if x == y }\n    return collisions\nend",
  "  collisions = 0\n  for i in 1..n\n    collisions += race_collision(i)\n  end\n\
    \  collisions *= n\n  collisions\nend", "  # write your code here\n  result =\
    \ 0\n  for i in range(n):\n    for j in range(n):\n      if(i != j):\n       \
    \ result = result + math.pow(abs(i-j), 2)\n  return result", "    count = 0\n\
    \    for i in 1:n\n        for j in i+1:n\n            if (cars_collision(i,j))\n\
    \                count += 1\n            end\n        end\n    end\n    return\
    \ count\nend", "    # initialize answer variable\n    answer = 0\n    # simulate\
    \ n cars moving right to left and moving left to right\n    for cars in 1..n\n\
    \        cars_riding = n - cars\n        cars_running = cars\n        # simulate\
    \ car running left to right and car riding right to left\n        while cars_riding\
    \ > 0\n            # simulate one less car riding\n            cars_riding -=\
    \ 1\n            # simulate one more car running\n            cars_running +=\
    \ 1\n            if cars_running > cars_riding\n                # simulate collision\n\
    \                answer = answer + 1\n            end\n        end\n    end\n\
    \    return answer\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n+1 for providing\
    \ a solution. Another approach is to simulate the race cars by hand.\n<|/ c |>\n\
    <| c |>\nGood answer. I would just add that you could use the [Bathroom problem](http://en.wikipedia.org/wiki/Bathroom_problem)\
    \ to find the number of bathrooms that you can get in a certain number of cycles.\n\
    <|/ c |>\n<| c |>\nThe solution by Lukasz is far superior to the recursive solution\
    \ since it is way more concise.\n<|/ c |>\n<| c |>\nThe Bathroom problem is way\
    \ more fun to solve than this one.\n<|/ c |>\n<| c |>\nWhat is this \"1\" for?\n\
    <|/ c |>\n<| a |>\nThe solution by Lukasz is far superior to the recursive solution\
    \ since it is way more concise.\nThe Bathroom problem is way more fun to solve\
    \ than this one.\nHere is the solution in Julia Language:\n<code>\nfunction simulate_race_cars(n,\
    \ cycles, race_cars)\n    # race_cars[car] = the number of race cars running on\
    \ the car at car position\n    cars_running = cycles\n    cars_riding = cycles\
    \ - n\n    answer = Dict()\n    # simulate race cars running left to right and\
    \ car riding right to left\n    for car in race_cars\n        car_running = car\n\
    \        car_riding = n - car\n        # simulate car running left to right and\
    \ car riding right to left\n        while car_riding > 0\n            # simulate\
    \ one less car riding\n            car_riding -= 1\n            # simulate one\
    \ more car running\n            car_running += 1\n            if car", "  count\
    \ = 0\n  car_distances = []\n  car_locations = []\n  for i in 0...n\n    car_locations[i]\
    \ = (rand(n), rand(n))\n    car_distances[i] = distance(position(car_locations[i]),\
    \ position(car_locations[(i+1)%n]))\n  end\n  \n  car_collisions = true\n  for\
    \ i in 0...n-1\n    colliding_with = (car_distances[i] + car_distances[i+1])/2\n\
    \    if car_distances[i] + car_distances[i+1] > colliding_with\n      car_collisions\
    \ = false\n    end\n  end\n  \n  if car_collisions\n    count = 1\n  end\n  return\
    \ count\nend", "  count = 0\n  for i in 1...n\n    count+= car_race_collision(i)\n\
    \  end\n  return count\nend", "  n = 1\n  count = 0\n  while n<500\n    a = 0\n\
    \    b = 0\n    c = 0\n    count = 1\n    while c<n\n      # Find out which car\
    \ will stop moving first.\n      while b>c\n        temp = a\n        a=b\n  \
    \      b=temp\n      while c>b\n        temp = c\n        c=a\n        a=temp\n\
    \      # Now a is definitely moving left.  Can we collide with the cars moving\
    \ right?\n      while a>0\n        temp = b\n        b=c\n        c=temp\n   \
    \   # Now b is definitely moving right.  Can we collide with the cars moving left?\n\
    \      while b>0\n        temp = c\n        c=b\n        b=temp\n      # Now,\
    \ c is definitely moving left.  Can we collide with the cars moving right?\n \
    \     while c>0\n        temp = a\n        a=b\n        b=temp\n      # Now, a\
    \ is definitely moving right.  Can we collide with the cars moving left?\n   \
    \   while a>0\n        temp = c\n        c=b\n        b=temp\n      # Now, c is\
    \ definitely moving left.  Can we collide with the cars moving right?\n      while\
    \ c>0\n        temp = a\n        a=b\n        b=temp\n      # Now, a is definitely\
    \ moving right.  Can we collide with the cars moving left?\n      while a>0\n\
    \        temp = c\n        c=b\n        b=temp\n      # Now, c is definitely moving\
    \ left.  Can we collide with the cars moving right?\n      while c>0\n       \
    \ temp = a\n        a=b\n        b=temp\n      # Now, a is definitely moving right.\
    \  Can we collide with the cars moving left?\n      while a>0\n        temp =\
    \ c\n        c=b\n        b=temp\n      # Now, c is definitely moving left.  Can\
    \ we collide with the cars moving right?\n      while c>0\n        temp = a\n\
    \        a=b\n        b=temp\n      # Now, a is definitely moving right.  Can\
    \ we collide with the cars moving left?\n      while a>0\n        temp = c\n \
    \       c=b\n        b=temp\n      # Now, c is definitely moving left.  Can we\
    \ collide with the cars moving right?\n      while c>0\n        temp = a\n   \
    \     a=b\n        b=temp\n      # Now, a is definitely moving right.  Can we\
    \ collide with the cars moving left?", "  count = 0\n  for i in 1...n\n    for\
    \ j in (i+1)...n\n      if cars[i] == cars[j]\n        count += 1\n      end\n\
    \    end\n  end\n  count\nend\n</cell>\n<code language=julia-1.5>\ncar_race_collision(10)\n\
    </cell>\n<text>\nTask 2: Define a function that determines whether two cars are\
    \ colliding.\nThe function should take in two cars as input and should output\
    \ true if the two cars\ncollide, otherwise it should output false.", "\tcollisions\
    \ = 0", "  car_race_start\n  collisions = 0\n  for i in 0..n-1\n    for j in (i+1)..n\n\
    \      collisions += car_race_collision_test(i,j)\n  end\n  return collisions\n\
    end", "  count = 0\n  (0...n).each do |i|\n    # i goes from 0..n-1\n    # j is\
    \ i+1\n    # k is i-1\n    (0...n-1).each do |j|\n      (0...n-1).each do |k|\n\
    \        # j+k > n\n        # i+k < 0 || (i==0 && j==0)\n        if (j+k > n ||\
    \ (i==0 && j==0)) || ((i!=0 && j!=0 && (j+k)>n) && (i+k<0) || (i==0 && k==0))\n\
    \          count += 1\n        end\n      end\n    end\n  end\n  count\nend",
  "  count = 0\n  collision = 0\n  for i in 1..n\n    count += car_race_collision_count(i)\n\
    \  end\n  for i in 0..n-1\n    if i != n and i != (n-1) and i%n == (n-2)/n \n\
    \      collision += 1\n    end\n  end\n  return collision\nend\n</cell>\n<code\
    \ language=julia-1.0>", "  counter = 0\n  while counter < n\n    # Calculate the\
    \ midpoint between the cars that are colliding.\n    x = (left_x + right_x)/2\n\
    \    y = (left_y + right_y)/2\n    # Calculate which car would have to move left\
    \ to right to minimize collisions.\n    # This will never happen, since we know\
    \ that no two cars will ever collide.\n    if x > right_x\n      right_x = x\n\
    \      right_y = y\n    else\n      left_x = x\n      left_y = y\n    counter\
    \ += 1\n  return counter\nend", "  num_collisions = 0\n  collide = false\n  speeds\
    \ = [0, 2, 4, 6, 8, 10]\n  while collide\n    collide = false\n    num_collisions\
    \ += 1\n    collision_number = 0\n    speed = speeds.sample\n    while collision_number\
    \ < n\n      car_num = rand(10) + 10\n      while car_num == car_num ||  (car_num\
    \ == car_num && !collide)\n        car_num = rand(10) + 10\n      car_speed =\
    \ speed(car_num)\n      car_pos = car_speed * car_num\n      car_distance = speed\
    \ * car_num + car_speed\n      car_left = car_pos - car_distance\n      car_right\
    \ = car_pos + car_distance\n      if car_left <= 0\n        car_pos = car_speed\n\
    \        car_left = car_speed + car_distance\n      elsif car_right >= 10\n  \
    \      car_pos = car_speed\n        car_right = car_speed - car_distance\n   \
    \   else\n        car_collided = false\n        if (car_left <= car_right) &&\
    \ (car_right >= car_left)\n          car_collided = true\n        end\n      \
    \  if (car_left >= car_right) && (car_right <= car_left)\n          car_collided\
    \ = true\n        end\n        if car_collided\n          collide = true\n   \
    \       collision_number = n\n        end\n      end\n    end\n  end\n  return\
    \ num_collisions\nend\nputs(\"Car race collisions = #{car_race_collision(10)}\"\
    )\n</cell>\n<text>\nWhen you run the cell above, you should see a number like\
    \ the following at the bottom: Car race collisions = 9. That's because after 5\
    \ iterations, the cars collide, and the race ends.  You should be able to modify\
    \ this function to count the number of times the race ended.", "  count = 0\n\
    \  a = rand\n  b = a * -1 - 1\n  for i in 1..n\n    if car_race_collision?(a,\
    \ b)\n      count += 1\n      b += 1\n    else\n      a += 1\n      b = a * -1\
    \ - 1\n    end\n  end\n  count\nend", "    car_numbers = Array.new(n)\n    \n\
    \    collision_number = 0\n    \n    car_numbers[0] = 2\n    car_numbers[1] =\
    \ 1\n    car_numbers[2] = 1\n    car_numbers[3] = 2\n    car_numbers[4] = 2\n\
    \    car_numbers[5] = 3\n    car_numbers[6] = 4\n    car_numbers[7] = 5\n    \n\
    \    \n    \n    \n    \n    \n    # Initialize your answer here!\n    \n    #\
    \ Your answer should return an integer within the range\n    # [2, n-1]", "\t\
    collisions = 0\n\tmax_car_dist = n\n\twhile max_car_dist>0\n\t\tmin_car_dist =\
    \ n\n\t\tfor i in 1..n\n\t\t\tmin_car_dist = min_car_dist<collision_distance(i,i+1)\
    \ ? min_car_dist : collision_distance(i,i+1)\n\t\tcollisions += n-min_car_dist\n\
    \t\tmax_car_dist = max_car_dist<max_car_dist*n ? max_car_dist*n : max_car_dist\n\
    \tend\n\treturn collisions\nend\n</cell>\n<code language=julia-0.4>", "  a = 0\n\
    \  b = n\n  while b > 0\n    puts \"#{a} and #{b}\"\n    puts \"#{b} is less than\
    \ #{a}!!\"\n    b = b - 1\n    a = a + 1\n  end\n  return a\nend", "  count =\
    \ 0\n  car_count = 0\n  \n  for i in (0 ... n)\n    # A car standing next to a\
    \ car on the left is considered to collide with\n    # a car standing next to\
    \ a car on the right.\n    left = car_count - 1\n    right = car_count + 1\n \
    \   \n    left    = left % n\n    right   = right % n\n    left_car = left * n\
    \ + car_count\n    right_car = right * n + car_count\n    \n    if left_car ==\
    \ right_car\n      count += 1\n    end\n    \n    car_count += 1\n  end\n  \n\
    \  count\nend", "  n = 1\n  while n <= n\n    return n\n  end\nend", "  collisions\
    \ = 0\n  car_collisions = Array[Array[Int]](n+1)\n  car_collisions(0) = Array[Int](n+1)\n\
    \  for i in 0 until n\n    car_collisions(i+1)(i) = i+1\n  end\n  for i in 0 until\
    \ n\n    for j in 1 until n\n      dist = 0\n      for k in 0 until n\n      \
    \  if i != k && j != k\n          dist = dist + abs(car_collisions(i)[k] - car_collisions(j)[k])\n\
    \        end\n      end\n      if dist < car_collisions(i)[j]\n        collisions\
    \ = collisions + 1\n        car_collisions(i)[j] = dist\n      end\n    end\n\
    \  end\n  return collisions\nend\n</cell>\n<code language=julia-1.0>", "  counter\
    \ = 0\n  collisions = 0\n  for i in 0..n-1\n    for j in 0..n-1\n      # No collision\
    \ if moving right and left.\n      if i != j and (car_speed * 0.1) > car_speed\
    \ + car_speed\n        # No collision if moving right and moving left.\n     \
    \   if j != i and car_speed * 0.1 > car_speed + car_speed\n          # Collision\
    \ happens if moving right and moving left hits the other car.\n          if car_speed_vector(i\
    \ - 1, j) == car_speed_vector(i, j - 1)\n            # Only count collision if\
    \ the car is moving slowly towards each other.\n            if car_speed * 0.9\
    \ < car_speed + car_speed\n              counter += 1\n              collisions\
    \ += 1\n        end\n      end\n    end\n  end\n  puts \"#{'Collision' if collisions\
    \ > 0 else ''}: #{collisions}\"\nend\ncar_race_collision(10)\n</cell>\n<text>\n\
    Part 5: Backward Euler Integration\nNow that you have the collision counter, you're\
    \ ready to solve the race problem.", "  car_array = []\n  for i in 1..n\n    car_array\
    \ << i\n  end\n  \n  collisions = 0\n  for i in 0..n-1\n    for j in i+1..n\n\
    \      if car_array[i] == car_array[j]\n        collisions += 1\n        break\n\
    \      end\n    end\n  end\n  \n  puts \"There are #{collisions} collisions in\
    \ the race.\"\n  puts \"The race ends when...\"\n  puts \"There are #{n} cars\
    \ left.\"\nend\n</cell>\n<cell>\ncar_race_collision(10)\n</cell>\n<text>\nWrite\
    \ a program to determine if a number is prime\nGiven a positive integer, N, check\
    \ whether N is prime.", "    collisions = 0\n    iterations = n # since the first\
    \ iteration just creates an infinite loop...\n    while iterations\n        collisions\
    \ += car_race_collision_iteration(n)\n        iterations -= 1\n    end\n    collisions\n\
    end\n</cell>\n<code language=julia-0.4>", "  count = 0\n  for i in 1..n\n    count\
    \ += (car_race_collision_helper(i, n) == 0)\n  end\n  return count\nend", "  #\
    \ Write your code here.\n  count = 0\n  for i in 0...n-1\n    for j in 0...n-1\n\
    \      count += 1 if car_collide(i, j, 1, 1) or car_collide(i, j, 1, 1)\n    end\n\
    \  end\n  return count\nend", "    \n    # Initialize the array\n    collisions\
    \ = []\n    \n    # Initialize two random cars\n    a = get_random_car(n)\n  \
    \  b = get_random_car(n)\n    \n    # Initialize a moving speed counter\n    i\
    \ = 0\n    \n    # Keep moving until they collide\n    while a.x < b.x + a.size\
    \ && b.x < a.x + a.size && a.y < b.y + a.size && b.y < a.y + a.size\n        \n\
    \        # Increment the speed counter\n        i += 1\n        \n        # Move\
    \ each car by a random amount\n        a.x += rand(-20, 20)\n        b.x += rand(-20,\
    \ 20)\n        \n        # Add the cars to the collisions array if the cars collide\n\
    \        if ((a.x + a.size + 10 < b.x) || (b.x + b.size + 10 < a.x) || (a.y +\
    \ a.size + 10 < b.y) || (b.y + b.size + 10 < a.y))\n            collisions.push\
    \ i\n        end\n    end\n    \n    # Return the number of collisions\n    return\
    \ collisions.length\nend", "  total = 0\n  (1..n).each do |i|\n    (i..n).each\
    \ do |j|\n      next if i==j\n      total += i_car_collision(i,j)\n    end\n \
    \ end\n  total\nend", "  collisions = 0\n  car_x_speed = 0\n  car_y_speed = 0\n\
    \  \n  car_x = rand(8) + 8\n  car_y = rand(8) + 8\n  car_x_speed = rand(8)\n \
    \ car_y_speed = rand(8)", "  count = 0\n  for i in 0...n\n    if i == 0\n    \
    \  j = n-1\n    else\n      j = 0\n    count = count + car_race_collision_helper(i,\
    \ j)\n  end\n  count\nend", "  count = 0\n  c1, c2 = 1, 1\n  while c1 < n && c2\
    \ < n\n    if cars[c1].location.x > cars[c2].location.x\n      c1 += 1\n    else\n\
    \      c2 += 1\n    end\n    count += 1\n  end\n  count\nend\n</code>\n<|/ a tags=ruby,hash\
    \ |>\n<| c |>\nHaven't really looked at it in a while but I'm pretty sure I understand\
    \ what's happening here but I can't quite get it to work. First of all, car_race_collision\
    \ should return an array of all the \"collisions\" not just the number. Second\
    \ of all, what does c1.location.x do and how does it relate to cars[c1].location.x?\
    \ Third, I'm pretty sure you meant to write \"c1 < n || c2 < n\" not \"c1 < n\
    \ && c2 < n\" which makes a lot of sense now you mentioned it but still doesn't\
    \ quite make sense.\n<|/ c |>\n<| c |>\nSorry to hear that my code didn't work.\
    \  I forgot about the distinction between logical and arithmetic operators in\
    \ Ruby; `c1 < n` is true when `c1` is less than `n`.  Similarly, `c2 < n` is true\
    \ when `c2` is less than `n`.  So the loop condition would have to be `while c1\
    \ < n || c2 < n` to check for a collision between two cars.\n<|/ c |>\n<| c |>\n\
    Okay I think I understand what's happening but I'm having a hard time converting\
    \ it to Ruby. How does c1.location.x relate to cars[c1].location.x? What's the\
    \ significance of cars[c1]?\n<|/ c |>\n<| c |>\nI edited the code to make it more\
    \ Rubythonic and to remove some redundancy.\n<|/ c |>\n<| c |>\nI appreciate the\
    \ edited version. I can get car_race_collision to return the right information\
    \ by doing: `puts car_race_collision(3)`, but I can't figure out how to get it\
    \ to return the collision information as an array. Where would I put the .each\
    \ do |car, count| code?\n<|/ c |>\n<| a tags=ruby,hash |>\nThe first answer is\
    \ great, however I needed some modifications to be able to use it in my own code,\
    \ so I made it a little more generic.\n<code>", "  count = 0\n  for i in 1..n\n\
    \    count = 0\n    for j in 1..n\n      collisions = car_race_collision_at(i,j)\n\
    \      count += collisions\n    end\n  end\n  count\nend\n</cell>\n<code language=julia-1.5>\n\
    car_race_collision(4)\n</cell>\n<text>\nLet's define a function car_race_collision_at\
    \ that computes how many times a car can collide with a car at a given position.\
    \  As in our car_race_collision function, each car can only collide with itself\
    \ and itself.", "  count=0\n  n.each_with_index do |car, index|\n    index = n-index-1\n\
    \    other_car=n[index]\n    next_car=n[index+1]\n    next if (other_car==next_car).nil?\n\
    \    distance = other_car.distance_to(next_car)\n    if (distance<car.distance_to(other_car))\n\
    \      count += 1\n    end\n  end\n  count\nend\n</code>\n<|/ a dscore=1 tags=algorithm,language-agnostic,computational-geometry\
    \ |>\n<| c |>\nYes, I see how you could come up with the \"simplest\" solution;\
    \ I'm just not all that familiar with mathematical concepts well enough to implement\
    \ it that way. Your answer definitely helps, though. Thanks!\n<|/ c |>\n<| c |>\n\
    By the way, thanks for that great answer! I do have one question: why is the `if`\
    \ clause necessary in the last line of `car_race_collision`?\n<|/ c |>\n<| c |>\n\
    One would need to exclude the `if` clause if the car was already colliding with\
    \ another car.  Since it's possible that a collision can happen with a car already\
    \ colliding with another car, I believe that `if` is necessary to account for\
    \ this.\n<|/ c |>\n<| a |>\nI hope that I've understood your question right. Suppose\
    \ you have a pair of cars A and B which are moving on a straight line and car\
    \ A is on the left and carB is on the right.\nWhat you need is to figure out whether\
    \ two cars collide or not. \nThis can be done by finding the distance of the cars\
    \ from each other and then adding them and then comparing that to the total distance\
    \ between the cars. If the total distance is less than the distance between the\
    \ cars, they do not collide.\n<|/ a dscore=0 tags=algorithm,language-agnostic,computational-geometry\
    \ |>\n<| c |>\nThat would work if the cars were moving in the same direction.\
    \  However, they would have to collide if they're moving in opposite directions\
    \ (i.e. one car moving forward, while the other one moving backward), which means\
    \ this wouldn't work. That's why my proposed solution, which is based on the fact\
    \ that they can only move in one direction, relies on checking the distance from\
    \ one end of the car to the other.  But that may prove problematic when there\
    \ are more than 2 cars to check, e.g. when there are 3 cars to check.\n<|/ c |>\n\
    <| a |>\nA simple approach would be to simply check each pair of cars with the\
    \ same speed and move each one into the direction it ", "  count = 0\n  n = n\
    \ # we won't change n\n  for i in 1..n\n    for j in (i+n)..n\n      if (j > n)\
    \ then\n        count = count + 1\n      end\n    end\n  end\n  return count\n\
    end", "  count = 0\n  for i in (0..n-1)\n    car_left = Car.new\n    car_left.speed\
    \ = 10\n    car_left.position = car_positions[i-1]\n    car_right = Car.new\n\
    \    car_right.speed = 10\n    car_right.position = car_positions[i]\n    collision\
    \ = collision_test(car_left, car_right)\n    if collision\n      count += 1\n\
    \    end\n  end\n  return count\nend", "  collisions = 0\n  collisions += car_collision_sum(n)\
    \ \n  collisions += car_collision_sum(n) \n  collisions += car_collision_sum(n)\
    \ \n  return collisions\nend", "  collision = 0\n  for i in 0..n-1\n    for j\
    \ in i+1..n\n      if (car_collision(i))\n        collision = collision + 1\n\
    \  return(collision)\nend", "  count = 0\n  for i in 0...n\n    if car_collision(n)\
    \ == car_collision(n-1)\n      count += 1\n    end\n  end\n  return count\nend",
  "  x = 0\n  while x < n\n    puts \"Car #{x} is moving #{(x % 2 == 0)?'left':'right'}\"\
    \n    x += 2\n  end\n  puts \"Car #{x} is colliding with #{(x % 2 == 0)?'right':'left'}\"\
    \n  x\nend\ncar_race_collision(100)", "  collisions = 0\n  for i in 0 .. n-1\n\
    \    collisions += num_collisions(i, i+1, n)\n  return collisions\nend", "  #\
    \ Write your code here.\n  return nil\nend", "  count = 0\n  for i in 1..n\n \
    \   j = n - i\n    count += 0 if cars_collide?(j, i)\n  end\n  count\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for the explanation. I realized that my problem had\
    \ to do with my definition of \"collision\". My definition of \"collision\" was\
    \ wrong, even though it was correct, I wasn't paying attention to the details.\
    \ Thanks again\n<|/ c |>\n<| a dscore=0 |>\nThe problem with your code is that\
    \ you don't consider if two cars collide, since you only check every car against\
    \ the previous one:\n<code>", "  count = 0\n  collision_count = 0\n  collide_cars\
    \ = n\n  while collide_cars > 0\n    collide_cars -= 1\n    car1 = generate_car()\n\
    \    car2 = generate_car()\n    car1.collision_count += 2\n    car2.collision_count\
    \ += 2\n    if car1.collision_count <= car2.collision_count\n      car2.collision_count\
    \ = car1.collision_count\n    car2.collision_count += 1\n    if car1.collision_count\
    \ == car2.collision_count\n      count += 1\n      collision_count += 1\n    end\n\
    \  end\n  return collision_count\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks\
    \ I really appreciate your help.\n<|/ c |>\n<| a dscore=0 |>\nThanks a lot for\
    \ all the help I got but I figured out how to do it. And here is my code:\n<code>",
  "\tcollisions = 0\n\tcar_num = n\n\twhile car_num != 0\n\t\tif car_num > (n /2)\n\
    \t\t\tcar_num = car_num - car_num / (n /2 )\n\t\telse\n\t\t\tcar_num = car_num\
    \ - car_num / 2\n\t\tend\n\t\tcollisions = collisions + 1\n\tend\n\treturn collisions\n\
    end", "  i = 0\n  while i < n\n    car_collision = car_collision_count(i)\n  \
    \  if (car_collision > 0)\n      car_collision = car_collision - 1\n      i =\
    \ i + 1\n    else\n      break\n    end\n  end\n  i = n\n  while i >= 0\n    car_collision\
    \ = car_collision_count(i)\n    if (car_collision > 0)\n      i = i - 1\n    end\n\
    \  end\n  puts \"There are #{car_collision} cars having collisions\"\nend\ncar_race_collision(10)\
    \ # --> There are 3 collisions", "  result = 0\n  while n != 0\n    if n & 1\n\
    \      result += 1\n      n -= 1\n    end\n    n >>= 1\n  end\n  result\nend",
  "    count = 0\n    last_collision = -1\n    iteration = 0\n    while iteration\
    \ < n do\n        last_collision = count\n        iteration += 1\n        # Find\
    \ the two cars colliding.  Try each one in turn.\n        if car_race_collision_left()\n\
    \            count += 1\n        if car_race_collision_right()\n            count\
    \ += 1\n        if count == last_collision\n            return count\n    return\
    \ 0\nend", "  collisions = 0\n  collisions += race_car_collision(n, n)\n  collisions\
    \ += race_car_collision(n, n - 1)\n  collisions += race_car_collision(n - 1, n)\n\
    \  collisions += race_car_collision(n, n - 2)\n  return collisions\nend\n</cell>\n\
    <code language=julia-0.5>\n@time car_race_collision(10000000)\n</cell>\n<text>\n\
    Problem 3. Racecars Racing", "    i = 2\n    collisions = 0\n    while i <= n\n\
    \        if car_collision(i) == car_collision(i-1)\n            collisions = collisions\
    \ + 1\n        i = i + 1\n    return collisions\nend\n</cell>\n<code language=julia-1.3>",
  '  number_of_collisions = 0', "  collisions = 0\n  car_left = Car.new(\"left_#{n}\"\
    , 0)\n  car_right = Car.new(\"right_#{n}\", 0)", "  count = 0\n  while n != 0\n\
    \    count += 1\n    n = n / 2\n  end\n  return count\nend", "   count = 0\n \
    \  cars_left = n\n   cars_right = n", "  collisions = 0 # number of collisions\n\
    \  i = 1\n  while i < n\n    j = i\n    while j > (n - 1)\n      if i == j\n \
    \       break\n      end\n      j -= 1\n    end\n    if i < j\n      break\n \
    \   end\n    i += 1\n  end\n  collisions += i\n  return collisions\nend", "  car_left_x\
    \ = -car_size*Math.rand.rand(n)\n  car_left_y = -car_size*Math.rand.rand(n)\n\
    \  car_right_x = car_size*Math.rand.rand(n)\n  car_right_y = car_size*Math.rand.rand(n)",
  '  num_collisions = 0', "\tcollision_count = 0\n\tprev_car_location = nil\n\t\n\t\
    for i in (0..n-1)\n\t\tcar_location = cars[i]\n\t\t\n\t\t# Check for a collision\
    \ at the first car\n\t\tif car_location == prev_car_location\n\t\t\tcollision_count\
    \ += 1\n\t\t\tbreak\n\t\t\n\t\t# Check for a collision at the last car\n\t\tif\
    \ i == n-1\n\t\t\tcollision_count += 1\n\t\t\tbreak\n\t\t\n\t\t# Otherwise, check\
    \ for a collision at the cars that come after it\n\t\tnext_car_location = cars[i+1]\n\
    \t\t\n\t\tif car_location == next_car_location\n\t\t\tcollision_count += 1\n\t\
    \tend\n\t\t\n\t\tprev_car_location = car_location\n\tend\n\t\n\tcollision_count\n\
    end", "    count = 0\n    left_speed, right_speed = [-speed for speed in car_speeds[:n]]\n\
    \    for i in 0..n - 1\n        right_speed = car_speeds[i+1]\n        for j in\
    \ 0..n - 1\n            left_speed = car_speeds[j+1]\n            intersection\
    \ = line_line_distance(cars[i][:2], cars[j][:2], left_speed, right_speed)\n  \
    \          if intersection == 0\n                count += 1\n            end\n\
    \        end\n    end\n    return count\nend", "  collisions = 0\n  for i in 1..n\n\
    \    collisions += car_race_collision(i)\n  return collisions\nend", "  count\
    \ = 0\n  for i in 0..n-1\n    for j in i..n\n      if (car_collision(i, j))\n\
    \        count += 1\n    end\n  end\n  count\nend\n</code>\nWe can use this to\
    \ solve the race condition you mentioned in the comments.  You said:", "  collisions\
    \ = 0\n  for i in 1..n\n    j = (i-1) % n\n    if cars_collide?(i, j)\n      collisions\
    \ += 1\n    end\n  end\n  collisions\nend", "   x = []\n   y = []\n   for i=0,n-1\
    \ do\n      x.push(i)\n      y.push(100)\n   end", "  collisions = 0\n  for i\
    \ in 0 .. n\n    for j in i+1 .. n\n      if j > i\n        if car_distance(i,\
    \ j) <= car_distance(n, j-2)\n          collisions += 1\n    end\n  end\n  return\
    \ collisions\nend", "\tcount = 0\n\tcars = Array.new(n) { Array.new(n) }\n\tfor\
    \ i in 0..n-1\n\t\tfor j in i+1..n\n\t\t\tcars[i] << {\n\t\t\t\t:x => rand(max),\n\
    \t\t\t\t:y => rand(max)\n\t\t\t}\n\t\t\tcars[j] << {\n\t\t\t\t:x => rand(max),\n\
    \t\t\t\t:y => rand(max)\n\t\t\t}\n\t\tend\n\tend\n\tfor i in 0..n-1\n\t\tcar_collisions(cars[i],\
    \ cars[i+1], count)\n\tend\n\tcount\nend", "  collisions = 0\n  for i in (0...n-1)\n\
    \    for j in (i+1...n)\n      collisions += ( collision_test(i, j) )\n  end\n\
    \  collisions\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
