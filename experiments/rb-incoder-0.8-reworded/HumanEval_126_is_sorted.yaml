name: HumanEval_126_is_sorted
language: rb
prompt: "# Given an array of numbers, return whether or not they are sorted\n# in\
  \ ascending order. If array has more than 1 duplicate of the same\n# number, return\
  \ false. Assume no negative numbers and only integers.\n# Examples\n# >>> is_sorted.call([5])\n\
  # true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1,\
  \ 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>>\
  \ is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2,\
  \ 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>>\
  \ is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n\
  \    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n\
  \    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false,\
  \ candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2,\
  \ 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n\
  \    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true,\
  \ candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false,\
  \ candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2,\
  \ 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true,\
  \ candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4]))\n  end\nend\n"
completions: ["  lst.sort {|a,b| a <=> b} == lst\nend", "  if lst.sort == nil\n  \
    \  false\n  else\n    true\n  end\nend", "    return lst==sorted.call(lst)\nend",
  "    return lst.size == lst.uniq.count && lst.uniq.sort == true\nend\n</code>\n\
    I believe this to be the simplest solution that has good performance. Even though\
    \ the code is not as concise as I would like, it is the fastest and most efficient\
    \ solution that I could come up with.\n<|/ a |>\n<| c |>\nFor Ruby 1.9+, you can\
    \ use `lst.uniq.length == 1` instead of `lst.uniq.count == 1`\n<|/ c |>\n<| c\
    \ |>\nTo make this even more concise you can do `if lst.uniq.sort == true`\n<|/\
    \ c |>\n<| a dscore=3 |>\nI made a small benchmark to test performance of different\
    \ methods proposed in this post:\n<code>\nmodule ActiveSupport\n  module CoreExtensions\n\
    \    module Array\n      module Sorted\n        def is_sorted?\n          length\
    \ == uniq.count && uniq.sort == true\n        end\n      end\n    end\n  end\n\
    end\n</code>\nComparing performance of the three methods above:\n<code>\n[\n \
    \ %{Methods:       1.348 s \xB1 0.070 s/eval,\n   Method:       1.262 s \xB1 0.072\
    \ s/eval,\n  Method:        1.237 s \xB1 0.050 s/eval,\n  Methods:       1.265\
    \ s \xB1 0.076 s/eval,\n  Method:       1.356 s \xB1 0.078 s/eval,\n  Methods:\
    \        1.347 s \xB1 0.074 s/eval,\n  Method:       1.322 s \xB1 0.078 s/eval,\n\
    \  Methods:       1.319 s \xB1 0.070 s/eval,\n  Method:       1.366 s \xB1 0.075\
    \ s/eval,\n  Methods:       1.332 s \xB1 0.072 s/eval,\n  Method:       1.333\
    \ s \xB1 0.072 s/eval,\n  Method:       1.333 s \xB1 0.070 s/eval},\n  %{Methods:\
    \       1.330 s \xB1 0.071 s/eval,\n   Method:       1.327 s \xB1 0.072 s/eval,\n\
    \  Method:        1.320 s \xB1 0.061 s/eval,\n  Methods:       1.325 s \xB1 0.076\
    \ s/eval,\n  Method:       1.331 s \xB1 0.0", "  lst = lst.sort\n  lst.size ==\
    \ 0 or (lst.first==lst.last)\nend", "  lst.sort!\n  return true\nend", "  # O(1)\
    \ time complexity\n  # O(n log n) space complexity\n  # Sort array in O(n log\
    \ n)\n  lst = lst.dup.sort\n  n = lst.length\n  return n != 0 and lst[0] == lst[n-1]\n\
    end", "  lst.each_with_index do |x,i|\n    return false if i == 0 && lst[i-1]\
    \ == x\n    return false if i == lst.size - 1 && lst[i+1] == x\n    return true\
    \ if lst[i-1] == x && lst[i+1] == x\n  end\n  return true\nend", "  sorted = false\n\
    \  duplicates = Hash.new(0)\n  lst.each_with_index do |x, i|\n    if x == sorted\n\
    \      duplicates[i] = duplicates[i] + 1\n    elsif x < sorted or duplicates[x\
    \ - 1] == duplicates[x]\n      sorted = false\n    else\n      sorted = true\n\
    \    end\n  end\n  not sorted\nend", "  return lst.uniq.count == lst.count\nend\n\
    </cell>\n<code language=julia-1.0>\n@test is_sorted([1, 2, 3]) \u2260 true\n@test\
    \ is_sorted([3, 2, 1]) \u2260 true\n@test is_sorted([1, 2, 2, 3]) \u2260 false\n\
    </cell>\n<text>\nSorted Array Exercise\nWrite a function called sorted_array that\
    \ takes in an array of numbers, and returns a sorted version of that array. For\
    \ example, sorted_array([3, 2, 1]) should return [1,2,3].", "  lst.sort\n  \n\
    \  unless lst.uniq.size == lst.size\n    return false\n  end\n  return true\n\
    end", "  lst.sort!\n  return true\nend", "  return lst.uniq.size == lst.size and\
    \ lst.all? { |x| x == lst.sort }.size == 1\nend", "  return lst.inject(true) {\
    \ |i,x| i && lst[i+1] < x }\nend", "  return lst.uniq == lst.sort\nend", "   \
    \ sorted = true\n    rest = lst\n    while rest && sorted\n        sorted = false\n\
    \        rest.each do |x|\n            if rest.find {|y| y == x }\n          \
    \      sorted = true\n            end\n        end\n    end\n    sorted\nend\n\
    </code>\nUsing this helper method, you can write a function like the following\n\
    <code>", "  return !is_sorted_rev(rev(lst))\nend", "  # Write your code here.\n\
    \  return true\nend", "  return lst.uniq.length <= lst.sort().uniq.size\nend\n\
    \"\"\"", "  return lst.size == 0 || lst.uniq.size == lst.size\nend", "  if lst.instance_of?(Array)\n\
    \    uniq = lst.uniq\n    uniq.instance_of?(Array) ? uniq == lst : uniq == sorted(uniq)\n\
    \  else\n    false\n  end\nend", "  return lst.uniq.length == lst.sort.length\n\
    end", "  return lst.uniq.sort == lst.sort\nend", "  return lst.count { |x| lst.count(x)\
    \ > 1 } == 0\nend", "  # sort is O(nlogn), but we only care about duplicates,\
    \ so it's O(n)\n  unique = []\n  for i in lst\n    unless unique.include?(i)\n\
    \      unique.push(i)\n    end\n  end\n  unique.uniq.length <= 1\nend", "  duplicated\
    \ = count_duplicated(lst)\n  if duplicated == 1\n    return true\n  return false\n\
    end", "  lst.each do |i|\n    break if lst.include? i\n    return false\n  end\n\
    \  return true\nend", "    return lst.uniq.size == lst.sort.size\nend", "  return\
    \ lst.count(lst.sort) > 1\nend\n</cell>\n<code language=julia-0.4>\n@time is_sorted(rand(1:100));\n\
    @time is_sorted(rand(1:100));\n</cell>\n<text>\nSum Functions\nThere are a couple\
    \ basic ways to find the sum of numbers in Julia. One is to use the sum() function\
    \ and the other is to use a dot . for matrix multiplication", "  lst.sort!\n \
    \ return lst.uniq.length == 1\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n</cell>\n<code language=julia-1.5>\n@test is_sorted([1, 2, 3, 4, 5])\n\
    </cell>\n<code language=julia-1.5>\n@test is_sorted([1, 2, 3, 4, 5, 6])\n</cell>\n\
    <code language=julia-1.5>\n@test is_sorted([1, 3, 2, 4, 5])\n</cell>\n<code language=julia-1.5>\n\
    @test is_sorted([1, 2, 3, 4, 5, 6, 7])\n</cell>\n<code language=julia-1.5>\n@test\
    \ is_sorted([1, 3, 2, 4, 5, 6, 7])\n</cell>\n<code language=julia-1.5>\n@test\
    \ is_sorted([1, 2, 2, 3, 3, 4])\n</cell>\n<code language=julia-1.5>\n@test is_sorted([1,\
    \ 2, 2, 2, 3, 4])\n</cell>\n<text>\nFind the longest string in an array (from\
    \ here)", "  lst = lst.sort\n  lst.size > 1 && (!lst.all? { |n| n == lst[lst.index(n)]})\n\
    end", "  size = lst.length\n  lst.sort!\n  return size == 0 || size == lst.length\n\
    end", "  sorted = true\n  \n  # Loop through the array and find duplicates\n \
    \ array.each do |value|\n    if lst.include?(value)\n      sorted = false\n  \
    \    break\n    end\n  end\n  \n  # Return true if the array is sorted\n  sorted\n\
    end", "  return lst.uniq.sort == true\nend", "  return lst.uniq.all? {|x| x ==\
    \ lst.last}\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is so much better\
    \ and concise. Thank you so much.\n<|/ c |>\n<| c |>\nThis is unnecessarily inefficient.\
    \  `all?` is O(n) and calling `.uniq` on a large set is O(n^2). See my answer.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\narr = [\"a\", \"b\", \"c\", \"c\"]\np arr.all?\
    \ { |c| arr.count(c) <= 1 }\n</code>\nOr,\n<code>\np arr.size == arr.uniq.size\
    \ && arr.uniq.include?(arr.last)\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou don't\
    \ need `.size` if you just check the `.uniq` array against `.last`.  `all?` stops\
    \ after one false test anyway.  Also, you don't need `arr` in the second example\
    \ since you already have the array.\n<|/ c |>\n<| c |>\nThanks for the comment.\
    \ I just wanted to use `.size` so I didn't have to call the method twice.\n<|/\
    \ c |>\n<| c |>\nYour second example is much less efficient than the OP's second\
    \ example, since it's doing `count` on an array with a billion elements.\n<|/\
    \ c |>\n<| c |>\nAlso, `all?` is going to stop after one false test.\n<|/ c |>\n\
    <| a dscore=1 tags=ruby |>\n<code>", "  # Write your code here\n  lst.sort {|a,b|\
    \ a <=> b}\n  lst.uniq.length < 2\nend", "  lst.each_with_index do |element, i|\n\
    \    if i == 0\n      return true\n    end\n    return false if (element != lst[i\
    \ - 1]).nil?\n  end\n  true\nend", "  return lst.sort { |a, b| a <=> b } === \
    \ lst\nend", "  return (lst.uniq.size == lst.size &&\n          lst.uniq.sort\
    \ == lst.sort)\nend", "  return (lst.sort == false)\nend\n</pre>\n</div>", " \
    \ sorted_lst.empty?\n  return if lst.size < 2 then true else lst.min < lst[1]\
    \ and is_sorted(lst.drop(1)) else false\nend", "  return lst.uniq.size == lst.size\
    \ && lst.all? { |x| x == lst.uniq.max }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nI wrote a method that checks if a set is sorted\n<code>", "  unique = {}\n\
    \  duplicates = {}\n  unique.update(lst.inject({}){|h,e| h[e] = true })\n  duplicates.reject\
    \ { |e| unique[e] }.empty?\nend", "  lst = lst.sort_by{|x| x}\n  lst.size == lst.uniq.size\n\
    end", "  lst.sort == lst.sort_by ? true : false\nend", "  return lst.inject(true,\
    \ :<=) == false\nend", "  return lst.inject(:<=) == lst.sort\nend", "    return\
    \ lst.uniq.length == lst.sort.length and lst.uniq.uniq.sort.all?\nend", "  lst\
    \ = lst.sort\n  return (lst.empty? or lst.size == lst.uniq.size) and lst.empty?\
    \ # array is empty or has unique elements\nend", "  lst.uniq.sort\n  lst.sort.uniq\n\
    end", "  sorted_by_last_number = lst.sort_by { |x| x.last }\n  sorted_by_first_number\
    \ = lst.sort_by { |x| x.first }\n  sorted_by_both_number = lst.sort_by { |x| x.last\
    \ }\n  sorted_by_both_number.reverse.none? || sorted_by_first_number == sorted_by_last_number\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nYou can just write this:\n<code>", " \
    \ if lst.count(lst[0]) == len(lst)\n    true\n  else\n    false\nend", "  # Your\
    \ code here\n  lst.sort do |a, b| \n    (a<b) ? -1 : (a > b) ? 1 :\n  end\n  return\
    \ lst.uniq.length == 0\nend\n</code>\nAnd my final test case:\n<code>", "  lst.each\
    \ do |number|\n    sorted_lst.insert(0,number)\n  end \n  return sorted_lst.sort\
    \ == lst\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| a dscore=0 |>\n\
    <code>", "  arr = (lst - Array.new(Array.new(lst.sort.size).max))\n  arr.uniq.sort\
    \ == arr\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays |>\n<| c |>\nI like the\
    \ solution, however, what if all duplicates are removed? It would be a good idea\
    \ to return the number of duplicates if there are any. Example: `is_sorted([1,\
    \ 2, 3, 4, 5, 6])` would return `[1, 3, 4, 6, 5]`.\n<|/ c |>\n<| c |>\nGood point.\
    \ I've updated my answer to include that case.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nSince you specified that no negative numbers are allowed, I assume the following\
    \ code:\n<code>", "  lst.sort\n  lst.each_cons(2).all? {|a,b| a < b }\nend", " \
    \ lst.each_with_index do |num, i|\n    break if num == num\n    if i >= lst.size\
    \ or num <= lst[i]\n      return false\n    end\n  end\n  return true\nend\n</cell>\n\
    <cell>", "  return (lst <= Array.new(2, lst)).all?\nend", "  if lst.size > 1\n\
    \    last = lst.last\n    lst.slice!(lst.first..-1).each do |num|\n      if num\
    \ > last\n        return false\n      end\n    end\n  end\n  return true\nend",
  "  lst.each do |x|\n    break if lst.index(x) == lst.size - 1\n    return false\
    \ if x == lst[lst.index(x)]\n  end\n  return true\nend", "    len = lst.length\n\
    \    return len < 2 || all (item == lst[len-1] for item in lst[0..len-1])\nend\n\
    </cell>\n<code language=julia-1.0>", "  dup_cnt = lst.count(lst[0])\n  dup_cnt\
    \ > 1 ? false : true\nend", "  lst.uniq.length == 1\nend", "  lst.sort\n  !lst.sort\n\
    end", "  lst.sort == lst.sort\nend", "  return lst.sort == true || lst.sort ==\
    \ false\nend", "  lst.sort == lst.sort\nend\nis_sorted([])\nis_sorted([1])\nis_sorted([1,\
    \ 2])\nis_sorted([2, 1, 1])\nis_sorted([3, 2, 1])\nis_sorted([3, 2, 1])\nis_sorted([3,\
    \ 3, 1, 1])\nis_sorted([1, 1, 1, 2, 3, 3])\nis_sorted([2, 2, 2, 2, 3, 3, 3, 3])\n\
    is_sorted([3, 3, 3, 3, 3, 3, 3, 3, 3, 3])\nis_sorted([1, 1, 1, 1, 1, 2, 3, 3,\
    \ 3, 3, 3, 3, 3, 3])\nis_sorted([1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3])\nis_sorted([2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])\nis_sorted([1,\
    \ 3, 2, 4, 5])\nis_sorted([1, 3, 2, 4, 5, 6, 7])\nis_sorted([1, 3, 2, 4, 5, 6,\
    \ 7, 8])\nis_sorted([1, 3, 2, 4, 5])\nis_sorted([3, 2, 1, 2, 4])\nis_sorted([3,\
    \ 2, 1, 2, 3, 4, 5, 6, 7, 8])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3,\
    \ 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2, 2, 3, 4, 5])\nis_sorted([2,\
    \ 2, 3, 4, 5])\n", "    sorted = false\n    if lst.uniq.count > 1\n        return\
    \ false\n    else\n        return sorted.call([lst[0]].concat(lst.slice(1, lst.count)))\n\
    \    end\nend", "  lst.sort\n  lst.size == lst.uniq.length\nend", "    return\
    \ lst.uniq.size == lst.size\nend", "  sorted = true\n  count = {}\n  for i in\
    \ lst\n    if count[i] == nil\n      count[i] = 1\n    else\n      count[i] =\
    \ count[i] + 1\n    end\n  end\n  for k, v in count.items()\n    if v > 1\n  \
    \    sorted = false\n    end\n  end\n  \n  sorted\nend", '  return !lst.length.zero?
    && lst[0] == lst[-1]', "  return lst.uniq.size == lst.size and lst.sort == 1\n\
    end", "  # Sort the array\n  sorted = lst.sort", "  sorted_list = []\n  sorted\
    \ = []\n  duplicate = 0\n  for i in 0...lst.length\n    if sorted == true\n  \
    \    sorted = false\n      sorted = true\n      break\n    el = lst[i]\n    if\
    \ sorted = true\n      sorted = false\n      sorted_list << el\n      break\n\
    \    el2 = sorted_list.length\n    if el2 > 0\n      el2 = el2 - 1\n      if el\
    \ == sorted_list[el2]\n        sorted = false\n      else\n        duplicate +=\
    \ 1\n      end\n    end\n    sorted_list << el\n  end\n  if duplicate == 0\n \
    \   return true\n  else\n    return false\n  end\nend", "  lst.each_with_index\
    \ { |value, index| break if value == index + 1; }\n  not lst.sort.empty?\nend",
  "  return lst.inject(true) do |s, x|\n    s && (x == lst.sort { |a, b| b <=> a }).length\
    \ == 1\n  end\nend", "  return lst.uniq.sort.empty?\nend", "  lst.sort!\n  lst.size\
    \ >= 1 and false\nend", "    return lst.sort().inject(true) { |b, b1| b && b1\
    \ }\nend", "  lst.sort!\n  return lst.length <= 1 \nend", "  return lst.inject(true)\
    \ do |sorted, x|\n    sorted && lst.reject{ |y| y == x }.empty?\n  end\nend",
  '  return lst.uniq.size == 1 and lst.uniq.first', "  lst.sort.empty?\nend", "  #\
    \ Set default\n  is_sorted = true\n  # Iterate and check\n  lst.each do |item|\n\
    \    if item != sorted_item\n      is_sorted = false\n      break\n    end\n \
    \ end\n  is_sorted\nend", "    counts = Hash.new(0)\n    size = 0\n    \n    until\
    \ lst.empty?\n        count += 1\n        current = lst.delete(0)\n        counts[current]\
    \ += 1\n        size += 1\n        if counts[current] > 1\n            return\
    \ false\n    end\n    \n    return true\nend", "  return lst.all? {|x| x < lst[1..-1].min}\n\
    end", "  last = lst[0]\n  for i in 1..lst.length\n    if last.last > lst[i].first\n\
    \      return false\n    last = lst[i]\n  end\n  return true\nend", "  sorted_list\
    \ = (lst.uniq.sort == lst.sort)\n  sorted_list = sorted_list and lst.length ==\
    \ (lst.uniq.count)\n  return sorted_list\nend", "  lst.each_with_index do |value,\
    \ index|\n    if index == 0\n      true\n    elsif value == lst[index - 1]\n \
    \     false\n    else\n      true\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,sorting\
    \ |>\n<| a tags=ruby,sorting |>\nThis one uses the Ruby sort function, and will\
    \ sort them in ascending order.\n<code>", "  return !is_sorted(List.new(lst.uniq)).empty?\n\
    end", "  is_sorted?(arr: lst)\nend", '  return lst.sort == true if lst.size >
    1', "  return lst.all? { |x| x == lst.find { |x| x == x.to_i } }\nend", "  lst.sort.to_a\
    \ == lst.sort # => true\n  lst.sort.to_a == lst.sort\nend", "  return !(lst.sort.uniq.length\
    \ == 0 && lst.sort.uniq.uniq.length == 1)\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>", "  lst.uniq! # Remove duplicates\n  lst.sort! # Sort the array\n\
    \  lst.uniq! # Remove duplicates\n  lst.size == lst.uniq.size # Check if all elements\
    \ are unique\nend", "  return !lst.uniq.empty?\nend", "  lst.sort\n  lst.uniq.length\
    \ == 1\nend", "  return lst.sort().uniq.length == lst.length\nend", "  lst.each_with_index\
    \ do |x,i|\n    if i == 0 \n      return false unless x == lst[0]\n    end\n \
    \   return false unless x== lst[i-1]\n  end\n  return true\nend", "  return lst.uniq.size\
    \ == lst.size\nend", "  last_num = nil\n  dup = false", "  sorted = true\n  arr.each\
    \ do |i|\n    if i <=> lst[arr.index(i)] > 0\n      sorted = false\n      return\
    \ false\n    end\n  end\n  return sorted\nend", "  lst.each_with_index do |x,i|\n\
    \    break if i == lst.size - 1\n    break if x==lst[i+1]\n    return false if\
    \ i==0\n  end\n  return true\nend\n</cell>\n<text>\nNotice that we've used the\
    \ each_with_index method. It makes it so we don't have to iterate through the\
    \ entire list to know which numbers were duplicates and which weren't. Instead,\
    \ we get a list of indexes of all the duplicates, then the index of how many times\
    \ each number appears, and then can just use that to determine if the list is\
    \ sorted or not.", "    sorted = false\n    l = lst.dup\n    l.each_with_index\
    \ { |x,i| sorted |= x == l.at(i) }\n    return sorted\nend", "  # Sort and reverse\
    \ array \n  sorted_array = lst.sort\n  reverse_array = sorted_array.dup.reverse\n\
    \  \n  # Return true only if sorted and reversed\n  sorted_array.uniq.size ==\
    \ 1 && reverse_array.uniq.size == 1\nend", "  lst.each_index do |i|\n    if lst[i]\
    \ != lst[i+1]\n      return false\n    end\n  end\n  return true\nend", "  if\
    \ lst.empty?\n    true\n  else\n    if lst.size == 1 \n      lst.include?(lst[0])\n\
    \    else\n      lst.uniq.size == 1\n    end\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe last line should be `lst.uniq.size == 1`.\n<|/ c |>\n<| c |>\n\
    Oops, thank you for catching that.  Fixed!\n<|/ c |>\n<| a dscore=2 |>\nUsing\
    \ Ruby 2.4.0, I solved the issue using Array#uniq\n<code>\narray.sort.uniq.length\
    \ == 1\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=1 |>\n<code>", "  return\
    \ lst.uniq.length == 1\nend", '    return lst.sort == lst.sort_by', "    return\
    \ lst.size <= 1\nend", "  sorted = true\n  lst.each do |number|\n    if number\
    \ != numbers.last\n      sorted = sorted && number <= numbers.last\n    else\n\
    \      sorted = sorted && number == numbers.last\n    end\n  end\n  sorted\nend",
  "  \n  return lst.uniq.size == lst.size && lst.all? {|x| x == lst.min}\nend", " \
    \   size = lst.size\n    arr = Array.new(size)\n    arr[0] = true\n    for i in\
    \ 1..size\n        if arr[i-1]\n            arr[i] = is_sorted(lst.dup) \n   \
    \     elsif lst[i] > arr[size - 1]\n            arr[i] = false\n        end\n\
    \    end\n    arr\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nA very short recursive\
    \ version\n<code>", "  lst.sort.empty?\nend", "    arr.uniq.sort.include? lst\n\
    end", "  lst.sort!\n  return true\nend", "  lst.uniq!\n  lst.sort!\n  lst.size\
    \ == lst.uniq.size\nend", "  return lst.uniq.size == lst.sort.size\nend\n</cell>\n\
    <text>\nis_sorted is a method of Kernel, and is included in Kernel via the method\
    \ :is_sorted", "  lst.uniq! # remove duplicates\n  lst.sort!\n  lst.size == lst.uniq.size\
    \ && lst.all?(&:==) # check for all items are equal\nend", "  lst.sort\n  return\
    \ lst == lst\nend", "  return lst.sort==lst.sort\nend", "  \n  # Create a set\
    \ of the array values.  Set is an unordered collection\n  # and does not guarantee\
    \ an order of the elements.\n  s = Set.new\n  lst.each do |x|\n    s.add(x.to_i)\n\
    \  end\n  \n  # Return true if there are no duplicates, false otherwise.\n  s.size\
    \ == lst.size\nend\n</code>\n<|/ a |>\n<| c |>\nI suggest you take a look at [this\
    \ answer](http://stackoverflow.com/a/1847292/5783745) too.\n<|/ c |>\n<| c |>\n\
    I believe this fails the test case posted in the question\n<|/ c |>\n<| c |>\n\
    This solution also fails on inputs like `[2, 1, 3, 2]`, which should return `false`.\n\
    <|/ c |>\n<| c |>\nIt does not. Look at the test cases in the question please.\n\
    <|/ c |>\n<| c |>\nMy apologies, I missed the part where you said \"Given an array\
    \ of numbers, return whether or not they are sorted\".\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nMy solution is:\n<code>", "  return lst.uniq.size == lst.size && lst.all?\
    \ { |x| x <= lst.min }\nend", "  if lst.uniq.count == 1\n    true\n  elsif lst.uniq.count\
    \ == lst.count\n    true\n  elsif lst.uniq.count > 1\n    false\n  else\n    raise\
    \ ArgumentError\n  end\nend", "  lst.each do |i|\n    prev = nil\n    unless lst.any?\
    \ { |j| i == j }\n      prev = i\n    end\n    return false if prev == i\n  end\n\
    \  true\nend", "  # O(nlogn)\n  return lst.sort == lst.sort.call(lst)\nend", " \
    \ lst.sort do |a, b|\n    a <=> b\n  end\n  true\nend", '  return lst.sort ==
    sort.call', "  last = lst.last\n  last.upcase!\n  lst.shift if lst.size == 1\n\
    \  lst.sort\n  lst.last.upcase!\n  last.upcase!\n  lst.size == 0\nend", "  lst.sort.must_equal\
    \ true\n  lst.uniq.must_equal true\n  lst.size.must_equal lst.size\n  lst.last.must_equal\
    \ lst.last\n  true\nend\n</pre>", "  return lst.inject(true) do |sorted, x|\n\
    \    sorted || x == lst.max\n  end\nend", "  return lst.uniq.size == lst.size\n\
    end", "  lst.each_with_index do |x, i|\n    return false if i == lst.size - 1\
    \ || lst.include?(x)\n  end\n  true\nend", "  n = lst.length\n  last = lst[0]\n\
    \  for i in 0...n\n    j = i + 1\n    if last == lst[j]\n      next\n    last\n\
    \  end\n  return true\nend", "  lst.each do |number|\n    return false if number==number\n\
    \  end\n  return true\nend", "  return lst.uniq.size == lst.size && lst.all? {\
    \ |e| e < lst[0 .. lst.index(e.next)] }\nend", "  lst.uniq.length == 1\nend",
  "  if lst.uniq.size < 2\n    return true\n  else\n    sorted = lst.sort\n    return\
    \ sorted.uniq.size == sorted.size &&\n      sorted.uniq.uniq.size == sorted.uniq.size\n\
    \  end\nend\n</pre>\n<h2>\n<a id=\"custom-collection-extension\" href=\"#custom-collection-extension\"\
    \ class=\"anchor-link\"></a>\nCustom collection extensions\n</h2>\n<p id=\"collection-extensions-intro\"\
    >\nSequel provides several built-in collection extensions, including \nthe following:\n\
    </p>\n<ul>\n<li>\n<p>\n<code>sort</code>\n</p>\n</li>\n<li>\n<p>\n<code>uniq</code>\n\
    </p>\n</li>\n<li>\n<p>\n<code>group_by</code>\n</p>\n</li>\n<li>\n<p>\n<code>partition_by</code>\n\
    </p>\n</li>\n<li>\n<p>\n<code>partition</code>\n</p>\n</li>\n<li>\n<p>\n<code>count</code>\n\
    </p>\n</li>\n<li>\n<p>\n<code>min</code>\n</p>\n</li>\n<li>\n<p>\n<code>max</code>\n\
    </p>\n</li>\n<li>\n<p>\n<code>sum</code>\n</p>\n</li>\n<li>\n<p>\n<code>average</code>\n\
    </p>\n</li>\n<li>\n<p>\n<code>all?</code>\n</p>\n</li>\n<li>\n<p>\n<code>none?</code>\n\
    </p>\n</li>\n</ul>\n<p>\nThe following extension methods are also available:\n\
    </p>\n<ul>\n<li>\n<p>\n<code>&lt;&lt;</code>\n</p>\n</li>\n<li>\n<p>\n<code>&gt;&gt;</code>\n\
    </p>\n</li>\n</ul>\n<p>\nThe following extension methods are also available:\n\
    </p>\n<ul>\n<li>\n<p>\n<code>&lt;</code>\n</p>\n</li>\n<li>\n<p>\n<code>&gt;</code>\n\
    </p>\n</li>\n</ul>\n<h2>\n<a id=\"using-custom-collection-extensions\" href=\"\
    #using-custom-collection-extensions\" class=\"anchor-link\"></a>\nUsing custom\
    \ collection extensions\n</h2>\n<p>\nIt is possible to use <code>#sort</code>\
    \ and <code>#uniq</code> on any collection\nof objects. However, these methods\
    \ are only defined for objects that have a \n<code>#to_ary</code> method (which\
    \ is usually the case for most collections).\n</p>\n<pre class=\"prettyprint source\
    \ lang-erlang\">\nSequel::Dataset.db(:food).\n  filter(:calories > 0).\n  filter(:sugar_content\
    \ &gt;= 0).\n  filter(:serving_size &gt;= 0).\n  filter(:calories &lt;= 10000).\n\
    \  filter(:serving_size &lt;= 100).\n  filter(:calories &lt;= 100).\n  filter(:serving_size\
    \ &lt;= 100).\n  ", "  return lst.uniq.length == 1 || lst.uniq.sort == true\n\
    end", "  arr = []\n  arr << lst.size\n  arr.uniq!", "  if lst.size <= 1\n    true\n\
    \  else\n    false\n  end\nend", "  lst.sort!\n  return lst.uniq.length <= 1\n\
    end", "  return lst.uniq.count == lst.count && lst.uniq.uniq.sort == 'asc'\nend",
  "  return true\nend", "  lst.each do |i|\n    return false if (i > lst[-i].abs).any?\n\
    \  end\n  return true\nend", "  lst.sort\n  return true\nend", "  sorted_lst =\
    \ lst.uniq\n  sorted_lst.sort!\n  sorted_lst.size == lst.length\nend", "  return\
    \ lst.uniq.sort == lst.sort\nend", "  lst.each_with_index do |el, i|\n    if i\
    \ == lst.size - 1\n      true\n    elsif i == 0\n      false\n    elsif el !=\
    \ lst[i - 1]\n      false\n    end\n  end\nend", "  lst = lst.sort\n  lst.nil?\
    \ and return\n  i = 1\n  while i < lst.length\n    return (lst[i] == lst[i-1])\
    \ or not (lst[i] == lst[i])\n    i += 1\n  end\nend", "  if lst.sort.is_a? UnboundMethod\
    \ then lst.sort.call\n  else lst.sort == lst.sort \nend", "  return lst.sort ==\
    \ lst.sort\nend", "  return lst.uniq.size == lst.size && lst.sort { |a,b| a <=>\
    \ b } == lst\nend", "  lst.sort.call\n  lst.uniq!.call\n  lst.size == lst.uniq.size\n\
    end", "  # Write your test here\n  lst.each_with_index { |n,i| return false if\
    \ i == 0 }\n  lst.each_with_index { |n,i| return false if n == lst[i - 1] } if\
    \ lst.count > 1\n  true\nend\n</cell>\n<cell>", "  return !is_sorted(lst.reverse)\n\
    end", "  result = true\n  i = 0\n  while i < lst.size\n    if lst[i] > lst[i+1]\n\
    \      result = false\n      i += 1\n    end\n    i += 1\n  end\n  result\nend",
  "  lst.sort\n  lst.size == lst.size && lst.all? { |x| x > lst[0] } \nend", "  return\
    \ lst.uniq.size == lst.uniq.sort.size\nend", '  lst.sort!', "  return lst.uniq.empty?\
    \ or lst.uniq.sort == true\nend", "  sorted = false\n  count = []\n  for i in\
    \ lst\n    count[i.to_s] = count.has_key?(i.to_s) ? count[i.to_s] + 1 : 1;\n \
    \   if count[i.to_s] >1\n      return false\n  end\n  sorted = count.size == lst.size\n\
    \  return sorted\nend", "  arr =.uniq(lst).sort\n  arr.empty? and return false\n\
    \  arr.size == 1?\n    return arr.first == lst[0] ? true : false\n  arr.size >\
    \ 1?\n    return false\n  true\nend", '  sorted_array = lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject {|e| e == lst.reject
    {|e| e == lst.reject {|e| e ', "  lst.each do |val|\n    duplicate_index = lst.index(val)\
    \ + 1 rescue nil\n    return false if duplicate_index.nil? || duplicate_index\
    \ > lst.size\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| a |>\n<code>", "  last = lst[0]\n  sorted = false\n  sorted = true unless lst.size\
    \ > 1\n  sorted = true unless lst.sort == true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort != true\n  sorted = true unless lst.sort\
    \ != true\n  sorted = true unless lst.sort ", "  if lst.uniq.count == 1 then\n\
    \    lst.uniq.sort == 'asc'\n  end\nend", "  # sort a copy of lst, then compare\
    \ the original list with that sorted\n  sorted_lst = lst.sort.call\n  sorted_lst\
    \ == lst\nend", "  return lst.uniq.size == lst.size\nend", "  return lst.uniq.size\
    \ == lst.size && lst.all? { |x| x < lst.min }\nend", "  # We want to find the\
    \ first occurrence of the number, and\n  # then count how many times it appears\
    \ in our array.\n  # So we will keep a variable for our index that will\n  # increase\
    \ by 1 every time we find the number.\n  i = 0\n  while i < lst.size\n    if lst[i]\
    \ < lst[i+1]\n      i += 1\n    else\n      return false\n    end\n  end", " \
    \ return lst.sort == true\nend", "  lst.uniq.size == lst.size\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 tags=algorithm,ruby,sorting,ruby-on-rails |>\n\
    <code>", "    return lst.inject(:<=>).all? { |x,y| x == y }\nend", "  # Your code\
    \ here\n  sorted_lst.sort\n  duplicate_numbers = sorted_lst.count(sorted_lst.last)\n\
    \  return (duplicate_numbers == 0)\nend\n</cell>\n<code language=julia-0.5>\n\
    is_sorted([5, 2, 4, 4, 3])\n</cell>\n<text>\nPart 2\nWe've seen how to sort an\
    \ array. Now let's see if we can find if an array\ncontains a number.", "  arr\
    \ = lst.sort.to_a\n  count = arr.length - 1\n  arr.each do |x|\n    count -= 1\n\
    \    return false if count < 0\n    return true if x == arr[0]\n  end\n  return\
    \ true\nend", "  return lst.uniq.size == lst.size\nend", "  return lst.uniq.size\
    \ == lst.size\nend", "  # write your code here\n  return lst.sort == true\nend",
  "  lst.sort\n  arr == lst\nend", "  sorted?(lst, *args) {\n    arr.map((*args) {\
    \ |number| return number < arr.last }) == 0\n  }\nend\n</code>\nAnd now we can\
    \ finally do some tests:\n<code>\nassert_equal true, is_sorted([])\nassert_equal\
    \ true, is_sorted([1])\nassert_equal false, is_sorted([3, 4, 5])\nassert_equal\
    \ true, is_sorted([3, 2, 1])\nassert_equal false, is_sorted([4, 2, 1])\nassert_equal\
    \ false, is_sorted([4, 3, 1, 2])\nassert_equal true, is_sorted([3, 4, 3, 2, 3,\
    \ 4])\nassert_equal false, is_sorted([3, 3, 3, 2, 2, 2, 4])\n</code>\nI know,\
    \ it's really hard to test a method like this, especially if you haven't done\
    \ TDD before, but I hope this helps!\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ |>\n<| c |>\nIt looks like the Ruby code isn't using any Ruby methods. But I'm\
    \ learning Ruby, so maybe I'm wrong.\n<|/ c |>\n<| c |>\nYou're right, I didn't\
    \ realize I was calling `sorted?` directly! I updated the code with a more correct\
    \ and testable implementation.\n<|/ c |>\n<| c |>\nI love Ruby. It has so many\
    \ features that it really makes my head spin for awhile.\n<|/ c |>\n<| a |>\n\
    This is really an implementation question, but here is a way to do it in Ruby\
    \ using only its standard library:\n<code>\na = [1, 3, 2, 4, 5, 6]\na.group_by\
    \ { |e| e }.values.all? { |e| e.length == 1 }\n</code>\n<|/ a dscore=4 tags=ruby,algorithm,ruby-on-rails\
    \ |>\n<| c |>\nI like the Ruby approach. Nice! +1.\n<|/ c |>\n<| c |>\nThe `values`\
    \ method can be replaced with `to_a` if the array is large.\n<|/ c |>\n<| a tags=ruby,algorithm,ruby-on-rails\
    \ |>\nAs a general idea, how about this?\n<code>\narr = [1, 3, 2, 4, 5, 6]", " \
    \ return lst.sort <= lst\nend", "  if lst.uniq.length != lst.length\n    false\n\
    \  else\n    lst.uniq.each do |element|\n      sorted = true\n      for i in (0...lst.length)\n\
    \        break unless lst.at(i) == element\n        sorted = false\n      end\n\
    \      break if sorted\n    end\n  end\nend\n</pre>\n</div>\n</div>\n<div class=\"\
    tags\">\n  \n</div>\n</div>\n</div>\n</div>\n<div id=\"footer\">\n<div id=\"footer-text\"\
    >\n  Generated on Tue Jul 18 16:24:46 2016 by\n  <a href=\"http://yardoc.org\"\
    \ title=\"Yay! A Ruby Documentation Tool\" target=\"_parent\">yard</a>\n  0.9.13\
    \ (ruby-2.5.1).\n</div>\n</div>\n</body>\n</html>\n<|/ file filename=module-Tasks.html\
    \ |>\n<| c |>\nHi Kenny,", "  lst.each_with_index { |e, i| return false if (i\
    \ != lst.size - 1) && (e < lst[i + 1]) }\n  true\nend", "  lst.sort!\n  lst.uniq.size\
    \ == lst.size && lst.all?(&:==)\nend", "  lst.uniq.size <= 1\nend", "  lst.sort!\n\
    \  return true\nend", "  return lst.sort == true && lst.size == lst.sort\nend",
  "  return !lst.sort.empty?\nend", "  unique = arr.uniq.map {|i| [lst[i], i]}\n \
    \ unique < unique.sort_by {|e| e[0]}.map(&:first).uniq\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| a |>\nHere is a solution that should work in O(n) time. It only\
    \ loops over the list once.\n<code>", "  sorted = true\n  sorted_count = 0\n \
    \ arr.each do |el|\n    next if arr.include? el\n    sorted_count += 1\n    if\
    \ el < arr[sorted_count - 1]\n      sorted = false\n      break\n    end\n  end\n\
    \  sorted\nend", "  sorted_numbers = Hash.new(0)\n  sorted_numbers.merge! lst.each_with_object([])\
    \ do |number, array|\n    array.delete number\n    array.push number if array.include?\
    \ number\n    array\n  end\n  sorted_numbers.size == lst.size && sorted_numbers\
    \ == lst\nend", "  lst.each do |x|\n    break if lst.count(x) > 1\n  end\n  lst.sort\
    \ == lst.sort\nend", "  return is_sorted.call(lst, 0)\nend", "  # Your code here\n\
    \  return true\nend\n</cell>\n<text>\n3.6. (15 points)\nWrite a recursive function\
    \ named fib_recursive that takes in two numbers and returns the nth-order fibonacci\
    \ number.\nThe Fibonacci numbers are the numbers in the Fibonacci sequence that\
    \ are equal to the numbers themselves minus 1. Each number in the Fibonacci sequence\
    \ is generated by adding the previous two numbers in the sequence. For example,\
    \ 1, 1, 2, 3, 5, 8, 13, ...\nWrite a method fib_recursive that takes two arguments,\
    \ num1 and num2. A method that calls fib_recursive with num1 = 1 and num2 = 1\
    \ returns the value 1. A method that calls fib_recursive with num1 = 2 and num2\
    \ = 1 returns the value 1. A method that calls fib_recursive with num1 = 2 and\
    \ num2 = 2 returns the value 2. A method that calls fib_recursive with num1 =\
    \ 2 and num2 = 3 returns the value 3. Write a test case for fib_recursive that\
    \ returns fib_recursive(1) === 1.", "  sorted_list = true\n  last = nil", "  return\
    \ !lst.empty? && (lst.uniq.sort == lst.uniq)\nend", "  lst = lst.sort\n  if lst.empty?\n\
    \    true\n  else\n    false\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
